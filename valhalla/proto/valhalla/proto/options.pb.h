// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_options_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_options_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_options_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_options_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace valhalla {
class AvoidEdge;
struct AvoidEdgeDefaultTypeInternal;
extern AvoidEdgeDefaultTypeInternal _AvoidEdge_default_instance_;
class Contour;
struct ContourDefaultTypeInternal;
extern ContourDefaultTypeInternal _Contour_default_instance_;
class CostingOptions;
struct CostingOptionsDefaultTypeInternal;
extern CostingOptionsDefaultTypeInternal _CostingOptions_default_instance_;
class Options;
struct OptionsDefaultTypeInternal;
extern OptionsDefaultTypeInternal _Options_default_instance_;
class Options_Ring;
struct Options_RingDefaultTypeInternal;
extern Options_RingDefaultTypeInternal _Options_Ring_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::AvoidEdge* Arena::CreateMaybeMessage<::valhalla::AvoidEdge>(Arena*);
template<> ::valhalla::Contour* Arena::CreateMaybeMessage<::valhalla::Contour>(Arena*);
template<> ::valhalla::CostingOptions* Arena::CreateMaybeMessage<::valhalla::CostingOptions>(Arena*);
template<> ::valhalla::Options* Arena::CreateMaybeMessage<::valhalla::Options>(Arena*);
template<> ::valhalla::Options_Ring* Arena::CreateMaybeMessage<::valhalla::Options_Ring>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum Options_Units : int {
  Options_Units_kilometers = 0,
  Options_Units_miles = 1
};
bool Options_Units_IsValid(int value);
constexpr Options_Units Options_Units_Units_MIN = Options_Units_kilometers;
constexpr Options_Units Options_Units_Units_MAX = Options_Units_miles;
constexpr int Options_Units_Units_ARRAYSIZE = Options_Units_Units_MAX + 1;

const std::string& Options_Units_Name(Options_Units value);
template<typename T>
inline const std::string& Options_Units_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_Units>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_Units_Name.");
  return Options_Units_Name(static_cast<Options_Units>(enum_t_value));
}
bool Options_Units_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Units* value);
enum Options_Format : int {
  Options_Format_json = 0,
  Options_Format_gpx = 1,
  Options_Format_osrm = 2
};
bool Options_Format_IsValid(int value);
constexpr Options_Format Options_Format_Format_MIN = Options_Format_json;
constexpr Options_Format Options_Format_Format_MAX = Options_Format_osrm;
constexpr int Options_Format_Format_ARRAYSIZE = Options_Format_Format_MAX + 1;

const std::string& Options_Format_Name(Options_Format value);
template<typename T>
inline const std::string& Options_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_Format_Name.");
  return Options_Format_Name(static_cast<Options_Format>(enum_t_value));
}
bool Options_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Format* value);
enum Options_Action : int {
  Options_Action_route = 1,
  Options_Action_locate = 2,
  Options_Action_sources_to_targets = 3,
  Options_Action_optimized_route = 4,
  Options_Action_isochrone = 5,
  Options_Action_trace_route = 6,
  Options_Action_trace_attributes = 7,
  Options_Action_height = 8,
  Options_Action_transit_available = 9,
  Options_Action_expansion = 10,
  Options_Action_centroid = 11,
  Options_Action_status = 12
};
bool Options_Action_IsValid(int value);
constexpr Options_Action Options_Action_Action_MIN = Options_Action_route;
constexpr Options_Action Options_Action_Action_MAX = Options_Action_status;
constexpr int Options_Action_Action_ARRAYSIZE = Options_Action_Action_MAX + 1;

const std::string& Options_Action_Name(Options_Action value);
template<typename T>
inline const std::string& Options_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_Action_Name.");
  return Options_Action_Name(static_cast<Options_Action>(enum_t_value));
}
bool Options_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Action* value);
enum Options_DateTimeType : int {
  Options_DateTimeType_current = 0,
  Options_DateTimeType_depart_at = 1,
  Options_DateTimeType_arrive_by = 2,
  Options_DateTimeType_invariant = 3
};
bool Options_DateTimeType_IsValid(int value);
constexpr Options_DateTimeType Options_DateTimeType_DateTimeType_MIN = Options_DateTimeType_current;
constexpr Options_DateTimeType Options_DateTimeType_DateTimeType_MAX = Options_DateTimeType_invariant;
constexpr int Options_DateTimeType_DateTimeType_ARRAYSIZE = Options_DateTimeType_DateTimeType_MAX + 1;

const std::string& Options_DateTimeType_Name(Options_DateTimeType value);
template<typename T>
inline const std::string& Options_DateTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Options_DateTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Options_DateTimeType_Name.");
  return Options_DateTimeType_Name(static_cast<Options_DateTimeType>(enum_t_value));
}
bool Options_DateTimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_DateTimeType* value);
enum ShapeMatch : int {
  edge_walk = 0,
  map_snap = 1,
  walk_or_snap = 2
};
bool ShapeMatch_IsValid(int value);
constexpr ShapeMatch ShapeMatch_MIN = edge_walk;
constexpr ShapeMatch ShapeMatch_MAX = walk_or_snap;
constexpr int ShapeMatch_ARRAYSIZE = ShapeMatch_MAX + 1;

const std::string& ShapeMatch_Name(ShapeMatch value);
template<typename T>
inline const std::string& ShapeMatch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeMatch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeMatch_Name.");
  return ShapeMatch_Name(static_cast<ShapeMatch>(enum_t_value));
}
bool ShapeMatch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeMatch* value);
enum FilterAction : int {
  exclude = 0,
  include = 1
};
bool FilterAction_IsValid(int value);
constexpr FilterAction FilterAction_MIN = exclude;
constexpr FilterAction FilterAction_MAX = include;
constexpr int FilterAction_ARRAYSIZE = FilterAction_MAX + 1;

const std::string& FilterAction_Name(FilterAction value);
template<typename T>
inline const std::string& FilterAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterAction_Name.");
  return FilterAction_Name(static_cast<FilterAction>(enum_t_value));
}
bool FilterAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterAction* value);
enum DirectionsType : int {
  none = 0,
  maneuvers = 1,
  instructions = 2
};
bool DirectionsType_IsValid(int value);
constexpr DirectionsType DirectionsType_MIN = none;
constexpr DirectionsType DirectionsType_MAX = instructions;
constexpr int DirectionsType_ARRAYSIZE = DirectionsType_MAX + 1;

const std::string& DirectionsType_Name(DirectionsType value);
template<typename T>
inline const std::string& DirectionsType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsType_Name.");
  return DirectionsType_Name(static_cast<DirectionsType>(enum_t_value));
}
bool DirectionsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsType* value);
enum ShapeFormat : int {
  polyline5 = 0,
  polyline6 = 1,
  geojson = 2
};
bool ShapeFormat_IsValid(int value);
constexpr ShapeFormat ShapeFormat_MIN = polyline5;
constexpr ShapeFormat ShapeFormat_MAX = geojson;
constexpr int ShapeFormat_ARRAYSIZE = ShapeFormat_MAX + 1;

const std::string& ShapeFormat_Name(ShapeFormat value);
template<typename T>
inline const std::string& ShapeFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeFormat_Name.");
  return ShapeFormat_Name(static_cast<ShapeFormat>(enum_t_value));
}
bool ShapeFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeFormat* value);
enum Costing : int {
  auto_ = 0,
  bicycle = 2,
  bus = 3,
  hov = 4,
  motor_scooter = 5,
  multimodal = 6,
  pedestrian = 7,
  transit = 8,
  truck = 9,
  motorcycle = 10,
  taxi = 12,
  none_ = 13,
  bikeshare = 14
};
bool Costing_IsValid(int value);
constexpr Costing Costing_MIN = auto_;
constexpr Costing Costing_MAX = bikeshare;
constexpr int Costing_ARRAYSIZE = Costing_MAX + 1;

const std::string& Costing_Name(Costing value);
template<typename T>
inline const std::string& Costing_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Costing>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Costing_Name.");
  return Costing_Name(static_cast<Costing>(enum_t_value));
}
bool Costing_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Costing* value);
// ===================================================================

class Contour final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Contour) */ {
 public:
  inline Contour() : Contour(nullptr) {}
  ~Contour() override;
  explicit constexpr Contour(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Contour(const Contour& from);
  Contour(Contour&& from) noexcept
    : Contour() {
    *this = ::std::move(from);
  }

  inline Contour& operator=(const Contour& from) {
    CopyFrom(from);
    return *this;
  }
  inline Contour& operator=(Contour&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Contour& default_instance() {
    return *internal_default_instance();
  }
  static inline const Contour* internal_default_instance() {
    return reinterpret_cast<const Contour*>(
               &_Contour_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Contour& a, Contour& b) {
    a.Swap(&b);
  }
  inline void Swap(Contour* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Contour* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Contour* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Contour>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Contour& from);
  void MergeFrom(const Contour& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Contour* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Contour";
  }
  protected:
  explicit Contour(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 2,
    kTimeFieldNumber = 1,
    kDistanceFieldNumber = 3,
  };
  // optional string color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // optional float time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // optional float distance = 3;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.Contour)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  float time_;
  float distance_;
  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class AvoidEdge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.AvoidEdge) */ {
 public:
  inline AvoidEdge() : AvoidEdge(nullptr) {}
  ~AvoidEdge() override;
  explicit constexpr AvoidEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvoidEdge(const AvoidEdge& from);
  AvoidEdge(AvoidEdge&& from) noexcept
    : AvoidEdge() {
    *this = ::std::move(from);
  }

  inline AvoidEdge& operator=(const AvoidEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvoidEdge& operator=(AvoidEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AvoidEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvoidEdge* internal_default_instance() {
    return reinterpret_cast<const AvoidEdge*>(
               &_AvoidEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AvoidEdge& a, AvoidEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(AvoidEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvoidEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvoidEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvoidEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AvoidEdge& from);
  void MergeFrom(const AvoidEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AvoidEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.AvoidEdge";
  }
  protected:
  explicit AvoidEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPercentAlongFieldNumber = 2,
  };
  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // optional float percent_along = 2;
  bool has_percent_along() const;
  private:
  bool _internal_has_percent_along() const;
  public:
  void clear_percent_along();
  float percent_along() const;
  void set_percent_along(float value);
  private:
  float _internal_percent_along() const;
  void _internal_set_percent_along(float value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.AvoidEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t id_;
  float percent_along_;
  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class CostingOptions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.CostingOptions) */ {
 public:
  inline CostingOptions() : CostingOptions(nullptr) {}
  ~CostingOptions() override;
  explicit constexpr CostingOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CostingOptions(const CostingOptions& from);
  CostingOptions(CostingOptions&& from) noexcept
    : CostingOptions() {
    *this = ::std::move(from);
  }

  inline CostingOptions& operator=(const CostingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CostingOptions& operator=(CostingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CostingOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CostingOptions* internal_default_instance() {
    return reinterpret_cast<const CostingOptions*>(
               &_CostingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CostingOptions& a, CostingOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(CostingOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CostingOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CostingOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CostingOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CostingOptions& from);
  void MergeFrom(const CostingOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CostingOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.CostingOptions";
  }
  protected:
  explicit CostingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterStopIdsFieldNumber = 50,
    kFilterOperatorIdsFieldNumber = 52,
    kFilterRouteIdsFieldNumber = 54,
    kAvoidEdgesFieldNumber = 92,
    kTransportTypeFieldNumber = 29,
    kNameFieldNumber = 91,
    kManeuverPenaltyFieldNumber = 1,
    kDestinationOnlyPenaltyFieldNumber = 2,
    kGateCostFieldNumber = 3,
    kGatePenaltyFieldNumber = 4,
    kTollBoothCostFieldNumber = 5,
    kTollBoothPenaltyFieldNumber = 6,
    kAlleyPenaltyFieldNumber = 7,
    kCountryCrossingCostFieldNumber = 8,
    kCountryCrossingPenaltyFieldNumber = 9,
    kFerryCostFieldNumber = 10,
    kAvoidBadSurfacesFieldNumber = 11,
    kUseFerryFieldNumber = 12,
    kUseHighwaysFieldNumber = 13,
    kUseTollsFieldNumber = 14,
    kUseRoadsFieldNumber = 15,
    kMaxDistanceFieldNumber = 16,
    kWalkingSpeedFieldNumber = 17,
    kStepPenaltyFieldNumber = 18,
    kMaxGradeFieldNumber = 19,
    kMaxHikingDifficultyFieldNumber = 20,
    kModeFactorFieldNumber = 21,
    kWalkwayFactorFieldNumber = 22,
    kSidewalkFactorFieldNumber = 23,
    kAlleyFactorFieldNumber = 24,
    kDrivewayFactorFieldNumber = 25,
    kDrivewayPenaltyFieldNumber = 26,
    kTransitStartEndMaxDistanceFieldNumber = 27,
    kTransitTransferMaxDistanceFieldNumber = 28,
    kTopSpeedFieldNumber = 30,
    kUseHillsFieldNumber = 31,
    kUsePrimaryFieldNumber = 32,
    kUseTrailsFieldNumber = 33,
    kLowClassPenaltyFieldNumber = 34,
    kWeightFieldNumber = 36,
    kAxleLoadFieldNumber = 37,
    kHeightFieldNumber = 38,
    kWidthFieldNumber = 39,
    kLengthFieldNumber = 40,
    kCyclingSpeedFieldNumber = 41,
    kUseBusFieldNumber = 44,
    kUseRailFieldNumber = 45,
    kHazmatFieldNumber = 35,
    kWheelchairFieldNumber = 42,
    kBicycleFieldNumber = 43,
    kIgnoreRestrictionsFieldNumber = 60,
    kUseTransfersFieldNumber = 46,
    kTransferCostFieldNumber = 47,
    kTransferPenaltyFieldNumber = 48,
    kFilterStopActionFieldNumber = 49,
    kFilterOperatorActionFieldNumber = 51,
    kFilterRouteActionFieldNumber = 53,
    kFlowMaskFieldNumber = 55,
    kBikeShareCostFieldNumber = 56,
    kBikeSharePenaltyFieldNumber = 57,
    kRailFerryCostFieldNumber = 58,
    kUseRailFerryFieldNumber = 59,
    kIgnoreOnewaysFieldNumber = 61,
    kIgnoreAccessFieldNumber = 62,
    kIgnoreClosuresFieldNumber = 63,
    kShortestFieldNumber = 64,
    kServicePenaltyFieldNumber = 65,
    kUseTracksFieldNumber = 66,
    kUseDistanceFieldNumber = 67,
    kUseLivingStreetsFieldNumber = 68,
    kServiceFactorFieldNumber = 69,
    kClosureFactorFieldNumber = 70,
    kCostingFieldNumber = 90,
    kFilterClosuresFieldNumber = 93,
  };
  // repeated string filter_stop_ids = 50;
  int filter_stop_ids_size() const;
  private:
  int _internal_filter_stop_ids_size() const;
  public:
  void clear_filter_stop_ids();
  const std::string& filter_stop_ids(int index) const;
  std::string* mutable_filter_stop_ids(int index);
  void set_filter_stop_ids(int index, const std::string& value);
  void set_filter_stop_ids(int index, std::string&& value);
  void set_filter_stop_ids(int index, const char* value);
  void set_filter_stop_ids(int index, const char* value, size_t size);
  std::string* add_filter_stop_ids();
  void add_filter_stop_ids(const std::string& value);
  void add_filter_stop_ids(std::string&& value);
  void add_filter_stop_ids(const char* value);
  void add_filter_stop_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_stop_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_stop_ids();
  private:
  const std::string& _internal_filter_stop_ids(int index) const;
  std::string* _internal_add_filter_stop_ids();
  public:

  // repeated string filter_operator_ids = 52;
  int filter_operator_ids_size() const;
  private:
  int _internal_filter_operator_ids_size() const;
  public:
  void clear_filter_operator_ids();
  const std::string& filter_operator_ids(int index) const;
  std::string* mutable_filter_operator_ids(int index);
  void set_filter_operator_ids(int index, const std::string& value);
  void set_filter_operator_ids(int index, std::string&& value);
  void set_filter_operator_ids(int index, const char* value);
  void set_filter_operator_ids(int index, const char* value, size_t size);
  std::string* add_filter_operator_ids();
  void add_filter_operator_ids(const std::string& value);
  void add_filter_operator_ids(std::string&& value);
  void add_filter_operator_ids(const char* value);
  void add_filter_operator_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_operator_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_operator_ids();
  private:
  const std::string& _internal_filter_operator_ids(int index) const;
  std::string* _internal_add_filter_operator_ids();
  public:

  // repeated string filter_route_ids = 54;
  int filter_route_ids_size() const;
  private:
  int _internal_filter_route_ids_size() const;
  public:
  void clear_filter_route_ids();
  const std::string& filter_route_ids(int index) const;
  std::string* mutable_filter_route_ids(int index);
  void set_filter_route_ids(int index, const std::string& value);
  void set_filter_route_ids(int index, std::string&& value);
  void set_filter_route_ids(int index, const char* value);
  void set_filter_route_ids(int index, const char* value, size_t size);
  std::string* add_filter_route_ids();
  void add_filter_route_ids(const std::string& value);
  void add_filter_route_ids(std::string&& value);
  void add_filter_route_ids(const char* value);
  void add_filter_route_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_route_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_route_ids();
  private:
  const std::string& _internal_filter_route_ids(int index) const;
  std::string* _internal_add_filter_route_ids();
  public:

  // repeated .valhalla.AvoidEdge avoid_edges = 92;
  int avoid_edges_size() const;
  private:
  int _internal_avoid_edges_size() const;
  public:
  void clear_avoid_edges();
  ::valhalla::AvoidEdge* mutable_avoid_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >*
      mutable_avoid_edges();
  private:
  const ::valhalla::AvoidEdge& _internal_avoid_edges(int index) const;
  ::valhalla::AvoidEdge* _internal_add_avoid_edges();
  public:
  const ::valhalla::AvoidEdge& avoid_edges(int index) const;
  ::valhalla::AvoidEdge* add_avoid_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >&
      avoid_edges() const;

  // optional string transport_type = 29;
  bool has_transport_type() const;
  private:
  bool _internal_has_transport_type() const;
  public:
  void clear_transport_type();
  const std::string& transport_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transport_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transport_type();
  PROTOBUF_NODISCARD std::string* release_transport_type();
  void set_allocated_transport_type(std::string* transport_type);
  private:
  const std::string& _internal_transport_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_type(const std::string& value);
  std::string* _internal_mutable_transport_type();
  public:

  // optional string name = 91;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional float maneuver_penalty = 1;
  bool has_maneuver_penalty() const;
  private:
  bool _internal_has_maneuver_penalty() const;
  public:
  void clear_maneuver_penalty();
  float maneuver_penalty() const;
  void set_maneuver_penalty(float value);
  private:
  float _internal_maneuver_penalty() const;
  void _internal_set_maneuver_penalty(float value);
  public:

  // optional float destination_only_penalty = 2;
  bool has_destination_only_penalty() const;
  private:
  bool _internal_has_destination_only_penalty() const;
  public:
  void clear_destination_only_penalty();
  float destination_only_penalty() const;
  void set_destination_only_penalty(float value);
  private:
  float _internal_destination_only_penalty() const;
  void _internal_set_destination_only_penalty(float value);
  public:

  // optional float gate_cost = 3;
  bool has_gate_cost() const;
  private:
  bool _internal_has_gate_cost() const;
  public:
  void clear_gate_cost();
  float gate_cost() const;
  void set_gate_cost(float value);
  private:
  float _internal_gate_cost() const;
  void _internal_set_gate_cost(float value);
  public:

  // optional float gate_penalty = 4;
  bool has_gate_penalty() const;
  private:
  bool _internal_has_gate_penalty() const;
  public:
  void clear_gate_penalty();
  float gate_penalty() const;
  void set_gate_penalty(float value);
  private:
  float _internal_gate_penalty() const;
  void _internal_set_gate_penalty(float value);
  public:

  // optional float toll_booth_cost = 5;
  bool has_toll_booth_cost() const;
  private:
  bool _internal_has_toll_booth_cost() const;
  public:
  void clear_toll_booth_cost();
  float toll_booth_cost() const;
  void set_toll_booth_cost(float value);
  private:
  float _internal_toll_booth_cost() const;
  void _internal_set_toll_booth_cost(float value);
  public:

  // optional float toll_booth_penalty = 6;
  bool has_toll_booth_penalty() const;
  private:
  bool _internal_has_toll_booth_penalty() const;
  public:
  void clear_toll_booth_penalty();
  float toll_booth_penalty() const;
  void set_toll_booth_penalty(float value);
  private:
  float _internal_toll_booth_penalty() const;
  void _internal_set_toll_booth_penalty(float value);
  public:

  // optional float alley_penalty = 7;
  bool has_alley_penalty() const;
  private:
  bool _internal_has_alley_penalty() const;
  public:
  void clear_alley_penalty();
  float alley_penalty() const;
  void set_alley_penalty(float value);
  private:
  float _internal_alley_penalty() const;
  void _internal_set_alley_penalty(float value);
  public:

  // optional float country_crossing_cost = 8;
  bool has_country_crossing_cost() const;
  private:
  bool _internal_has_country_crossing_cost() const;
  public:
  void clear_country_crossing_cost();
  float country_crossing_cost() const;
  void set_country_crossing_cost(float value);
  private:
  float _internal_country_crossing_cost() const;
  void _internal_set_country_crossing_cost(float value);
  public:

  // optional float country_crossing_penalty = 9;
  bool has_country_crossing_penalty() const;
  private:
  bool _internal_has_country_crossing_penalty() const;
  public:
  void clear_country_crossing_penalty();
  float country_crossing_penalty() const;
  void set_country_crossing_penalty(float value);
  private:
  float _internal_country_crossing_penalty() const;
  void _internal_set_country_crossing_penalty(float value);
  public:

  // optional float ferry_cost = 10;
  bool has_ferry_cost() const;
  private:
  bool _internal_has_ferry_cost() const;
  public:
  void clear_ferry_cost();
  float ferry_cost() const;
  void set_ferry_cost(float value);
  private:
  float _internal_ferry_cost() const;
  void _internal_set_ferry_cost(float value);
  public:

  // optional float avoid_bad_surfaces = 11;
  bool has_avoid_bad_surfaces() const;
  private:
  bool _internal_has_avoid_bad_surfaces() const;
  public:
  void clear_avoid_bad_surfaces();
  float avoid_bad_surfaces() const;
  void set_avoid_bad_surfaces(float value);
  private:
  float _internal_avoid_bad_surfaces() const;
  void _internal_set_avoid_bad_surfaces(float value);
  public:

  // optional float use_ferry = 12;
  bool has_use_ferry() const;
  private:
  bool _internal_has_use_ferry() const;
  public:
  void clear_use_ferry();
  float use_ferry() const;
  void set_use_ferry(float value);
  private:
  float _internal_use_ferry() const;
  void _internal_set_use_ferry(float value);
  public:

  // optional float use_highways = 13;
  bool has_use_highways() const;
  private:
  bool _internal_has_use_highways() const;
  public:
  void clear_use_highways();
  float use_highways() const;
  void set_use_highways(float value);
  private:
  float _internal_use_highways() const;
  void _internal_set_use_highways(float value);
  public:

  // optional float use_tolls = 14;
  bool has_use_tolls() const;
  private:
  bool _internal_has_use_tolls() const;
  public:
  void clear_use_tolls();
  float use_tolls() const;
  void set_use_tolls(float value);
  private:
  float _internal_use_tolls() const;
  void _internal_set_use_tolls(float value);
  public:

  // optional float use_roads = 15;
  bool has_use_roads() const;
  private:
  bool _internal_has_use_roads() const;
  public:
  void clear_use_roads();
  float use_roads() const;
  void set_use_roads(float value);
  private:
  float _internal_use_roads() const;
  void _internal_set_use_roads(float value);
  public:

  // optional uint32 max_distance = 16;
  bool has_max_distance() const;
  private:
  bool _internal_has_max_distance() const;
  public:
  void clear_max_distance();
  uint32_t max_distance() const;
  void set_max_distance(uint32_t value);
  private:
  uint32_t _internal_max_distance() const;
  void _internal_set_max_distance(uint32_t value);
  public:

  // optional float walking_speed = 17;
  bool has_walking_speed() const;
  private:
  bool _internal_has_walking_speed() const;
  public:
  void clear_walking_speed();
  float walking_speed() const;
  void set_walking_speed(float value);
  private:
  float _internal_walking_speed() const;
  void _internal_set_walking_speed(float value);
  public:

  // optional float step_penalty = 18;
  bool has_step_penalty() const;
  private:
  bool _internal_has_step_penalty() const;
  public:
  void clear_step_penalty();
  float step_penalty() const;
  void set_step_penalty(float value);
  private:
  float _internal_step_penalty() const;
  void _internal_set_step_penalty(float value);
  public:

  // optional uint32 max_grade = 19;
  bool has_max_grade() const;
  private:
  bool _internal_has_max_grade() const;
  public:
  void clear_max_grade();
  uint32_t max_grade() const;
  void set_max_grade(uint32_t value);
  private:
  uint32_t _internal_max_grade() const;
  void _internal_set_max_grade(uint32_t value);
  public:

  // optional uint32 max_hiking_difficulty = 20;
  bool has_max_hiking_difficulty() const;
  private:
  bool _internal_has_max_hiking_difficulty() const;
  public:
  void clear_max_hiking_difficulty();
  uint32_t max_hiking_difficulty() const;
  void set_max_hiking_difficulty(uint32_t value);
  private:
  uint32_t _internal_max_hiking_difficulty() const;
  void _internal_set_max_hiking_difficulty(uint32_t value);
  public:

  // optional float mode_factor = 21;
  bool has_mode_factor() const;
  private:
  bool _internal_has_mode_factor() const;
  public:
  void clear_mode_factor();
  float mode_factor() const;
  void set_mode_factor(float value);
  private:
  float _internal_mode_factor() const;
  void _internal_set_mode_factor(float value);
  public:

  // optional float walkway_factor = 22;
  bool has_walkway_factor() const;
  private:
  bool _internal_has_walkway_factor() const;
  public:
  void clear_walkway_factor();
  float walkway_factor() const;
  void set_walkway_factor(float value);
  private:
  float _internal_walkway_factor() const;
  void _internal_set_walkway_factor(float value);
  public:

  // optional float sidewalk_factor = 23;
  bool has_sidewalk_factor() const;
  private:
  bool _internal_has_sidewalk_factor() const;
  public:
  void clear_sidewalk_factor();
  float sidewalk_factor() const;
  void set_sidewalk_factor(float value);
  private:
  float _internal_sidewalk_factor() const;
  void _internal_set_sidewalk_factor(float value);
  public:

  // optional float alley_factor = 24;
  bool has_alley_factor() const;
  private:
  bool _internal_has_alley_factor() const;
  public:
  void clear_alley_factor();
  float alley_factor() const;
  void set_alley_factor(float value);
  private:
  float _internal_alley_factor() const;
  void _internal_set_alley_factor(float value);
  public:

  // optional float driveway_factor = 25;
  bool has_driveway_factor() const;
  private:
  bool _internal_has_driveway_factor() const;
  public:
  void clear_driveway_factor();
  float driveway_factor() const;
  void set_driveway_factor(float value);
  private:
  float _internal_driveway_factor() const;
  void _internal_set_driveway_factor(float value);
  public:

  // optional float driveway_penalty = 26;
  bool has_driveway_penalty() const;
  private:
  bool _internal_has_driveway_penalty() const;
  public:
  void clear_driveway_penalty();
  float driveway_penalty() const;
  void set_driveway_penalty(float value);
  private:
  float _internal_driveway_penalty() const;
  void _internal_set_driveway_penalty(float value);
  public:

  // optional uint32 transit_start_end_max_distance = 27;
  bool has_transit_start_end_max_distance() const;
  private:
  bool _internal_has_transit_start_end_max_distance() const;
  public:
  void clear_transit_start_end_max_distance();
  uint32_t transit_start_end_max_distance() const;
  void set_transit_start_end_max_distance(uint32_t value);
  private:
  uint32_t _internal_transit_start_end_max_distance() const;
  void _internal_set_transit_start_end_max_distance(uint32_t value);
  public:

  // optional uint32 transit_transfer_max_distance = 28;
  bool has_transit_transfer_max_distance() const;
  private:
  bool _internal_has_transit_transfer_max_distance() const;
  public:
  void clear_transit_transfer_max_distance();
  uint32_t transit_transfer_max_distance() const;
  void set_transit_transfer_max_distance(uint32_t value);
  private:
  uint32_t _internal_transit_transfer_max_distance() const;
  void _internal_set_transit_transfer_max_distance(uint32_t value);
  public:

  // optional float top_speed = 30;
  bool has_top_speed() const;
  private:
  bool _internal_has_top_speed() const;
  public:
  void clear_top_speed();
  float top_speed() const;
  void set_top_speed(float value);
  private:
  float _internal_top_speed() const;
  void _internal_set_top_speed(float value);
  public:

  // optional float use_hills = 31;
  bool has_use_hills() const;
  private:
  bool _internal_has_use_hills() const;
  public:
  void clear_use_hills();
  float use_hills() const;
  void set_use_hills(float value);
  private:
  float _internal_use_hills() const;
  void _internal_set_use_hills(float value);
  public:

  // optional float use_primary = 32;
  bool has_use_primary() const;
  private:
  bool _internal_has_use_primary() const;
  public:
  void clear_use_primary();
  float use_primary() const;
  void set_use_primary(float value);
  private:
  float _internal_use_primary() const;
  void _internal_set_use_primary(float value);
  public:

  // optional float use_trails = 33;
  bool has_use_trails() const;
  private:
  bool _internal_has_use_trails() const;
  public:
  void clear_use_trails();
  float use_trails() const;
  void set_use_trails(float value);
  private:
  float _internal_use_trails() const;
  void _internal_set_use_trails(float value);
  public:

  // optional float low_class_penalty = 34;
  bool has_low_class_penalty() const;
  private:
  bool _internal_has_low_class_penalty() const;
  public:
  void clear_low_class_penalty();
  float low_class_penalty() const;
  void set_low_class_penalty(float value);
  private:
  float _internal_low_class_penalty() const;
  void _internal_set_low_class_penalty(float value);
  public:

  // optional float weight = 36;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  float weight() const;
  void set_weight(float value);
  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);
  public:

  // optional float axle_load = 37;
  bool has_axle_load() const;
  private:
  bool _internal_has_axle_load() const;
  public:
  void clear_axle_load();
  float axle_load() const;
  void set_axle_load(float value);
  private:
  float _internal_axle_load() const;
  void _internal_set_axle_load(float value);
  public:

  // optional float height = 38;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // optional float width = 39;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // optional float length = 40;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // optional float cycling_speed = 41;
  bool has_cycling_speed() const;
  private:
  bool _internal_has_cycling_speed() const;
  public:
  void clear_cycling_speed();
  float cycling_speed() const;
  void set_cycling_speed(float value);
  private:
  float _internal_cycling_speed() const;
  void _internal_set_cycling_speed(float value);
  public:

  // optional float use_bus = 44;
  bool has_use_bus() const;
  private:
  bool _internal_has_use_bus() const;
  public:
  void clear_use_bus();
  float use_bus() const;
  void set_use_bus(float value);
  private:
  float _internal_use_bus() const;
  void _internal_set_use_bus(float value);
  public:

  // optional float use_rail = 45;
  bool has_use_rail() const;
  private:
  bool _internal_has_use_rail() const;
  public:
  void clear_use_rail();
  float use_rail() const;
  void set_use_rail(float value);
  private:
  float _internal_use_rail() const;
  void _internal_set_use_rail(float value);
  public:

  // optional bool hazmat = 35;
  bool has_hazmat() const;
  private:
  bool _internal_has_hazmat() const;
  public:
  void clear_hazmat();
  bool hazmat() const;
  void set_hazmat(bool value);
  private:
  bool _internal_hazmat() const;
  void _internal_set_hazmat(bool value);
  public:

  // optional bool wheelchair = 42;
  bool has_wheelchair() const;
  private:
  bool _internal_has_wheelchair() const;
  public:
  void clear_wheelchair();
  bool wheelchair() const;
  void set_wheelchair(bool value);
  private:
  bool _internal_wheelchair() const;
  void _internal_set_wheelchair(bool value);
  public:

  // optional bool bicycle = 43;
  bool has_bicycle() const;
  private:
  bool _internal_has_bicycle() const;
  public:
  void clear_bicycle();
  bool bicycle() const;
  void set_bicycle(bool value);
  private:
  bool _internal_bicycle() const;
  void _internal_set_bicycle(bool value);
  public:

  // optional bool ignore_restrictions = 60;
  bool has_ignore_restrictions() const;
  private:
  bool _internal_has_ignore_restrictions() const;
  public:
  void clear_ignore_restrictions();
  bool ignore_restrictions() const;
  void set_ignore_restrictions(bool value);
  private:
  bool _internal_ignore_restrictions() const;
  void _internal_set_ignore_restrictions(bool value);
  public:

  // optional float use_transfers = 46;
  bool has_use_transfers() const;
  private:
  bool _internal_has_use_transfers() const;
  public:
  void clear_use_transfers();
  float use_transfers() const;
  void set_use_transfers(float value);
  private:
  float _internal_use_transfers() const;
  void _internal_set_use_transfers(float value);
  public:

  // optional float transfer_cost = 47;
  bool has_transfer_cost() const;
  private:
  bool _internal_has_transfer_cost() const;
  public:
  void clear_transfer_cost();
  float transfer_cost() const;
  void set_transfer_cost(float value);
  private:
  float _internal_transfer_cost() const;
  void _internal_set_transfer_cost(float value);
  public:

  // optional float transfer_penalty = 48;
  bool has_transfer_penalty() const;
  private:
  bool _internal_has_transfer_penalty() const;
  public:
  void clear_transfer_penalty();
  float transfer_penalty() const;
  void set_transfer_penalty(float value);
  private:
  float _internal_transfer_penalty() const;
  void _internal_set_transfer_penalty(float value);
  public:

  // optional .valhalla.FilterAction filter_stop_action = 49;
  bool has_filter_stop_action() const;
  private:
  bool _internal_has_filter_stop_action() const;
  public:
  void clear_filter_stop_action();
  ::valhalla::FilterAction filter_stop_action() const;
  void set_filter_stop_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_stop_action() const;
  void _internal_set_filter_stop_action(::valhalla::FilterAction value);
  public:

  // optional .valhalla.FilterAction filter_operator_action = 51;
  bool has_filter_operator_action() const;
  private:
  bool _internal_has_filter_operator_action() const;
  public:
  void clear_filter_operator_action();
  ::valhalla::FilterAction filter_operator_action() const;
  void set_filter_operator_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_operator_action() const;
  void _internal_set_filter_operator_action(::valhalla::FilterAction value);
  public:

  // optional .valhalla.FilterAction filter_route_action = 53;
  bool has_filter_route_action() const;
  private:
  bool _internal_has_filter_route_action() const;
  public:
  void clear_filter_route_action();
  ::valhalla::FilterAction filter_route_action() const;
  void set_filter_route_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_route_action() const;
  void _internal_set_filter_route_action(::valhalla::FilterAction value);
  public:

  // optional uint32 flow_mask = 55;
  bool has_flow_mask() const;
  private:
  bool _internal_has_flow_mask() const;
  public:
  void clear_flow_mask();
  uint32_t flow_mask() const;
  void set_flow_mask(uint32_t value);
  private:
  uint32_t _internal_flow_mask() const;
  void _internal_set_flow_mask(uint32_t value);
  public:

  // optional float bike_share_cost = 56;
  bool has_bike_share_cost() const;
  private:
  bool _internal_has_bike_share_cost() const;
  public:
  void clear_bike_share_cost();
  float bike_share_cost() const;
  void set_bike_share_cost(float value);
  private:
  float _internal_bike_share_cost() const;
  void _internal_set_bike_share_cost(float value);
  public:

  // optional float bike_share_penalty = 57;
  bool has_bike_share_penalty() const;
  private:
  bool _internal_has_bike_share_penalty() const;
  public:
  void clear_bike_share_penalty();
  float bike_share_penalty() const;
  void set_bike_share_penalty(float value);
  private:
  float _internal_bike_share_penalty() const;
  void _internal_set_bike_share_penalty(float value);
  public:

  // optional float rail_ferry_cost = 58;
  bool has_rail_ferry_cost() const;
  private:
  bool _internal_has_rail_ferry_cost() const;
  public:
  void clear_rail_ferry_cost();
  float rail_ferry_cost() const;
  void set_rail_ferry_cost(float value);
  private:
  float _internal_rail_ferry_cost() const;
  void _internal_set_rail_ferry_cost(float value);
  public:

  // optional float use_rail_ferry = 59;
  bool has_use_rail_ferry() const;
  private:
  bool _internal_has_use_rail_ferry() const;
  public:
  void clear_use_rail_ferry();
  float use_rail_ferry() const;
  void set_use_rail_ferry(float value);
  private:
  float _internal_use_rail_ferry() const;
  void _internal_set_use_rail_ferry(float value);
  public:

  // optional bool ignore_oneways = 61;
  bool has_ignore_oneways() const;
  private:
  bool _internal_has_ignore_oneways() const;
  public:
  void clear_ignore_oneways();
  bool ignore_oneways() const;
  void set_ignore_oneways(bool value);
  private:
  bool _internal_ignore_oneways() const;
  void _internal_set_ignore_oneways(bool value);
  public:

  // optional bool ignore_access = 62;
  bool has_ignore_access() const;
  private:
  bool _internal_has_ignore_access() const;
  public:
  void clear_ignore_access();
  bool ignore_access() const;
  void set_ignore_access(bool value);
  private:
  bool _internal_ignore_access() const;
  void _internal_set_ignore_access(bool value);
  public:

  // optional bool ignore_closures = 63;
  bool has_ignore_closures() const;
  private:
  bool _internal_has_ignore_closures() const;
  public:
  void clear_ignore_closures();
  bool ignore_closures() const;
  void set_ignore_closures(bool value);
  private:
  bool _internal_ignore_closures() const;
  void _internal_set_ignore_closures(bool value);
  public:

  // optional bool shortest = 64;
  bool has_shortest() const;
  private:
  bool _internal_has_shortest() const;
  public:
  void clear_shortest();
  bool shortest() const;
  void set_shortest(bool value);
  private:
  bool _internal_shortest() const;
  void _internal_set_shortest(bool value);
  public:

  // optional float service_penalty = 65;
  bool has_service_penalty() const;
  private:
  bool _internal_has_service_penalty() const;
  public:
  void clear_service_penalty();
  float service_penalty() const;
  void set_service_penalty(float value);
  private:
  float _internal_service_penalty() const;
  void _internal_set_service_penalty(float value);
  public:

  // optional float use_tracks = 66;
  bool has_use_tracks() const;
  private:
  bool _internal_has_use_tracks() const;
  public:
  void clear_use_tracks();
  float use_tracks() const;
  void set_use_tracks(float value);
  private:
  float _internal_use_tracks() const;
  void _internal_set_use_tracks(float value);
  public:

  // optional float use_distance = 67;
  bool has_use_distance() const;
  private:
  bool _internal_has_use_distance() const;
  public:
  void clear_use_distance();
  float use_distance() const;
  void set_use_distance(float value);
  private:
  float _internal_use_distance() const;
  void _internal_set_use_distance(float value);
  public:

  // optional float use_living_streets = 68;
  bool has_use_living_streets() const;
  private:
  bool _internal_has_use_living_streets() const;
  public:
  void clear_use_living_streets();
  float use_living_streets() const;
  void set_use_living_streets(float value);
  private:
  float _internal_use_living_streets() const;
  void _internal_set_use_living_streets(float value);
  public:

  // optional float service_factor = 69;
  bool has_service_factor() const;
  private:
  bool _internal_has_service_factor() const;
  public:
  void clear_service_factor();
  float service_factor() const;
  void set_service_factor(float value);
  private:
  float _internal_service_factor() const;
  void _internal_set_service_factor(float value);
  public:

  // optional float closure_factor = 70;
  bool has_closure_factor() const;
  private:
  bool _internal_has_closure_factor() const;
  public:
  void clear_closure_factor();
  float closure_factor() const;
  void set_closure_factor(float value);
  private:
  float _internal_closure_factor() const;
  void _internal_set_closure_factor(float value);
  public:

  // optional .valhalla.Costing costing = 90;
  bool has_costing() const;
  private:
  bool _internal_has_costing() const;
  public:
  void clear_costing();
  ::valhalla::Costing costing() const;
  void set_costing(::valhalla::Costing value);
  private:
  ::valhalla::Costing _internal_costing() const;
  void _internal_set_costing(::valhalla::Costing value);
  public:

  // optional bool filter_closures = 93 [default = true];
  bool has_filter_closures() const;
  private:
  bool _internal_has_filter_closures() const;
  public:
  void clear_filter_closures();
  bool filter_closures() const;
  void set_filter_closures(bool value);
  private:
  bool _internal_filter_closures() const;
  void _internal_set_filter_closures(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.CostingOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<3> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_stop_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_operator_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_route_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge > avoid_edges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transport_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  float maneuver_penalty_;
  float destination_only_penalty_;
  float gate_cost_;
  float gate_penalty_;
  float toll_booth_cost_;
  float toll_booth_penalty_;
  float alley_penalty_;
  float country_crossing_cost_;
  float country_crossing_penalty_;
  float ferry_cost_;
  float avoid_bad_surfaces_;
  float use_ferry_;
  float use_highways_;
  float use_tolls_;
  float use_roads_;
  uint32_t max_distance_;
  float walking_speed_;
  float step_penalty_;
  uint32_t max_grade_;
  uint32_t max_hiking_difficulty_;
  float mode_factor_;
  float walkway_factor_;
  float sidewalk_factor_;
  float alley_factor_;
  float driveway_factor_;
  float driveway_penalty_;
  uint32_t transit_start_end_max_distance_;
  uint32_t transit_transfer_max_distance_;
  float top_speed_;
  float use_hills_;
  float use_primary_;
  float use_trails_;
  float low_class_penalty_;
  float weight_;
  float axle_load_;
  float height_;
  float width_;
  float length_;
  float cycling_speed_;
  float use_bus_;
  float use_rail_;
  bool hazmat_;
  bool wheelchair_;
  bool bicycle_;
  bool ignore_restrictions_;
  float use_transfers_;
  float transfer_cost_;
  float transfer_penalty_;
  int filter_stop_action_;
  int filter_operator_action_;
  int filter_route_action_;
  uint32_t flow_mask_;
  float bike_share_cost_;
  float bike_share_penalty_;
  float rail_ferry_cost_;
  float use_rail_ferry_;
  bool ignore_oneways_;
  bool ignore_access_;
  bool ignore_closures_;
  bool shortest_;
  float service_penalty_;
  float use_tracks_;
  float use_distance_;
  float use_living_streets_;
  float service_factor_;
  float closure_factor_;
  int costing_;
  bool filter_closures_;
  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class Options_Ring final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Options.Ring) */ {
 public:
  inline Options_Ring() : Options_Ring(nullptr) {}
  ~Options_Ring() override;
  explicit constexpr Options_Ring(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Options_Ring(const Options_Ring& from);
  Options_Ring(Options_Ring&& from) noexcept
    : Options_Ring() {
    *this = ::std::move(from);
  }

  inline Options_Ring& operator=(const Options_Ring& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options_Ring& operator=(Options_Ring&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Options_Ring& default_instance() {
    return *internal_default_instance();
  }
  static inline const Options_Ring* internal_default_instance() {
    return reinterpret_cast<const Options_Ring*>(
               &_Options_Ring_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Options_Ring& a, Options_Ring& b) {
    a.Swap(&b);
  }
  inline void Swap(Options_Ring* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options_Ring* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options_Ring* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Options_Ring>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Options_Ring& from);
  void MergeFrom(const Options_Ring& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Options_Ring* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Options.Ring";
  }
  protected:
  explicit Options_Ring(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordsFieldNumber = 1,
  };
  // repeated .valhalla.LatLng coords = 1;
  int coords_size() const;
  private:
  int _internal_coords_size() const;
  public:
  void clear_coords();
  ::valhalla::LatLng* mutable_coords(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >*
      mutable_coords();
  private:
  const ::valhalla::LatLng& _internal_coords(int index) const;
  ::valhalla::LatLng* _internal_add_coords();
  public:
  const ::valhalla::LatLng& coords(int index) const;
  ::valhalla::LatLng* add_coords();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >&
      coords() const;

  // @@protoc_insertion_point(class_scope:valhalla.Options.Ring)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng > coords_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_options_2eproto;
};
// -------------------------------------------------------------------

class Options final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Options) */ {
 public:
  inline Options() : Options(nullptr) {}
  ~Options() override;
  explicit constexpr Options(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Options(const Options& from);
  Options(Options&& from) noexcept
    : Options() {
    *this = ::std::move(from);
  }

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options& operator=(Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Options& default_instance() {
    return *internal_default_instance();
  }
  static inline const Options* internal_default_instance() {
    return reinterpret_cast<const Options*>(
               &_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Options& a, Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Options>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Options* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Options";
  }
  protected:
  explicit Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Options_Ring Ring;

  typedef Options_Units Units;
  static constexpr Units kilometers =
    Options_Units_kilometers;
  static constexpr Units miles =
    Options_Units_miles;
  static inline bool Units_IsValid(int value) {
    return Options_Units_IsValid(value);
  }
  static constexpr Units Units_MIN =
    Options_Units_Units_MIN;
  static constexpr Units Units_MAX =
    Options_Units_Units_MAX;
  static constexpr int Units_ARRAYSIZE =
    Options_Units_Units_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Units_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Units>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Units_Name.");
    return Options_Units_Name(enum_t_value);
  }
  static inline bool Units_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Units* value) {
    return Options_Units_Parse(name, value);
  }

  typedef Options_Format Format;
  static constexpr Format json =
    Options_Format_json;
  static constexpr Format gpx =
    Options_Format_gpx;
  static constexpr Format osrm =
    Options_Format_osrm;
  static inline bool Format_IsValid(int value) {
    return Options_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    Options_Format_Format_MIN;
  static constexpr Format Format_MAX =
    Options_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    Options_Format_Format_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return Options_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return Options_Format_Parse(name, value);
  }

  typedef Options_Action Action;
  static constexpr Action route =
    Options_Action_route;
  static constexpr Action locate =
    Options_Action_locate;
  static constexpr Action sources_to_targets =
    Options_Action_sources_to_targets;
  static constexpr Action optimized_route =
    Options_Action_optimized_route;
  static constexpr Action isochrone =
    Options_Action_isochrone;
  static constexpr Action trace_route =
    Options_Action_trace_route;
  static constexpr Action trace_attributes =
    Options_Action_trace_attributes;
  static constexpr Action height =
    Options_Action_height;
  static constexpr Action transit_available =
    Options_Action_transit_available;
  static constexpr Action expansion =
    Options_Action_expansion;
  static constexpr Action centroid =
    Options_Action_centroid;
  static constexpr Action status =
    Options_Action_status;
  static inline bool Action_IsValid(int value) {
    return Options_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    Options_Action_Action_MIN;
  static constexpr Action Action_MAX =
    Options_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    Options_Action_Action_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return Options_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Action* value) {
    return Options_Action_Parse(name, value);
  }

  typedef Options_DateTimeType DateTimeType;
  static constexpr DateTimeType current =
    Options_DateTimeType_current;
  static constexpr DateTimeType depart_at =
    Options_DateTimeType_depart_at;
  static constexpr DateTimeType arrive_by =
    Options_DateTimeType_arrive_by;
  static constexpr DateTimeType invariant =
    Options_DateTimeType_invariant;
  static inline bool DateTimeType_IsValid(int value) {
    return Options_DateTimeType_IsValid(value);
  }
  static constexpr DateTimeType DateTimeType_MIN =
    Options_DateTimeType_DateTimeType_MIN;
  static constexpr DateTimeType DateTimeType_MAX =
    Options_DateTimeType_DateTimeType_MAX;
  static constexpr int DateTimeType_ARRAYSIZE =
    Options_DateTimeType_DateTimeType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& DateTimeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DateTimeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DateTimeType_Name.");
    return Options_DateTimeType_Name(enum_t_value);
  }
  static inline bool DateTimeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DateTimeType* value) {
    return Options_DateTimeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCostingOptionsFieldNumber = 13,
    kLocationsFieldNumber = 14,
    kAvoidLocationsFieldNumber = 15,
    kSourcesFieldNumber = 16,
    kTargetsFieldNumber = 17,
    kShapeFieldNumber = 20,
    kContoursFieldNumber = 22,
    kTraceFieldNumber = 27,
    kFilterAttributesFieldNumber = 34,
    kRecostingsFieldNumber = 46,
    kAvoidPolygonsFieldNumber = 47,
    kLanguageFieldNumber = 2,
    kIdFieldNumber = 5,
    kJsonpFieldNumber = 6,
    kEncodedPolylineFieldNumber = 7,
    kDateTimeFieldNumber = 19,
    kUnitsFieldNumber = 1,
    kFormatFieldNumber = 4,
    kCostingFieldNumber = 12,
    kDoNotTrackFieldNumber = 9,
    kRangeFieldNumber = 10,
    kVerboseFieldNumber = 11,
    kPolygonsFieldNumber = 23,
    kResampleDistanceFieldNumber = 21,
    kDateTimeTypeFieldNumber = 18,
    kGeneralizeFieldNumber = 25,
    kGpsAccuracyFieldNumber = 30,
    kSearchRadiusFieldNumber = 31,
    kTurnPenaltyFactorFieldNumber = 32,
    kFilterActionFieldNumber = 33,
    kBreakageDistanceFieldNumber = 36,
    kShowLocationsFieldNumber = 26,
    kUseTimestampsFieldNumber = 37,
    kGuidanceViewsFieldNumber = 41,
    kLinearReferencesFieldNumber = 45,
    kAlternatesFieldNumber = 39,
    kInterpolationDistanceFieldNumber = 40,
    kHeightPrecisionFieldNumber = 43,
    kRoundaboutExitsFieldNumber = 44,
    kDirectionsTypeFieldNumber = 3,
    kActionFieldNumber = 8,
    kDenoiseFieldNumber = 24,
    kShapeMatchFieldNumber = 28,
    kBestPathsFieldNumber = 29,
    kShapeFormatFieldNumber = 38,
  };
  // repeated .valhalla.CostingOptions costing_options = 13;
  int costing_options_size() const;
  private:
  int _internal_costing_options_size() const;
  public:
  void clear_costing_options();
  ::valhalla::CostingOptions* mutable_costing_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >*
      mutable_costing_options();
  private:
  const ::valhalla::CostingOptions& _internal_costing_options(int index) const;
  ::valhalla::CostingOptions* _internal_add_costing_options();
  public:
  const ::valhalla::CostingOptions& costing_options(int index) const;
  ::valhalla::CostingOptions* add_costing_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >&
      costing_options() const;

  // repeated .valhalla.Location locations = 14;
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::valhalla::Location* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_locations();
  private:
  const ::valhalla::Location& _internal_locations(int index) const;
  ::valhalla::Location* _internal_add_locations();
  public:
  const ::valhalla::Location& locations(int index) const;
  ::valhalla::Location* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      locations() const;

  // repeated .valhalla.Location avoid_locations = 15;
  int avoid_locations_size() const;
  private:
  int _internal_avoid_locations_size() const;
  public:
  void clear_avoid_locations();
  ::valhalla::Location* mutable_avoid_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_avoid_locations();
  private:
  const ::valhalla::Location& _internal_avoid_locations(int index) const;
  ::valhalla::Location* _internal_add_avoid_locations();
  public:
  const ::valhalla::Location& avoid_locations(int index) const;
  ::valhalla::Location* add_avoid_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      avoid_locations() const;

  // repeated .valhalla.Location sources = 16;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::valhalla::Location* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_sources();
  private:
  const ::valhalla::Location& _internal_sources(int index) const;
  ::valhalla::Location* _internal_add_sources();
  public:
  const ::valhalla::Location& sources(int index) const;
  ::valhalla::Location* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      sources() const;

  // repeated .valhalla.Location targets = 17;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::valhalla::Location* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_targets();
  private:
  const ::valhalla::Location& _internal_targets(int index) const;
  ::valhalla::Location* _internal_add_targets();
  public:
  const ::valhalla::Location& targets(int index) const;
  ::valhalla::Location* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      targets() const;

  // repeated .valhalla.Location shape = 20;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  ::valhalla::Location* mutable_shape(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_shape();
  private:
  const ::valhalla::Location& _internal_shape(int index) const;
  ::valhalla::Location* _internal_add_shape();
  public:
  const ::valhalla::Location& shape(int index) const;
  ::valhalla::Location* add_shape();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      shape() const;

  // repeated .valhalla.Contour contours = 22;
  int contours_size() const;
  private:
  int _internal_contours_size() const;
  public:
  void clear_contours();
  ::valhalla::Contour* mutable_contours(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >*
      mutable_contours();
  private:
  const ::valhalla::Contour& _internal_contours(int index) const;
  ::valhalla::Contour* _internal_add_contours();
  public:
  const ::valhalla::Contour& contours(int index) const;
  ::valhalla::Contour* add_contours();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >&
      contours() const;

  // repeated .valhalla.Location trace = 27;
  int trace_size() const;
  private:
  int _internal_trace_size() const;
  public:
  void clear_trace();
  ::valhalla::Location* mutable_trace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_trace();
  private:
  const ::valhalla::Location& _internal_trace(int index) const;
  ::valhalla::Location* _internal_add_trace();
  public:
  const ::valhalla::Location& trace(int index) const;
  ::valhalla::Location* add_trace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      trace() const;

  // repeated string filter_attributes = 34;
  int filter_attributes_size() const;
  private:
  int _internal_filter_attributes_size() const;
  public:
  void clear_filter_attributes();
  const std::string& filter_attributes(int index) const;
  std::string* mutable_filter_attributes(int index);
  void set_filter_attributes(int index, const std::string& value);
  void set_filter_attributes(int index, std::string&& value);
  void set_filter_attributes(int index, const char* value);
  void set_filter_attributes(int index, const char* value, size_t size);
  std::string* add_filter_attributes();
  void add_filter_attributes(const std::string& value);
  void add_filter_attributes(std::string&& value);
  void add_filter_attributes(const char* value);
  void add_filter_attributes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filter_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filter_attributes();
  private:
  const std::string& _internal_filter_attributes(int index) const;
  std::string* _internal_add_filter_attributes();
  public:

  // repeated .valhalla.CostingOptions recostings = 46;
  int recostings_size() const;
  private:
  int _internal_recostings_size() const;
  public:
  void clear_recostings();
  ::valhalla::CostingOptions* mutable_recostings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >*
      mutable_recostings();
  private:
  const ::valhalla::CostingOptions& _internal_recostings(int index) const;
  ::valhalla::CostingOptions* _internal_add_recostings();
  public:
  const ::valhalla::CostingOptions& recostings(int index) const;
  ::valhalla::CostingOptions* add_recostings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >&
      recostings() const;

  // repeated .valhalla.Options.Ring avoid_polygons = 47;
  int avoid_polygons_size() const;
  private:
  int _internal_avoid_polygons_size() const;
  public:
  void clear_avoid_polygons();
  ::valhalla::Options_Ring* mutable_avoid_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Options_Ring >*
      mutable_avoid_polygons();
  private:
  const ::valhalla::Options_Ring& _internal_avoid_polygons(int index) const;
  ::valhalla::Options_Ring* _internal_add_avoid_polygons();
  public:
  const ::valhalla::Options_Ring& avoid_polygons(int index) const;
  ::valhalla::Options_Ring* add_avoid_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Options_Ring >&
      avoid_polygons() const;

  // optional string language = 2 [default = "en-US"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string id = 5;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string jsonp = 6;
  bool has_jsonp() const;
  private:
  bool _internal_has_jsonp() const;
  public:
  void clear_jsonp();
  const std::string& jsonp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonp();
  PROTOBUF_NODISCARD std::string* release_jsonp();
  void set_allocated_jsonp(std::string* jsonp);
  private:
  const std::string& _internal_jsonp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonp(const std::string& value);
  std::string* _internal_mutable_jsonp();
  public:

  // optional string encoded_polyline = 7;
  bool has_encoded_polyline() const;
  private:
  bool _internal_has_encoded_polyline() const;
  public:
  void clear_encoded_polyline();
  const std::string& encoded_polyline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encoded_polyline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encoded_polyline();
  PROTOBUF_NODISCARD std::string* release_encoded_polyline();
  void set_allocated_encoded_polyline(std::string* encoded_polyline);
  private:
  const std::string& _internal_encoded_polyline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_polyline(const std::string& value);
  std::string* _internal_mutable_encoded_polyline();
  public:

  // optional string date_time = 19;
  bool has_date_time() const;
  private:
  bool _internal_has_date_time() const;
  public:
  void clear_date_time();
  const std::string& date_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_time();
  PROTOBUF_NODISCARD std::string* release_date_time();
  void set_allocated_date_time(std::string* date_time);
  private:
  const std::string& _internal_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_time(const std::string& value);
  std::string* _internal_mutable_date_time();
  public:

  // optional .valhalla.Options.Units units = 1;
  bool has_units() const;
  private:
  bool _internal_has_units() const;
  public:
  void clear_units();
  ::valhalla::Options_Units units() const;
  void set_units(::valhalla::Options_Units value);
  private:
  ::valhalla::Options_Units _internal_units() const;
  void _internal_set_units(::valhalla::Options_Units value);
  public:

  // optional .valhalla.Options.Format format = 4 [default = json];
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::valhalla::Options_Format format() const;
  void set_format(::valhalla::Options_Format value);
  private:
  ::valhalla::Options_Format _internal_format() const;
  void _internal_set_format(::valhalla::Options_Format value);
  public:

  // optional .valhalla.Costing costing = 12;
  bool has_costing() const;
  private:
  bool _internal_has_costing() const;
  public:
  void clear_costing();
  ::valhalla::Costing costing() const;
  void set_costing(::valhalla::Costing value);
  private:
  ::valhalla::Costing _internal_costing() const;
  void _internal_set_costing(::valhalla::Costing value);
  public:

  // optional bool do_not_track = 9 [default = false];
  bool has_do_not_track() const;
  private:
  bool _internal_has_do_not_track() const;
  public:
  void clear_do_not_track();
  bool do_not_track() const;
  void set_do_not_track(bool value);
  private:
  bool _internal_do_not_track() const;
  void _internal_set_do_not_track(bool value);
  public:

  // optional bool range = 10 [default = false];
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  bool range() const;
  void set_range(bool value);
  private:
  bool _internal_range() const;
  void _internal_set_range(bool value);
  public:

  // optional bool verbose = 11 [default = false];
  bool has_verbose() const;
  private:
  bool _internal_has_verbose() const;
  public:
  void clear_verbose();
  bool verbose() const;
  void set_verbose(bool value);
  private:
  bool _internal_verbose() const;
  void _internal_set_verbose(bool value);
  public:

  // optional bool polygons = 23;
  bool has_polygons() const;
  private:
  bool _internal_has_polygons() const;
  public:
  void clear_polygons();
  bool polygons() const;
  void set_polygons(bool value);
  private:
  bool _internal_polygons() const;
  void _internal_set_polygons(bool value);
  public:

  // optional double resample_distance = 21;
  bool has_resample_distance() const;
  private:
  bool _internal_has_resample_distance() const;
  public:
  void clear_resample_distance();
  double resample_distance() const;
  void set_resample_distance(double value);
  private:
  double _internal_resample_distance() const;
  void _internal_set_resample_distance(double value);
  public:

  // optional .valhalla.Options.DateTimeType date_time_type = 18;
  bool has_date_time_type() const;
  private:
  bool _internal_has_date_time_type() const;
  public:
  void clear_date_time_type();
  ::valhalla::Options_DateTimeType date_time_type() const;
  void set_date_time_type(::valhalla::Options_DateTimeType value);
  private:
  ::valhalla::Options_DateTimeType _internal_date_time_type() const;
  void _internal_set_date_time_type(::valhalla::Options_DateTimeType value);
  public:

  // optional float generalize = 25;
  bool has_generalize() const;
  private:
  bool _internal_has_generalize() const;
  public:
  void clear_generalize();
  float generalize() const;
  void set_generalize(float value);
  private:
  float _internal_generalize() const;
  void _internal_set_generalize(float value);
  public:

  // optional float gps_accuracy = 30;
  bool has_gps_accuracy() const;
  private:
  bool _internal_has_gps_accuracy() const;
  public:
  void clear_gps_accuracy();
  float gps_accuracy() const;
  void set_gps_accuracy(float value);
  private:
  float _internal_gps_accuracy() const;
  void _internal_set_gps_accuracy(float value);
  public:

  // optional float search_radius = 31;
  bool has_search_radius() const;
  private:
  bool _internal_has_search_radius() const;
  public:
  void clear_search_radius();
  float search_radius() const;
  void set_search_radius(float value);
  private:
  float _internal_search_radius() const;
  void _internal_set_search_radius(float value);
  public:

  // optional float turn_penalty_factor = 32;
  bool has_turn_penalty_factor() const;
  private:
  bool _internal_has_turn_penalty_factor() const;
  public:
  void clear_turn_penalty_factor();
  float turn_penalty_factor() const;
  void set_turn_penalty_factor(float value);
  private:
  float _internal_turn_penalty_factor() const;
  void _internal_set_turn_penalty_factor(float value);
  public:

  // optional .valhalla.FilterAction filter_action = 33;
  bool has_filter_action() const;
  private:
  bool _internal_has_filter_action() const;
  public:
  void clear_filter_action();
  ::valhalla::FilterAction filter_action() const;
  void set_filter_action(::valhalla::FilterAction value);
  private:
  ::valhalla::FilterAction _internal_filter_action() const;
  void _internal_set_filter_action(::valhalla::FilterAction value);
  public:

  // optional float breakage_distance = 36;
  bool has_breakage_distance() const;
  private:
  bool _internal_has_breakage_distance() const;
  public:
  void clear_breakage_distance();
  float breakage_distance() const;
  void set_breakage_distance(float value);
  private:
  float _internal_breakage_distance() const;
  void _internal_set_breakage_distance(float value);
  public:

  // optional bool show_locations = 26;
  bool has_show_locations() const;
  private:
  bool _internal_has_show_locations() const;
  public:
  void clear_show_locations();
  bool show_locations() const;
  void set_show_locations(bool value);
  private:
  bool _internal_show_locations() const;
  void _internal_set_show_locations(bool value);
  public:

  // optional bool use_timestamps = 37 [default = false];
  bool has_use_timestamps() const;
  private:
  bool _internal_has_use_timestamps() const;
  public:
  void clear_use_timestamps();
  bool use_timestamps() const;
  void set_use_timestamps(bool value);
  private:
  bool _internal_use_timestamps() const;
  void _internal_set_use_timestamps(bool value);
  public:

  // optional bool guidance_views = 41;
  bool has_guidance_views() const;
  private:
  bool _internal_has_guidance_views() const;
  public:
  void clear_guidance_views();
  bool guidance_views() const;
  void set_guidance_views(bool value);
  private:
  bool _internal_guidance_views() const;
  void _internal_set_guidance_views(bool value);
  public:

  // optional bool linear_references = 45;
  bool has_linear_references() const;
  private:
  bool _internal_has_linear_references() const;
  public:
  void clear_linear_references();
  bool linear_references() const;
  void set_linear_references(bool value);
  private:
  bool _internal_linear_references() const;
  void _internal_set_linear_references(bool value);
  public:

  // optional uint32 alternates = 39;
  bool has_alternates() const;
  private:
  bool _internal_has_alternates() const;
  public:
  void clear_alternates();
  uint32_t alternates() const;
  void set_alternates(uint32_t value);
  private:
  uint32_t _internal_alternates() const;
  void _internal_set_alternates(uint32_t value);
  public:

  // optional float interpolation_distance = 40;
  bool has_interpolation_distance() const;
  private:
  bool _internal_has_interpolation_distance() const;
  public:
  void clear_interpolation_distance();
  float interpolation_distance() const;
  void set_interpolation_distance(float value);
  private:
  float _internal_interpolation_distance() const;
  void _internal_set_interpolation_distance(float value);
  public:

  // optional uint32 height_precision = 43 [default = 0];
  bool has_height_precision() const;
  private:
  bool _internal_has_height_precision() const;
  public:
  void clear_height_precision();
  uint32_t height_precision() const;
  void set_height_precision(uint32_t value);
  private:
  uint32_t _internal_height_precision() const;
  void _internal_set_height_precision(uint32_t value);
  public:

  // optional bool roundabout_exits = 44 [default = true];
  bool has_roundabout_exits() const;
  private:
  bool _internal_has_roundabout_exits() const;
  public:
  void clear_roundabout_exits();
  bool roundabout_exits() const;
  void set_roundabout_exits(bool value);
  private:
  bool _internal_roundabout_exits() const;
  void _internal_set_roundabout_exits(bool value);
  public:

  // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
  bool has_directions_type() const;
  private:
  bool _internal_has_directions_type() const;
  public:
  void clear_directions_type();
  ::valhalla::DirectionsType directions_type() const;
  void set_directions_type(::valhalla::DirectionsType value);
  private:
  ::valhalla::DirectionsType _internal_directions_type() const;
  void _internal_set_directions_type(::valhalla::DirectionsType value);
  public:

  // optional .valhalla.Options.Action action = 8;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::valhalla::Options_Action action() const;
  void set_action(::valhalla::Options_Action value);
  private:
  ::valhalla::Options_Action _internal_action() const;
  void _internal_set_action(::valhalla::Options_Action value);
  public:

  // optional float denoise = 24 [default = 1];
  bool has_denoise() const;
  private:
  bool _internal_has_denoise() const;
  public:
  void clear_denoise();
  float denoise() const;
  void set_denoise(float value);
  private:
  float _internal_denoise() const;
  void _internal_set_denoise(float value);
  public:

  // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
  bool has_shape_match() const;
  private:
  bool _internal_has_shape_match() const;
  public:
  void clear_shape_match();
  ::valhalla::ShapeMatch shape_match() const;
  void set_shape_match(::valhalla::ShapeMatch value);
  private:
  ::valhalla::ShapeMatch _internal_shape_match() const;
  void _internal_set_shape_match(::valhalla::ShapeMatch value);
  public:

  // optional uint32 best_paths = 29 [default = 1];
  bool has_best_paths() const;
  private:
  bool _internal_has_best_paths() const;
  public:
  void clear_best_paths();
  uint32_t best_paths() const;
  void set_best_paths(uint32_t value);
  private:
  uint32_t _internal_best_paths() const;
  void _internal_set_best_paths(uint32_t value);
  public:

  // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
  bool has_shape_format() const;
  private:
  bool _internal_has_shape_format() const;
  public:
  void clear_shape_format();
  ::valhalla::ShapeFormat shape_format() const;
  void set_shape_format(::valhalla::ShapeFormat value);
  private:
  ::valhalla::ShapeFormat _internal_shape_format() const;
  void _internal_set_shape_format(::valhalla::ShapeFormat value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.Options)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions > costing_options_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > locations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > avoid_locations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > sources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > targets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > shape_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour > contours_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > trace_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filter_attributes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions > recostings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Options_Ring > avoid_polygons_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_polyline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_time_;
  int units_;
  int format_;
  int costing_;
  bool do_not_track_;
  bool range_;
  bool verbose_;
  bool polygons_;
  double resample_distance_;
  int date_time_type_;
  float generalize_;
  float gps_accuracy_;
  float search_radius_;
  float turn_penalty_factor_;
  int filter_action_;
  float breakage_distance_;
  bool show_locations_;
  bool use_timestamps_;
  bool guidance_views_;
  bool linear_references_;
  uint32_t alternates_;
  float interpolation_distance_;
  uint32_t height_precision_;
  bool roundabout_exits_;
  int directions_type_;
  int action_;
  float denoise_;
  int shape_match_;
  uint32_t best_paths_;
  int shape_format_;
  friend struct ::TableStruct_options_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Contour

// optional float time = 1;
inline bool Contour::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Contour::has_time() const {
  return _internal_has_time();
}
inline void Contour::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Contour::_internal_time() const {
  return time_;
}
inline float Contour::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.time)
  return _internal_time();
}
inline void Contour::_internal_set_time(float value) {
  _has_bits_[0] |= 0x00000002u;
  time_ = value;
}
inline void Contour::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.time)
}

// optional string color = 2;
inline bool Contour::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Contour::has_color() const {
  return _internal_has_color();
}
inline void Contour::clear_color() {
  color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Contour::color() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Contour::set_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Contour.color)
}
inline std::string* Contour::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:valhalla.Contour.color)
  return _s;
}
inline const std::string& Contour::_internal_color() const {
  return color_.Get();
}
inline void Contour::_internal_set_color(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Contour::_internal_mutable_color() {
  _has_bits_[0] |= 0x00000001u;
  return color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Contour::release_color() {
  // @@protoc_insertion_point(field_release:valhalla.Contour.color)
  if (!_internal_has_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Contour::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Contour.color)
}

// optional float distance = 3;
inline bool Contour::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Contour::has_distance() const {
  return _internal_has_distance();
}
inline void Contour::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Contour::_internal_distance() const {
  return distance_;
}
inline float Contour::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Contour.distance)
  return _internal_distance();
}
inline void Contour::_internal_set_distance(float value) {
  _has_bits_[0] |= 0x00000004u;
  distance_ = value;
}
inline void Contour::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Contour.distance)
}

// -------------------------------------------------------------------

// AvoidEdge

// optional uint64 id = 1;
inline bool AvoidEdge::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AvoidEdge::has_id() const {
  return _internal_has_id();
}
inline void AvoidEdge::clear_id() {
  id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t AvoidEdge::_internal_id() const {
  return id_;
}
inline uint64_t AvoidEdge::id() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.id)
  return _internal_id();
}
inline void AvoidEdge::_internal_set_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void AvoidEdge::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.id)
}

// optional float percent_along = 2;
inline bool AvoidEdge::_internal_has_percent_along() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AvoidEdge::has_percent_along() const {
  return _internal_has_percent_along();
}
inline void AvoidEdge::clear_percent_along() {
  percent_along_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float AvoidEdge::_internal_percent_along() const {
  return percent_along_;
}
inline float AvoidEdge::percent_along() const {
  // @@protoc_insertion_point(field_get:valhalla.AvoidEdge.percent_along)
  return _internal_percent_along();
}
inline void AvoidEdge::_internal_set_percent_along(float value) {
  _has_bits_[0] |= 0x00000002u;
  percent_along_ = value;
}
inline void AvoidEdge::set_percent_along(float value) {
  _internal_set_percent_along(value);
  // @@protoc_insertion_point(field_set:valhalla.AvoidEdge.percent_along)
}

// -------------------------------------------------------------------

// CostingOptions

// optional float maneuver_penalty = 1;
inline bool CostingOptions::_internal_has_maneuver_penalty() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CostingOptions::has_maneuver_penalty() const {
  return _internal_has_maneuver_penalty();
}
inline void CostingOptions::clear_maneuver_penalty() {
  maneuver_penalty_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CostingOptions::_internal_maneuver_penalty() const {
  return maneuver_penalty_;
}
inline float CostingOptions::maneuver_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.maneuver_penalty)
  return _internal_maneuver_penalty();
}
inline void CostingOptions::_internal_set_maneuver_penalty(float value) {
  _has_bits_[0] |= 0x00000004u;
  maneuver_penalty_ = value;
}
inline void CostingOptions::set_maneuver_penalty(float value) {
  _internal_set_maneuver_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.maneuver_penalty)
}

// optional float destination_only_penalty = 2;
inline bool CostingOptions::_internal_has_destination_only_penalty() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CostingOptions::has_destination_only_penalty() const {
  return _internal_has_destination_only_penalty();
}
inline void CostingOptions::clear_destination_only_penalty() {
  destination_only_penalty_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CostingOptions::_internal_destination_only_penalty() const {
  return destination_only_penalty_;
}
inline float CostingOptions::destination_only_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.destination_only_penalty)
  return _internal_destination_only_penalty();
}
inline void CostingOptions::_internal_set_destination_only_penalty(float value) {
  _has_bits_[0] |= 0x00000008u;
  destination_only_penalty_ = value;
}
inline void CostingOptions::set_destination_only_penalty(float value) {
  _internal_set_destination_only_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.destination_only_penalty)
}

// optional float gate_cost = 3;
inline bool CostingOptions::_internal_has_gate_cost() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CostingOptions::has_gate_cost() const {
  return _internal_has_gate_cost();
}
inline void CostingOptions::clear_gate_cost() {
  gate_cost_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float CostingOptions::_internal_gate_cost() const {
  return gate_cost_;
}
inline float CostingOptions::gate_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.gate_cost)
  return _internal_gate_cost();
}
inline void CostingOptions::_internal_set_gate_cost(float value) {
  _has_bits_[0] |= 0x00000010u;
  gate_cost_ = value;
}
inline void CostingOptions::set_gate_cost(float value) {
  _internal_set_gate_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.gate_cost)
}

// optional float gate_penalty = 4;
inline bool CostingOptions::_internal_has_gate_penalty() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CostingOptions::has_gate_penalty() const {
  return _internal_has_gate_penalty();
}
inline void CostingOptions::clear_gate_penalty() {
  gate_penalty_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float CostingOptions::_internal_gate_penalty() const {
  return gate_penalty_;
}
inline float CostingOptions::gate_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.gate_penalty)
  return _internal_gate_penalty();
}
inline void CostingOptions::_internal_set_gate_penalty(float value) {
  _has_bits_[0] |= 0x00000020u;
  gate_penalty_ = value;
}
inline void CostingOptions::set_gate_penalty(float value) {
  _internal_set_gate_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.gate_penalty)
}

// optional float toll_booth_cost = 5;
inline bool CostingOptions::_internal_has_toll_booth_cost() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CostingOptions::has_toll_booth_cost() const {
  return _internal_has_toll_booth_cost();
}
inline void CostingOptions::clear_toll_booth_cost() {
  toll_booth_cost_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float CostingOptions::_internal_toll_booth_cost() const {
  return toll_booth_cost_;
}
inline float CostingOptions::toll_booth_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.toll_booth_cost)
  return _internal_toll_booth_cost();
}
inline void CostingOptions::_internal_set_toll_booth_cost(float value) {
  _has_bits_[0] |= 0x00000040u;
  toll_booth_cost_ = value;
}
inline void CostingOptions::set_toll_booth_cost(float value) {
  _internal_set_toll_booth_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.toll_booth_cost)
}

// optional float toll_booth_penalty = 6;
inline bool CostingOptions::_internal_has_toll_booth_penalty() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CostingOptions::has_toll_booth_penalty() const {
  return _internal_has_toll_booth_penalty();
}
inline void CostingOptions::clear_toll_booth_penalty() {
  toll_booth_penalty_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float CostingOptions::_internal_toll_booth_penalty() const {
  return toll_booth_penalty_;
}
inline float CostingOptions::toll_booth_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.toll_booth_penalty)
  return _internal_toll_booth_penalty();
}
inline void CostingOptions::_internal_set_toll_booth_penalty(float value) {
  _has_bits_[0] |= 0x00000080u;
  toll_booth_penalty_ = value;
}
inline void CostingOptions::set_toll_booth_penalty(float value) {
  _internal_set_toll_booth_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.toll_booth_penalty)
}

// optional float alley_penalty = 7;
inline bool CostingOptions::_internal_has_alley_penalty() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CostingOptions::has_alley_penalty() const {
  return _internal_has_alley_penalty();
}
inline void CostingOptions::clear_alley_penalty() {
  alley_penalty_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float CostingOptions::_internal_alley_penalty() const {
  return alley_penalty_;
}
inline float CostingOptions::alley_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.alley_penalty)
  return _internal_alley_penalty();
}
inline void CostingOptions::_internal_set_alley_penalty(float value) {
  _has_bits_[0] |= 0x00000100u;
  alley_penalty_ = value;
}
inline void CostingOptions::set_alley_penalty(float value) {
  _internal_set_alley_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.alley_penalty)
}

// optional float country_crossing_cost = 8;
inline bool CostingOptions::_internal_has_country_crossing_cost() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CostingOptions::has_country_crossing_cost() const {
  return _internal_has_country_crossing_cost();
}
inline void CostingOptions::clear_country_crossing_cost() {
  country_crossing_cost_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float CostingOptions::_internal_country_crossing_cost() const {
  return country_crossing_cost_;
}
inline float CostingOptions::country_crossing_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.country_crossing_cost)
  return _internal_country_crossing_cost();
}
inline void CostingOptions::_internal_set_country_crossing_cost(float value) {
  _has_bits_[0] |= 0x00000200u;
  country_crossing_cost_ = value;
}
inline void CostingOptions::set_country_crossing_cost(float value) {
  _internal_set_country_crossing_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.country_crossing_cost)
}

// optional float country_crossing_penalty = 9;
inline bool CostingOptions::_internal_has_country_crossing_penalty() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CostingOptions::has_country_crossing_penalty() const {
  return _internal_has_country_crossing_penalty();
}
inline void CostingOptions::clear_country_crossing_penalty() {
  country_crossing_penalty_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float CostingOptions::_internal_country_crossing_penalty() const {
  return country_crossing_penalty_;
}
inline float CostingOptions::country_crossing_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.country_crossing_penalty)
  return _internal_country_crossing_penalty();
}
inline void CostingOptions::_internal_set_country_crossing_penalty(float value) {
  _has_bits_[0] |= 0x00000400u;
  country_crossing_penalty_ = value;
}
inline void CostingOptions::set_country_crossing_penalty(float value) {
  _internal_set_country_crossing_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.country_crossing_penalty)
}

// optional float ferry_cost = 10;
inline bool CostingOptions::_internal_has_ferry_cost() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CostingOptions::has_ferry_cost() const {
  return _internal_has_ferry_cost();
}
inline void CostingOptions::clear_ferry_cost() {
  ferry_cost_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float CostingOptions::_internal_ferry_cost() const {
  return ferry_cost_;
}
inline float CostingOptions::ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ferry_cost)
  return _internal_ferry_cost();
}
inline void CostingOptions::_internal_set_ferry_cost(float value) {
  _has_bits_[0] |= 0x00000800u;
  ferry_cost_ = value;
}
inline void CostingOptions::set_ferry_cost(float value) {
  _internal_set_ferry_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ferry_cost)
}

// optional float avoid_bad_surfaces = 11;
inline bool CostingOptions::_internal_has_avoid_bad_surfaces() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CostingOptions::has_avoid_bad_surfaces() const {
  return _internal_has_avoid_bad_surfaces();
}
inline void CostingOptions::clear_avoid_bad_surfaces() {
  avoid_bad_surfaces_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float CostingOptions::_internal_avoid_bad_surfaces() const {
  return avoid_bad_surfaces_;
}
inline float CostingOptions::avoid_bad_surfaces() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.avoid_bad_surfaces)
  return _internal_avoid_bad_surfaces();
}
inline void CostingOptions::_internal_set_avoid_bad_surfaces(float value) {
  _has_bits_[0] |= 0x00001000u;
  avoid_bad_surfaces_ = value;
}
inline void CostingOptions::set_avoid_bad_surfaces(float value) {
  _internal_set_avoid_bad_surfaces(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.avoid_bad_surfaces)
}

// optional float use_ferry = 12;
inline bool CostingOptions::_internal_has_use_ferry() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_ferry() const {
  return _internal_has_use_ferry();
}
inline void CostingOptions::clear_use_ferry() {
  use_ferry_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float CostingOptions::_internal_use_ferry() const {
  return use_ferry_;
}
inline float CostingOptions::use_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_ferry)
  return _internal_use_ferry();
}
inline void CostingOptions::_internal_set_use_ferry(float value) {
  _has_bits_[0] |= 0x00002000u;
  use_ferry_ = value;
}
inline void CostingOptions::set_use_ferry(float value) {
  _internal_set_use_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_ferry)
}

// optional float use_highways = 13;
inline bool CostingOptions::_internal_has_use_highways() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_highways() const {
  return _internal_has_use_highways();
}
inline void CostingOptions::clear_use_highways() {
  use_highways_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float CostingOptions::_internal_use_highways() const {
  return use_highways_;
}
inline float CostingOptions::use_highways() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_highways)
  return _internal_use_highways();
}
inline void CostingOptions::_internal_set_use_highways(float value) {
  _has_bits_[0] |= 0x00004000u;
  use_highways_ = value;
}
inline void CostingOptions::set_use_highways(float value) {
  _internal_set_use_highways(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_highways)
}

// optional float use_tolls = 14;
inline bool CostingOptions::_internal_has_use_tolls() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_tolls() const {
  return _internal_has_use_tolls();
}
inline void CostingOptions::clear_use_tolls() {
  use_tolls_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float CostingOptions::_internal_use_tolls() const {
  return use_tolls_;
}
inline float CostingOptions::use_tolls() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_tolls)
  return _internal_use_tolls();
}
inline void CostingOptions::_internal_set_use_tolls(float value) {
  _has_bits_[0] |= 0x00008000u;
  use_tolls_ = value;
}
inline void CostingOptions::set_use_tolls(float value) {
  _internal_set_use_tolls(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_tolls)
}

// optional float use_roads = 15;
inline bool CostingOptions::_internal_has_use_roads() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_roads() const {
  return _internal_has_use_roads();
}
inline void CostingOptions::clear_use_roads() {
  use_roads_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float CostingOptions::_internal_use_roads() const {
  return use_roads_;
}
inline float CostingOptions::use_roads() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_roads)
  return _internal_use_roads();
}
inline void CostingOptions::_internal_set_use_roads(float value) {
  _has_bits_[0] |= 0x00010000u;
  use_roads_ = value;
}
inline void CostingOptions::set_use_roads(float value) {
  _internal_set_use_roads(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_roads)
}

// optional uint32 max_distance = 16;
inline bool CostingOptions::_internal_has_max_distance() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CostingOptions::has_max_distance() const {
  return _internal_has_max_distance();
}
inline void CostingOptions::clear_max_distance() {
  max_distance_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t CostingOptions::_internal_max_distance() const {
  return max_distance_;
}
inline uint32_t CostingOptions::max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.max_distance)
  return _internal_max_distance();
}
inline void CostingOptions::_internal_set_max_distance(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  max_distance_ = value;
}
inline void CostingOptions::set_max_distance(uint32_t value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.max_distance)
}

// optional float walking_speed = 17;
inline bool CostingOptions::_internal_has_walking_speed() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CostingOptions::has_walking_speed() const {
  return _internal_has_walking_speed();
}
inline void CostingOptions::clear_walking_speed() {
  walking_speed_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline float CostingOptions::_internal_walking_speed() const {
  return walking_speed_;
}
inline float CostingOptions::walking_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.walking_speed)
  return _internal_walking_speed();
}
inline void CostingOptions::_internal_set_walking_speed(float value) {
  _has_bits_[0] |= 0x00040000u;
  walking_speed_ = value;
}
inline void CostingOptions::set_walking_speed(float value) {
  _internal_set_walking_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.walking_speed)
}

// optional float step_penalty = 18;
inline bool CostingOptions::_internal_has_step_penalty() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CostingOptions::has_step_penalty() const {
  return _internal_has_step_penalty();
}
inline void CostingOptions::clear_step_penalty() {
  step_penalty_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float CostingOptions::_internal_step_penalty() const {
  return step_penalty_;
}
inline float CostingOptions::step_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.step_penalty)
  return _internal_step_penalty();
}
inline void CostingOptions::_internal_set_step_penalty(float value) {
  _has_bits_[0] |= 0x00080000u;
  step_penalty_ = value;
}
inline void CostingOptions::set_step_penalty(float value) {
  _internal_set_step_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.step_penalty)
}

// optional uint32 max_grade = 19;
inline bool CostingOptions::_internal_has_max_grade() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CostingOptions::has_max_grade() const {
  return _internal_has_max_grade();
}
inline void CostingOptions::clear_max_grade() {
  max_grade_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline uint32_t CostingOptions::_internal_max_grade() const {
  return max_grade_;
}
inline uint32_t CostingOptions::max_grade() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.max_grade)
  return _internal_max_grade();
}
inline void CostingOptions::_internal_set_max_grade(uint32_t value) {
  _has_bits_[0] |= 0x00100000u;
  max_grade_ = value;
}
inline void CostingOptions::set_max_grade(uint32_t value) {
  _internal_set_max_grade(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.max_grade)
}

// optional uint32 max_hiking_difficulty = 20;
inline bool CostingOptions::_internal_has_max_hiking_difficulty() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CostingOptions::has_max_hiking_difficulty() const {
  return _internal_has_max_hiking_difficulty();
}
inline void CostingOptions::clear_max_hiking_difficulty() {
  max_hiking_difficulty_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CostingOptions::_internal_max_hiking_difficulty() const {
  return max_hiking_difficulty_;
}
inline uint32_t CostingOptions::max_hiking_difficulty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.max_hiking_difficulty)
  return _internal_max_hiking_difficulty();
}
inline void CostingOptions::_internal_set_max_hiking_difficulty(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  max_hiking_difficulty_ = value;
}
inline void CostingOptions::set_max_hiking_difficulty(uint32_t value) {
  _internal_set_max_hiking_difficulty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.max_hiking_difficulty)
}

// optional float mode_factor = 21;
inline bool CostingOptions::_internal_has_mode_factor() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CostingOptions::has_mode_factor() const {
  return _internal_has_mode_factor();
}
inline void CostingOptions::clear_mode_factor() {
  mode_factor_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline float CostingOptions::_internal_mode_factor() const {
  return mode_factor_;
}
inline float CostingOptions::mode_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.mode_factor)
  return _internal_mode_factor();
}
inline void CostingOptions::_internal_set_mode_factor(float value) {
  _has_bits_[0] |= 0x00400000u;
  mode_factor_ = value;
}
inline void CostingOptions::set_mode_factor(float value) {
  _internal_set_mode_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.mode_factor)
}

// optional float walkway_factor = 22;
inline bool CostingOptions::_internal_has_walkway_factor() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CostingOptions::has_walkway_factor() const {
  return _internal_has_walkway_factor();
}
inline void CostingOptions::clear_walkway_factor() {
  walkway_factor_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline float CostingOptions::_internal_walkway_factor() const {
  return walkway_factor_;
}
inline float CostingOptions::walkway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.walkway_factor)
  return _internal_walkway_factor();
}
inline void CostingOptions::_internal_set_walkway_factor(float value) {
  _has_bits_[0] |= 0x00800000u;
  walkway_factor_ = value;
}
inline void CostingOptions::set_walkway_factor(float value) {
  _internal_set_walkway_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.walkway_factor)
}

// optional float sidewalk_factor = 23;
inline bool CostingOptions::_internal_has_sidewalk_factor() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CostingOptions::has_sidewalk_factor() const {
  return _internal_has_sidewalk_factor();
}
inline void CostingOptions::clear_sidewalk_factor() {
  sidewalk_factor_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline float CostingOptions::_internal_sidewalk_factor() const {
  return sidewalk_factor_;
}
inline float CostingOptions::sidewalk_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.sidewalk_factor)
  return _internal_sidewalk_factor();
}
inline void CostingOptions::_internal_set_sidewalk_factor(float value) {
  _has_bits_[0] |= 0x01000000u;
  sidewalk_factor_ = value;
}
inline void CostingOptions::set_sidewalk_factor(float value) {
  _internal_set_sidewalk_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.sidewalk_factor)
}

// optional float alley_factor = 24;
inline bool CostingOptions::_internal_has_alley_factor() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CostingOptions::has_alley_factor() const {
  return _internal_has_alley_factor();
}
inline void CostingOptions::clear_alley_factor() {
  alley_factor_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline float CostingOptions::_internal_alley_factor() const {
  return alley_factor_;
}
inline float CostingOptions::alley_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.alley_factor)
  return _internal_alley_factor();
}
inline void CostingOptions::_internal_set_alley_factor(float value) {
  _has_bits_[0] |= 0x02000000u;
  alley_factor_ = value;
}
inline void CostingOptions::set_alley_factor(float value) {
  _internal_set_alley_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.alley_factor)
}

// optional float driveway_factor = 25;
inline bool CostingOptions::_internal_has_driveway_factor() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CostingOptions::has_driveway_factor() const {
  return _internal_has_driveway_factor();
}
inline void CostingOptions::clear_driveway_factor() {
  driveway_factor_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline float CostingOptions::_internal_driveway_factor() const {
  return driveway_factor_;
}
inline float CostingOptions::driveway_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.driveway_factor)
  return _internal_driveway_factor();
}
inline void CostingOptions::_internal_set_driveway_factor(float value) {
  _has_bits_[0] |= 0x04000000u;
  driveway_factor_ = value;
}
inline void CostingOptions::set_driveway_factor(float value) {
  _internal_set_driveway_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.driveway_factor)
}

// optional float driveway_penalty = 26;
inline bool CostingOptions::_internal_has_driveway_penalty() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool CostingOptions::has_driveway_penalty() const {
  return _internal_has_driveway_penalty();
}
inline void CostingOptions::clear_driveway_penalty() {
  driveway_penalty_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline float CostingOptions::_internal_driveway_penalty() const {
  return driveway_penalty_;
}
inline float CostingOptions::driveway_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.driveway_penalty)
  return _internal_driveway_penalty();
}
inline void CostingOptions::_internal_set_driveway_penalty(float value) {
  _has_bits_[0] |= 0x08000000u;
  driveway_penalty_ = value;
}
inline void CostingOptions::set_driveway_penalty(float value) {
  _internal_set_driveway_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.driveway_penalty)
}

// optional uint32 transit_start_end_max_distance = 27;
inline bool CostingOptions::_internal_has_transit_start_end_max_distance() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool CostingOptions::has_transit_start_end_max_distance() const {
  return _internal_has_transit_start_end_max_distance();
}
inline void CostingOptions::clear_transit_start_end_max_distance() {
  transit_start_end_max_distance_ = 0u;
  _has_bits_[0] &= ~0x10000000u;
}
inline uint32_t CostingOptions::_internal_transit_start_end_max_distance() const {
  return transit_start_end_max_distance_;
}
inline uint32_t CostingOptions::transit_start_end_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transit_start_end_max_distance)
  return _internal_transit_start_end_max_distance();
}
inline void CostingOptions::_internal_set_transit_start_end_max_distance(uint32_t value) {
  _has_bits_[0] |= 0x10000000u;
  transit_start_end_max_distance_ = value;
}
inline void CostingOptions::set_transit_start_end_max_distance(uint32_t value) {
  _internal_set_transit_start_end_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transit_start_end_max_distance)
}

// optional uint32 transit_transfer_max_distance = 28;
inline bool CostingOptions::_internal_has_transit_transfer_max_distance() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool CostingOptions::has_transit_transfer_max_distance() const {
  return _internal_has_transit_transfer_max_distance();
}
inline void CostingOptions::clear_transit_transfer_max_distance() {
  transit_transfer_max_distance_ = 0u;
  _has_bits_[0] &= ~0x20000000u;
}
inline uint32_t CostingOptions::_internal_transit_transfer_max_distance() const {
  return transit_transfer_max_distance_;
}
inline uint32_t CostingOptions::transit_transfer_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transit_transfer_max_distance)
  return _internal_transit_transfer_max_distance();
}
inline void CostingOptions::_internal_set_transit_transfer_max_distance(uint32_t value) {
  _has_bits_[0] |= 0x20000000u;
  transit_transfer_max_distance_ = value;
}
inline void CostingOptions::set_transit_transfer_max_distance(uint32_t value) {
  _internal_set_transit_transfer_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transit_transfer_max_distance)
}

// optional string transport_type = 29;
inline bool CostingOptions::_internal_has_transport_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CostingOptions::has_transport_type() const {
  return _internal_has_transport_type();
}
inline void CostingOptions::clear_transport_type() {
  transport_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CostingOptions::transport_type() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transport_type)
  return _internal_transport_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CostingOptions::set_transport_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 transport_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transport_type)
}
inline std::string* CostingOptions::mutable_transport_type() {
  std::string* _s = _internal_mutable_transport_type();
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.transport_type)
  return _s;
}
inline const std::string& CostingOptions::_internal_transport_type() const {
  return transport_type_.Get();
}
inline void CostingOptions::_internal_set_transport_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  transport_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CostingOptions::_internal_mutable_transport_type() {
  _has_bits_[0] |= 0x00000001u;
  return transport_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CostingOptions::release_transport_type() {
  // @@protoc_insertion_point(field_release:valhalla.CostingOptions.transport_type)
  if (!_internal_has_transport_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = transport_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transport_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transport_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CostingOptions::set_allocated_transport_type(std::string* transport_type) {
  if (transport_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  transport_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transport_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (transport_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    transport_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.CostingOptions.transport_type)
}

// optional float top_speed = 30;
inline bool CostingOptions::_internal_has_top_speed() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool CostingOptions::has_top_speed() const {
  return _internal_has_top_speed();
}
inline void CostingOptions::clear_top_speed() {
  top_speed_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline float CostingOptions::_internal_top_speed() const {
  return top_speed_;
}
inline float CostingOptions::top_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.top_speed)
  return _internal_top_speed();
}
inline void CostingOptions::_internal_set_top_speed(float value) {
  _has_bits_[0] |= 0x40000000u;
  top_speed_ = value;
}
inline void CostingOptions::set_top_speed(float value) {
  _internal_set_top_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.top_speed)
}

// optional float use_hills = 31;
inline bool CostingOptions::_internal_has_use_hills() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_hills() const {
  return _internal_has_use_hills();
}
inline void CostingOptions::clear_use_hills() {
  use_hills_ = 0;
  _has_bits_[0] &= ~0x80000000u;
}
inline float CostingOptions::_internal_use_hills() const {
  return use_hills_;
}
inline float CostingOptions::use_hills() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_hills)
  return _internal_use_hills();
}
inline void CostingOptions::_internal_set_use_hills(float value) {
  _has_bits_[0] |= 0x80000000u;
  use_hills_ = value;
}
inline void CostingOptions::set_use_hills(float value) {
  _internal_set_use_hills(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_hills)
}

// optional float use_primary = 32;
inline bool CostingOptions::_internal_has_use_primary() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool CostingOptions::has_use_primary() const {
  return _internal_has_use_primary();
}
inline void CostingOptions::clear_use_primary() {
  use_primary_ = 0;
  _has_bits_[1] &= ~0x00000001u;
}
inline float CostingOptions::_internal_use_primary() const {
  return use_primary_;
}
inline float CostingOptions::use_primary() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_primary)
  return _internal_use_primary();
}
inline void CostingOptions::_internal_set_use_primary(float value) {
  _has_bits_[1] |= 0x00000001u;
  use_primary_ = value;
}
inline void CostingOptions::set_use_primary(float value) {
  _internal_set_use_primary(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_primary)
}

// optional float use_trails = 33;
inline bool CostingOptions::_internal_has_use_trails() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool CostingOptions::has_use_trails() const {
  return _internal_has_use_trails();
}
inline void CostingOptions::clear_use_trails() {
  use_trails_ = 0;
  _has_bits_[1] &= ~0x00000002u;
}
inline float CostingOptions::_internal_use_trails() const {
  return use_trails_;
}
inline float CostingOptions::use_trails() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_trails)
  return _internal_use_trails();
}
inline void CostingOptions::_internal_set_use_trails(float value) {
  _has_bits_[1] |= 0x00000002u;
  use_trails_ = value;
}
inline void CostingOptions::set_use_trails(float value) {
  _internal_set_use_trails(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_trails)
}

// optional float low_class_penalty = 34;
inline bool CostingOptions::_internal_has_low_class_penalty() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool CostingOptions::has_low_class_penalty() const {
  return _internal_has_low_class_penalty();
}
inline void CostingOptions::clear_low_class_penalty() {
  low_class_penalty_ = 0;
  _has_bits_[1] &= ~0x00000004u;
}
inline float CostingOptions::_internal_low_class_penalty() const {
  return low_class_penalty_;
}
inline float CostingOptions::low_class_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.low_class_penalty)
  return _internal_low_class_penalty();
}
inline void CostingOptions::_internal_set_low_class_penalty(float value) {
  _has_bits_[1] |= 0x00000004u;
  low_class_penalty_ = value;
}
inline void CostingOptions::set_low_class_penalty(float value) {
  _internal_set_low_class_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.low_class_penalty)
}

// optional bool hazmat = 35;
inline bool CostingOptions::_internal_has_hazmat() const {
  bool value = (_has_bits_[1] & 0x00000800u) != 0;
  return value;
}
inline bool CostingOptions::has_hazmat() const {
  return _internal_has_hazmat();
}
inline void CostingOptions::clear_hazmat() {
  hazmat_ = false;
  _has_bits_[1] &= ~0x00000800u;
}
inline bool CostingOptions::_internal_hazmat() const {
  return hazmat_;
}
inline bool CostingOptions::hazmat() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.hazmat)
  return _internal_hazmat();
}
inline void CostingOptions::_internal_set_hazmat(bool value) {
  _has_bits_[1] |= 0x00000800u;
  hazmat_ = value;
}
inline void CostingOptions::set_hazmat(bool value) {
  _internal_set_hazmat(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.hazmat)
}

// optional float weight = 36;
inline bool CostingOptions::_internal_has_weight() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool CostingOptions::has_weight() const {
  return _internal_has_weight();
}
inline void CostingOptions::clear_weight() {
  weight_ = 0;
  _has_bits_[1] &= ~0x00000008u;
}
inline float CostingOptions::_internal_weight() const {
  return weight_;
}
inline float CostingOptions::weight() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.weight)
  return _internal_weight();
}
inline void CostingOptions::_internal_set_weight(float value) {
  _has_bits_[1] |= 0x00000008u;
  weight_ = value;
}
inline void CostingOptions::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.weight)
}

// optional float axle_load = 37;
inline bool CostingOptions::_internal_has_axle_load() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool CostingOptions::has_axle_load() const {
  return _internal_has_axle_load();
}
inline void CostingOptions::clear_axle_load() {
  axle_load_ = 0;
  _has_bits_[1] &= ~0x00000010u;
}
inline float CostingOptions::_internal_axle_load() const {
  return axle_load_;
}
inline float CostingOptions::axle_load() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.axle_load)
  return _internal_axle_load();
}
inline void CostingOptions::_internal_set_axle_load(float value) {
  _has_bits_[1] |= 0x00000010u;
  axle_load_ = value;
}
inline void CostingOptions::set_axle_load(float value) {
  _internal_set_axle_load(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.axle_load)
}

// optional float height = 38;
inline bool CostingOptions::_internal_has_height() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool CostingOptions::has_height() const {
  return _internal_has_height();
}
inline void CostingOptions::clear_height() {
  height_ = 0;
  _has_bits_[1] &= ~0x00000020u;
}
inline float CostingOptions::_internal_height() const {
  return height_;
}
inline float CostingOptions::height() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.height)
  return _internal_height();
}
inline void CostingOptions::_internal_set_height(float value) {
  _has_bits_[1] |= 0x00000020u;
  height_ = value;
}
inline void CostingOptions::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.height)
}

// optional float width = 39;
inline bool CostingOptions::_internal_has_width() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool CostingOptions::has_width() const {
  return _internal_has_width();
}
inline void CostingOptions::clear_width() {
  width_ = 0;
  _has_bits_[1] &= ~0x00000040u;
}
inline float CostingOptions::_internal_width() const {
  return width_;
}
inline float CostingOptions::width() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.width)
  return _internal_width();
}
inline void CostingOptions::_internal_set_width(float value) {
  _has_bits_[1] |= 0x00000040u;
  width_ = value;
}
inline void CostingOptions::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.width)
}

// optional float length = 40;
inline bool CostingOptions::_internal_has_length() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool CostingOptions::has_length() const {
  return _internal_has_length();
}
inline void CostingOptions::clear_length() {
  length_ = 0;
  _has_bits_[1] &= ~0x00000080u;
}
inline float CostingOptions::_internal_length() const {
  return length_;
}
inline float CostingOptions::length() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.length)
  return _internal_length();
}
inline void CostingOptions::_internal_set_length(float value) {
  _has_bits_[1] |= 0x00000080u;
  length_ = value;
}
inline void CostingOptions::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.length)
}

// optional float cycling_speed = 41;
inline bool CostingOptions::_internal_has_cycling_speed() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool CostingOptions::has_cycling_speed() const {
  return _internal_has_cycling_speed();
}
inline void CostingOptions::clear_cycling_speed() {
  cycling_speed_ = 0;
  _has_bits_[1] &= ~0x00000100u;
}
inline float CostingOptions::_internal_cycling_speed() const {
  return cycling_speed_;
}
inline float CostingOptions::cycling_speed() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.cycling_speed)
  return _internal_cycling_speed();
}
inline void CostingOptions::_internal_set_cycling_speed(float value) {
  _has_bits_[1] |= 0x00000100u;
  cycling_speed_ = value;
}
inline void CostingOptions::set_cycling_speed(float value) {
  _internal_set_cycling_speed(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.cycling_speed)
}

// optional bool wheelchair = 42;
inline bool CostingOptions::_internal_has_wheelchair() const {
  bool value = (_has_bits_[1] & 0x00001000u) != 0;
  return value;
}
inline bool CostingOptions::has_wheelchair() const {
  return _internal_has_wheelchair();
}
inline void CostingOptions::clear_wheelchair() {
  wheelchair_ = false;
  _has_bits_[1] &= ~0x00001000u;
}
inline bool CostingOptions::_internal_wheelchair() const {
  return wheelchair_;
}
inline bool CostingOptions::wheelchair() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.wheelchair)
  return _internal_wheelchair();
}
inline void CostingOptions::_internal_set_wheelchair(bool value) {
  _has_bits_[1] |= 0x00001000u;
  wheelchair_ = value;
}
inline void CostingOptions::set_wheelchair(bool value) {
  _internal_set_wheelchair(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.wheelchair)
}

// optional bool bicycle = 43;
inline bool CostingOptions::_internal_has_bicycle() const {
  bool value = (_has_bits_[1] & 0x00002000u) != 0;
  return value;
}
inline bool CostingOptions::has_bicycle() const {
  return _internal_has_bicycle();
}
inline void CostingOptions::clear_bicycle() {
  bicycle_ = false;
  _has_bits_[1] &= ~0x00002000u;
}
inline bool CostingOptions::_internal_bicycle() const {
  return bicycle_;
}
inline bool CostingOptions::bicycle() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.bicycle)
  return _internal_bicycle();
}
inline void CostingOptions::_internal_set_bicycle(bool value) {
  _has_bits_[1] |= 0x00002000u;
  bicycle_ = value;
}
inline void CostingOptions::set_bicycle(bool value) {
  _internal_set_bicycle(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.bicycle)
}

// optional float use_bus = 44;
inline bool CostingOptions::_internal_has_use_bus() const {
  bool value = (_has_bits_[1] & 0x00000200u) != 0;
  return value;
}
inline bool CostingOptions::has_use_bus() const {
  return _internal_has_use_bus();
}
inline void CostingOptions::clear_use_bus() {
  use_bus_ = 0;
  _has_bits_[1] &= ~0x00000200u;
}
inline float CostingOptions::_internal_use_bus() const {
  return use_bus_;
}
inline float CostingOptions::use_bus() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_bus)
  return _internal_use_bus();
}
inline void CostingOptions::_internal_set_use_bus(float value) {
  _has_bits_[1] |= 0x00000200u;
  use_bus_ = value;
}
inline void CostingOptions::set_use_bus(float value) {
  _internal_set_use_bus(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_bus)
}

// optional float use_rail = 45;
inline bool CostingOptions::_internal_has_use_rail() const {
  bool value = (_has_bits_[1] & 0x00000400u) != 0;
  return value;
}
inline bool CostingOptions::has_use_rail() const {
  return _internal_has_use_rail();
}
inline void CostingOptions::clear_use_rail() {
  use_rail_ = 0;
  _has_bits_[1] &= ~0x00000400u;
}
inline float CostingOptions::_internal_use_rail() const {
  return use_rail_;
}
inline float CostingOptions::use_rail() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_rail)
  return _internal_use_rail();
}
inline void CostingOptions::_internal_set_use_rail(float value) {
  _has_bits_[1] |= 0x00000400u;
  use_rail_ = value;
}
inline void CostingOptions::set_use_rail(float value) {
  _internal_set_use_rail(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_rail)
}

// optional float use_transfers = 46;
inline bool CostingOptions::_internal_has_use_transfers() const {
  bool value = (_has_bits_[1] & 0x00008000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_transfers() const {
  return _internal_has_use_transfers();
}
inline void CostingOptions::clear_use_transfers() {
  use_transfers_ = 0;
  _has_bits_[1] &= ~0x00008000u;
}
inline float CostingOptions::_internal_use_transfers() const {
  return use_transfers_;
}
inline float CostingOptions::use_transfers() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_transfers)
  return _internal_use_transfers();
}
inline void CostingOptions::_internal_set_use_transfers(float value) {
  _has_bits_[1] |= 0x00008000u;
  use_transfers_ = value;
}
inline void CostingOptions::set_use_transfers(float value) {
  _internal_set_use_transfers(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_transfers)
}

// optional float transfer_cost = 47;
inline bool CostingOptions::_internal_has_transfer_cost() const {
  bool value = (_has_bits_[1] & 0x00010000u) != 0;
  return value;
}
inline bool CostingOptions::has_transfer_cost() const {
  return _internal_has_transfer_cost();
}
inline void CostingOptions::clear_transfer_cost() {
  transfer_cost_ = 0;
  _has_bits_[1] &= ~0x00010000u;
}
inline float CostingOptions::_internal_transfer_cost() const {
  return transfer_cost_;
}
inline float CostingOptions::transfer_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transfer_cost)
  return _internal_transfer_cost();
}
inline void CostingOptions::_internal_set_transfer_cost(float value) {
  _has_bits_[1] |= 0x00010000u;
  transfer_cost_ = value;
}
inline void CostingOptions::set_transfer_cost(float value) {
  _internal_set_transfer_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transfer_cost)
}

// optional float transfer_penalty = 48;
inline bool CostingOptions::_internal_has_transfer_penalty() const {
  bool value = (_has_bits_[1] & 0x00020000u) != 0;
  return value;
}
inline bool CostingOptions::has_transfer_penalty() const {
  return _internal_has_transfer_penalty();
}
inline void CostingOptions::clear_transfer_penalty() {
  transfer_penalty_ = 0;
  _has_bits_[1] &= ~0x00020000u;
}
inline float CostingOptions::_internal_transfer_penalty() const {
  return transfer_penalty_;
}
inline float CostingOptions::transfer_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.transfer_penalty)
  return _internal_transfer_penalty();
}
inline void CostingOptions::_internal_set_transfer_penalty(float value) {
  _has_bits_[1] |= 0x00020000u;
  transfer_penalty_ = value;
}
inline void CostingOptions::set_transfer_penalty(float value) {
  _internal_set_transfer_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.transfer_penalty)
}

// optional .valhalla.FilterAction filter_stop_action = 49;
inline bool CostingOptions::_internal_has_filter_stop_action() const {
  bool value = (_has_bits_[1] & 0x00040000u) != 0;
  return value;
}
inline bool CostingOptions::has_filter_stop_action() const {
  return _internal_has_filter_stop_action();
}
inline void CostingOptions::clear_filter_stop_action() {
  filter_stop_action_ = 0;
  _has_bits_[1] &= ~0x00040000u;
}
inline ::valhalla::FilterAction CostingOptions::_internal_filter_stop_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_stop_action_);
}
inline ::valhalla::FilterAction CostingOptions::filter_stop_action() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_stop_action)
  return _internal_filter_stop_action();
}
inline void CostingOptions::_internal_set_filter_stop_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  _has_bits_[1] |= 0x00040000u;
  filter_stop_action_ = value;
}
inline void CostingOptions::set_filter_stop_action(::valhalla::FilterAction value) {
  _internal_set_filter_stop_action(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_stop_action)
}

// repeated string filter_stop_ids = 50;
inline int CostingOptions::_internal_filter_stop_ids_size() const {
  return filter_stop_ids_.size();
}
inline int CostingOptions::filter_stop_ids_size() const {
  return _internal_filter_stop_ids_size();
}
inline void CostingOptions::clear_filter_stop_ids() {
  filter_stop_ids_.Clear();
}
inline std::string* CostingOptions::add_filter_stop_ids() {
  std::string* _s = _internal_add_filter_stop_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.CostingOptions.filter_stop_ids)
  return _s;
}
inline const std::string& CostingOptions::_internal_filter_stop_ids(int index) const {
  return filter_stop_ids_.Get(index);
}
inline const std::string& CostingOptions::filter_stop_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_stop_ids)
  return _internal_filter_stop_ids(index);
}
inline std::string* CostingOptions::mutable_filter_stop_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.filter_stop_ids)
  return filter_stop_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_stop_ids(int index, const std::string& value) {
  filter_stop_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::set_filter_stop_ids(int index, std::string&& value) {
  filter_stop_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::set_filter_stop_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_stop_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::set_filter_stop_ids(int index, const char* value, size_t size) {
  filter_stop_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.filter_stop_ids)
}
inline std::string* CostingOptions::_internal_add_filter_stop_ids() {
  return filter_stop_ids_.Add();
}
inline void CostingOptions::add_filter_stop_ids(const std::string& value) {
  filter_stop_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::add_filter_stop_ids(std::string&& value) {
  filter_stop_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::add_filter_stop_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_stop_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.CostingOptions.filter_stop_ids)
}
inline void CostingOptions::add_filter_stop_ids(const char* value, size_t size) {
  filter_stop_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.CostingOptions.filter_stop_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CostingOptions::filter_stop_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.filter_stop_ids)
  return filter_stop_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CostingOptions::mutable_filter_stop_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.filter_stop_ids)
  return &filter_stop_ids_;
}

// optional .valhalla.FilterAction filter_operator_action = 51;
inline bool CostingOptions::_internal_has_filter_operator_action() const {
  bool value = (_has_bits_[1] & 0x00080000u) != 0;
  return value;
}
inline bool CostingOptions::has_filter_operator_action() const {
  return _internal_has_filter_operator_action();
}
inline void CostingOptions::clear_filter_operator_action() {
  filter_operator_action_ = 0;
  _has_bits_[1] &= ~0x00080000u;
}
inline ::valhalla::FilterAction CostingOptions::_internal_filter_operator_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_operator_action_);
}
inline ::valhalla::FilterAction CostingOptions::filter_operator_action() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_operator_action)
  return _internal_filter_operator_action();
}
inline void CostingOptions::_internal_set_filter_operator_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  _has_bits_[1] |= 0x00080000u;
  filter_operator_action_ = value;
}
inline void CostingOptions::set_filter_operator_action(::valhalla::FilterAction value) {
  _internal_set_filter_operator_action(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_operator_action)
}

// repeated string filter_operator_ids = 52;
inline int CostingOptions::_internal_filter_operator_ids_size() const {
  return filter_operator_ids_.size();
}
inline int CostingOptions::filter_operator_ids_size() const {
  return _internal_filter_operator_ids_size();
}
inline void CostingOptions::clear_filter_operator_ids() {
  filter_operator_ids_.Clear();
}
inline std::string* CostingOptions::add_filter_operator_ids() {
  std::string* _s = _internal_add_filter_operator_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.CostingOptions.filter_operator_ids)
  return _s;
}
inline const std::string& CostingOptions::_internal_filter_operator_ids(int index) const {
  return filter_operator_ids_.Get(index);
}
inline const std::string& CostingOptions::filter_operator_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_operator_ids)
  return _internal_filter_operator_ids(index);
}
inline std::string* CostingOptions::mutable_filter_operator_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.filter_operator_ids)
  return filter_operator_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_operator_ids(int index, const std::string& value) {
  filter_operator_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::set_filter_operator_ids(int index, std::string&& value) {
  filter_operator_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::set_filter_operator_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_operator_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::set_filter_operator_ids(int index, const char* value, size_t size) {
  filter_operator_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.filter_operator_ids)
}
inline std::string* CostingOptions::_internal_add_filter_operator_ids() {
  return filter_operator_ids_.Add();
}
inline void CostingOptions::add_filter_operator_ids(const std::string& value) {
  filter_operator_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::add_filter_operator_ids(std::string&& value) {
  filter_operator_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::add_filter_operator_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_operator_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.CostingOptions.filter_operator_ids)
}
inline void CostingOptions::add_filter_operator_ids(const char* value, size_t size) {
  filter_operator_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.CostingOptions.filter_operator_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CostingOptions::filter_operator_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.filter_operator_ids)
  return filter_operator_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CostingOptions::mutable_filter_operator_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.filter_operator_ids)
  return &filter_operator_ids_;
}

// optional .valhalla.FilterAction filter_route_action = 53;
inline bool CostingOptions::_internal_has_filter_route_action() const {
  bool value = (_has_bits_[1] & 0x00100000u) != 0;
  return value;
}
inline bool CostingOptions::has_filter_route_action() const {
  return _internal_has_filter_route_action();
}
inline void CostingOptions::clear_filter_route_action() {
  filter_route_action_ = 0;
  _has_bits_[1] &= ~0x00100000u;
}
inline ::valhalla::FilterAction CostingOptions::_internal_filter_route_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_route_action_);
}
inline ::valhalla::FilterAction CostingOptions::filter_route_action() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_route_action)
  return _internal_filter_route_action();
}
inline void CostingOptions::_internal_set_filter_route_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  _has_bits_[1] |= 0x00100000u;
  filter_route_action_ = value;
}
inline void CostingOptions::set_filter_route_action(::valhalla::FilterAction value) {
  _internal_set_filter_route_action(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_route_action)
}

// repeated string filter_route_ids = 54;
inline int CostingOptions::_internal_filter_route_ids_size() const {
  return filter_route_ids_.size();
}
inline int CostingOptions::filter_route_ids_size() const {
  return _internal_filter_route_ids_size();
}
inline void CostingOptions::clear_filter_route_ids() {
  filter_route_ids_.Clear();
}
inline std::string* CostingOptions::add_filter_route_ids() {
  std::string* _s = _internal_add_filter_route_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.CostingOptions.filter_route_ids)
  return _s;
}
inline const std::string& CostingOptions::_internal_filter_route_ids(int index) const {
  return filter_route_ids_.Get(index);
}
inline const std::string& CostingOptions::filter_route_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_route_ids)
  return _internal_filter_route_ids(index);
}
inline std::string* CostingOptions::mutable_filter_route_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.filter_route_ids)
  return filter_route_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_route_ids(int index, const std::string& value) {
  filter_route_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::set_filter_route_ids(int index, std::string&& value) {
  filter_route_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::set_filter_route_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_route_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::set_filter_route_ids(int index, const char* value, size_t size) {
  filter_route_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.CostingOptions.filter_route_ids)
}
inline std::string* CostingOptions::_internal_add_filter_route_ids() {
  return filter_route_ids_.Add();
}
inline void CostingOptions::add_filter_route_ids(const std::string& value) {
  filter_route_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::add_filter_route_ids(std::string&& value) {
  filter_route_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::add_filter_route_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_route_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.CostingOptions.filter_route_ids)
}
inline void CostingOptions::add_filter_route_ids(const char* value, size_t size) {
  filter_route_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.CostingOptions.filter_route_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CostingOptions::filter_route_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.filter_route_ids)
  return filter_route_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CostingOptions::mutable_filter_route_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.filter_route_ids)
  return &filter_route_ids_;
}

// optional uint32 flow_mask = 55;
inline bool CostingOptions::_internal_has_flow_mask() const {
  bool value = (_has_bits_[1] & 0x00200000u) != 0;
  return value;
}
inline bool CostingOptions::has_flow_mask() const {
  return _internal_has_flow_mask();
}
inline void CostingOptions::clear_flow_mask() {
  flow_mask_ = 0u;
  _has_bits_[1] &= ~0x00200000u;
}
inline uint32_t CostingOptions::_internal_flow_mask() const {
  return flow_mask_;
}
inline uint32_t CostingOptions::flow_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.flow_mask)
  return _internal_flow_mask();
}
inline void CostingOptions::_internal_set_flow_mask(uint32_t value) {
  _has_bits_[1] |= 0x00200000u;
  flow_mask_ = value;
}
inline void CostingOptions::set_flow_mask(uint32_t value) {
  _internal_set_flow_mask(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.flow_mask)
}

// optional float bike_share_cost = 56;
inline bool CostingOptions::_internal_has_bike_share_cost() const {
  bool value = (_has_bits_[1] & 0x00400000u) != 0;
  return value;
}
inline bool CostingOptions::has_bike_share_cost() const {
  return _internal_has_bike_share_cost();
}
inline void CostingOptions::clear_bike_share_cost() {
  bike_share_cost_ = 0;
  _has_bits_[1] &= ~0x00400000u;
}
inline float CostingOptions::_internal_bike_share_cost() const {
  return bike_share_cost_;
}
inline float CostingOptions::bike_share_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.bike_share_cost)
  return _internal_bike_share_cost();
}
inline void CostingOptions::_internal_set_bike_share_cost(float value) {
  _has_bits_[1] |= 0x00400000u;
  bike_share_cost_ = value;
}
inline void CostingOptions::set_bike_share_cost(float value) {
  _internal_set_bike_share_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.bike_share_cost)
}

// optional float bike_share_penalty = 57;
inline bool CostingOptions::_internal_has_bike_share_penalty() const {
  bool value = (_has_bits_[1] & 0x00800000u) != 0;
  return value;
}
inline bool CostingOptions::has_bike_share_penalty() const {
  return _internal_has_bike_share_penalty();
}
inline void CostingOptions::clear_bike_share_penalty() {
  bike_share_penalty_ = 0;
  _has_bits_[1] &= ~0x00800000u;
}
inline float CostingOptions::_internal_bike_share_penalty() const {
  return bike_share_penalty_;
}
inline float CostingOptions::bike_share_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.bike_share_penalty)
  return _internal_bike_share_penalty();
}
inline void CostingOptions::_internal_set_bike_share_penalty(float value) {
  _has_bits_[1] |= 0x00800000u;
  bike_share_penalty_ = value;
}
inline void CostingOptions::set_bike_share_penalty(float value) {
  _internal_set_bike_share_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.bike_share_penalty)
}

// optional float rail_ferry_cost = 58;
inline bool CostingOptions::_internal_has_rail_ferry_cost() const {
  bool value = (_has_bits_[1] & 0x01000000u) != 0;
  return value;
}
inline bool CostingOptions::has_rail_ferry_cost() const {
  return _internal_has_rail_ferry_cost();
}
inline void CostingOptions::clear_rail_ferry_cost() {
  rail_ferry_cost_ = 0;
  _has_bits_[1] &= ~0x01000000u;
}
inline float CostingOptions::_internal_rail_ferry_cost() const {
  return rail_ferry_cost_;
}
inline float CostingOptions::rail_ferry_cost() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.rail_ferry_cost)
  return _internal_rail_ferry_cost();
}
inline void CostingOptions::_internal_set_rail_ferry_cost(float value) {
  _has_bits_[1] |= 0x01000000u;
  rail_ferry_cost_ = value;
}
inline void CostingOptions::set_rail_ferry_cost(float value) {
  _internal_set_rail_ferry_cost(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.rail_ferry_cost)
}

// optional float use_rail_ferry = 59;
inline bool CostingOptions::_internal_has_use_rail_ferry() const {
  bool value = (_has_bits_[1] & 0x02000000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_rail_ferry() const {
  return _internal_has_use_rail_ferry();
}
inline void CostingOptions::clear_use_rail_ferry() {
  use_rail_ferry_ = 0;
  _has_bits_[1] &= ~0x02000000u;
}
inline float CostingOptions::_internal_use_rail_ferry() const {
  return use_rail_ferry_;
}
inline float CostingOptions::use_rail_ferry() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_rail_ferry)
  return _internal_use_rail_ferry();
}
inline void CostingOptions::_internal_set_use_rail_ferry(float value) {
  _has_bits_[1] |= 0x02000000u;
  use_rail_ferry_ = value;
}
inline void CostingOptions::set_use_rail_ferry(float value) {
  _internal_set_use_rail_ferry(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_rail_ferry)
}

// optional bool ignore_restrictions = 60;
inline bool CostingOptions::_internal_has_ignore_restrictions() const {
  bool value = (_has_bits_[1] & 0x00004000u) != 0;
  return value;
}
inline bool CostingOptions::has_ignore_restrictions() const {
  return _internal_has_ignore_restrictions();
}
inline void CostingOptions::clear_ignore_restrictions() {
  ignore_restrictions_ = false;
  _has_bits_[1] &= ~0x00004000u;
}
inline bool CostingOptions::_internal_ignore_restrictions() const {
  return ignore_restrictions_;
}
inline bool CostingOptions::ignore_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_restrictions)
  return _internal_ignore_restrictions();
}
inline void CostingOptions::_internal_set_ignore_restrictions(bool value) {
  _has_bits_[1] |= 0x00004000u;
  ignore_restrictions_ = value;
}
inline void CostingOptions::set_ignore_restrictions(bool value) {
  _internal_set_ignore_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_restrictions)
}

// optional bool ignore_oneways = 61;
inline bool CostingOptions::_internal_has_ignore_oneways() const {
  bool value = (_has_bits_[1] & 0x04000000u) != 0;
  return value;
}
inline bool CostingOptions::has_ignore_oneways() const {
  return _internal_has_ignore_oneways();
}
inline void CostingOptions::clear_ignore_oneways() {
  ignore_oneways_ = false;
  _has_bits_[1] &= ~0x04000000u;
}
inline bool CostingOptions::_internal_ignore_oneways() const {
  return ignore_oneways_;
}
inline bool CostingOptions::ignore_oneways() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_oneways)
  return _internal_ignore_oneways();
}
inline void CostingOptions::_internal_set_ignore_oneways(bool value) {
  _has_bits_[1] |= 0x04000000u;
  ignore_oneways_ = value;
}
inline void CostingOptions::set_ignore_oneways(bool value) {
  _internal_set_ignore_oneways(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_oneways)
}

// optional bool ignore_access = 62;
inline bool CostingOptions::_internal_has_ignore_access() const {
  bool value = (_has_bits_[1] & 0x08000000u) != 0;
  return value;
}
inline bool CostingOptions::has_ignore_access() const {
  return _internal_has_ignore_access();
}
inline void CostingOptions::clear_ignore_access() {
  ignore_access_ = false;
  _has_bits_[1] &= ~0x08000000u;
}
inline bool CostingOptions::_internal_ignore_access() const {
  return ignore_access_;
}
inline bool CostingOptions::ignore_access() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_access)
  return _internal_ignore_access();
}
inline void CostingOptions::_internal_set_ignore_access(bool value) {
  _has_bits_[1] |= 0x08000000u;
  ignore_access_ = value;
}
inline void CostingOptions::set_ignore_access(bool value) {
  _internal_set_ignore_access(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_access)
}

// optional bool ignore_closures = 63;
inline bool CostingOptions::_internal_has_ignore_closures() const {
  bool value = (_has_bits_[1] & 0x10000000u) != 0;
  return value;
}
inline bool CostingOptions::has_ignore_closures() const {
  return _internal_has_ignore_closures();
}
inline void CostingOptions::clear_ignore_closures() {
  ignore_closures_ = false;
  _has_bits_[1] &= ~0x10000000u;
}
inline bool CostingOptions::_internal_ignore_closures() const {
  return ignore_closures_;
}
inline bool CostingOptions::ignore_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.ignore_closures)
  return _internal_ignore_closures();
}
inline void CostingOptions::_internal_set_ignore_closures(bool value) {
  _has_bits_[1] |= 0x10000000u;
  ignore_closures_ = value;
}
inline void CostingOptions::set_ignore_closures(bool value) {
  _internal_set_ignore_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.ignore_closures)
}

// optional bool shortest = 64;
inline bool CostingOptions::_internal_has_shortest() const {
  bool value = (_has_bits_[1] & 0x20000000u) != 0;
  return value;
}
inline bool CostingOptions::has_shortest() const {
  return _internal_has_shortest();
}
inline void CostingOptions::clear_shortest() {
  shortest_ = false;
  _has_bits_[1] &= ~0x20000000u;
}
inline bool CostingOptions::_internal_shortest() const {
  return shortest_;
}
inline bool CostingOptions::shortest() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.shortest)
  return _internal_shortest();
}
inline void CostingOptions::_internal_set_shortest(bool value) {
  _has_bits_[1] |= 0x20000000u;
  shortest_ = value;
}
inline void CostingOptions::set_shortest(bool value) {
  _internal_set_shortest(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.shortest)
}

// optional float service_penalty = 65;
inline bool CostingOptions::_internal_has_service_penalty() const {
  bool value = (_has_bits_[1] & 0x40000000u) != 0;
  return value;
}
inline bool CostingOptions::has_service_penalty() const {
  return _internal_has_service_penalty();
}
inline void CostingOptions::clear_service_penalty() {
  service_penalty_ = 0;
  _has_bits_[1] &= ~0x40000000u;
}
inline float CostingOptions::_internal_service_penalty() const {
  return service_penalty_;
}
inline float CostingOptions::service_penalty() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.service_penalty)
  return _internal_service_penalty();
}
inline void CostingOptions::_internal_set_service_penalty(float value) {
  _has_bits_[1] |= 0x40000000u;
  service_penalty_ = value;
}
inline void CostingOptions::set_service_penalty(float value) {
  _internal_set_service_penalty(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.service_penalty)
}

// optional float use_tracks = 66;
inline bool CostingOptions::_internal_has_use_tracks() const {
  bool value = (_has_bits_[1] & 0x80000000u) != 0;
  return value;
}
inline bool CostingOptions::has_use_tracks() const {
  return _internal_has_use_tracks();
}
inline void CostingOptions::clear_use_tracks() {
  use_tracks_ = 0;
  _has_bits_[1] &= ~0x80000000u;
}
inline float CostingOptions::_internal_use_tracks() const {
  return use_tracks_;
}
inline float CostingOptions::use_tracks() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_tracks)
  return _internal_use_tracks();
}
inline void CostingOptions::_internal_set_use_tracks(float value) {
  _has_bits_[1] |= 0x80000000u;
  use_tracks_ = value;
}
inline void CostingOptions::set_use_tracks(float value) {
  _internal_set_use_tracks(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_tracks)
}

// optional float use_distance = 67;
inline bool CostingOptions::_internal_has_use_distance() const {
  bool value = (_has_bits_[2] & 0x00000001u) != 0;
  return value;
}
inline bool CostingOptions::has_use_distance() const {
  return _internal_has_use_distance();
}
inline void CostingOptions::clear_use_distance() {
  use_distance_ = 0;
  _has_bits_[2] &= ~0x00000001u;
}
inline float CostingOptions::_internal_use_distance() const {
  return use_distance_;
}
inline float CostingOptions::use_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_distance)
  return _internal_use_distance();
}
inline void CostingOptions::_internal_set_use_distance(float value) {
  _has_bits_[2] |= 0x00000001u;
  use_distance_ = value;
}
inline void CostingOptions::set_use_distance(float value) {
  _internal_set_use_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_distance)
}

// optional float use_living_streets = 68;
inline bool CostingOptions::_internal_has_use_living_streets() const {
  bool value = (_has_bits_[2] & 0x00000002u) != 0;
  return value;
}
inline bool CostingOptions::has_use_living_streets() const {
  return _internal_has_use_living_streets();
}
inline void CostingOptions::clear_use_living_streets() {
  use_living_streets_ = 0;
  _has_bits_[2] &= ~0x00000002u;
}
inline float CostingOptions::_internal_use_living_streets() const {
  return use_living_streets_;
}
inline float CostingOptions::use_living_streets() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.use_living_streets)
  return _internal_use_living_streets();
}
inline void CostingOptions::_internal_set_use_living_streets(float value) {
  _has_bits_[2] |= 0x00000002u;
  use_living_streets_ = value;
}
inline void CostingOptions::set_use_living_streets(float value) {
  _internal_set_use_living_streets(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.use_living_streets)
}

// optional float service_factor = 69;
inline bool CostingOptions::_internal_has_service_factor() const {
  bool value = (_has_bits_[2] & 0x00000004u) != 0;
  return value;
}
inline bool CostingOptions::has_service_factor() const {
  return _internal_has_service_factor();
}
inline void CostingOptions::clear_service_factor() {
  service_factor_ = 0;
  _has_bits_[2] &= ~0x00000004u;
}
inline float CostingOptions::_internal_service_factor() const {
  return service_factor_;
}
inline float CostingOptions::service_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.service_factor)
  return _internal_service_factor();
}
inline void CostingOptions::_internal_set_service_factor(float value) {
  _has_bits_[2] |= 0x00000004u;
  service_factor_ = value;
}
inline void CostingOptions::set_service_factor(float value) {
  _internal_set_service_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.service_factor)
}

// optional float closure_factor = 70;
inline bool CostingOptions::_internal_has_closure_factor() const {
  bool value = (_has_bits_[2] & 0x00000008u) != 0;
  return value;
}
inline bool CostingOptions::has_closure_factor() const {
  return _internal_has_closure_factor();
}
inline void CostingOptions::clear_closure_factor() {
  closure_factor_ = 0;
  _has_bits_[2] &= ~0x00000008u;
}
inline float CostingOptions::_internal_closure_factor() const {
  return closure_factor_;
}
inline float CostingOptions::closure_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.closure_factor)
  return _internal_closure_factor();
}
inline void CostingOptions::_internal_set_closure_factor(float value) {
  _has_bits_[2] |= 0x00000008u;
  closure_factor_ = value;
}
inline void CostingOptions::set_closure_factor(float value) {
  _internal_set_closure_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.closure_factor)
}

// optional .valhalla.Costing costing = 90;
inline bool CostingOptions::_internal_has_costing() const {
  bool value = (_has_bits_[2] & 0x00000010u) != 0;
  return value;
}
inline bool CostingOptions::has_costing() const {
  return _internal_has_costing();
}
inline void CostingOptions::clear_costing() {
  costing_ = 0;
  _has_bits_[2] &= ~0x00000010u;
}
inline ::valhalla::Costing CostingOptions::_internal_costing() const {
  return static_cast< ::valhalla::Costing >(costing_);
}
inline ::valhalla::Costing CostingOptions::costing() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.costing)
  return _internal_costing();
}
inline void CostingOptions::_internal_set_costing(::valhalla::Costing value) {
  assert(::valhalla::Costing_IsValid(value));
  _has_bits_[2] |= 0x00000010u;
  costing_ = value;
}
inline void CostingOptions::set_costing(::valhalla::Costing value) {
  _internal_set_costing(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.costing)
}

// optional string name = 91;
inline bool CostingOptions::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CostingOptions::has_name() const {
  return _internal_has_name();
}
inline void CostingOptions::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CostingOptions::name() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CostingOptions::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.name)
}
inline std::string* CostingOptions::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.name)
  return _s;
}
inline const std::string& CostingOptions::_internal_name() const {
  return name_.Get();
}
inline void CostingOptions::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CostingOptions::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CostingOptions::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.CostingOptions.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CostingOptions::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.CostingOptions.name)
}

// repeated .valhalla.AvoidEdge avoid_edges = 92;
inline int CostingOptions::_internal_avoid_edges_size() const {
  return avoid_edges_.size();
}
inline int CostingOptions::avoid_edges_size() const {
  return _internal_avoid_edges_size();
}
inline void CostingOptions::clear_avoid_edges() {
  avoid_edges_.Clear();
}
inline ::valhalla::AvoidEdge* CostingOptions::mutable_avoid_edges(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.CostingOptions.avoid_edges)
  return avoid_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >*
CostingOptions::mutable_avoid_edges() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.CostingOptions.avoid_edges)
  return &avoid_edges_;
}
inline const ::valhalla::AvoidEdge& CostingOptions::_internal_avoid_edges(int index) const {
  return avoid_edges_.Get(index);
}
inline const ::valhalla::AvoidEdge& CostingOptions::avoid_edges(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.avoid_edges)
  return _internal_avoid_edges(index);
}
inline ::valhalla::AvoidEdge* CostingOptions::_internal_add_avoid_edges() {
  return avoid_edges_.Add();
}
inline ::valhalla::AvoidEdge* CostingOptions::add_avoid_edges() {
  ::valhalla::AvoidEdge* _add = _internal_add_avoid_edges();
  // @@protoc_insertion_point(field_add:valhalla.CostingOptions.avoid_edges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::AvoidEdge >&
CostingOptions::avoid_edges() const {
  // @@protoc_insertion_point(field_list:valhalla.CostingOptions.avoid_edges)
  return avoid_edges_;
}

// optional bool filter_closures = 93 [default = true];
inline bool CostingOptions::_internal_has_filter_closures() const {
  bool value = (_has_bits_[2] & 0x00000020u) != 0;
  return value;
}
inline bool CostingOptions::has_filter_closures() const {
  return _internal_has_filter_closures();
}
inline void CostingOptions::clear_filter_closures() {
  filter_closures_ = true;
  _has_bits_[2] &= ~0x00000020u;
}
inline bool CostingOptions::_internal_filter_closures() const {
  return filter_closures_;
}
inline bool CostingOptions::filter_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.CostingOptions.filter_closures)
  return _internal_filter_closures();
}
inline void CostingOptions::_internal_set_filter_closures(bool value) {
  _has_bits_[2] |= 0x00000020u;
  filter_closures_ = value;
}
inline void CostingOptions::set_filter_closures(bool value) {
  _internal_set_filter_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.CostingOptions.filter_closures)
}

// -------------------------------------------------------------------

// Options_Ring

// repeated .valhalla.LatLng coords = 1;
inline int Options_Ring::_internal_coords_size() const {
  return coords_.size();
}
inline int Options_Ring::coords_size() const {
  return _internal_coords_size();
}
inline ::valhalla::LatLng* Options_Ring::mutable_coords(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.Ring.coords)
  return coords_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >*
Options_Ring::mutable_coords() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.Ring.coords)
  return &coords_;
}
inline const ::valhalla::LatLng& Options_Ring::_internal_coords(int index) const {
  return coords_.Get(index);
}
inline const ::valhalla::LatLng& Options_Ring::coords(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.Ring.coords)
  return _internal_coords(index);
}
inline ::valhalla::LatLng* Options_Ring::_internal_add_coords() {
  return coords_.Add();
}
inline ::valhalla::LatLng* Options_Ring::add_coords() {
  ::valhalla::LatLng* _add = _internal_add_coords();
  // @@protoc_insertion_point(field_add:valhalla.Options.Ring.coords)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::LatLng >&
Options_Ring::coords() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.Ring.coords)
  return coords_;
}

// -------------------------------------------------------------------

// Options

// optional .valhalla.Options.Units units = 1;
inline bool Options::_internal_has_units() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Options::has_units() const {
  return _internal_has_units();
}
inline void Options::clear_units() {
  units_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::valhalla::Options_Units Options::_internal_units() const {
  return static_cast< ::valhalla::Options_Units >(units_);
}
inline ::valhalla::Options_Units Options::units() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.units)
  return _internal_units();
}
inline void Options::_internal_set_units(::valhalla::Options_Units value) {
  assert(::valhalla::Options_Units_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  units_ = value;
}
inline void Options::set_units(::valhalla::Options_Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.units)
}

// optional string language = 2 [default = "en-US"];
inline bool Options::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Options::has_language() const {
  return _internal_has_language();
}
inline void Options::clear_language() {
  language_.ClearToDefault(::valhalla::Options::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Options::language() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.language)
  if (language_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_language_.get();
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Options::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.language)
}
inline std::string* Options::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.language)
  return _s;
}
inline const std::string& Options::_internal_language() const {
  return language_.Get();
}
inline void Options::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000001u;
  return language_.Mutable(::valhalla::Options::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
}
inline std::string* Options::release_language() {
  // @@protoc_insertion_point(field_release:valhalla.Options.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = language_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void Options::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  language_.SetAllocated(nullptr, language,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.language)
}

// optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
inline bool Options::_internal_has_directions_type() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Options::has_directions_type() const {
  return _internal_has_directions_type();
}
inline void Options::clear_directions_type() {
  directions_type_ = 2;
  _has_bits_[0] &= ~0x10000000u;
}
inline ::valhalla::DirectionsType Options::_internal_directions_type() const {
  return static_cast< ::valhalla::DirectionsType >(directions_type_);
}
inline ::valhalla::DirectionsType Options::directions_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.directions_type)
  return _internal_directions_type();
}
inline void Options::_internal_set_directions_type(::valhalla::DirectionsType value) {
  assert(::valhalla::DirectionsType_IsValid(value));
  _has_bits_[0] |= 0x10000000u;
  directions_type_ = value;
}
inline void Options::set_directions_type(::valhalla::DirectionsType value) {
  _internal_set_directions_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.directions_type)
}

// optional .valhalla.Options.Format format = 4 [default = json];
inline bool Options::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Options::has_format() const {
  return _internal_has_format();
}
inline void Options::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::valhalla::Options_Format Options::_internal_format() const {
  return static_cast< ::valhalla::Options_Format >(format_);
}
inline ::valhalla::Options_Format Options::format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.format)
  return _internal_format();
}
inline void Options::_internal_set_format(::valhalla::Options_Format value) {
  assert(::valhalla::Options_Format_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  format_ = value;
}
inline void Options::set_format(::valhalla::Options_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.format)
}

// optional string id = 5;
inline bool Options::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Options::has_id() const {
  return _internal_has_id();
}
inline void Options::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Options::id() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Options::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.id)
}
inline std::string* Options::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.id)
  return _s;
}
inline const std::string& Options::_internal_id() const {
  return id_.Get();
}
inline void Options::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000002u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_id() {
  // @@protoc_insertion_point(field_release:valhalla.Options.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Options::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.id)
}

// optional string jsonp = 6;
inline bool Options::_internal_has_jsonp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Options::has_jsonp() const {
  return _internal_has_jsonp();
}
inline void Options::clear_jsonp() {
  jsonp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Options::jsonp() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.jsonp)
  return _internal_jsonp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Options::set_jsonp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 jsonp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.jsonp)
}
inline std::string* Options::mutable_jsonp() {
  std::string* _s = _internal_mutable_jsonp();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.jsonp)
  return _s;
}
inline const std::string& Options::_internal_jsonp() const {
  return jsonp_.Get();
}
inline void Options::_internal_set_jsonp(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  jsonp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_jsonp() {
  _has_bits_[0] |= 0x00000004u;
  return jsonp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_jsonp() {
  // @@protoc_insertion_point(field_release:valhalla.Options.jsonp)
  if (!_internal_has_jsonp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = jsonp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (jsonp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    jsonp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Options::set_allocated_jsonp(std::string* jsonp) {
  if (jsonp != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  jsonp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jsonp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (jsonp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    jsonp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.jsonp)
}

// optional string encoded_polyline = 7;
inline bool Options::_internal_has_encoded_polyline() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Options::has_encoded_polyline() const {
  return _internal_has_encoded_polyline();
}
inline void Options::clear_encoded_polyline() {
  encoded_polyline_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Options::encoded_polyline() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.encoded_polyline)
  return _internal_encoded_polyline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Options::set_encoded_polyline(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 encoded_polyline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.encoded_polyline)
}
inline std::string* Options::mutable_encoded_polyline() {
  std::string* _s = _internal_mutable_encoded_polyline();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.encoded_polyline)
  return _s;
}
inline const std::string& Options::_internal_encoded_polyline() const {
  return encoded_polyline_.Get();
}
inline void Options::_internal_set_encoded_polyline(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encoded_polyline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_encoded_polyline() {
  _has_bits_[0] |= 0x00000008u;
  return encoded_polyline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_encoded_polyline() {
  // @@protoc_insertion_point(field_release:valhalla.Options.encoded_polyline)
  if (!_internal_has_encoded_polyline()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = encoded_polyline_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_polyline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoded_polyline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Options::set_allocated_encoded_polyline(std::string* encoded_polyline) {
  if (encoded_polyline != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encoded_polyline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_polyline,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encoded_polyline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encoded_polyline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.encoded_polyline)
}

// optional .valhalla.Options.Action action = 8;
inline bool Options::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Options::has_action() const {
  return _internal_has_action();
}
inline void Options::clear_action() {
  action_ = 1;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::valhalla::Options_Action Options::_internal_action() const {
  return static_cast< ::valhalla::Options_Action >(action_);
}
inline ::valhalla::Options_Action Options::action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.action)
  return _internal_action();
}
inline void Options::_internal_set_action(::valhalla::Options_Action value) {
  assert(::valhalla::Options_Action_IsValid(value));
  _has_bits_[0] |= 0x20000000u;
  action_ = value;
}
inline void Options::set_action(::valhalla::Options_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.action)
}

// optional bool do_not_track = 9 [default = false];
inline bool Options::_internal_has_do_not_track() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Options::has_do_not_track() const {
  return _internal_has_do_not_track();
}
inline void Options::clear_do_not_track() {
  do_not_track_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Options::_internal_do_not_track() const {
  return do_not_track_;
}
inline bool Options::do_not_track() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.do_not_track)
  return _internal_do_not_track();
}
inline void Options::_internal_set_do_not_track(bool value) {
  _has_bits_[0] |= 0x00000100u;
  do_not_track_ = value;
}
inline void Options::set_do_not_track(bool value) {
  _internal_set_do_not_track(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.do_not_track)
}

// optional bool range = 10 [default = false];
inline bool Options::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Options::has_range() const {
  return _internal_has_range();
}
inline void Options::clear_range() {
  range_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Options::_internal_range() const {
  return range_;
}
inline bool Options::range() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.range)
  return _internal_range();
}
inline void Options::_internal_set_range(bool value) {
  _has_bits_[0] |= 0x00000200u;
  range_ = value;
}
inline void Options::set_range(bool value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.range)
}

// optional bool verbose = 11 [default = false];
inline bool Options::_internal_has_verbose() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Options::has_verbose() const {
  return _internal_has_verbose();
}
inline void Options::clear_verbose() {
  verbose_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Options::_internal_verbose() const {
  return verbose_;
}
inline bool Options::verbose() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.verbose)
  return _internal_verbose();
}
inline void Options::_internal_set_verbose(bool value) {
  _has_bits_[0] |= 0x00000400u;
  verbose_ = value;
}
inline void Options::set_verbose(bool value) {
  _internal_set_verbose(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.verbose)
}

// optional .valhalla.Costing costing = 12;
inline bool Options::_internal_has_costing() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Options::has_costing() const {
  return _internal_has_costing();
}
inline void Options::clear_costing() {
  costing_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::valhalla::Costing Options::_internal_costing() const {
  return static_cast< ::valhalla::Costing >(costing_);
}
inline ::valhalla::Costing Options::costing() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.costing)
  return _internal_costing();
}
inline void Options::_internal_set_costing(::valhalla::Costing value) {
  assert(::valhalla::Costing_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  costing_ = value;
}
inline void Options::set_costing(::valhalla::Costing value) {
  _internal_set_costing(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.costing)
}

// repeated .valhalla.CostingOptions costing_options = 13;
inline int Options::_internal_costing_options_size() const {
  return costing_options_.size();
}
inline int Options::costing_options_size() const {
  return _internal_costing_options_size();
}
inline void Options::clear_costing_options() {
  costing_options_.Clear();
}
inline ::valhalla::CostingOptions* Options::mutable_costing_options(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.costing_options)
  return costing_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >*
Options::mutable_costing_options() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.costing_options)
  return &costing_options_;
}
inline const ::valhalla::CostingOptions& Options::_internal_costing_options(int index) const {
  return costing_options_.Get(index);
}
inline const ::valhalla::CostingOptions& Options::costing_options(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.costing_options)
  return _internal_costing_options(index);
}
inline ::valhalla::CostingOptions* Options::_internal_add_costing_options() {
  return costing_options_.Add();
}
inline ::valhalla::CostingOptions* Options::add_costing_options() {
  ::valhalla::CostingOptions* _add = _internal_add_costing_options();
  // @@protoc_insertion_point(field_add:valhalla.Options.costing_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >&
Options::costing_options() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.costing_options)
  return costing_options_;
}

// repeated .valhalla.Location locations = 14;
inline int Options::_internal_locations_size() const {
  return locations_.size();
}
inline int Options::locations_size() const {
  return _internal_locations_size();
}
inline ::valhalla::Location* Options::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.locations)
  return locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.locations)
  return &locations_;
}
inline const ::valhalla::Location& Options::_internal_locations(int index) const {
  return locations_.Get(index);
}
inline const ::valhalla::Location& Options::locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.locations)
  return _internal_locations(index);
}
inline ::valhalla::Location* Options::_internal_add_locations() {
  return locations_.Add();
}
inline ::valhalla::Location* Options::add_locations() {
  ::valhalla::Location* _add = _internal_add_locations();
  // @@protoc_insertion_point(field_add:valhalla.Options.locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.locations)
  return locations_;
}

// repeated .valhalla.Location avoid_locations = 15;
inline int Options::_internal_avoid_locations_size() const {
  return avoid_locations_.size();
}
inline int Options::avoid_locations_size() const {
  return _internal_avoid_locations_size();
}
inline ::valhalla::Location* Options::mutable_avoid_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.avoid_locations)
  return avoid_locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_avoid_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.avoid_locations)
  return &avoid_locations_;
}
inline const ::valhalla::Location& Options::_internal_avoid_locations(int index) const {
  return avoid_locations_.Get(index);
}
inline const ::valhalla::Location& Options::avoid_locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.avoid_locations)
  return _internal_avoid_locations(index);
}
inline ::valhalla::Location* Options::_internal_add_avoid_locations() {
  return avoid_locations_.Add();
}
inline ::valhalla::Location* Options::add_avoid_locations() {
  ::valhalla::Location* _add = _internal_add_avoid_locations();
  // @@protoc_insertion_point(field_add:valhalla.Options.avoid_locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::avoid_locations() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.avoid_locations)
  return avoid_locations_;
}

// repeated .valhalla.Location sources = 16;
inline int Options::_internal_sources_size() const {
  return sources_.size();
}
inline int Options::sources_size() const {
  return _internal_sources_size();
}
inline ::valhalla::Location* Options::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.sources)
  return sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.sources)
  return &sources_;
}
inline const ::valhalla::Location& Options::_internal_sources(int index) const {
  return sources_.Get(index);
}
inline const ::valhalla::Location& Options::sources(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.sources)
  return _internal_sources(index);
}
inline ::valhalla::Location* Options::_internal_add_sources() {
  return sources_.Add();
}
inline ::valhalla::Location* Options::add_sources() {
  ::valhalla::Location* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:valhalla.Options.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::sources() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.sources)
  return sources_;
}

// repeated .valhalla.Location targets = 17;
inline int Options::_internal_targets_size() const {
  return targets_.size();
}
inline int Options::targets_size() const {
  return _internal_targets_size();
}
inline ::valhalla::Location* Options::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.targets)
  return &targets_;
}
inline const ::valhalla::Location& Options::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::valhalla::Location& Options::targets(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.targets)
  return _internal_targets(index);
}
inline ::valhalla::Location* Options::_internal_add_targets() {
  return targets_.Add();
}
inline ::valhalla::Location* Options::add_targets() {
  ::valhalla::Location* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:valhalla.Options.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::targets() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.targets)
  return targets_;
}

// optional .valhalla.Options.DateTimeType date_time_type = 18;
inline bool Options::_internal_has_date_time_type() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Options::has_date_time_type() const {
  return _internal_has_date_time_type();
}
inline void Options::clear_date_time_type() {
  date_time_type_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::valhalla::Options_DateTimeType Options::_internal_date_time_type() const {
  return static_cast< ::valhalla::Options_DateTimeType >(date_time_type_);
}
inline ::valhalla::Options_DateTimeType Options::date_time_type() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time_type)
  return _internal_date_time_type();
}
inline void Options::_internal_set_date_time_type(::valhalla::Options_DateTimeType value) {
  assert(::valhalla::Options_DateTimeType_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  date_time_type_ = value;
}
inline void Options::set_date_time_type(::valhalla::Options_DateTimeType value) {
  _internal_set_date_time_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time_type)
}

// optional string date_time = 19;
inline bool Options::_internal_has_date_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Options::has_date_time() const {
  return _internal_has_date_time();
}
inline void Options::clear_date_time() {
  date_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Options::date_time() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.date_time)
  return _internal_date_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Options::set_date_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Options.date_time)
}
inline std::string* Options::mutable_date_time() {
  std::string* _s = _internal_mutable_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.Options.date_time)
  return _s;
}
inline const std::string& Options::_internal_date_time() const {
  return date_time_.Get();
}
inline void Options::_internal_set_date_time(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Options::_internal_mutable_date_time() {
  _has_bits_[0] |= 0x00000010u;
  return date_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Options::release_date_time() {
  // @@protoc_insertion_point(field_release:valhalla.Options.date_time)
  if (!_internal_has_date_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = date_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Options::set_allocated_date_time(std::string* date_time) {
  if (date_time != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  date_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Options.date_time)
}

// repeated .valhalla.Location shape = 20;
inline int Options::_internal_shape_size() const {
  return shape_.size();
}
inline int Options::shape_size() const {
  return _internal_shape_size();
}
inline ::valhalla::Location* Options::mutable_shape(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.shape)
  return shape_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.shape)
  return &shape_;
}
inline const ::valhalla::Location& Options::_internal_shape(int index) const {
  return shape_.Get(index);
}
inline const ::valhalla::Location& Options::shape(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape)
  return _internal_shape(index);
}
inline ::valhalla::Location* Options::_internal_add_shape() {
  return shape_.Add();
}
inline ::valhalla::Location* Options::add_shape() {
  ::valhalla::Location* _add = _internal_add_shape();
  // @@protoc_insertion_point(field_add:valhalla.Options.shape)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::shape() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.shape)
  return shape_;
}

// optional double resample_distance = 21;
inline bool Options::_internal_has_resample_distance() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Options::has_resample_distance() const {
  return _internal_has_resample_distance();
}
inline void Options::clear_resample_distance() {
  resample_distance_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double Options::_internal_resample_distance() const {
  return resample_distance_;
}
inline double Options::resample_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.resample_distance)
  return _internal_resample_distance();
}
inline void Options::_internal_set_resample_distance(double value) {
  _has_bits_[0] |= 0x00001000u;
  resample_distance_ = value;
}
inline void Options::set_resample_distance(double value) {
  _internal_set_resample_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.resample_distance)
}

// repeated .valhalla.Contour contours = 22;
inline int Options::_internal_contours_size() const {
  return contours_.size();
}
inline int Options::contours_size() const {
  return _internal_contours_size();
}
inline void Options::clear_contours() {
  contours_.Clear();
}
inline ::valhalla::Contour* Options::mutable_contours(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.contours)
  return contours_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >*
Options::mutable_contours() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.contours)
  return &contours_;
}
inline const ::valhalla::Contour& Options::_internal_contours(int index) const {
  return contours_.Get(index);
}
inline const ::valhalla::Contour& Options::contours(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.contours)
  return _internal_contours(index);
}
inline ::valhalla::Contour* Options::_internal_add_contours() {
  return contours_.Add();
}
inline ::valhalla::Contour* Options::add_contours() {
  ::valhalla::Contour* _add = _internal_add_contours();
  // @@protoc_insertion_point(field_add:valhalla.Options.contours)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Contour >&
Options::contours() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.contours)
  return contours_;
}

// optional bool polygons = 23;
inline bool Options::_internal_has_polygons() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Options::has_polygons() const {
  return _internal_has_polygons();
}
inline void Options::clear_polygons() {
  polygons_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Options::_internal_polygons() const {
  return polygons_;
}
inline bool Options::polygons() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.polygons)
  return _internal_polygons();
}
inline void Options::_internal_set_polygons(bool value) {
  _has_bits_[0] |= 0x00000800u;
  polygons_ = value;
}
inline void Options::set_polygons(bool value) {
  _internal_set_polygons(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.polygons)
}

// optional float denoise = 24 [default = 1];
inline bool Options::_internal_has_denoise() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Options::has_denoise() const {
  return _internal_has_denoise();
}
inline void Options::clear_denoise() {
  denoise_ = 1;
  _has_bits_[0] &= ~0x40000000u;
}
inline float Options::_internal_denoise() const {
  return denoise_;
}
inline float Options::denoise() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.denoise)
  return _internal_denoise();
}
inline void Options::_internal_set_denoise(float value) {
  _has_bits_[0] |= 0x40000000u;
  denoise_ = value;
}
inline void Options::set_denoise(float value) {
  _internal_set_denoise(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.denoise)
}

// optional float generalize = 25;
inline bool Options::_internal_has_generalize() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Options::has_generalize() const {
  return _internal_has_generalize();
}
inline void Options::clear_generalize() {
  generalize_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float Options::_internal_generalize() const {
  return generalize_;
}
inline float Options::generalize() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.generalize)
  return _internal_generalize();
}
inline void Options::_internal_set_generalize(float value) {
  _has_bits_[0] |= 0x00004000u;
  generalize_ = value;
}
inline void Options::set_generalize(float value) {
  _internal_set_generalize(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.generalize)
}

// optional bool show_locations = 26;
inline bool Options::_internal_has_show_locations() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Options::has_show_locations() const {
  return _internal_has_show_locations();
}
inline void Options::clear_show_locations() {
  show_locations_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool Options::_internal_show_locations() const {
  return show_locations_;
}
inline bool Options::show_locations() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.show_locations)
  return _internal_show_locations();
}
inline void Options::_internal_set_show_locations(bool value) {
  _has_bits_[0] |= 0x00100000u;
  show_locations_ = value;
}
inline void Options::set_show_locations(bool value) {
  _internal_set_show_locations(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.show_locations)
}

// repeated .valhalla.Location trace = 27;
inline int Options::_internal_trace_size() const {
  return trace_.size();
}
inline int Options::trace_size() const {
  return _internal_trace_size();
}
inline ::valhalla::Location* Options::mutable_trace(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.trace)
  return trace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_trace() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.trace)
  return &trace_;
}
inline const ::valhalla::Location& Options::_internal_trace(int index) const {
  return trace_.Get(index);
}
inline const ::valhalla::Location& Options::trace(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.trace)
  return _internal_trace(index);
}
inline ::valhalla::Location* Options::_internal_add_trace() {
  return trace_.Add();
}
inline ::valhalla::Location* Options::add_trace() {
  ::valhalla::Location* _add = _internal_add_trace();
  // @@protoc_insertion_point(field_add:valhalla.Options.trace)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
Options::trace() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.trace)
  return trace_;
}

// optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
inline bool Options::_internal_has_shape_match() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool Options::has_shape_match() const {
  return _internal_has_shape_match();
}
inline void Options::clear_shape_match() {
  shape_match_ = 2;
  _has_bits_[0] &= ~0x80000000u;
}
inline ::valhalla::ShapeMatch Options::_internal_shape_match() const {
  return static_cast< ::valhalla::ShapeMatch >(shape_match_);
}
inline ::valhalla::ShapeMatch Options::shape_match() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_match)
  return _internal_shape_match();
}
inline void Options::_internal_set_shape_match(::valhalla::ShapeMatch value) {
  assert(::valhalla::ShapeMatch_IsValid(value));
  _has_bits_[0] |= 0x80000000u;
  shape_match_ = value;
}
inline void Options::set_shape_match(::valhalla::ShapeMatch value) {
  _internal_set_shape_match(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_match)
}

// optional uint32 best_paths = 29 [default = 1];
inline bool Options::_internal_has_best_paths() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool Options::has_best_paths() const {
  return _internal_has_best_paths();
}
inline void Options::clear_best_paths() {
  best_paths_ = 1u;
  _has_bits_[1] &= ~0x00000001u;
}
inline uint32_t Options::_internal_best_paths() const {
  return best_paths_;
}
inline uint32_t Options::best_paths() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.best_paths)
  return _internal_best_paths();
}
inline void Options::_internal_set_best_paths(uint32_t value) {
  _has_bits_[1] |= 0x00000001u;
  best_paths_ = value;
}
inline void Options::set_best_paths(uint32_t value) {
  _internal_set_best_paths(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.best_paths)
}

// optional float gps_accuracy = 30;
inline bool Options::_internal_has_gps_accuracy() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Options::has_gps_accuracy() const {
  return _internal_has_gps_accuracy();
}
inline void Options::clear_gps_accuracy() {
  gps_accuracy_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float Options::_internal_gps_accuracy() const {
  return gps_accuracy_;
}
inline float Options::gps_accuracy() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.gps_accuracy)
  return _internal_gps_accuracy();
}
inline void Options::_internal_set_gps_accuracy(float value) {
  _has_bits_[0] |= 0x00008000u;
  gps_accuracy_ = value;
}
inline void Options::set_gps_accuracy(float value) {
  _internal_set_gps_accuracy(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.gps_accuracy)
}

// optional float search_radius = 31;
inline bool Options::_internal_has_search_radius() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Options::has_search_radius() const {
  return _internal_has_search_radius();
}
inline void Options::clear_search_radius() {
  search_radius_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float Options::_internal_search_radius() const {
  return search_radius_;
}
inline float Options::search_radius() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.search_radius)
  return _internal_search_radius();
}
inline void Options::_internal_set_search_radius(float value) {
  _has_bits_[0] |= 0x00010000u;
  search_radius_ = value;
}
inline void Options::set_search_radius(float value) {
  _internal_set_search_radius(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.search_radius)
}

// optional float turn_penalty_factor = 32;
inline bool Options::_internal_has_turn_penalty_factor() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Options::has_turn_penalty_factor() const {
  return _internal_has_turn_penalty_factor();
}
inline void Options::clear_turn_penalty_factor() {
  turn_penalty_factor_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline float Options::_internal_turn_penalty_factor() const {
  return turn_penalty_factor_;
}
inline float Options::turn_penalty_factor() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.turn_penalty_factor)
  return _internal_turn_penalty_factor();
}
inline void Options::_internal_set_turn_penalty_factor(float value) {
  _has_bits_[0] |= 0x00020000u;
  turn_penalty_factor_ = value;
}
inline void Options::set_turn_penalty_factor(float value) {
  _internal_set_turn_penalty_factor(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.turn_penalty_factor)
}

// optional .valhalla.FilterAction filter_action = 33;
inline bool Options::_internal_has_filter_action() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Options::has_filter_action() const {
  return _internal_has_filter_action();
}
inline void Options::clear_filter_action() {
  filter_action_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::valhalla::FilterAction Options::_internal_filter_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_action_);
}
inline ::valhalla::FilterAction Options::filter_action() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_action)
  return _internal_filter_action();
}
inline void Options::_internal_set_filter_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  filter_action_ = value;
}
inline void Options::set_filter_action(::valhalla::FilterAction value) {
  _internal_set_filter_action(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_action)
}

// repeated string filter_attributes = 34;
inline int Options::_internal_filter_attributes_size() const {
  return filter_attributes_.size();
}
inline int Options::filter_attributes_size() const {
  return _internal_filter_attributes_size();
}
inline void Options::clear_filter_attributes() {
  filter_attributes_.Clear();
}
inline std::string* Options::add_filter_attributes() {
  std::string* _s = _internal_add_filter_attributes();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Options.filter_attributes)
  return _s;
}
inline const std::string& Options::_internal_filter_attributes(int index) const {
  return filter_attributes_.Get(index);
}
inline const std::string& Options::filter_attributes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.filter_attributes)
  return _internal_filter_attributes(index);
}
inline std::string* Options::mutable_filter_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.filter_attributes)
  return filter_attributes_.Mutable(index);
}
inline void Options::set_filter_attributes(int index, const std::string& value) {
  filter_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, std::string&& value) {
  filter_attributes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Options.filter_attributes)
}
inline void Options::set_filter_attributes(int index, const char* value, size_t size) {
  filter_attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Options.filter_attributes)
}
inline std::string* Options::_internal_add_filter_attributes() {
  return filter_attributes_.Add();
}
inline void Options::add_filter_attributes(const std::string& value) {
  filter_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(std::string&& value) {
  filter_attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filter_attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Options.filter_attributes)
}
inline void Options::add_filter_attributes(const char* value, size_t size) {
  filter_attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Options.filter_attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Options::filter_attributes() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.filter_attributes)
  return filter_attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Options::mutable_filter_attributes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.filter_attributes)
  return &filter_attributes_;
}

// optional float breakage_distance = 36;
inline bool Options::_internal_has_breakage_distance() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Options::has_breakage_distance() const {
  return _internal_has_breakage_distance();
}
inline void Options::clear_breakage_distance() {
  breakage_distance_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float Options::_internal_breakage_distance() const {
  return breakage_distance_;
}
inline float Options::breakage_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.breakage_distance)
  return _internal_breakage_distance();
}
inline void Options::_internal_set_breakage_distance(float value) {
  _has_bits_[0] |= 0x00080000u;
  breakage_distance_ = value;
}
inline void Options::set_breakage_distance(float value) {
  _internal_set_breakage_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.breakage_distance)
}

// optional bool use_timestamps = 37 [default = false];
inline bool Options::_internal_has_use_timestamps() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Options::has_use_timestamps() const {
  return _internal_has_use_timestamps();
}
inline void Options::clear_use_timestamps() {
  use_timestamps_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Options::_internal_use_timestamps() const {
  return use_timestamps_;
}
inline bool Options::use_timestamps() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.use_timestamps)
  return _internal_use_timestamps();
}
inline void Options::_internal_set_use_timestamps(bool value) {
  _has_bits_[0] |= 0x00200000u;
  use_timestamps_ = value;
}
inline void Options::set_use_timestamps(bool value) {
  _internal_set_use_timestamps(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.use_timestamps)
}

// optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
inline bool Options::_internal_has_shape_format() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool Options::has_shape_format() const {
  return _internal_has_shape_format();
}
inline void Options::clear_shape_format() {
  shape_format_ = 1;
  _has_bits_[1] &= ~0x00000002u;
}
inline ::valhalla::ShapeFormat Options::_internal_shape_format() const {
  return static_cast< ::valhalla::ShapeFormat >(shape_format_);
}
inline ::valhalla::ShapeFormat Options::shape_format() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.shape_format)
  return _internal_shape_format();
}
inline void Options::_internal_set_shape_format(::valhalla::ShapeFormat value) {
  assert(::valhalla::ShapeFormat_IsValid(value));
  _has_bits_[1] |= 0x00000002u;
  shape_format_ = value;
}
inline void Options::set_shape_format(::valhalla::ShapeFormat value) {
  _internal_set_shape_format(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.shape_format)
}

// optional uint32 alternates = 39;
inline bool Options::_internal_has_alternates() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Options::has_alternates() const {
  return _internal_has_alternates();
}
inline void Options::clear_alternates() {
  alternates_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline uint32_t Options::_internal_alternates() const {
  return alternates_;
}
inline uint32_t Options::alternates() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.alternates)
  return _internal_alternates();
}
inline void Options::_internal_set_alternates(uint32_t value) {
  _has_bits_[0] |= 0x01000000u;
  alternates_ = value;
}
inline void Options::set_alternates(uint32_t value) {
  _internal_set_alternates(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.alternates)
}

// optional float interpolation_distance = 40;
inline bool Options::_internal_has_interpolation_distance() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Options::has_interpolation_distance() const {
  return _internal_has_interpolation_distance();
}
inline void Options::clear_interpolation_distance() {
  interpolation_distance_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline float Options::_internal_interpolation_distance() const {
  return interpolation_distance_;
}
inline float Options::interpolation_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.interpolation_distance)
  return _internal_interpolation_distance();
}
inline void Options::_internal_set_interpolation_distance(float value) {
  _has_bits_[0] |= 0x02000000u;
  interpolation_distance_ = value;
}
inline void Options::set_interpolation_distance(float value) {
  _internal_set_interpolation_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.interpolation_distance)
}

// optional bool guidance_views = 41;
inline bool Options::_internal_has_guidance_views() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Options::has_guidance_views() const {
  return _internal_has_guidance_views();
}
inline void Options::clear_guidance_views() {
  guidance_views_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Options::_internal_guidance_views() const {
  return guidance_views_;
}
inline bool Options::guidance_views() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.guidance_views)
  return _internal_guidance_views();
}
inline void Options::_internal_set_guidance_views(bool value) {
  _has_bits_[0] |= 0x00400000u;
  guidance_views_ = value;
}
inline void Options::set_guidance_views(bool value) {
  _internal_set_guidance_views(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.guidance_views)
}

// optional uint32 height_precision = 43 [default = 0];
inline bool Options::_internal_has_height_precision() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Options::has_height_precision() const {
  return _internal_has_height_precision();
}
inline void Options::clear_height_precision() {
  height_precision_ = 0u;
  _has_bits_[0] &= ~0x04000000u;
}
inline uint32_t Options::_internal_height_precision() const {
  return height_precision_;
}
inline uint32_t Options::height_precision() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.height_precision)
  return _internal_height_precision();
}
inline void Options::_internal_set_height_precision(uint32_t value) {
  _has_bits_[0] |= 0x04000000u;
  height_precision_ = value;
}
inline void Options::set_height_precision(uint32_t value) {
  _internal_set_height_precision(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.height_precision)
}

// optional bool roundabout_exits = 44 [default = true];
inline bool Options::_internal_has_roundabout_exits() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Options::has_roundabout_exits() const {
  return _internal_has_roundabout_exits();
}
inline void Options::clear_roundabout_exits() {
  roundabout_exits_ = true;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool Options::_internal_roundabout_exits() const {
  return roundabout_exits_;
}
inline bool Options::roundabout_exits() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.roundabout_exits)
  return _internal_roundabout_exits();
}
inline void Options::_internal_set_roundabout_exits(bool value) {
  _has_bits_[0] |= 0x08000000u;
  roundabout_exits_ = value;
}
inline void Options::set_roundabout_exits(bool value) {
  _internal_set_roundabout_exits(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.roundabout_exits)
}

// optional bool linear_references = 45;
inline bool Options::_internal_has_linear_references() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Options::has_linear_references() const {
  return _internal_has_linear_references();
}
inline void Options::clear_linear_references() {
  linear_references_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool Options::_internal_linear_references() const {
  return linear_references_;
}
inline bool Options::linear_references() const {
  // @@protoc_insertion_point(field_get:valhalla.Options.linear_references)
  return _internal_linear_references();
}
inline void Options::_internal_set_linear_references(bool value) {
  _has_bits_[0] |= 0x00800000u;
  linear_references_ = value;
}
inline void Options::set_linear_references(bool value) {
  _internal_set_linear_references(value);
  // @@protoc_insertion_point(field_set:valhalla.Options.linear_references)
}

// repeated .valhalla.CostingOptions recostings = 46;
inline int Options::_internal_recostings_size() const {
  return recostings_.size();
}
inline int Options::recostings_size() const {
  return _internal_recostings_size();
}
inline void Options::clear_recostings() {
  recostings_.Clear();
}
inline ::valhalla::CostingOptions* Options::mutable_recostings(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.recostings)
  return recostings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >*
Options::mutable_recostings() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.recostings)
  return &recostings_;
}
inline const ::valhalla::CostingOptions& Options::_internal_recostings(int index) const {
  return recostings_.Get(index);
}
inline const ::valhalla::CostingOptions& Options::recostings(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.recostings)
  return _internal_recostings(index);
}
inline ::valhalla::CostingOptions* Options::_internal_add_recostings() {
  return recostings_.Add();
}
inline ::valhalla::CostingOptions* Options::add_recostings() {
  ::valhalla::CostingOptions* _add = _internal_add_recostings();
  // @@protoc_insertion_point(field_add:valhalla.Options.recostings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::CostingOptions >&
Options::recostings() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.recostings)
  return recostings_;
}

// repeated .valhalla.Options.Ring avoid_polygons = 47;
inline int Options::_internal_avoid_polygons_size() const {
  return avoid_polygons_.size();
}
inline int Options::avoid_polygons_size() const {
  return _internal_avoid_polygons_size();
}
inline void Options::clear_avoid_polygons() {
  avoid_polygons_.Clear();
}
inline ::valhalla::Options_Ring* Options::mutable_avoid_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Options.avoid_polygons)
  return avoid_polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Options_Ring >*
Options::mutable_avoid_polygons() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Options.avoid_polygons)
  return &avoid_polygons_;
}
inline const ::valhalla::Options_Ring& Options::_internal_avoid_polygons(int index) const {
  return avoid_polygons_.Get(index);
}
inline const ::valhalla::Options_Ring& Options::avoid_polygons(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Options.avoid_polygons)
  return _internal_avoid_polygons(index);
}
inline ::valhalla::Options_Ring* Options::_internal_add_avoid_polygons() {
  return avoid_polygons_.Add();
}
inline ::valhalla::Options_Ring* Options::add_avoid_polygons() {
  ::valhalla::Options_Ring* _add = _internal_add_avoid_polygons();
  // @@protoc_insertion_point(field_add:valhalla.Options.avoid_polygons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Options_Ring >&
Options::avoid_polygons() const {
  // @@protoc_insertion_point(field_list:valhalla.Options.avoid_polygons)
  return avoid_polygons_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::Options_Units> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Format> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_Action> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Options_DateTimeType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::ShapeMatch> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::FilterAction> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::ShapeFormat> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Costing> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_options_2eproto
