// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#include "options.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace valhalla {
constexpr Contour::Contour(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : color_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , time_(0)
  , distance_(0){}
struct ContourDefaultTypeInternal {
  constexpr ContourDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ContourDefaultTypeInternal() {}
  union {
    Contour _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ContourDefaultTypeInternal _Contour_default_instance_;
constexpr AvoidEdge::AvoidEdge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(uint64_t{0u})
  , percent_along_(0){}
struct AvoidEdgeDefaultTypeInternal {
  constexpr AvoidEdgeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvoidEdgeDefaultTypeInternal() {}
  union {
    AvoidEdge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvoidEdgeDefaultTypeInternal _AvoidEdge_default_instance_;
constexpr CostingOptions::CostingOptions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : filter_stop_ids_()
  , filter_operator_ids_()
  , filter_route_ids_()
  , avoid_edges_()
  , transport_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , maneuver_penalty_(0)
  , destination_only_penalty_(0)
  , gate_cost_(0)
  , gate_penalty_(0)
  , toll_booth_cost_(0)
  , toll_booth_penalty_(0)
  , alley_penalty_(0)
  , country_crossing_cost_(0)
  , country_crossing_penalty_(0)
  , ferry_cost_(0)
  , avoid_bad_surfaces_(0)
  , use_ferry_(0)
  , use_highways_(0)
  , use_tolls_(0)
  , use_roads_(0)
  , max_distance_(0u)
  , walking_speed_(0)
  , step_penalty_(0)
  , max_grade_(0u)
  , max_hiking_difficulty_(0u)
  , mode_factor_(0)
  , walkway_factor_(0)
  , sidewalk_factor_(0)
  , alley_factor_(0)
  , driveway_factor_(0)
  , driveway_penalty_(0)
  , transit_start_end_max_distance_(0u)
  , transit_transfer_max_distance_(0u)
  , top_speed_(0)
  , use_hills_(0)
  , use_primary_(0)
  , use_trails_(0)
  , low_class_penalty_(0)
  , weight_(0)
  , axle_load_(0)
  , height_(0)
  , width_(0)
  , length_(0)
  , cycling_speed_(0)
  , use_bus_(0)
  , use_rail_(0)
  , hazmat_(false)
  , wheelchair_(false)
  , bicycle_(false)
  , ignore_restrictions_(false)
  , use_transfers_(0)
  , transfer_cost_(0)
  , transfer_penalty_(0)
  , filter_stop_action_(0)

  , filter_operator_action_(0)

  , filter_route_action_(0)

  , flow_mask_(0u)
  , bike_share_cost_(0)
  , bike_share_penalty_(0)
  , rail_ferry_cost_(0)
  , use_rail_ferry_(0)
  , ignore_oneways_(false)
  , ignore_access_(false)
  , ignore_closures_(false)
  , shortest_(false)
  , service_penalty_(0)
  , use_tracks_(0)
  , use_distance_(0)
  , use_living_streets_(0)
  , service_factor_(0)
  , closure_factor_(0)
  , costing_(0)

  , filter_closures_(true){}
struct CostingOptionsDefaultTypeInternal {
  constexpr CostingOptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CostingOptionsDefaultTypeInternal() {}
  union {
    CostingOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CostingOptionsDefaultTypeInternal _CostingOptions_default_instance_;
constexpr Options_Ring::Options_Ring(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : coords_(){}
struct Options_RingDefaultTypeInternal {
  constexpr Options_RingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~Options_RingDefaultTypeInternal() {}
  union {
    Options_Ring _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT Options_RingDefaultTypeInternal _Options_Ring_default_instance_;
constexpr Options::Options(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : costing_options_()
  , locations_()
  , avoid_locations_()
  , sources_()
  , targets_()
  , shape_()
  , contours_()
  , trace_()
  , filter_attributes_()
  , recostings_()
  , avoid_polygons_()
  , language_(nullptr)
  , id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , jsonp_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , encoded_polyline_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , date_time_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , units_(0)

  , format_(0)

  , costing_(0)

  , do_not_track_(false)
  , range_(false)
  , verbose_(false)
  , polygons_(false)
  , resample_distance_(0)
  , date_time_type_(0)

  , generalize_(0)
  , gps_accuracy_(0)
  , search_radius_(0)
  , turn_penalty_factor_(0)
  , filter_action_(0)

  , breakage_distance_(0)
  , show_locations_(false)
  , use_timestamps_(false)
  , guidance_views_(false)
  , linear_references_(false)
  , alternates_(0u)
  , interpolation_distance_(0)
  , height_precision_(0u)
  , roundabout_exits_(true)
  , directions_type_(2)

  , action_(1)

  , denoise_(1)
  , shape_match_(2)

  , best_paths_(1u)
  , shape_format_(1)
{}
struct OptionsDefaultTypeInternal {
  constexpr OptionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OptionsDefaultTypeInternal() {}
  union {
    Options _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OptionsDefaultTypeInternal _Options_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool Options_Units_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_Units_strings[2] = {};

static const char Options_Units_names[] =
  "kilometers"
  "miles";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_Units_entries[] = {
  { {Options_Units_names + 0, 10}, 0 },
  { {Options_Units_names + 10, 5}, 1 },
};

static const int Options_Units_entries_by_number[] = {
  0, // 0 -> kilometers
  1, // 1 -> miles
};

const std::string& Options_Units_Name(
    Options_Units value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_Units_entries,
          Options_Units_entries_by_number,
          2, Options_Units_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_Units_entries,
      Options_Units_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_Units_strings[idx].get();
}
bool Options_Units_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Units* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_Units_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Options_Units>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Options_Units Options::kilometers;
constexpr Options_Units Options::miles;
constexpr Options_Units Options::Units_MIN;
constexpr Options_Units Options::Units_MAX;
constexpr int Options::Units_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Options_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_Format_strings[3] = {};

static const char Options_Format_names[] =
  "gpx"
  "json"
  "osrm";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_Format_entries[] = {
  { {Options_Format_names + 0, 3}, 1 },
  { {Options_Format_names + 3, 4}, 0 },
  { {Options_Format_names + 7, 4}, 2 },
};

static const int Options_Format_entries_by_number[] = {
  1, // 0 -> json
  0, // 1 -> gpx
  2, // 2 -> osrm
};

const std::string& Options_Format_Name(
    Options_Format value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_Format_entries,
          Options_Format_entries_by_number,
          3, Options_Format_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_Format_entries,
      Options_Format_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_Format_strings[idx].get();
}
bool Options_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Format* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_Format_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Options_Format>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Options_Format Options::json;
constexpr Options_Format Options::gpx;
constexpr Options_Format Options::osrm;
constexpr Options_Format Options::Format_MIN;
constexpr Options_Format Options::Format_MAX;
constexpr int Options::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Options_Action_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_Action_strings[12] = {};

static const char Options_Action_names[] =
  "centroid"
  "expansion"
  "height"
  "isochrone"
  "locate"
  "optimized_route"
  "route"
  "sources_to_targets"
  "status"
  "trace_attributes"
  "trace_route"
  "transit_available";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_Action_entries[] = {
  { {Options_Action_names + 0, 8}, 11 },
  { {Options_Action_names + 8, 9}, 10 },
  { {Options_Action_names + 17, 6}, 8 },
  { {Options_Action_names + 23, 9}, 5 },
  { {Options_Action_names + 32, 6}, 2 },
  { {Options_Action_names + 38, 15}, 4 },
  { {Options_Action_names + 53, 5}, 1 },
  { {Options_Action_names + 58, 18}, 3 },
  { {Options_Action_names + 76, 6}, 12 },
  { {Options_Action_names + 82, 16}, 7 },
  { {Options_Action_names + 98, 11}, 6 },
  { {Options_Action_names + 109, 17}, 9 },
};

static const int Options_Action_entries_by_number[] = {
  6, // 1 -> route
  4, // 2 -> locate
  7, // 3 -> sources_to_targets
  5, // 4 -> optimized_route
  3, // 5 -> isochrone
  10, // 6 -> trace_route
  9, // 7 -> trace_attributes
  2, // 8 -> height
  11, // 9 -> transit_available
  1, // 10 -> expansion
  0, // 11 -> centroid
  8, // 12 -> status
};

const std::string& Options_Action_Name(
    Options_Action value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_Action_entries,
          Options_Action_entries_by_number,
          12, Options_Action_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_Action_entries,
      Options_Action_entries_by_number,
      12, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_Action_strings[idx].get();
}
bool Options_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_Action* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_Action_entries, 12, name, &int_value);
  if (success) {
    *value = static_cast<Options_Action>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Options_Action Options::route;
constexpr Options_Action Options::locate;
constexpr Options_Action Options::sources_to_targets;
constexpr Options_Action Options::optimized_route;
constexpr Options_Action Options::isochrone;
constexpr Options_Action Options::trace_route;
constexpr Options_Action Options::trace_attributes;
constexpr Options_Action Options::height;
constexpr Options_Action Options::transit_available;
constexpr Options_Action Options::expansion;
constexpr Options_Action Options::centroid;
constexpr Options_Action Options::status;
constexpr Options_Action Options::Action_MIN;
constexpr Options_Action Options::Action_MAX;
constexpr int Options::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool Options_DateTimeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Options_DateTimeType_strings[4] = {};

static const char Options_DateTimeType_names[] =
  "arrive_by"
  "current"
  "depart_at"
  "invariant";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Options_DateTimeType_entries[] = {
  { {Options_DateTimeType_names + 0, 9}, 2 },
  { {Options_DateTimeType_names + 9, 7}, 0 },
  { {Options_DateTimeType_names + 16, 9}, 1 },
  { {Options_DateTimeType_names + 25, 9}, 3 },
};

static const int Options_DateTimeType_entries_by_number[] = {
  1, // 0 -> current
  2, // 1 -> depart_at
  0, // 2 -> arrive_by
  3, // 3 -> invariant
};

const std::string& Options_DateTimeType_Name(
    Options_DateTimeType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Options_DateTimeType_entries,
          Options_DateTimeType_entries_by_number,
          4, Options_DateTimeType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Options_DateTimeType_entries,
      Options_DateTimeType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Options_DateTimeType_strings[idx].get();
}
bool Options_DateTimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Options_DateTimeType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Options_DateTimeType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Options_DateTimeType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Options_DateTimeType Options::current;
constexpr Options_DateTimeType Options::depart_at;
constexpr Options_DateTimeType Options::arrive_by;
constexpr Options_DateTimeType Options::invariant;
constexpr Options_DateTimeType Options::DateTimeType_MIN;
constexpr Options_DateTimeType Options::DateTimeType_MAX;
constexpr int Options::DateTimeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool ShapeMatch_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShapeMatch_strings[3] = {};

static const char ShapeMatch_names[] =
  "edge_walk"
  "map_snap"
  "walk_or_snap";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShapeMatch_entries[] = {
  { {ShapeMatch_names + 0, 9}, 0 },
  { {ShapeMatch_names + 9, 8}, 1 },
  { {ShapeMatch_names + 17, 12}, 2 },
};

static const int ShapeMatch_entries_by_number[] = {
  0, // 0 -> edge_walk
  1, // 1 -> map_snap
  2, // 2 -> walk_or_snap
};

const std::string& ShapeMatch_Name(
    ShapeMatch value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShapeMatch_entries,
          ShapeMatch_entries_by_number,
          3, ShapeMatch_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShapeMatch_entries,
      ShapeMatch_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShapeMatch_strings[idx].get();
}
bool ShapeMatch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeMatch* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShapeMatch_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShapeMatch>(int_value);
  }
  return success;
}
bool FilterAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FilterAction_strings[2] = {};

static const char FilterAction_names[] =
  "exclude"
  "include";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FilterAction_entries[] = {
  { {FilterAction_names + 0, 7}, 0 },
  { {FilterAction_names + 7, 7}, 1 },
};

static const int FilterAction_entries_by_number[] = {
  0, // 0 -> exclude
  1, // 1 -> include
};

const std::string& FilterAction_Name(
    FilterAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          FilterAction_entries,
          FilterAction_entries_by_number,
          2, FilterAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      FilterAction_entries,
      FilterAction_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     FilterAction_strings[idx].get();
}
bool FilterAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      FilterAction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<FilterAction>(int_value);
  }
  return success;
}
bool DirectionsType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DirectionsType_strings[3] = {};

static const char DirectionsType_names[] =
  "instructions"
  "maneuvers"
  "none";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DirectionsType_entries[] = {
  { {DirectionsType_names + 0, 12}, 2 },
  { {DirectionsType_names + 12, 9}, 1 },
  { {DirectionsType_names + 21, 4}, 0 },
};

static const int DirectionsType_entries_by_number[] = {
  2, // 0 -> none
  1, // 1 -> maneuvers
  0, // 2 -> instructions
};

const std::string& DirectionsType_Name(
    DirectionsType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DirectionsType_entries,
          DirectionsType_entries_by_number,
          3, DirectionsType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DirectionsType_entries,
      DirectionsType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DirectionsType_strings[idx].get();
}
bool DirectionsType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DirectionsType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DirectionsType>(int_value);
  }
  return success;
}
bool ShapeFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShapeFormat_strings[3] = {};

static const char ShapeFormat_names[] =
  "geojson"
  "polyline5"
  "polyline6";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShapeFormat_entries[] = {
  { {ShapeFormat_names + 0, 7}, 2 },
  { {ShapeFormat_names + 7, 9}, 0 },
  { {ShapeFormat_names + 16, 9}, 1 },
};

static const int ShapeFormat_entries_by_number[] = {
  1, // 0 -> polyline5
  2, // 1 -> polyline6
  0, // 2 -> geojson
};

const std::string& ShapeFormat_Name(
    ShapeFormat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShapeFormat_entries,
          ShapeFormat_entries_by_number,
          3, ShapeFormat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShapeFormat_entries,
      ShapeFormat_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShapeFormat_strings[idx].get();
}
bool ShapeFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeFormat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShapeFormat_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ShapeFormat>(int_value);
  }
  return success;
}
bool Costing_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Costing_strings[13] = {};

static const char Costing_names[] =
  "auto_"
  "bicycle"
  "bikeshare"
  "bus"
  "hov"
  "motor_scooter"
  "motorcycle"
  "multimodal"
  "none_"
  "pedestrian"
  "taxi"
  "transit"
  "truck";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Costing_entries[] = {
  { {Costing_names + 0, 5}, 0 },
  { {Costing_names + 5, 7}, 2 },
  { {Costing_names + 12, 9}, 14 },
  { {Costing_names + 21, 3}, 3 },
  { {Costing_names + 24, 3}, 4 },
  { {Costing_names + 27, 13}, 5 },
  { {Costing_names + 40, 10}, 10 },
  { {Costing_names + 50, 10}, 6 },
  { {Costing_names + 60, 5}, 13 },
  { {Costing_names + 65, 10}, 7 },
  { {Costing_names + 75, 4}, 12 },
  { {Costing_names + 79, 7}, 8 },
  { {Costing_names + 86, 5}, 9 },
};

static const int Costing_entries_by_number[] = {
  0, // 0 -> auto_
  1, // 2 -> bicycle
  3, // 3 -> bus
  4, // 4 -> hov
  5, // 5 -> motor_scooter
  7, // 6 -> multimodal
  9, // 7 -> pedestrian
  11, // 8 -> transit
  12, // 9 -> truck
  6, // 10 -> motorcycle
  10, // 12 -> taxi
  8, // 13 -> none_
  2, // 14 -> bikeshare
};

const std::string& Costing_Name(
    Costing value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Costing_entries,
          Costing_entries_by_number,
          13, Costing_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Costing_entries,
      Costing_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Costing_strings[idx].get();
}
bool Costing_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Costing* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Costing_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<Costing>(int_value);
  }
  return success;
}

// ===================================================================

class Contour::_Internal {
 public:
  using HasBits = decltype(std::declval<Contour>()._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Contour::Contour(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.Contour)
}
Contour::Contour(const Contour& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  color_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_color()) {
    color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_color(), 
      GetArenaForAllocation());
  }
  ::memcpy(&time_, &from.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&time_)) + sizeof(distance_));
  // @@protoc_insertion_point(copy_constructor:valhalla.Contour)
}

inline void Contour::SharedCtor() {
color_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&distance_) -
    reinterpret_cast<char*>(&time_)) + sizeof(distance_));
}

Contour::~Contour() {
  // @@protoc_insertion_point(destructor:valhalla.Contour)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Contour::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  color_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Contour::ArenaDtor(void* object) {
  Contour* _this = reinterpret_cast< Contour* >(object);
  (void)_this;
}
void Contour::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Contour::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Contour::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Contour)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    color_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&distance_) -
        reinterpret_cast<char*>(&time_)) + sizeof(distance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Contour::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional string color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_color();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_distance(&has_bits);
          distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Contour::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Contour)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_time(), target);
  }

  // optional string color = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_color(), target);
  }

  // optional float distance = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Contour)
  return target;
}

size_t Contour::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Contour)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string color = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_color());
    }

    // optional float time = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float distance = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Contour::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Contour*>(
      &from));
}

void Contour::MergeFrom(const Contour& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Contour)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_color(from._internal_color());
    }
    if (cached_has_bits & 0x00000002u) {
      time_ = from.time_;
    }
    if (cached_has_bits & 0x00000004u) {
      distance_ = from.distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Contour::CopyFrom(const Contour& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Contour)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contour::IsInitialized() const {
  return true;
}

void Contour::InternalSwap(Contour* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &color_, GetArenaForAllocation(),
      &other->color_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Contour, distance_)
      + sizeof(Contour::distance_)
      - PROTOBUF_FIELD_OFFSET(Contour, time_)>(
          reinterpret_cast<char*>(&time_),
          reinterpret_cast<char*>(&other->time_));
}

std::string Contour::GetTypeName() const {
  return "valhalla.Contour";
}


// ===================================================================

class AvoidEdge::_Internal {
 public:
  using HasBits = decltype(std::declval<AvoidEdge>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_percent_along(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AvoidEdge::AvoidEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.AvoidEdge)
}
AvoidEdge::AvoidEdge(const AvoidEdge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&percent_along_) -
    reinterpret_cast<char*>(&id_)) + sizeof(percent_along_));
  // @@protoc_insertion_point(copy_constructor:valhalla.AvoidEdge)
}

inline void AvoidEdge::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&percent_along_) -
    reinterpret_cast<char*>(&id_)) + sizeof(percent_along_));
}

AvoidEdge::~AvoidEdge() {
  // @@protoc_insertion_point(destructor:valhalla.AvoidEdge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void AvoidEdge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AvoidEdge::ArenaDtor(void* object) {
  AvoidEdge* _this = reinterpret_cast< AvoidEdge* >(object);
  (void)_this;
}
void AvoidEdge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvoidEdge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvoidEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.AvoidEdge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&percent_along_) -
        reinterpret_cast<char*>(&id_)) + sizeof(percent_along_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AvoidEdge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float percent_along = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_percent_along(&has_bits);
          percent_along_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AvoidEdge::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.AvoidEdge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_id(), target);
  }

  // optional float percent_along = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_percent_along(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.AvoidEdge)
  return target;
}

size_t AvoidEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.AvoidEdge)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_id());
    }

    // optional float percent_along = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AvoidEdge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const AvoidEdge*>(
      &from));
}

void AvoidEdge::MergeFrom(const AvoidEdge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.AvoidEdge)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      percent_along_ = from.percent_along_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AvoidEdge::CopyFrom(const AvoidEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.AvoidEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvoidEdge::IsInitialized() const {
  return true;
}

void AvoidEdge::InternalSwap(AvoidEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvoidEdge, percent_along_)
      + sizeof(AvoidEdge::percent_along_)
      - PROTOBUF_FIELD_OFFSET(AvoidEdge, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

std::string AvoidEdge::GetTypeName() const {
  return "valhalla.AvoidEdge";
}


// ===================================================================

class CostingOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<CostingOptions>()._has_bits_);
  static void set_has_maneuver_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_destination_only_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gate_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gate_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_toll_booth_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_toll_booth_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_alley_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_country_crossing_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_country_crossing_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_ferry_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_avoid_bad_surfaces(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_use_ferry(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_use_highways(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_use_tolls(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_use_roads(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_max_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_walking_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_step_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_max_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_max_hiking_difficulty(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_mode_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_walkway_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_sidewalk_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_alley_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_driveway_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_driveway_penalty(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_transit_start_end_max_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_transit_transfer_max_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_transport_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_top_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_use_hills(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_use_primary(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_use_trails(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_low_class_penalty(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_hazmat(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_axle_load(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static void set_has_cycling_speed(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_wheelchair(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_bicycle(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_use_bus(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_use_rail(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
  static void set_has_use_transfers(HasBits* has_bits) {
    (*has_bits)[1] |= 32768u;
  }
  static void set_has_transfer_cost(HasBits* has_bits) {
    (*has_bits)[1] |= 65536u;
  }
  static void set_has_transfer_penalty(HasBits* has_bits) {
    (*has_bits)[1] |= 131072u;
  }
  static void set_has_filter_stop_action(HasBits* has_bits) {
    (*has_bits)[1] |= 262144u;
  }
  static void set_has_filter_operator_action(HasBits* has_bits) {
    (*has_bits)[1] |= 524288u;
  }
  static void set_has_filter_route_action(HasBits* has_bits) {
    (*has_bits)[1] |= 1048576u;
  }
  static void set_has_flow_mask(HasBits* has_bits) {
    (*has_bits)[1] |= 2097152u;
  }
  static void set_has_bike_share_cost(HasBits* has_bits) {
    (*has_bits)[1] |= 4194304u;
  }
  static void set_has_bike_share_penalty(HasBits* has_bits) {
    (*has_bits)[1] |= 8388608u;
  }
  static void set_has_rail_ferry_cost(HasBits* has_bits) {
    (*has_bits)[1] |= 16777216u;
  }
  static void set_has_use_rail_ferry(HasBits* has_bits) {
    (*has_bits)[1] |= 33554432u;
  }
  static void set_has_ignore_restrictions(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_ignore_oneways(HasBits* has_bits) {
    (*has_bits)[1] |= 67108864u;
  }
  static void set_has_ignore_access(HasBits* has_bits) {
    (*has_bits)[1] |= 134217728u;
  }
  static void set_has_ignore_closures(HasBits* has_bits) {
    (*has_bits)[1] |= 268435456u;
  }
  static void set_has_shortest(HasBits* has_bits) {
    (*has_bits)[1] |= 536870912u;
  }
  static void set_has_service_penalty(HasBits* has_bits) {
    (*has_bits)[1] |= 1073741824u;
  }
  static void set_has_use_tracks(HasBits* has_bits) {
    (*has_bits)[1] |= 2147483648u;
  }
  static void set_has_use_distance(HasBits* has_bits) {
    (*has_bits)[2] |= 1u;
  }
  static void set_has_use_living_streets(HasBits* has_bits) {
    (*has_bits)[2] |= 2u;
  }
  static void set_has_service_factor(HasBits* has_bits) {
    (*has_bits)[2] |= 4u;
  }
  static void set_has_closure_factor(HasBits* has_bits) {
    (*has_bits)[2] |= 8u;
  }
  static void set_has_costing(HasBits* has_bits) {
    (*has_bits)[2] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filter_closures(HasBits* has_bits) {
    (*has_bits)[2] |= 32u;
  }
};

CostingOptions::CostingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  filter_stop_ids_(arena),
  filter_operator_ids_(arena),
  filter_route_ids_(arena),
  avoid_edges_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.CostingOptions)
}
CostingOptions::CostingOptions(const CostingOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      filter_stop_ids_(from.filter_stop_ids_),
      filter_operator_ids_(from.filter_operator_ids_),
      filter_route_ids_(from.filter_route_ids_),
      avoid_edges_(from.avoid_edges_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  transport_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_transport_type()) {
    transport_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_transport_type(), 
      GetArenaForAllocation());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&maneuver_penalty_, &from.maneuver_penalty_,
    static_cast<size_t>(reinterpret_cast<char*>(&filter_closures_) -
    reinterpret_cast<char*>(&maneuver_penalty_)) + sizeof(filter_closures_));
  // @@protoc_insertion_point(copy_constructor:valhalla.CostingOptions)
}

inline void CostingOptions::SharedCtor() {
transport_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&maneuver_penalty_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&costing_) -
    reinterpret_cast<char*>(&maneuver_penalty_)) + sizeof(costing_));
filter_closures_ = true;
}

CostingOptions::~CostingOptions() {
  // @@protoc_insertion_point(destructor:valhalla.CostingOptions)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void CostingOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  transport_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CostingOptions::ArenaDtor(void* object) {
  CostingOptions* _this = reinterpret_cast< CostingOptions* >(object);
  (void)_this;
}
void CostingOptions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CostingOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CostingOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.CostingOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  filter_stop_ids_.Clear();
  filter_operator_ids_.Clear();
  filter_route_ids_.Clear();
  avoid_edges_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      transport_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&maneuver_penalty_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&toll_booth_penalty_) -
        reinterpret_cast<char*>(&maneuver_penalty_)) + sizeof(toll_booth_penalty_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&alley_penalty_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_tolls_) -
        reinterpret_cast<char*>(&alley_penalty_)) + sizeof(use_tolls_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&use_roads_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&walkway_factor_) -
        reinterpret_cast<char*>(&use_roads_)) + sizeof(walkway_factor_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&sidewalk_factor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_hills_) -
        reinterpret_cast<char*>(&sidewalk_factor_)) + sizeof(use_hills_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&use_primary_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&use_primary_)) + sizeof(length_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&cycling_speed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_transfers_) -
        reinterpret_cast<char*>(&cycling_speed_)) + sizeof(use_transfers_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&transfer_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bike_share_penalty_) -
        reinterpret_cast<char*>(&transfer_cost_)) + sizeof(bike_share_penalty_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&rail_ferry_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_tracks_) -
        reinterpret_cast<char*>(&rail_ferry_cost_)) + sizeof(use_tracks_));
  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&use_distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&costing_) -
        reinterpret_cast<char*>(&use_distance_)) + sizeof(costing_));
    filter_closures_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CostingOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float maneuver_penalty = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_maneuver_penalty(&_has_bits_);
          maneuver_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float destination_only_penalty = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_destination_only_penalty(&_has_bits_);
          destination_only_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gate_cost = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_gate_cost(&_has_bits_);
          gate_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gate_penalty = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_gate_penalty(&_has_bits_);
          gate_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float toll_booth_cost = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_toll_booth_cost(&_has_bits_);
          toll_booth_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float toll_booth_penalty = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_toll_booth_penalty(&_has_bits_);
          toll_booth_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alley_penalty = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_alley_penalty(&_has_bits_);
          alley_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float country_crossing_cost = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_country_crossing_cost(&_has_bits_);
          country_crossing_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float country_crossing_penalty = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_country_crossing_penalty(&_has_bits_);
          country_crossing_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float ferry_cost = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_ferry_cost(&_has_bits_);
          ferry_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float avoid_bad_surfaces = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_avoid_bad_surfaces(&_has_bits_);
          avoid_bad_surfaces_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_ferry = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_use_ferry(&_has_bits_);
          use_ferry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_highways = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 109)) {
          _Internal::set_has_use_highways(&_has_bits_);
          use_highways_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_tolls = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_use_tolls(&_has_bits_);
          use_tolls_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_roads = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_use_roads(&_has_bits_);
          use_roads_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_distance = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_max_distance(&_has_bits_);
          max_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float walking_speed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_walking_speed(&_has_bits_);
          walking_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float step_penalty = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_step_penalty(&_has_bits_);
          step_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_grade = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          _Internal::set_has_max_grade(&_has_bits_);
          max_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 max_hiking_difficulty = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_max_hiking_difficulty(&_has_bits_);
          max_hiking_difficulty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float mode_factor = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 173)) {
          _Internal::set_has_mode_factor(&_has_bits_);
          mode_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float walkway_factor = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 181)) {
          _Internal::set_has_walkway_factor(&_has_bits_);
          walkway_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float sidewalk_factor = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 189)) {
          _Internal::set_has_sidewalk_factor(&_has_bits_);
          sidewalk_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float alley_factor = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 197)) {
          _Internal::set_has_alley_factor(&_has_bits_);
          alley_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float driveway_factor = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 205)) {
          _Internal::set_has_driveway_factor(&_has_bits_);
          driveway_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float driveway_penalty = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 213)) {
          _Internal::set_has_driveway_penalty(&_has_bits_);
          driveway_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 transit_start_end_max_distance = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_transit_start_end_max_distance(&_has_bits_);
          transit_start_end_max_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 transit_transfer_max_distance = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_transit_transfer_max_distance(&_has_bits_);
          transit_transfer_max_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string transport_type = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          auto str = _internal_mutable_transport_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float top_speed = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 245)) {
          _Internal::set_has_top_speed(&_has_bits_);
          top_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_hills = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 253)) {
          _Internal::set_has_use_hills(&_has_bits_);
          use_hills_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_primary = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 5)) {
          _Internal::set_has_use_primary(&_has_bits_);
          use_primary_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_trails = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_use_trails(&_has_bits_);
          use_trails_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float low_class_penalty = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_low_class_penalty(&_has_bits_);
          low_class_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool hazmat = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_hazmat(&_has_bits_);
          hazmat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float weight = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_weight(&_has_bits_);
          weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float axle_load = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_axle_load(&_has_bits_);
          axle_load_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float height = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_height(&_has_bits_);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float width = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_width(&_has_bits_);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float length = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_length(&_has_bits_);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float cycling_speed = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_cycling_speed(&_has_bits_);
          cycling_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool wheelchair = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_wheelchair(&_has_bits_);
          wheelchair_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool bicycle = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_bicycle(&_has_bits_);
          bicycle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float use_bus = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_use_bus(&_has_bits_);
          use_bus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_rail = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 109)) {
          _Internal::set_has_use_rail(&_has_bits_);
          use_rail_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_transfers = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_use_transfers(&_has_bits_);
          use_transfers_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float transfer_cost = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_transfer_cost(&_has_bits_);
          transfer_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float transfer_penalty = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 133)) {
          _Internal::set_has_transfer_penalty(&_has_bits_);
          transfer_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.FilterAction filter_stop_action = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::FilterAction_IsValid(val))) {
            _internal_set_filter_stop_action(static_cast<::valhalla::FilterAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(49, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string filter_stop_ids = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_stop_ids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<402>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .valhalla.FilterAction filter_operator_action = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::FilterAction_IsValid(val))) {
            _internal_set_filter_operator_action(static_cast<::valhalla::FilterAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(51, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string filter_operator_ids = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_operator_ids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<418>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .valhalla.FilterAction filter_route_action = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::FilterAction_IsValid(val))) {
            _internal_set_filter_route_action(static_cast<::valhalla::FilterAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(53, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string filter_route_ids = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_route_ids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<434>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 flow_mask = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_flow_mask(&_has_bits_);
          flow_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float bike_share_cost = 56;
      case 56:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 197)) {
          _Internal::set_has_bike_share_cost(&_has_bits_);
          bike_share_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float bike_share_penalty = 57;
      case 57:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 205)) {
          _Internal::set_has_bike_share_penalty(&_has_bits_);
          bike_share_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float rail_ferry_cost = 58;
      case 58:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 213)) {
          _Internal::set_has_rail_ferry_cost(&_has_bits_);
          rail_ferry_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_rail_ferry = 59;
      case 59:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 221)) {
          _Internal::set_has_use_rail_ferry(&_has_bits_);
          use_rail_ferry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool ignore_restrictions = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_ignore_restrictions(&_has_bits_);
          ignore_restrictions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ignore_oneways = 61;
      case 61:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_ignore_oneways(&_has_bits_);
          ignore_oneways_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ignore_access = 62;
      case 62:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_ignore_access(&_has_bits_);
          ignore_access_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ignore_closures = 63;
      case 63:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_ignore_closures(&_has_bits_);
          ignore_closures_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool shortest = 64;
      case 64:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_shortest(&_has_bits_);
          shortest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float service_penalty = 65;
      case 65:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_service_penalty(&_has_bits_);
          service_penalty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_tracks = 66;
      case 66:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_use_tracks(&_has_bits_);
          use_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_distance = 67;
      case 67:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_use_distance(&_has_bits_);
          use_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float use_living_streets = 68;
      case 68:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_use_living_streets(&_has_bits_);
          use_living_streets_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float service_factor = 69;
      case 69:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_service_factor(&_has_bits_);
          service_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float closure_factor = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_closure_factor(&_has_bits_);
          closure_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.Costing costing = 90;
      case 90:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::Costing_IsValid(val))) {
            _internal_set_costing(static_cast<::valhalla::Costing>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(90, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string name = 91;
      case 91:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.AvoidEdge avoid_edges = 92;
      case 92:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 226)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_avoid_edges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<738>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool filter_closures = 93 [default = true];
      case 93:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_filter_closures(&_has_bits_);
          filter_closures_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CostingOptions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.CostingOptions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float maneuver_penalty = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_maneuver_penalty(), target);
  }

  // optional float destination_only_penalty = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_destination_only_penalty(), target);
  }

  // optional float gate_cost = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_gate_cost(), target);
  }

  // optional float gate_penalty = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_gate_penalty(), target);
  }

  // optional float toll_booth_cost = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_toll_booth_cost(), target);
  }

  // optional float toll_booth_penalty = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_toll_booth_penalty(), target);
  }

  // optional float alley_penalty = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_alley_penalty(), target);
  }

  // optional float country_crossing_cost = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_country_crossing_cost(), target);
  }

  // optional float country_crossing_penalty = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_country_crossing_penalty(), target);
  }

  // optional float ferry_cost = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_ferry_cost(), target);
  }

  // optional float avoid_bad_surfaces = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_avoid_bad_surfaces(), target);
  }

  // optional float use_ferry = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_use_ferry(), target);
  }

  // optional float use_highways = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_use_highways(), target);
  }

  // optional float use_tolls = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_use_tolls(), target);
  }

  // optional float use_roads = 15;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_use_roads(), target);
  }

  // optional uint32 max_distance = 16;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->_internal_max_distance(), target);
  }

  // optional float walking_speed = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_walking_speed(), target);
  }

  // optional float step_penalty = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_step_penalty(), target);
  }

  // optional uint32 max_grade = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(19, this->_internal_max_grade(), target);
  }

  // optional uint32 max_hiking_difficulty = 20;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(20, this->_internal_max_hiking_difficulty(), target);
  }

  // optional float mode_factor = 21;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_mode_factor(), target);
  }

  // optional float walkway_factor = 22;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(22, this->_internal_walkway_factor(), target);
  }

  // optional float sidewalk_factor = 23;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(23, this->_internal_sidewalk_factor(), target);
  }

  // optional float alley_factor = 24;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(24, this->_internal_alley_factor(), target);
  }

  // optional float driveway_factor = 25;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_driveway_factor(), target);
  }

  // optional float driveway_penalty = 26;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(26, this->_internal_driveway_penalty(), target);
  }

  // optional uint32 transit_start_end_max_distance = 27;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(27, this->_internal_transit_start_end_max_distance(), target);
  }

  // optional uint32 transit_transfer_max_distance = 28;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(28, this->_internal_transit_transfer_max_distance(), target);
  }

  // optional string transport_type = 29;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        29, this->_internal_transport_type(), target);
  }

  // optional float top_speed = 30;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(30, this->_internal_top_speed(), target);
  }

  // optional float use_hills = 31;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(31, this->_internal_use_hills(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional float use_primary = 32;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(32, this->_internal_use_primary(), target);
  }

  // optional float use_trails = 33;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(33, this->_internal_use_trails(), target);
  }

  // optional float low_class_penalty = 34;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(34, this->_internal_low_class_penalty(), target);
  }

  // optional bool hazmat = 35;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(35, this->_internal_hazmat(), target);
  }

  // optional float weight = 36;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(36, this->_internal_weight(), target);
  }

  // optional float axle_load = 37;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(37, this->_internal_axle_load(), target);
  }

  // optional float height = 38;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(38, this->_internal_height(), target);
  }

  // optional float width = 39;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(39, this->_internal_width(), target);
  }

  // optional float length = 40;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(40, this->_internal_length(), target);
  }

  // optional float cycling_speed = 41;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(41, this->_internal_cycling_speed(), target);
  }

  // optional bool wheelchair = 42;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(42, this->_internal_wheelchair(), target);
  }

  // optional bool bicycle = 43;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(43, this->_internal_bicycle(), target);
  }

  // optional float use_bus = 44;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(44, this->_internal_use_bus(), target);
  }

  // optional float use_rail = 45;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(45, this->_internal_use_rail(), target);
  }

  // optional float use_transfers = 46;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(46, this->_internal_use_transfers(), target);
  }

  // optional float transfer_cost = 47;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(47, this->_internal_transfer_cost(), target);
  }

  // optional float transfer_penalty = 48;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(48, this->_internal_transfer_penalty(), target);
  }

  // optional .valhalla.FilterAction filter_stop_action = 49;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      49, this->_internal_filter_stop_action(), target);
  }

  // repeated string filter_stop_ids = 50;
  for (int i = 0, n = this->_internal_filter_stop_ids_size(); i < n; i++) {
    const auto& s = this->_internal_filter_stop_ids(i);
    target = stream->WriteString(50, s, target);
  }

  // optional .valhalla.FilterAction filter_operator_action = 51;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      51, this->_internal_filter_operator_action(), target);
  }

  // repeated string filter_operator_ids = 52;
  for (int i = 0, n = this->_internal_filter_operator_ids_size(); i < n; i++) {
    const auto& s = this->_internal_filter_operator_ids(i);
    target = stream->WriteString(52, s, target);
  }

  // optional .valhalla.FilterAction filter_route_action = 53;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      53, this->_internal_filter_route_action(), target);
  }

  // repeated string filter_route_ids = 54;
  for (int i = 0, n = this->_internal_filter_route_ids_size(); i < n; i++) {
    const auto& s = this->_internal_filter_route_ids(i);
    target = stream->WriteString(54, s, target);
  }

  // optional uint32 flow_mask = 55;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(55, this->_internal_flow_mask(), target);
  }

  // optional float bike_share_cost = 56;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(56, this->_internal_bike_share_cost(), target);
  }

  // optional float bike_share_penalty = 57;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(57, this->_internal_bike_share_penalty(), target);
  }

  // optional float rail_ferry_cost = 58;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(58, this->_internal_rail_ferry_cost(), target);
  }

  // optional float use_rail_ferry = 59;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(59, this->_internal_use_rail_ferry(), target);
  }

  // optional bool ignore_restrictions = 60;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(60, this->_internal_ignore_restrictions(), target);
  }

  // optional bool ignore_oneways = 61;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(61, this->_internal_ignore_oneways(), target);
  }

  // optional bool ignore_access = 62;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(62, this->_internal_ignore_access(), target);
  }

  // optional bool ignore_closures = 63;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(63, this->_internal_ignore_closures(), target);
  }

  // optional bool shortest = 64;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(64, this->_internal_shortest(), target);
  }

  // optional float service_penalty = 65;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(65, this->_internal_service_penalty(), target);
  }

  // optional float use_tracks = 66;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(66, this->_internal_use_tracks(), target);
  }

  cached_has_bits = _has_bits_[2];
  // optional float use_distance = 67;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(67, this->_internal_use_distance(), target);
  }

  // optional float use_living_streets = 68;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(68, this->_internal_use_living_streets(), target);
  }

  // optional float service_factor = 69;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(69, this->_internal_service_factor(), target);
  }

  // optional float closure_factor = 70;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(70, this->_internal_closure_factor(), target);
  }

  // optional .valhalla.Costing costing = 90;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      90, this->_internal_costing(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string name = 91;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        91, this->_internal_name(), target);
  }

  // repeated .valhalla.AvoidEdge avoid_edges = 92;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_avoid_edges_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(92, this->_internal_avoid_edges(i), target, stream);
  }

  cached_has_bits = _has_bits_[2];
  // optional bool filter_closures = 93 [default = true];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(93, this->_internal_filter_closures(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.CostingOptions)
  return target;
}

size_t CostingOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.CostingOptions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string filter_stop_ids = 50;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(filter_stop_ids_.size());
  for (int i = 0, n = filter_stop_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      filter_stop_ids_.Get(i));
  }

  // repeated string filter_operator_ids = 52;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(filter_operator_ids_.size());
  for (int i = 0, n = filter_operator_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      filter_operator_ids_.Get(i));
  }

  // repeated string filter_route_ids = 54;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(filter_route_ids_.size());
  for (int i = 0, n = filter_route_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      filter_route_ids_.Get(i));
  }

  // repeated .valhalla.AvoidEdge avoid_edges = 92;
  total_size += 2UL * this->_internal_avoid_edges_size();
  for (const auto& msg : this->avoid_edges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string transport_type = 29;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_transport_type());
    }

    // optional string name = 91;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional float maneuver_penalty = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float destination_only_penalty = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float gate_cost = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float gate_penalty = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float toll_booth_cost = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float toll_booth_penalty = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float alley_penalty = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float country_crossing_cost = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float country_crossing_penalty = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float ferry_cost = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float avoid_bad_surfaces = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float use_ferry = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 4;
    }

    // optional float use_highways = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional float use_tolls = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float use_roads = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 4;
    }

    // optional uint32 max_distance = 16;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_distance());
    }

    // optional float walking_speed = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 4;
    }

    // optional float step_penalty = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional uint32 max_grade = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_grade());
    }

    // optional uint32 max_hiking_difficulty = 20;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_max_hiking_difficulty());
    }

    // optional float mode_factor = 21;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional float walkway_factor = 22;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional float sidewalk_factor = 23;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional float alley_factor = 24;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 4;
    }

    // optional float driveway_factor = 25;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 4;
    }

    // optional float driveway_penalty = 26;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 4;
    }

    // optional uint32 transit_start_end_max_distance = 27;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_transit_start_end_max_distance());
    }

    // optional uint32 transit_transfer_max_distance = 28;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_transit_transfer_max_distance());
    }

    // optional float top_speed = 30;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

    // optional float use_hills = 31;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 4;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional float use_primary = 32;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 4;
    }

    // optional float use_trails = 33;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 4;
    }

    // optional float low_class_penalty = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 4;
    }

    // optional float weight = 36;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 4;
    }

    // optional float axle_load = 37;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 4;
    }

    // optional float height = 38;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 4;
    }

    // optional float width = 39;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 4;
    }

    // optional float length = 40;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float cycling_speed = 41;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 4;
    }

    // optional float use_bus = 44;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 4;
    }

    // optional float use_rail = 45;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 4;
    }

    // optional bool hazmat = 35;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool wheelchair = 42;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool bicycle = 43;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool ignore_restrictions = 60;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional float use_transfers = 46;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float transfer_cost = 47;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float transfer_penalty = 48;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional .valhalla.FilterAction filter_stop_action = 49;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_filter_stop_action());
    }

    // optional .valhalla.FilterAction filter_operator_action = 51;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_filter_operator_action());
    }

    // optional .valhalla.FilterAction filter_route_action = 53;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_filter_route_action());
    }

    // optional uint32 flow_mask = 55;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_flow_mask());
    }

    // optional float bike_share_cost = 56;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional float bike_share_penalty = 57;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional float rail_ferry_cost = 58;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional float use_rail_ferry = 59;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 4;
    }

    // optional bool ignore_oneways = 61;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool ignore_access = 62;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool ignore_closures = 63;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool shortest = 64;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional float service_penalty = 65;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

    // optional float use_tracks = 66;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 4;
    }

  }
  cached_has_bits = _has_bits_[2];
  if (cached_has_bits & 0x0000003fu) {
    // optional float use_distance = 67;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 4;
    }

    // optional float use_living_streets = 68;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 4;
    }

    // optional float service_factor = 69;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 4;
    }

    // optional float closure_factor = 70;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + 4;
    }

    // optional .valhalla.Costing costing = 90;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_costing());
    }

    // optional bool filter_closures = 93 [default = true];
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CostingOptions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const CostingOptions*>(
      &from));
}

void CostingOptions::MergeFrom(const CostingOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.CostingOptions)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  filter_stop_ids_.MergeFrom(from.filter_stop_ids_);
  filter_operator_ids_.MergeFrom(from.filter_operator_ids_);
  filter_route_ids_.MergeFrom(from.filter_route_ids_);
  avoid_edges_.MergeFrom(from.avoid_edges_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_transport_type(from._internal_transport_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      maneuver_penalty_ = from.maneuver_penalty_;
    }
    if (cached_has_bits & 0x00000008u) {
      destination_only_penalty_ = from.destination_only_penalty_;
    }
    if (cached_has_bits & 0x00000010u) {
      gate_cost_ = from.gate_cost_;
    }
    if (cached_has_bits & 0x00000020u) {
      gate_penalty_ = from.gate_penalty_;
    }
    if (cached_has_bits & 0x00000040u) {
      toll_booth_cost_ = from.toll_booth_cost_;
    }
    if (cached_has_bits & 0x00000080u) {
      toll_booth_penalty_ = from.toll_booth_penalty_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      alley_penalty_ = from.alley_penalty_;
    }
    if (cached_has_bits & 0x00000200u) {
      country_crossing_cost_ = from.country_crossing_cost_;
    }
    if (cached_has_bits & 0x00000400u) {
      country_crossing_penalty_ = from.country_crossing_penalty_;
    }
    if (cached_has_bits & 0x00000800u) {
      ferry_cost_ = from.ferry_cost_;
    }
    if (cached_has_bits & 0x00001000u) {
      avoid_bad_surfaces_ = from.avoid_bad_surfaces_;
    }
    if (cached_has_bits & 0x00002000u) {
      use_ferry_ = from.use_ferry_;
    }
    if (cached_has_bits & 0x00004000u) {
      use_highways_ = from.use_highways_;
    }
    if (cached_has_bits & 0x00008000u) {
      use_tolls_ = from.use_tolls_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      use_roads_ = from.use_roads_;
    }
    if (cached_has_bits & 0x00020000u) {
      max_distance_ = from.max_distance_;
    }
    if (cached_has_bits & 0x00040000u) {
      walking_speed_ = from.walking_speed_;
    }
    if (cached_has_bits & 0x00080000u) {
      step_penalty_ = from.step_penalty_;
    }
    if (cached_has_bits & 0x00100000u) {
      max_grade_ = from.max_grade_;
    }
    if (cached_has_bits & 0x00200000u) {
      max_hiking_difficulty_ = from.max_hiking_difficulty_;
    }
    if (cached_has_bits & 0x00400000u) {
      mode_factor_ = from.mode_factor_;
    }
    if (cached_has_bits & 0x00800000u) {
      walkway_factor_ = from.walkway_factor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      sidewalk_factor_ = from.sidewalk_factor_;
    }
    if (cached_has_bits & 0x02000000u) {
      alley_factor_ = from.alley_factor_;
    }
    if (cached_has_bits & 0x04000000u) {
      driveway_factor_ = from.driveway_factor_;
    }
    if (cached_has_bits & 0x08000000u) {
      driveway_penalty_ = from.driveway_penalty_;
    }
    if (cached_has_bits & 0x10000000u) {
      transit_start_end_max_distance_ = from.transit_start_end_max_distance_;
    }
    if (cached_has_bits & 0x20000000u) {
      transit_transfer_max_distance_ = from.transit_transfer_max_distance_;
    }
    if (cached_has_bits & 0x40000000u) {
      top_speed_ = from.top_speed_;
    }
    if (cached_has_bits & 0x80000000u) {
      use_hills_ = from.use_hills_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      use_primary_ = from.use_primary_;
    }
    if (cached_has_bits & 0x00000002u) {
      use_trails_ = from.use_trails_;
    }
    if (cached_has_bits & 0x00000004u) {
      low_class_penalty_ = from.low_class_penalty_;
    }
    if (cached_has_bits & 0x00000008u) {
      weight_ = from.weight_;
    }
    if (cached_has_bits & 0x00000010u) {
      axle_load_ = from.axle_load_;
    }
    if (cached_has_bits & 0x00000020u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000040u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000080u) {
      length_ = from.length_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      cycling_speed_ = from.cycling_speed_;
    }
    if (cached_has_bits & 0x00000200u) {
      use_bus_ = from.use_bus_;
    }
    if (cached_has_bits & 0x00000400u) {
      use_rail_ = from.use_rail_;
    }
    if (cached_has_bits & 0x00000800u) {
      hazmat_ = from.hazmat_;
    }
    if (cached_has_bits & 0x00001000u) {
      wheelchair_ = from.wheelchair_;
    }
    if (cached_has_bits & 0x00002000u) {
      bicycle_ = from.bicycle_;
    }
    if (cached_has_bits & 0x00004000u) {
      ignore_restrictions_ = from.ignore_restrictions_;
    }
    if (cached_has_bits & 0x00008000u) {
      use_transfers_ = from.use_transfers_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      transfer_cost_ = from.transfer_cost_;
    }
    if (cached_has_bits & 0x00020000u) {
      transfer_penalty_ = from.transfer_penalty_;
    }
    if (cached_has_bits & 0x00040000u) {
      filter_stop_action_ = from.filter_stop_action_;
    }
    if (cached_has_bits & 0x00080000u) {
      filter_operator_action_ = from.filter_operator_action_;
    }
    if (cached_has_bits & 0x00100000u) {
      filter_route_action_ = from.filter_route_action_;
    }
    if (cached_has_bits & 0x00200000u) {
      flow_mask_ = from.flow_mask_;
    }
    if (cached_has_bits & 0x00400000u) {
      bike_share_cost_ = from.bike_share_cost_;
    }
    if (cached_has_bits & 0x00800000u) {
      bike_share_penalty_ = from.bike_share_penalty_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      rail_ferry_cost_ = from.rail_ferry_cost_;
    }
    if (cached_has_bits & 0x02000000u) {
      use_rail_ferry_ = from.use_rail_ferry_;
    }
    if (cached_has_bits & 0x04000000u) {
      ignore_oneways_ = from.ignore_oneways_;
    }
    if (cached_has_bits & 0x08000000u) {
      ignore_access_ = from.ignore_access_;
    }
    if (cached_has_bits & 0x10000000u) {
      ignore_closures_ = from.ignore_closures_;
    }
    if (cached_has_bits & 0x20000000u) {
      shortest_ = from.shortest_;
    }
    if (cached_has_bits & 0x40000000u) {
      service_penalty_ = from.service_penalty_;
    }
    if (cached_has_bits & 0x80000000u) {
      use_tracks_ = from.use_tracks_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[2];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      use_distance_ = from.use_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      use_living_streets_ = from.use_living_streets_;
    }
    if (cached_has_bits & 0x00000004u) {
      service_factor_ = from.service_factor_;
    }
    if (cached_has_bits & 0x00000008u) {
      closure_factor_ = from.closure_factor_;
    }
    if (cached_has_bits & 0x00000010u) {
      costing_ = from.costing_;
    }
    if (cached_has_bits & 0x00000020u) {
      filter_closures_ = from.filter_closures_;
    }
    _has_bits_[2] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CostingOptions::CopyFrom(const CostingOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.CostingOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CostingOptions::IsInitialized() const {
  return true;
}

void CostingOptions::InternalSwap(CostingOptions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  swap(_has_bits_[2], other->_has_bits_[2]);
  filter_stop_ids_.InternalSwap(&other->filter_stop_ids_);
  filter_operator_ids_.InternalSwap(&other->filter_operator_ids_);
  filter_route_ids_.InternalSwap(&other->filter_route_ids_);
  avoid_edges_.InternalSwap(&other->avoid_edges_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &transport_type_, GetArenaForAllocation(),
      &other->transport_type_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, GetArenaForAllocation(),
      &other->name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CostingOptions, costing_)
      + sizeof(CostingOptions::costing_)
      - PROTOBUF_FIELD_OFFSET(CostingOptions, maneuver_penalty_)>(
          reinterpret_cast<char*>(&maneuver_penalty_),
          reinterpret_cast<char*>(&other->maneuver_penalty_));
  swap(filter_closures_, other->filter_closures_);
}

std::string CostingOptions::GetTypeName() const {
  return "valhalla.CostingOptions";
}


// ===================================================================

class Options_Ring::_Internal {
 public:
};

void Options_Ring::clear_coords() {
  coords_.Clear();
}
Options_Ring::Options_Ring(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  coords_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.Options.Ring)
}
Options_Ring::Options_Ring(const Options_Ring& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      coords_(from.coords_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.Options.Ring)
}

inline void Options_Ring::SharedCtor() {
}

Options_Ring::~Options_Ring() {
  // @@protoc_insertion_point(destructor:valhalla.Options.Ring)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Options_Ring::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Options_Ring::ArenaDtor(void* object) {
  Options_Ring* _this = reinterpret_cast< Options_Ring* >(object);
  (void)_this;
}
void Options_Ring::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Options_Ring::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Options_Ring::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Options.Ring)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  coords_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Options_Ring::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.LatLng coords = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coords(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Options_Ring::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Options.Ring)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.LatLng coords = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_coords_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_coords(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Options.Ring)
  return target;
}

size_t Options_Ring::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Options.Ring)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.LatLng coords = 1;
  total_size += 1UL * this->_internal_coords_size();
  for (const auto& msg : this->coords_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Options_Ring::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Options_Ring*>(
      &from));
}

void Options_Ring::MergeFrom(const Options_Ring& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Options.Ring)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  coords_.MergeFrom(from.coords_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Options_Ring::CopyFrom(const Options_Ring& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Options.Ring)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options_Ring::IsInitialized() const {
  return true;
}

void Options_Ring::InternalSwap(Options_Ring* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  coords_.InternalSwap(&other->coords_);
}

std::string Options_Ring::GetTypeName() const {
  return "valhalla.Options.Ring";
}


// ===================================================================

class Options::_Internal {
 public:
  using HasBits = decltype(std::declval<Options>()._has_bits_);
  static void set_has_units(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_directions_type(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_jsonp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_encoded_polyline(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_do_not_track(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_range(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_verbose(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_costing(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_date_time_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_date_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_resample_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_polygons(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_denoise(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_generalize(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_show_locations(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_shape_match(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_best_paths(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_gps_accuracy(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_search_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_turn_penalty_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_filter_action(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_breakage_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_use_timestamps(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_shape_format(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_alternates(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_interpolation_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_guidance_views(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_height_precision(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_roundabout_exits(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_linear_references(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::internal::LazyString Options::_i_give_permission_to_break_this_code_default_language_{{{"en-US", 5}}, {nullptr}};
void Options::clear_locations() {
  locations_.Clear();
}
void Options::clear_avoid_locations() {
  avoid_locations_.Clear();
}
void Options::clear_sources() {
  sources_.Clear();
}
void Options::clear_targets() {
  targets_.Clear();
}
void Options::clear_shape() {
  shape_.Clear();
}
void Options::clear_trace() {
  trace_.Clear();
}
Options::Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  costing_options_(arena),
  locations_(arena),
  avoid_locations_(arena),
  sources_(arena),
  targets_(arena),
  shape_(arena),
  contours_(arena),
  trace_(arena),
  filter_attributes_(arena),
  recostings_(arena),
  avoid_polygons_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.Options)
}
Options::Options(const Options& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      costing_options_(from.costing_options_),
      locations_(from.locations_),
      avoid_locations_(from.avoid_locations_),
      sources_(from.sources_),
      targets_(from.targets_),
      shape_(from.shape_),
      contours_(from.contours_),
      trace_(from.trace_),
      filter_attributes_(from.filter_attributes_),
      recostings_(from.recostings_),
      avoid_polygons_(from.avoid_polygons_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  language_.UnsafeSetDefault(nullptr);
  if (from._internal_has_language()) {
    language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_language(), 
      GetArenaForAllocation());
  }
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_id(), 
      GetArenaForAllocation());
  }
  jsonp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_jsonp()) {
    jsonp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_jsonp(), 
      GetArenaForAllocation());
  }
  encoded_polyline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_encoded_polyline()) {
    encoded_polyline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encoded_polyline(), 
      GetArenaForAllocation());
  }
  date_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_date_time()) {
    date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_date_time(), 
      GetArenaForAllocation());
  }
  ::memcpy(&units_, &from.units_,
    static_cast<size_t>(reinterpret_cast<char*>(&shape_format_) -
    reinterpret_cast<char*>(&units_)) + sizeof(shape_format_));
  // @@protoc_insertion_point(copy_constructor:valhalla.Options)
}

inline void Options::SharedCtor() {
language_.UnsafeSetDefault(nullptr);
id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
jsonp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
encoded_polyline_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
date_time_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&units_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_precision_) -
    reinterpret_cast<char*>(&units_)) + sizeof(height_precision_));
roundabout_exits_ = true;
directions_type_ = 2;
action_ = 1;
denoise_ = 1;
shape_match_ = 2;
best_paths_ = 1u;
shape_format_ = 1;
}

Options::~Options() {
  // @@protoc_insertion_point(destructor:valhalla.Options)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Options::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  language_.DestroyNoArena(nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  jsonp_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encoded_polyline_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  date_time_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Options::ArenaDtor(void* object) {
  Options* _this = reinterpret_cast< Options* >(object);
  (void)_this;
}
void Options::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Options::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Options::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Options)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  costing_options_.Clear();
  locations_.Clear();
  avoid_locations_.Clear();
  sources_.Clear();
  targets_.Clear();
  shape_.Clear();
  contours_.Clear();
  trace_.Clear();
  filter_attributes_.Clear();
  recostings_.Clear();
  avoid_polygons_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      language_.ClearToDefault(::valhalla::Options::_i_give_permission_to_break_this_code_default_language_, GetArenaForAllocation());
       }
    if (cached_has_bits & 0x00000002u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      jsonp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      encoded_polyline_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      date_time_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&units_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&costing_) -
        reinterpret_cast<char*>(&units_)) + sizeof(costing_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&do_not_track_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gps_accuracy_) -
        reinterpret_cast<char*>(&do_not_track_)) + sizeof(gps_accuracy_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&search_radius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&linear_references_) -
        reinterpret_cast<char*>(&search_radius_)) + sizeof(linear_references_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&alternates_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_precision_) -
        reinterpret_cast<char*>(&alternates_)) + sizeof(height_precision_));
    roundabout_exits_ = true;
    directions_type_ = 2;
    action_ = 1;
    denoise_ = 1;
    shape_match_ = 2;
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    best_paths_ = 1u;
    shape_format_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Options::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .valhalla.Options.Units units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::Options_Units_IsValid(val))) {
            _internal_set_units(static_cast<::valhalla::Options_Units>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string language = 2 [default = "en-US"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::DirectionsType_IsValid(val))) {
            _internal_set_directions_type(static_cast<::valhalla::DirectionsType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.Options.Format format = 4 [default = json];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::Options_Format_IsValid(val))) {
            _internal_set_format(static_cast<::valhalla::Options_Format>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string jsonp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_jsonp();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string encoded_polyline = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_encoded_polyline();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.Options.Action action = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::Options_Action_IsValid(val))) {
            _internal_set_action(static_cast<::valhalla::Options_Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool do_not_track = 9 [default = false];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_do_not_track(&_has_bits_);
          do_not_track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool range = 10 [default = false];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_range(&_has_bits_);
          range_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool verbose = 11 [default = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_verbose(&_has_bits_);
          verbose_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.Costing costing = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::Costing_IsValid(val))) {
            _internal_set_costing(static_cast<::valhalla::Costing>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.CostingOptions costing_options = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_costing_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location locations = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location avoid_locations = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_avoid_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location sources = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_sources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location targets = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .valhalla.Options.DateTimeType date_time_type = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::Options_DateTimeType_IsValid(val))) {
            _internal_set_date_time_type(static_cast<::valhalla::Options_DateTimeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string date_time = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          auto str = _internal_mutable_date_time();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location shape = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_shape(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else goto handle_unusual;
        continue;
      // optional double resample_distance = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 169)) {
          _Internal::set_has_resample_distance(&_has_bits_);
          resample_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Contour contours = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_contours(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool polygons = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_polygons(&_has_bits_);
          polygons_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float denoise = 24 [default = 1];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 197)) {
          _Internal::set_has_denoise(&_has_bits_);
          denoise_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float generalize = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 205)) {
          _Internal::set_has_generalize(&_has_bits_);
          generalize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool show_locations = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_show_locations(&_has_bits_);
          show_locations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location trace = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_trace(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::ShapeMatch_IsValid(val))) {
            _internal_set_shape_match(static_cast<::valhalla::ShapeMatch>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(28, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 best_paths = 29 [default = 1];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_best_paths(&_has_bits_);
          best_paths_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float gps_accuracy = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 245)) {
          _Internal::set_has_gps_accuracy(&_has_bits_);
          gps_accuracy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float search_radius = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 253)) {
          _Internal::set_has_search_radius(&_has_bits_);
          search_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float turn_penalty_factor = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 5)) {
          _Internal::set_has_turn_penalty_factor(&_has_bits_);
          turn_penalty_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.FilterAction filter_action = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::FilterAction_IsValid(val))) {
            _internal_set_filter_action(static_cast<::valhalla::FilterAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(33, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated string filter_attributes = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_filter_attributes();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<274>(ptr));
        } else goto handle_unusual;
        continue;
      // optional float breakage_distance = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_breakage_distance(&_has_bits_);
          breakage_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool use_timestamps = 37 [default = false];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_use_timestamps(&_has_bits_);
          use_timestamps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::ShapeFormat_IsValid(val))) {
            _internal_set_shape_format(static_cast<::valhalla::ShapeFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(38, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 alternates = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_alternates(&_has_bits_);
          alternates_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float interpolation_distance = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_interpolation_distance(&_has_bits_);
          interpolation_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool guidance_views = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_guidance_views(&_has_bits_);
          guidance_views_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 height_precision = 43 [default = 0];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_height_precision(&_has_bits_);
          height_precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool roundabout_exits = 44 [default = true];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_roundabout_exits(&_has_bits_);
          roundabout_exits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool linear_references = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_linear_references(&_has_bits_);
          linear_references_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.CostingOptions recostings = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_recostings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<370>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Options.Ring avoid_polygons = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_avoid_polygons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<378>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Options::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Options)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .valhalla.Options.Units units = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_units(), target);
  }

  // optional string language = 2 [default = "en-US"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_language(), target);
  }

  // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_directions_type(), target);
  }

  // optional .valhalla.Options.Format format = 4 [default = json];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_format(), target);
  }

  // optional string id = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_id(), target);
  }

  // optional string jsonp = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_jsonp(), target);
  }

  // optional string encoded_polyline = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_encoded_polyline(), target);
  }

  // optional .valhalla.Options.Action action = 8;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_action(), target);
  }

  // optional bool do_not_track = 9 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_do_not_track(), target);
  }

  // optional bool range = 10 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_range(), target);
  }

  // optional bool verbose = 11 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_verbose(), target);
  }

  // optional .valhalla.Costing costing = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_costing(), target);
  }

  // repeated .valhalla.CostingOptions costing_options = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_costing_options_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_costing_options(i), target, stream);
  }

  // repeated .valhalla.Location locations = 14;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_locations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, this->_internal_locations(i), target, stream);
  }

  // repeated .valhalla.Location avoid_locations = 15;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_avoid_locations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, this->_internal_avoid_locations(i), target, stream);
  }

  // repeated .valhalla.Location sources = 16;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, this->_internal_sources(i), target, stream);
  }

  // repeated .valhalla.Location targets = 17;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_targets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, this->_internal_targets(i), target, stream);
  }

  // optional .valhalla.Options.DateTimeType date_time_type = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      18, this->_internal_date_time_type(), target);
  }

  // optional string date_time = 19;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_date_time(), target);
  }

  // repeated .valhalla.Location shape = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_shape_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_shape(i), target, stream);
  }

  // optional double resample_distance = 21;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(21, this->_internal_resample_distance(), target);
  }

  // repeated .valhalla.Contour contours = 22;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_contours_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, this->_internal_contours(i), target, stream);
  }

  // optional bool polygons = 23;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_polygons(), target);
  }

  // optional float denoise = 24 [default = 1];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(24, this->_internal_denoise(), target);
  }

  // optional float generalize = 25;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_generalize(), target);
  }

  // optional bool show_locations = 26;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(26, this->_internal_show_locations(), target);
  }

  // repeated .valhalla.Location trace = 27;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_trace_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, this->_internal_trace(i), target, stream);
  }

  // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      28, this->_internal_shape_match(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional uint32 best_paths = 29 [default = 1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(29, this->_internal_best_paths(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional float gps_accuracy = 30;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(30, this->_internal_gps_accuracy(), target);
  }

  // optional float search_radius = 31;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(31, this->_internal_search_radius(), target);
  }

  // optional float turn_penalty_factor = 32;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(32, this->_internal_turn_penalty_factor(), target);
  }

  // optional .valhalla.FilterAction filter_action = 33;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      33, this->_internal_filter_action(), target);
  }

  // repeated string filter_attributes = 34;
  for (int i = 0, n = this->_internal_filter_attributes_size(); i < n; i++) {
    const auto& s = this->_internal_filter_attributes(i);
    target = stream->WriteString(34, s, target);
  }

  // optional float breakage_distance = 36;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(36, this->_internal_breakage_distance(), target);
  }

  // optional bool use_timestamps = 37 [default = false];
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(37, this->_internal_use_timestamps(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      38, this->_internal_shape_format(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 alternates = 39;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(39, this->_internal_alternates(), target);
  }

  // optional float interpolation_distance = 40;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(40, this->_internal_interpolation_distance(), target);
  }

  // optional bool guidance_views = 41;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(41, this->_internal_guidance_views(), target);
  }

  // optional uint32 height_precision = 43 [default = 0];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(43, this->_internal_height_precision(), target);
  }

  // optional bool roundabout_exits = 44 [default = true];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(44, this->_internal_roundabout_exits(), target);
  }

  // optional bool linear_references = 45;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(45, this->_internal_linear_references(), target);
  }

  // repeated .valhalla.CostingOptions recostings = 46;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_recostings_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(46, this->_internal_recostings(i), target, stream);
  }

  // repeated .valhalla.Options.Ring avoid_polygons = 47;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_avoid_polygons_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(47, this->_internal_avoid_polygons(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Options)
  return target;
}

size_t Options::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Options)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.CostingOptions costing_options = 13;
  total_size += 1UL * this->_internal_costing_options_size();
  for (const auto& msg : this->costing_options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location locations = 14;
  total_size += 1UL * this->_internal_locations_size();
  for (const auto& msg : this->locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location avoid_locations = 15;
  total_size += 1UL * this->_internal_avoid_locations_size();
  for (const auto& msg : this->avoid_locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location sources = 16;
  total_size += 2UL * this->_internal_sources_size();
  for (const auto& msg : this->sources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location targets = 17;
  total_size += 2UL * this->_internal_targets_size();
  for (const auto& msg : this->targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location shape = 20;
  total_size += 2UL * this->_internal_shape_size();
  for (const auto& msg : this->shape_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Contour contours = 22;
  total_size += 2UL * this->_internal_contours_size();
  for (const auto& msg : this->contours_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Location trace = 27;
  total_size += 2UL * this->_internal_trace_size();
  for (const auto& msg : this->trace_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string filter_attributes = 34;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(filter_attributes_.size());
  for (int i = 0, n = filter_attributes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      filter_attributes_.Get(i));
  }

  // repeated .valhalla.CostingOptions recostings = 46;
  total_size += 2UL * this->_internal_recostings_size();
  for (const auto& msg : this->recostings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.Options.Ring avoid_polygons = 47;
  total_size += 2UL * this->_internal_avoid_polygons_size();
  for (const auto& msg : this->avoid_polygons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string language = 2 [default = "en-US"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional string id = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id());
    }

    // optional string jsonp = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_jsonp());
    }

    // optional string encoded_polyline = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_encoded_polyline());
    }

    // optional string date_time = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_date_time());
    }

    // optional .valhalla.Options.Units units = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_units());
    }

    // optional .valhalla.Options.Format format = 4 [default = json];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_format());
    }

    // optional .valhalla.Costing costing = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_costing());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool do_not_track = 9 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool range = 10 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool verbose = 11 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool polygons = 23;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional double resample_distance = 21;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 8;
    }

    // optional .valhalla.Options.DateTimeType date_time_type = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_date_time_type());
    }

    // optional float generalize = 25;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional float gps_accuracy = 30;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional float search_radius = 31;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float turn_penalty_factor = 32;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional .valhalla.FilterAction filter_action = 33;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_filter_action());
    }

    // optional float breakage_distance = 36;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional bool show_locations = 26;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool use_timestamps = 37 [default = false];
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool guidance_views = 41;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool linear_references = 45;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 alternates = 39;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_alternates());
    }

    // optional float interpolation_distance = 40;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 4;
    }

    // optional uint32 height_precision = 43 [default = 0];
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_height_precision());
    }

    // optional bool roundabout_exits = 44 [default = true];
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
    if (cached_has_bits & 0x10000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_directions_type());
    }

    // optional .valhalla.Options.Action action = 8;
    if (cached_has_bits & 0x20000000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_action());
    }

    // optional float denoise = 24 [default = 1];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + 4;
    }

    // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_shape_match());
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 best_paths = 29 [default = 1];
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_best_paths());
    }

    // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_shape_format());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Options::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Options*>(
      &from));
}

void Options::MergeFrom(const Options& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Options)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  costing_options_.MergeFrom(from.costing_options_);
  locations_.MergeFrom(from.locations_);
  avoid_locations_.MergeFrom(from.avoid_locations_);
  sources_.MergeFrom(from.sources_);
  targets_.MergeFrom(from.targets_);
  shape_.MergeFrom(from.shape_);
  contours_.MergeFrom(from.contours_);
  trace_.MergeFrom(from.trace_);
  filter_attributes_.MergeFrom(from.filter_attributes_);
  recostings_.MergeFrom(from.recostings_);
  avoid_polygons_.MergeFrom(from.avoid_polygons_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_jsonp(from._internal_jsonp());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_encoded_polyline(from._internal_encoded_polyline());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_date_time(from._internal_date_time());
    }
    if (cached_has_bits & 0x00000020u) {
      units_ = from.units_;
    }
    if (cached_has_bits & 0x00000040u) {
      format_ = from.format_;
    }
    if (cached_has_bits & 0x00000080u) {
      costing_ = from.costing_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      do_not_track_ = from.do_not_track_;
    }
    if (cached_has_bits & 0x00000200u) {
      range_ = from.range_;
    }
    if (cached_has_bits & 0x00000400u) {
      verbose_ = from.verbose_;
    }
    if (cached_has_bits & 0x00000800u) {
      polygons_ = from.polygons_;
    }
    if (cached_has_bits & 0x00001000u) {
      resample_distance_ = from.resample_distance_;
    }
    if (cached_has_bits & 0x00002000u) {
      date_time_type_ = from.date_time_type_;
    }
    if (cached_has_bits & 0x00004000u) {
      generalize_ = from.generalize_;
    }
    if (cached_has_bits & 0x00008000u) {
      gps_accuracy_ = from.gps_accuracy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      search_radius_ = from.search_radius_;
    }
    if (cached_has_bits & 0x00020000u) {
      turn_penalty_factor_ = from.turn_penalty_factor_;
    }
    if (cached_has_bits & 0x00040000u) {
      filter_action_ = from.filter_action_;
    }
    if (cached_has_bits & 0x00080000u) {
      breakage_distance_ = from.breakage_distance_;
    }
    if (cached_has_bits & 0x00100000u) {
      show_locations_ = from.show_locations_;
    }
    if (cached_has_bits & 0x00200000u) {
      use_timestamps_ = from.use_timestamps_;
    }
    if (cached_has_bits & 0x00400000u) {
      guidance_views_ = from.guidance_views_;
    }
    if (cached_has_bits & 0x00800000u) {
      linear_references_ = from.linear_references_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      alternates_ = from.alternates_;
    }
    if (cached_has_bits & 0x02000000u) {
      interpolation_distance_ = from.interpolation_distance_;
    }
    if (cached_has_bits & 0x04000000u) {
      height_precision_ = from.height_precision_;
    }
    if (cached_has_bits & 0x08000000u) {
      roundabout_exits_ = from.roundabout_exits_;
    }
    if (cached_has_bits & 0x10000000u) {
      directions_type_ = from.directions_type_;
    }
    if (cached_has_bits & 0x20000000u) {
      action_ = from.action_;
    }
    if (cached_has_bits & 0x40000000u) {
      denoise_ = from.denoise_;
    }
    if (cached_has_bits & 0x80000000u) {
      shape_match_ = from.shape_match_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      best_paths_ = from.best_paths_;
    }
    if (cached_has_bits & 0x00000002u) {
      shape_format_ = from.shape_format_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Options::CopyFrom(const Options& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Options)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options::IsInitialized() const {
  return true;
}

void Options::InternalSwap(Options* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  costing_options_.InternalSwap(&other->costing_options_);
  locations_.InternalSwap(&other->locations_);
  avoid_locations_.InternalSwap(&other->avoid_locations_);
  sources_.InternalSwap(&other->sources_);
  targets_.InternalSwap(&other->targets_);
  shape_.InternalSwap(&other->shape_);
  contours_.InternalSwap(&other->contours_);
  trace_.InternalSwap(&other->trace_);
  filter_attributes_.InternalSwap(&other->filter_attributes_);
  recostings_.InternalSwap(&other->recostings_);
  avoid_polygons_.InternalSwap(&other->avoid_polygons_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &language_, GetArenaForAllocation(),
      &other->language_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &id_, GetArenaForAllocation(),
      &other->id_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &jsonp_, GetArenaForAllocation(),
      &other->jsonp_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encoded_polyline_, GetArenaForAllocation(),
      &other->encoded_polyline_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &date_time_, GetArenaForAllocation(),
      &other->date_time_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Options, height_precision_)
      + sizeof(Options::height_precision_)
      - PROTOBUF_FIELD_OFFSET(Options, units_)>(
          reinterpret_cast<char*>(&units_),
          reinterpret_cast<char*>(&other->units_));
  swap(roundabout_exits_, other->roundabout_exits_);
  swap(directions_type_, other->directions_type_);
  swap(action_, other->action_);
  swap(denoise_, other->denoise_);
  swap(shape_match_, other->shape_match_);
  swap(best_paths_, other->best_paths_);
  swap(shape_format_, other->shape_format_);
}

std::string Options::GetTypeName() const {
  return "valhalla.Options";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::valhalla::Contour* Arena::CreateMaybeMessage< ::valhalla::Contour >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Contour >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::AvoidEdge* Arena::CreateMaybeMessage< ::valhalla::AvoidEdge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::AvoidEdge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::CostingOptions* Arena::CreateMaybeMessage< ::valhalla::CostingOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::CostingOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Options_Ring* Arena::CreateMaybeMessage< ::valhalla::Options_Ring >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Options_Ring >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Options* Arena::CreateMaybeMessage< ::valhalla::Options >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Options >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
