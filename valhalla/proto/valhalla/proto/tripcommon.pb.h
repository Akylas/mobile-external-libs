// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tripcommon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tripcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tripcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tripcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tripcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
namespace valhalla {
class BoundingBox;
struct BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class LatLng;
struct LatLngDefaultTypeInternal;
extern LatLngDefaultTypeInternal _LatLng_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Location_PathEdge;
struct Location_PathEdgeDefaultTypeInternal;
extern Location_PathEdgeDefaultTypeInternal _Location_PathEdge_default_instance_;
class Location_SearchFilter;
struct Location_SearchFilterDefaultTypeInternal;
extern Location_SearchFilterDefaultTypeInternal _Location_SearchFilter_default_instance_;
class StreetName;
struct StreetNameDefaultTypeInternal;
extern StreetNameDefaultTypeInternal _StreetName_default_instance_;
class TaggedValue;
struct TaggedValueDefaultTypeInternal;
extern TaggedValueDefaultTypeInternal _TaggedValue_default_instance_;
class TransitEgressInfo;
struct TransitEgressInfoDefaultTypeInternal;
extern TransitEgressInfoDefaultTypeInternal _TransitEgressInfo_default_instance_;
class TransitPlatformInfo;
struct TransitPlatformInfoDefaultTypeInternal;
extern TransitPlatformInfoDefaultTypeInternal _TransitPlatformInfo_default_instance_;
class TransitStationInfo;
struct TransitStationInfoDefaultTypeInternal;
extern TransitStationInfoDefaultTypeInternal _TransitStationInfo_default_instance_;
class TurnLane;
struct TurnLaneDefaultTypeInternal;
extern TurnLaneDefaultTypeInternal _TurnLane_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::BoundingBox* Arena::CreateMaybeMessage<::valhalla::BoundingBox>(Arena*);
template<> ::valhalla::LatLng* Arena::CreateMaybeMessage<::valhalla::LatLng>(Arena*);
template<> ::valhalla::Location* Arena::CreateMaybeMessage<::valhalla::Location>(Arena*);
template<> ::valhalla::Location_PathEdge* Arena::CreateMaybeMessage<::valhalla::Location_PathEdge>(Arena*);
template<> ::valhalla::Location_SearchFilter* Arena::CreateMaybeMessage<::valhalla::Location_SearchFilter>(Arena*);
template<> ::valhalla::StreetName* Arena::CreateMaybeMessage<::valhalla::StreetName>(Arena*);
template<> ::valhalla::TaggedValue* Arena::CreateMaybeMessage<::valhalla::TaggedValue>(Arena*);
template<> ::valhalla::TransitEgressInfo* Arena::CreateMaybeMessage<::valhalla::TransitEgressInfo>(Arena*);
template<> ::valhalla::TransitPlatformInfo* Arena::CreateMaybeMessage<::valhalla::TransitPlatformInfo>(Arena*);
template<> ::valhalla::TransitStationInfo* Arena::CreateMaybeMessage<::valhalla::TransitStationInfo>(Arena*);
template<> ::valhalla::TurnLane* Arena::CreateMaybeMessage<::valhalla::TurnLane>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum Location_Type : int {
  Location_Type_kBreak = 0,
  Location_Type_kThrough = 1,
  Location_Type_kVia = 2,
  Location_Type_kBreakThrough = 3
};
bool Location_Type_IsValid(int value);
constexpr Location_Type Location_Type_Type_MIN = Location_Type_kBreak;
constexpr Location_Type Location_Type_Type_MAX = Location_Type_kBreakThrough;
constexpr int Location_Type_Type_ARRAYSIZE = Location_Type_Type_MAX + 1;

const std::string& Location_Type_Name(Location_Type value);
template<typename T>
inline const std::string& Location_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Location_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Location_Type_Name.");
  return Location_Type_Name(static_cast<Location_Type>(enum_t_value));
}
bool Location_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Location_Type* value);
enum Location_SideOfStreet : int {
  Location_SideOfStreet_kNone = 0,
  Location_SideOfStreet_kLeft = 1,
  Location_SideOfStreet_kRight = 2
};
bool Location_SideOfStreet_IsValid(int value);
constexpr Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MIN = Location_SideOfStreet_kNone;
constexpr Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MAX = Location_SideOfStreet_kRight;
constexpr int Location_SideOfStreet_SideOfStreet_ARRAYSIZE = Location_SideOfStreet_SideOfStreet_MAX + 1;

const std::string& Location_SideOfStreet_Name(Location_SideOfStreet value);
template<typename T>
inline const std::string& Location_SideOfStreet_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Location_SideOfStreet>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Location_SideOfStreet_Name.");
  return Location_SideOfStreet_Name(static_cast<Location_SideOfStreet>(enum_t_value));
}
bool Location_SideOfStreet_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Location_SideOfStreet* value);
enum Location_PreferredSide : int {
  Location_PreferredSide_either = 0,
  Location_PreferredSide_same = 1,
  Location_PreferredSide_opposite = 2
};
bool Location_PreferredSide_IsValid(int value);
constexpr Location_PreferredSide Location_PreferredSide_PreferredSide_MIN = Location_PreferredSide_either;
constexpr Location_PreferredSide Location_PreferredSide_PreferredSide_MAX = Location_PreferredSide_opposite;
constexpr int Location_PreferredSide_PreferredSide_ARRAYSIZE = Location_PreferredSide_PreferredSide_MAX + 1;

const std::string& Location_PreferredSide_Name(Location_PreferredSide value);
template<typename T>
inline const std::string& Location_PreferredSide_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Location_PreferredSide>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Location_PreferredSide_Name.");
  return Location_PreferredSide_Name(static_cast<Location_PreferredSide>(enum_t_value));
}
bool Location_PreferredSide_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Location_PreferredSide* value);
enum TransitPlatformInfo_Type : int {
  TransitPlatformInfo_Type_kStop = 0,
  TransitPlatformInfo_Type_kStation = 1
};
bool TransitPlatformInfo_Type_IsValid(int value);
constexpr TransitPlatformInfo_Type TransitPlatformInfo_Type_Type_MIN = TransitPlatformInfo_Type_kStop;
constexpr TransitPlatformInfo_Type TransitPlatformInfo_Type_Type_MAX = TransitPlatformInfo_Type_kStation;
constexpr int TransitPlatformInfo_Type_Type_ARRAYSIZE = TransitPlatformInfo_Type_Type_MAX + 1;

const std::string& TransitPlatformInfo_Type_Name(TransitPlatformInfo_Type value);
template<typename T>
inline const std::string& TransitPlatformInfo_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransitPlatformInfo_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransitPlatformInfo_Type_Name.");
  return TransitPlatformInfo_Type_Name(static_cast<TransitPlatformInfo_Type>(enum_t_value));
}
bool TransitPlatformInfo_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransitPlatformInfo_Type* value);
enum TurnLane_State : int {
  TurnLane_State_kInvalid = 0,
  TurnLane_State_kValid = 1,
  TurnLane_State_kActive = 2
};
bool TurnLane_State_IsValid(int value);
constexpr TurnLane_State TurnLane_State_State_MIN = TurnLane_State_kInvalid;
constexpr TurnLane_State TurnLane_State_State_MAX = TurnLane_State_kActive;
constexpr int TurnLane_State_State_ARRAYSIZE = TurnLane_State_State_MAX + 1;

const std::string& TurnLane_State_Name(TurnLane_State value);
template<typename T>
inline const std::string& TurnLane_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TurnLane_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TurnLane_State_Name.");
  return TurnLane_State_Name(static_cast<TurnLane_State>(enum_t_value));
}
bool TurnLane_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TurnLane_State* value);
enum TaggedValue_Type : int {
  TaggedValue_Type_kLayer = 1,
  TaggedValue_Type_kTunnel = 49,
  TaggedValue_Type_kBridge = 50
};
bool TaggedValue_Type_IsValid(int value);
constexpr TaggedValue_Type TaggedValue_Type_Type_MIN = TaggedValue_Type_kLayer;
constexpr TaggedValue_Type TaggedValue_Type_Type_MAX = TaggedValue_Type_kBridge;
constexpr int TaggedValue_Type_Type_ARRAYSIZE = TaggedValue_Type_Type_MAX + 1;

const std::string& TaggedValue_Type_Name(TaggedValue_Type value);
template<typename T>
inline const std::string& TaggedValue_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaggedValue_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaggedValue_Type_Name.");
  return TaggedValue_Type_Name(static_cast<TaggedValue_Type>(enum_t_value));
}
bool TaggedValue_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaggedValue_Type* value);
enum RoadClass : int {
  kMotorway = 0,
  kTrunk = 1,
  kPrimary = 2,
  kSecondary = 3,
  kTertiary = 4,
  kUnclassified = 5,
  kResidential = 6,
  kServiceOther = 7
};
bool RoadClass_IsValid(int value);
constexpr RoadClass RoadClass_MIN = kMotorway;
constexpr RoadClass RoadClass_MAX = kServiceOther;
constexpr int RoadClass_ARRAYSIZE = RoadClass_MAX + 1;

const std::string& RoadClass_Name(RoadClass value);
template<typename T>
inline const std::string& RoadClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadClass_Name.");
  return RoadClass_Name(static_cast<RoadClass>(enum_t_value));
}
bool RoadClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoadClass* value);
// ===================================================================

class LatLng final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.LatLng) */ {
 public:
  inline LatLng() : LatLng(nullptr) {}
  ~LatLng() override;
  explicit constexpr LatLng(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LatLng(const LatLng& from);
  LatLng(LatLng&& from) noexcept
    : LatLng() {
    *this = ::std::move(from);
  }

  inline LatLng& operator=(const LatLng& from) {
    CopyFrom(from);
    return *this;
  }
  inline LatLng& operator=(LatLng&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LatLng& default_instance() {
    return *internal_default_instance();
  }
  static inline const LatLng* internal_default_instance() {
    return reinterpret_cast<const LatLng*>(
               &_LatLng_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LatLng& a, LatLng& b) {
    a.Swap(&b);
  }
  inline void Swap(LatLng* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LatLng* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LatLng* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LatLng>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const LatLng& from);
  void MergeFrom(const LatLng& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LatLng* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.LatLng";
  }
  protected:
  explicit LatLng(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLngFieldNumber = 2,
  };
  // optional double lat = 1;
  bool has_lat() const;
  private:
  bool _internal_has_lat() const;
  public:
  void clear_lat();
  double lat() const;
  void set_lat(double value);
  private:
  double _internal_lat() const;
  void _internal_set_lat(double value);
  public:

  // optional double lng = 2;
  bool has_lng() const;
  private:
  bool _internal_has_lng() const;
  public:
  void clear_lng();
  double lng() const;
  void set_lng(double value);
  private:
  double _internal_lng() const;
  void _internal_set_lng(double value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.LatLng)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double lat_;
  double lng_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class BoundingBox final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.BoundingBox) */ {
 public:
  inline BoundingBox() : BoundingBox(nullptr) {}
  ~BoundingBox() override;
  explicit constexpr BoundingBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoundingBox(const BoundingBox& from);
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BoundingBox& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingBox* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoundingBox* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoundingBox>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoundingBox* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.BoundingBox";
  }
  protected:
  explicit BoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinLlFieldNumber = 1,
    kMaxLlFieldNumber = 2,
  };
  // optional .valhalla.LatLng min_ll = 1;
  bool has_min_ll() const;
  private:
  bool _internal_has_min_ll() const;
  public:
  void clear_min_ll();
  const ::valhalla::LatLng& min_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_min_ll();
  ::valhalla::LatLng* mutable_min_ll();
  void set_allocated_min_ll(::valhalla::LatLng* min_ll);
  private:
  const ::valhalla::LatLng& _internal_min_ll() const;
  ::valhalla::LatLng* _internal_mutable_min_ll();
  public:
  void unsafe_arena_set_allocated_min_ll(
      ::valhalla::LatLng* min_ll);
  ::valhalla::LatLng* unsafe_arena_release_min_ll();

  // optional .valhalla.LatLng max_ll = 2;
  bool has_max_ll() const;
  private:
  bool _internal_has_max_ll() const;
  public:
  void clear_max_ll();
  const ::valhalla::LatLng& max_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_max_ll();
  ::valhalla::LatLng* mutable_max_ll();
  void set_allocated_max_ll(::valhalla::LatLng* max_ll);
  private:
  const ::valhalla::LatLng& _internal_max_ll() const;
  ::valhalla::LatLng* _internal_mutable_max_ll();
  public:
  void unsafe_arena_set_allocated_max_ll(
      ::valhalla::LatLng* max_ll);
  ::valhalla::LatLng* unsafe_arena_release_max_ll();

  // @@protoc_insertion_point(class_scope:valhalla.BoundingBox)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::valhalla::LatLng* min_ll_;
  ::valhalla::LatLng* max_ll_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class Location_PathEdge final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Location.PathEdge) */ {
 public:
  inline Location_PathEdge() : Location_PathEdge(nullptr) {}
  ~Location_PathEdge() override;
  explicit constexpr Location_PathEdge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location_PathEdge(const Location_PathEdge& from);
  Location_PathEdge(Location_PathEdge&& from) noexcept
    : Location_PathEdge() {
    *this = ::std::move(from);
  }

  inline Location_PathEdge& operator=(const Location_PathEdge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location_PathEdge& operator=(Location_PathEdge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Location_PathEdge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location_PathEdge* internal_default_instance() {
    return reinterpret_cast<const Location_PathEdge*>(
               &_Location_PathEdge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Location_PathEdge& a, Location_PathEdge& b) {
    a.Swap(&b);
  }
  inline void Swap(Location_PathEdge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location_PathEdge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location_PathEdge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location_PathEdge>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Location_PathEdge& from);
  void MergeFrom(const Location_PathEdge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Location_PathEdge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Location.PathEdge";
  }
  protected:
  explicit Location_PathEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 10,
    kLlFieldNumber = 3,
    kGraphIdFieldNumber = 1,
    kPercentAlongFieldNumber = 2,
    kDistanceFieldNumber = 5,
    kSideOfStreetFieldNumber = 4,
    kMinimumReachabilityFieldNumber = 6,
    kBeginNodeFieldNumber = 7,
    kEndNodeFieldNumber = 8,
    kOutboundReachFieldNumber = 11,
    kInboundReachFieldNumber = 12,
  };
  // repeated string names = 10;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // optional .valhalla.LatLng ll = 3;
  bool has_ll() const;
  private:
  bool _internal_has_ll() const;
  public:
  void clear_ll();
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* ll);
  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();
  public:
  void unsafe_arena_set_allocated_ll(
      ::valhalla::LatLng* ll);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  // optional uint64 graph_id = 1;
  bool has_graph_id() const;
  private:
  bool _internal_has_graph_id() const;
  public:
  void clear_graph_id();
  uint64_t graph_id() const;
  void set_graph_id(uint64_t value);
  private:
  uint64_t _internal_graph_id() const;
  void _internal_set_graph_id(uint64_t value);
  public:

  // optional double percent_along = 2;
  bool has_percent_along() const;
  private:
  bool _internal_has_percent_along() const;
  public:
  void clear_percent_along();
  double percent_along() const;
  void set_percent_along(double value);
  private:
  double _internal_percent_along() const;
  void _internal_set_percent_along(double value);
  public:

  // optional double distance = 5;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // optional .valhalla.Location.SideOfStreet side_of_street = 4;
  bool has_side_of_street() const;
  private:
  bool _internal_has_side_of_street() const;
  public:
  void clear_side_of_street();
  ::valhalla::Location_SideOfStreet side_of_street() const;
  void set_side_of_street(::valhalla::Location_SideOfStreet value);
  private:
  ::valhalla::Location_SideOfStreet _internal_side_of_street() const;
  void _internal_set_side_of_street(::valhalla::Location_SideOfStreet value);
  public:

  // optional int32 minimum_reachability = 6;
  bool has_minimum_reachability() const;
  private:
  bool _internal_has_minimum_reachability() const;
  public:
  void clear_minimum_reachability();
  int32_t minimum_reachability() const;
  void set_minimum_reachability(int32_t value);
  private:
  int32_t _internal_minimum_reachability() const;
  void _internal_set_minimum_reachability(int32_t value);
  public:

  // optional bool begin_node = 7;
  bool has_begin_node() const;
  private:
  bool _internal_has_begin_node() const;
  public:
  void clear_begin_node();
  bool begin_node() const;
  void set_begin_node(bool value);
  private:
  bool _internal_begin_node() const;
  void _internal_set_begin_node(bool value);
  public:

  // optional bool end_node = 8;
  bool has_end_node() const;
  private:
  bool _internal_has_end_node() const;
  public:
  void clear_end_node();
  bool end_node() const;
  void set_end_node(bool value);
  private:
  bool _internal_end_node() const;
  void _internal_set_end_node(bool value);
  public:

  // optional int32 outbound_reach = 11;
  bool has_outbound_reach() const;
  private:
  bool _internal_has_outbound_reach() const;
  public:
  void clear_outbound_reach();
  int32_t outbound_reach() const;
  void set_outbound_reach(int32_t value);
  private:
  int32_t _internal_outbound_reach() const;
  void _internal_set_outbound_reach(int32_t value);
  public:

  // optional int32 inbound_reach = 12;
  bool has_inbound_reach() const;
  private:
  bool _internal_has_inbound_reach() const;
  public:
  void clear_inbound_reach();
  int32_t inbound_reach() const;
  void set_inbound_reach(int32_t value);
  private:
  int32_t _internal_inbound_reach() const;
  void _internal_set_inbound_reach(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.Location.PathEdge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
  ::valhalla::LatLng* ll_;
  uint64_t graph_id_;
  double percent_along_;
  double distance_;
  int side_of_street_;
  int32_t minimum_reachability_;
  bool begin_node_;
  bool end_node_;
  int32_t outbound_reach_;
  int32_t inbound_reach_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class Location_SearchFilter final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Location.SearchFilter) */ {
 public:
  inline Location_SearchFilter() : Location_SearchFilter(nullptr) {}
  ~Location_SearchFilter() override;
  explicit constexpr Location_SearchFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location_SearchFilter(const Location_SearchFilter& from);
  Location_SearchFilter(Location_SearchFilter&& from) noexcept
    : Location_SearchFilter() {
    *this = ::std::move(from);
  }

  inline Location_SearchFilter& operator=(const Location_SearchFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location_SearchFilter& operator=(Location_SearchFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Location_SearchFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location_SearchFilter* internal_default_instance() {
    return reinterpret_cast<const Location_SearchFilter*>(
               &_Location_SearchFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Location_SearchFilter& a, Location_SearchFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(Location_SearchFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location_SearchFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location_SearchFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location_SearchFilter>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Location_SearchFilter& from);
  void MergeFrom(const Location_SearchFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Location_SearchFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Location.SearchFilter";
  }
  protected:
  explicit Location_SearchFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxRoadClassFieldNumber = 2,
    kExcludeTunnelFieldNumber = 3,
    kExcludeBridgeFieldNumber = 4,
    kExcludeRampFieldNumber = 5,
    kMinRoadClassFieldNumber = 1,
    kExcludeClosuresFieldNumber = 6,
  };
  // optional .valhalla.RoadClass max_road_class = 2 [default = kMotorway];
  bool has_max_road_class() const;
  private:
  bool _internal_has_max_road_class() const;
  public:
  void clear_max_road_class();
  ::valhalla::RoadClass max_road_class() const;
  void set_max_road_class(::valhalla::RoadClass value);
  private:
  ::valhalla::RoadClass _internal_max_road_class() const;
  void _internal_set_max_road_class(::valhalla::RoadClass value);
  public:

  // optional bool exclude_tunnel = 3;
  bool has_exclude_tunnel() const;
  private:
  bool _internal_has_exclude_tunnel() const;
  public:
  void clear_exclude_tunnel();
  bool exclude_tunnel() const;
  void set_exclude_tunnel(bool value);
  private:
  bool _internal_exclude_tunnel() const;
  void _internal_set_exclude_tunnel(bool value);
  public:

  // optional bool exclude_bridge = 4;
  bool has_exclude_bridge() const;
  private:
  bool _internal_has_exclude_bridge() const;
  public:
  void clear_exclude_bridge();
  bool exclude_bridge() const;
  void set_exclude_bridge(bool value);
  private:
  bool _internal_exclude_bridge() const;
  void _internal_set_exclude_bridge(bool value);
  public:

  // optional bool exclude_ramp = 5;
  bool has_exclude_ramp() const;
  private:
  bool _internal_has_exclude_ramp() const;
  public:
  void clear_exclude_ramp();
  bool exclude_ramp() const;
  void set_exclude_ramp(bool value);
  private:
  bool _internal_exclude_ramp() const;
  void _internal_set_exclude_ramp(bool value);
  public:

  // optional .valhalla.RoadClass min_road_class = 1 [default = kServiceOther];
  bool has_min_road_class() const;
  private:
  bool _internal_has_min_road_class() const;
  public:
  void clear_min_road_class();
  ::valhalla::RoadClass min_road_class() const;
  void set_min_road_class(::valhalla::RoadClass value);
  private:
  ::valhalla::RoadClass _internal_min_road_class() const;
  void _internal_set_min_road_class(::valhalla::RoadClass value);
  public:

  // optional bool exclude_closures = 6 [default = true];
  bool has_exclude_closures() const;
  private:
  bool _internal_has_exclude_closures() const;
  public:
  void clear_exclude_closures();
  bool exclude_closures() const;
  void set_exclude_closures(bool value);
  private:
  bool _internal_exclude_closures() const;
  void _internal_set_exclude_closures(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.Location.SearchFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int max_road_class_;
  bool exclude_tunnel_;
  bool exclude_bridge_;
  bool exclude_ramp_;
  int min_road_class_;
  bool exclude_closures_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit constexpr Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Location_PathEdge PathEdge;
  typedef Location_SearchFilter SearchFilter;

  typedef Location_Type Type;
  static constexpr Type kBreak =
    Location_Type_kBreak;
  static constexpr Type kThrough =
    Location_Type_kThrough;
  static constexpr Type kVia =
    Location_Type_kVia;
  static constexpr Type kBreakThrough =
    Location_Type_kBreakThrough;
  static inline bool Type_IsValid(int value) {
    return Location_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Location_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Location_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Location_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Location_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Location_Type_Parse(name, value);
  }

  typedef Location_SideOfStreet SideOfStreet;
  static constexpr SideOfStreet kNone =
    Location_SideOfStreet_kNone;
  static constexpr SideOfStreet kLeft =
    Location_SideOfStreet_kLeft;
  static constexpr SideOfStreet kRight =
    Location_SideOfStreet_kRight;
  static inline bool SideOfStreet_IsValid(int value) {
    return Location_SideOfStreet_IsValid(value);
  }
  static constexpr SideOfStreet SideOfStreet_MIN =
    Location_SideOfStreet_SideOfStreet_MIN;
  static constexpr SideOfStreet SideOfStreet_MAX =
    Location_SideOfStreet_SideOfStreet_MAX;
  static constexpr int SideOfStreet_ARRAYSIZE =
    Location_SideOfStreet_SideOfStreet_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SideOfStreet_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SideOfStreet>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SideOfStreet_Name.");
    return Location_SideOfStreet_Name(enum_t_value);
  }
  static inline bool SideOfStreet_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SideOfStreet* value) {
    return Location_SideOfStreet_Parse(name, value);
  }

  typedef Location_PreferredSide PreferredSide;
  static constexpr PreferredSide either =
    Location_PreferredSide_either;
  static constexpr PreferredSide same =
    Location_PreferredSide_same;
  static constexpr PreferredSide opposite =
    Location_PreferredSide_opposite;
  static inline bool PreferredSide_IsValid(int value) {
    return Location_PreferredSide_IsValid(value);
  }
  static constexpr PreferredSide PreferredSide_MIN =
    Location_PreferredSide_PreferredSide_MIN;
  static constexpr PreferredSide PreferredSide_MAX =
    Location_PreferredSide_PreferredSide_MAX;
  static constexpr int PreferredSide_ARRAYSIZE =
    Location_PreferredSide_PreferredSide_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PreferredSide_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PreferredSide>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PreferredSide_Name.");
    return Location_PreferredSide_Name(enum_t_value);
  }
  static inline bool PreferredSide_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PreferredSide* value) {
    return Location_PreferredSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathEdgesFieldNumber = 22,
    kFilteredEdgesFieldNumber = 23,
    kNameFieldNumber = 4,
    kStreetFieldNumber = 5,
    kCityFieldNumber = 6,
    kStateFieldNumber = 7,
    kPostalCodeFieldNumber = 8,
    kCountryFieldNumber = 9,
    kPhoneFieldNumber = 10,
    kUrlFieldNumber = 11,
    kDateTimeFieldNumber = 12,
    kLlFieldNumber = 1,
    kProjectedLlFieldNumber = 25,
    kDisplayLlFieldNumber = 27,
    kSearchFilterFieldNumber = 32,
    kTypeFieldNumber = 2,
    kHeadingFieldNumber = 3,
    kSideOfStreetFieldNumber = 13,
    kHeadingToleranceFieldNumber = 14,
    kWayIdFieldNumber = 16,
    kNodeSnapToleranceFieldNumber = 15,
    kMinimumReachabilityFieldNumber = 17,
    kRadiusFieldNumber = 18,
    kAccuracyFieldNumber = 19,
    kOriginalIndexFieldNumber = 24,
    kPreferredSideFieldNumber = 26,
    kSearchCutoffFieldNumber = 28,
    kStreetSideToleranceFieldNumber = 29,
    kRouteIndexFieldNumber = 30,
    kWaypointIndexFieldNumber = 31,
    kStreetSideMaxDistanceFieldNumber = 33,
    kPreferredLayerFieldNumber = 34,
    kDistanceFromLegOriginFieldNumber = 36,
    kLegShapeIndexFieldNumber = 35,
    kRankCandidatesFieldNumber = 21,
    kTimeFieldNumber = 20,
  };
  // repeated .valhalla.Location.PathEdge path_edges = 22;
  int path_edges_size() const;
  private:
  int _internal_path_edges_size() const;
  public:
  void clear_path_edges();
  ::valhalla::Location_PathEdge* mutable_path_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >*
      mutable_path_edges();
  private:
  const ::valhalla::Location_PathEdge& _internal_path_edges(int index) const;
  ::valhalla::Location_PathEdge* _internal_add_path_edges();
  public:
  const ::valhalla::Location_PathEdge& path_edges(int index) const;
  ::valhalla::Location_PathEdge* add_path_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >&
      path_edges() const;

  // repeated .valhalla.Location.PathEdge filtered_edges = 23;
  int filtered_edges_size() const;
  private:
  int _internal_filtered_edges_size() const;
  public:
  void clear_filtered_edges();
  ::valhalla::Location_PathEdge* mutable_filtered_edges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >*
      mutable_filtered_edges();
  private:
  const ::valhalla::Location_PathEdge& _internal_filtered_edges(int index) const;
  ::valhalla::Location_PathEdge* _internal_add_filtered_edges();
  public:
  const ::valhalla::Location_PathEdge& filtered_edges(int index) const;
  ::valhalla::Location_PathEdge* add_filtered_edges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >&
      filtered_edges() const;

  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string street = 5;
  bool has_street() const;
  private:
  bool _internal_has_street() const;
  public:
  void clear_street();
  const std::string& street() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_street(ArgT0&& arg0, ArgT... args);
  std::string* mutable_street();
  PROTOBUF_NODISCARD std::string* release_street();
  void set_allocated_street(std::string* street);
  private:
  const std::string& _internal_street() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street(const std::string& value);
  std::string* _internal_mutable_street();
  public:

  // optional string city = 6;
  bool has_city() const;
  private:
  bool _internal_has_city() const;
  public:
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // optional string state = 7;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string postal_code = 8;
  bool has_postal_code() const;
  private:
  bool _internal_has_postal_code() const;
  public:
  void clear_postal_code();
  const std::string& postal_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_postal_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_postal_code();
  PROTOBUF_NODISCARD std::string* release_postal_code();
  void set_allocated_postal_code(std::string* postal_code);
  private:
  const std::string& _internal_postal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postal_code(const std::string& value);
  std::string* _internal_mutable_postal_code();
  public:

  // optional string country = 9;
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string phone = 10;
  bool has_phone() const;
  private:
  bool _internal_has_phone() const;
  public:
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // optional string url = 11;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string date_time = 12;
  bool has_date_time() const;
  private:
  bool _internal_has_date_time() const;
  public:
  void clear_date_time();
  const std::string& date_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_time();
  PROTOBUF_NODISCARD std::string* release_date_time();
  void set_allocated_date_time(std::string* date_time);
  private:
  const std::string& _internal_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_time(const std::string& value);
  std::string* _internal_mutable_date_time();
  public:

  // optional .valhalla.LatLng ll = 1;
  bool has_ll() const;
  private:
  bool _internal_has_ll() const;
  public:
  void clear_ll();
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* ll);
  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();
  public:
  void unsafe_arena_set_allocated_ll(
      ::valhalla::LatLng* ll);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  // optional .valhalla.LatLng projected_ll = 25;
  bool has_projected_ll() const;
  private:
  bool _internal_has_projected_ll() const;
  public:
  void clear_projected_ll();
  const ::valhalla::LatLng& projected_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_projected_ll();
  ::valhalla::LatLng* mutable_projected_ll();
  void set_allocated_projected_ll(::valhalla::LatLng* projected_ll);
  private:
  const ::valhalla::LatLng& _internal_projected_ll() const;
  ::valhalla::LatLng* _internal_mutable_projected_ll();
  public:
  void unsafe_arena_set_allocated_projected_ll(
      ::valhalla::LatLng* projected_ll);
  ::valhalla::LatLng* unsafe_arena_release_projected_ll();

  // optional .valhalla.LatLng display_ll = 27;
  bool has_display_ll() const;
  private:
  bool _internal_has_display_ll() const;
  public:
  void clear_display_ll();
  const ::valhalla::LatLng& display_ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_display_ll();
  ::valhalla::LatLng* mutable_display_ll();
  void set_allocated_display_ll(::valhalla::LatLng* display_ll);
  private:
  const ::valhalla::LatLng& _internal_display_ll() const;
  ::valhalla::LatLng* _internal_mutable_display_ll();
  public:
  void unsafe_arena_set_allocated_display_ll(
      ::valhalla::LatLng* display_ll);
  ::valhalla::LatLng* unsafe_arena_release_display_ll();

  // optional .valhalla.Location.SearchFilter search_filter = 32;
  bool has_search_filter() const;
  private:
  bool _internal_has_search_filter() const;
  public:
  void clear_search_filter();
  const ::valhalla::Location_SearchFilter& search_filter() const;
  PROTOBUF_NODISCARD ::valhalla::Location_SearchFilter* release_search_filter();
  ::valhalla::Location_SearchFilter* mutable_search_filter();
  void set_allocated_search_filter(::valhalla::Location_SearchFilter* search_filter);
  private:
  const ::valhalla::Location_SearchFilter& _internal_search_filter() const;
  ::valhalla::Location_SearchFilter* _internal_mutable_search_filter();
  public:
  void unsafe_arena_set_allocated_search_filter(
      ::valhalla::Location_SearchFilter* search_filter);
  ::valhalla::Location_SearchFilter* unsafe_arena_release_search_filter();

  // optional .valhalla.Location.Type type = 2 [default = kBreak];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::Location_Type type() const;
  void set_type(::valhalla::Location_Type value);
  private:
  ::valhalla::Location_Type _internal_type() const;
  void _internal_set_type(::valhalla::Location_Type value);
  public:

  // optional uint32 heading = 3;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  uint32_t heading() const;
  void set_heading(uint32_t value);
  private:
  uint32_t _internal_heading() const;
  void _internal_set_heading(uint32_t value);
  public:

  // optional .valhalla.Location.SideOfStreet side_of_street = 13;
  bool has_side_of_street() const;
  private:
  bool _internal_has_side_of_street() const;
  public:
  void clear_side_of_street();
  ::valhalla::Location_SideOfStreet side_of_street() const;
  void set_side_of_street(::valhalla::Location_SideOfStreet value);
  private:
  ::valhalla::Location_SideOfStreet _internal_side_of_street() const;
  void _internal_set_side_of_street(::valhalla::Location_SideOfStreet value);
  public:

  // optional uint32 heading_tolerance = 14;
  bool has_heading_tolerance() const;
  private:
  bool _internal_has_heading_tolerance() const;
  public:
  void clear_heading_tolerance();
  uint32_t heading_tolerance() const;
  void set_heading_tolerance(uint32_t value);
  private:
  uint32_t _internal_heading_tolerance() const;
  void _internal_set_heading_tolerance(uint32_t value);
  public:

  // optional uint64 way_id = 16;
  bool has_way_id() const;
  private:
  bool _internal_has_way_id() const;
  public:
  void clear_way_id();
  uint64_t way_id() const;
  void set_way_id(uint64_t value);
  private:
  uint64_t _internal_way_id() const;
  void _internal_set_way_id(uint64_t value);
  public:

  // optional uint32 node_snap_tolerance = 15;
  bool has_node_snap_tolerance() const;
  private:
  bool _internal_has_node_snap_tolerance() const;
  public:
  void clear_node_snap_tolerance();
  uint32_t node_snap_tolerance() const;
  void set_node_snap_tolerance(uint32_t value);
  private:
  uint32_t _internal_node_snap_tolerance() const;
  void _internal_set_node_snap_tolerance(uint32_t value);
  public:

  // optional uint32 minimum_reachability = 17;
  bool has_minimum_reachability() const;
  private:
  bool _internal_has_minimum_reachability() const;
  public:
  void clear_minimum_reachability();
  uint32_t minimum_reachability() const;
  void set_minimum_reachability(uint32_t value);
  private:
  uint32_t _internal_minimum_reachability() const;
  void _internal_set_minimum_reachability(uint32_t value);
  public:

  // optional uint32 radius = 18;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  uint32_t radius() const;
  void set_radius(uint32_t value);
  private:
  uint32_t _internal_radius() const;
  void _internal_set_radius(uint32_t value);
  public:

  // optional uint32 accuracy = 19;
  bool has_accuracy() const;
  private:
  bool _internal_has_accuracy() const;
  public:
  void clear_accuracy();
  uint32_t accuracy() const;
  void set_accuracy(uint32_t value);
  private:
  uint32_t _internal_accuracy() const;
  void _internal_set_accuracy(uint32_t value);
  public:

  // optional uint32 original_index = 24;
  bool has_original_index() const;
  private:
  bool _internal_has_original_index() const;
  public:
  void clear_original_index();
  uint32_t original_index() const;
  void set_original_index(uint32_t value);
  private:
  uint32_t _internal_original_index() const;
  void _internal_set_original_index(uint32_t value);
  public:

  // optional .valhalla.Location.PreferredSide preferred_side = 26 [default = either];
  bool has_preferred_side() const;
  private:
  bool _internal_has_preferred_side() const;
  public:
  void clear_preferred_side();
  ::valhalla::Location_PreferredSide preferred_side() const;
  void set_preferred_side(::valhalla::Location_PreferredSide value);
  private:
  ::valhalla::Location_PreferredSide _internal_preferred_side() const;
  void _internal_set_preferred_side(::valhalla::Location_PreferredSide value);
  public:

  // optional uint32 search_cutoff = 28;
  bool has_search_cutoff() const;
  private:
  bool _internal_has_search_cutoff() const;
  public:
  void clear_search_cutoff();
  uint32_t search_cutoff() const;
  void set_search_cutoff(uint32_t value);
  private:
  uint32_t _internal_search_cutoff() const;
  void _internal_set_search_cutoff(uint32_t value);
  public:

  // optional uint32 street_side_tolerance = 29;
  bool has_street_side_tolerance() const;
  private:
  bool _internal_has_street_side_tolerance() const;
  public:
  void clear_street_side_tolerance();
  uint32_t street_side_tolerance() const;
  void set_street_side_tolerance(uint32_t value);
  private:
  uint32_t _internal_street_side_tolerance() const;
  void _internal_set_street_side_tolerance(uint32_t value);
  public:

  // optional uint32 route_index = 30;
  bool has_route_index() const;
  private:
  bool _internal_has_route_index() const;
  public:
  void clear_route_index();
  uint32_t route_index() const;
  void set_route_index(uint32_t value);
  private:
  uint32_t _internal_route_index() const;
  void _internal_set_route_index(uint32_t value);
  public:

  // optional uint32 waypoint_index = 31;
  bool has_waypoint_index() const;
  private:
  bool _internal_has_waypoint_index() const;
  public:
  void clear_waypoint_index();
  uint32_t waypoint_index() const;
  void set_waypoint_index(uint32_t value);
  private:
  uint32_t _internal_waypoint_index() const;
  void _internal_set_waypoint_index(uint32_t value);
  public:

  // optional uint32 street_side_max_distance = 33;
  bool has_street_side_max_distance() const;
  private:
  bool _internal_has_street_side_max_distance() const;
  public:
  void clear_street_side_max_distance();
  uint32_t street_side_max_distance() const;
  void set_street_side_max_distance(uint32_t value);
  private:
  uint32_t _internal_street_side_max_distance() const;
  void _internal_set_street_side_max_distance(uint32_t value);
  public:

  // optional int32 preferred_layer = 34;
  bool has_preferred_layer() const;
  private:
  bool _internal_has_preferred_layer() const;
  public:
  void clear_preferred_layer();
  int32_t preferred_layer() const;
  void set_preferred_layer(int32_t value);
  private:
  int32_t _internal_preferred_layer() const;
  void _internal_set_preferred_layer(int32_t value);
  public:

  // optional double distance_from_leg_origin = 36;
  bool has_distance_from_leg_origin() const;
  private:
  bool _internal_has_distance_from_leg_origin() const;
  public:
  void clear_distance_from_leg_origin();
  double distance_from_leg_origin() const;
  void set_distance_from_leg_origin(double value);
  private:
  double _internal_distance_from_leg_origin() const;
  void _internal_set_distance_from_leg_origin(double value);
  public:

  // optional uint32 leg_shape_index = 35;
  bool has_leg_shape_index() const;
  private:
  bool _internal_has_leg_shape_index() const;
  public:
  void clear_leg_shape_index();
  uint32_t leg_shape_index() const;
  void set_leg_shape_index(uint32_t value);
  private:
  uint32_t _internal_leg_shape_index() const;
  void _internal_set_leg_shape_index(uint32_t value);
  public:

  // optional bool rank_candidates = 21 [default = true];
  bool has_rank_candidates() const;
  private:
  bool _internal_has_rank_candidates() const;
  public:
  void clear_rank_candidates();
  bool rank_candidates() const;
  void set_rank_candidates(bool value);
  private:
  bool _internal_rank_candidates() const;
  void _internal_set_rank_candidates(bool value);
  public:

  // optional double time = 20 [default = -1];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge > path_edges_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge > filtered_edges_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr street_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postal_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_time_;
  ::valhalla::LatLng* ll_;
  ::valhalla::LatLng* projected_ll_;
  ::valhalla::LatLng* display_ll_;
  ::valhalla::Location_SearchFilter* search_filter_;
  int type_;
  uint32_t heading_;
  int side_of_street_;
  uint32_t heading_tolerance_;
  uint64_t way_id_;
  uint32_t node_snap_tolerance_;
  uint32_t minimum_reachability_;
  uint32_t radius_;
  uint32_t accuracy_;
  uint32_t original_index_;
  int preferred_side_;
  uint32_t search_cutoff_;
  uint32_t street_side_tolerance_;
  uint32_t route_index_;
  uint32_t waypoint_index_;
  uint32_t street_side_max_distance_;
  int32_t preferred_layer_;
  double distance_from_leg_origin_;
  uint32_t leg_shape_index_;
  bool rank_candidates_;
  double time_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class TransitEgressInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitEgressInfo) */ {
 public:
  inline TransitEgressInfo() : TransitEgressInfo(nullptr) {}
  ~TransitEgressInfo() override;
  explicit constexpr TransitEgressInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransitEgressInfo(const TransitEgressInfo& from);
  TransitEgressInfo(TransitEgressInfo&& from) noexcept
    : TransitEgressInfo() {
    *this = ::std::move(from);
  }

  inline TransitEgressInfo& operator=(const TransitEgressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitEgressInfo& operator=(TransitEgressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitEgressInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitEgressInfo* internal_default_instance() {
    return reinterpret_cast<const TransitEgressInfo*>(
               &_TransitEgressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TransitEgressInfo& a, TransitEgressInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitEgressInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitEgressInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitEgressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitEgressInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TransitEgressInfo& from);
  void MergeFrom(const TransitEgressInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransitEgressInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TransitEgressInfo";
  }
  protected:
  explicit TransitEgressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnestopIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLlFieldNumber = 3,
  };
  // optional string onestop_id = 1;
  bool has_onestop_id() const;
  private:
  bool _internal_has_onestop_id() const;
  public:
  void clear_onestop_id();
  const std::string& onestop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_onestop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* onestop_id);
  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(const std::string& value);
  std::string* _internal_mutable_onestop_id();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .valhalla.LatLng ll = 3;
  bool has_ll() const;
  private:
  bool _internal_has_ll() const;
  public:
  void clear_ll();
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* ll);
  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();
  public:
  void unsafe_arena_set_allocated_ll(
      ::valhalla::LatLng* ll);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  // @@protoc_insertion_point(class_scope:valhalla.TransitEgressInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onestop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::valhalla::LatLng* ll_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class TransitStationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitStationInfo) */ {
 public:
  inline TransitStationInfo() : TransitStationInfo(nullptr) {}
  ~TransitStationInfo() override;
  explicit constexpr TransitStationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransitStationInfo(const TransitStationInfo& from);
  TransitStationInfo(TransitStationInfo&& from) noexcept
    : TransitStationInfo() {
    *this = ::std::move(from);
  }

  inline TransitStationInfo& operator=(const TransitStationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitStationInfo& operator=(TransitStationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitStationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitStationInfo* internal_default_instance() {
    return reinterpret_cast<const TransitStationInfo*>(
               &_TransitStationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TransitStationInfo& a, TransitStationInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitStationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitStationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitStationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitStationInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TransitStationInfo& from);
  void MergeFrom(const TransitStationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransitStationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TransitStationInfo";
  }
  protected:
  explicit TransitStationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnestopIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLlFieldNumber = 3,
  };
  // optional string onestop_id = 1;
  bool has_onestop_id() const;
  private:
  bool _internal_has_onestop_id() const;
  public:
  void clear_onestop_id();
  const std::string& onestop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_onestop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* onestop_id);
  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(const std::string& value);
  std::string* _internal_mutable_onestop_id();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .valhalla.LatLng ll = 3;
  bool has_ll() const;
  private:
  bool _internal_has_ll() const;
  public:
  void clear_ll();
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* ll);
  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();
  public:
  void unsafe_arena_set_allocated_ll(
      ::valhalla::LatLng* ll);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  // @@protoc_insertion_point(class_scope:valhalla.TransitStationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onestop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::valhalla::LatLng* ll_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class TransitPlatformInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TransitPlatformInfo) */ {
 public:
  inline TransitPlatformInfo() : TransitPlatformInfo(nullptr) {}
  ~TransitPlatformInfo() override;
  explicit constexpr TransitPlatformInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransitPlatformInfo(const TransitPlatformInfo& from);
  TransitPlatformInfo(TransitPlatformInfo&& from) noexcept
    : TransitPlatformInfo() {
    *this = ::std::move(from);
  }

  inline TransitPlatformInfo& operator=(const TransitPlatformInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransitPlatformInfo& operator=(TransitPlatformInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TransitPlatformInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransitPlatformInfo* internal_default_instance() {
    return reinterpret_cast<const TransitPlatformInfo*>(
               &_TransitPlatformInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransitPlatformInfo& a, TransitPlatformInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransitPlatformInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransitPlatformInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransitPlatformInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransitPlatformInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TransitPlatformInfo& from);
  void MergeFrom(const TransitPlatformInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TransitPlatformInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TransitPlatformInfo";
  }
  protected:
  explicit TransitPlatformInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TransitPlatformInfo_Type Type;
  static constexpr Type kStop =
    TransitPlatformInfo_Type_kStop;
  static constexpr Type kStation =
    TransitPlatformInfo_Type_kStation;
  static inline bool Type_IsValid(int value) {
    return TransitPlatformInfo_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TransitPlatformInfo_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TransitPlatformInfo_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TransitPlatformInfo_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TransitPlatformInfo_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TransitPlatformInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOnestopIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kArrivalDateTimeFieldNumber = 4,
    kDepartureDateTimeFieldNumber = 5,
    kStationOnestopIdFieldNumber = 8,
    kStationNameFieldNumber = 9,
    kLlFieldNumber = 7,
    kTypeFieldNumber = 1,
    kAssumedScheduleFieldNumber = 6,
  };
  // optional string onestop_id = 2;
  bool has_onestop_id() const;
  private:
  bool _internal_has_onestop_id() const;
  public:
  void clear_onestop_id();
  const std::string& onestop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_onestop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_onestop_id();
  PROTOBUF_NODISCARD std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* onestop_id);
  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(const std::string& value);
  std::string* _internal_mutable_onestop_id();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string arrival_date_time = 4;
  bool has_arrival_date_time() const;
  private:
  bool _internal_has_arrival_date_time() const;
  public:
  void clear_arrival_date_time();
  const std::string& arrival_date_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arrival_date_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arrival_date_time();
  PROTOBUF_NODISCARD std::string* release_arrival_date_time();
  void set_allocated_arrival_date_time(std::string* arrival_date_time);
  private:
  const std::string& _internal_arrival_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrival_date_time(const std::string& value);
  std::string* _internal_mutable_arrival_date_time();
  public:

  // optional string departure_date_time = 5;
  bool has_departure_date_time() const;
  private:
  bool _internal_has_departure_date_time() const;
  public:
  void clear_departure_date_time();
  const std::string& departure_date_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_departure_date_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_departure_date_time();
  PROTOBUF_NODISCARD std::string* release_departure_date_time();
  void set_allocated_departure_date_time(std::string* departure_date_time);
  private:
  const std::string& _internal_departure_date_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_departure_date_time(const std::string& value);
  std::string* _internal_mutable_departure_date_time();
  public:

  // optional string station_onestop_id = 8;
  bool has_station_onestop_id() const;
  private:
  bool _internal_has_station_onestop_id() const;
  public:
  void clear_station_onestop_id();
  const std::string& station_onestop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_onestop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_onestop_id();
  PROTOBUF_NODISCARD std::string* release_station_onestop_id();
  void set_allocated_station_onestop_id(std::string* station_onestop_id);
  private:
  const std::string& _internal_station_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_onestop_id(const std::string& value);
  std::string* _internal_mutable_station_onestop_id();
  public:

  // optional string station_name = 9;
  bool has_station_name() const;
  private:
  bool _internal_has_station_name() const;
  public:
  void clear_station_name();
  const std::string& station_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_name();
  PROTOBUF_NODISCARD std::string* release_station_name();
  void set_allocated_station_name(std::string* station_name);
  private:
  const std::string& _internal_station_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_name(const std::string& value);
  std::string* _internal_mutable_station_name();
  public:

  // optional .valhalla.LatLng ll = 7;
  bool has_ll() const;
  private:
  bool _internal_has_ll() const;
  public:
  void clear_ll();
  const ::valhalla::LatLng& ll() const;
  PROTOBUF_NODISCARD ::valhalla::LatLng* release_ll();
  ::valhalla::LatLng* mutable_ll();
  void set_allocated_ll(::valhalla::LatLng* ll);
  private:
  const ::valhalla::LatLng& _internal_ll() const;
  ::valhalla::LatLng* _internal_mutable_ll();
  public:
  void unsafe_arena_set_allocated_ll(
      ::valhalla::LatLng* ll);
  ::valhalla::LatLng* unsafe_arena_release_ll();

  // optional .valhalla.TransitPlatformInfo.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::TransitPlatformInfo_Type type() const;
  void set_type(::valhalla::TransitPlatformInfo_Type value);
  private:
  ::valhalla::TransitPlatformInfo_Type _internal_type() const;
  void _internal_set_type(::valhalla::TransitPlatformInfo_Type value);
  public:

  // optional bool assumed_schedule = 6;
  bool has_assumed_schedule() const;
  private:
  bool _internal_has_assumed_schedule() const;
  public:
  void clear_assumed_schedule();
  bool assumed_schedule() const;
  void set_assumed_schedule(bool value);
  private:
  bool _internal_assumed_schedule() const;
  void _internal_set_assumed_schedule(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TransitPlatformInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onestop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arrival_date_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr departure_date_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_onestop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_name_;
  ::valhalla::LatLng* ll_;
  int type_;
  bool assumed_schedule_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class StreetName final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.StreetName) */ {
 public:
  inline StreetName() : StreetName(nullptr) {}
  ~StreetName() override;
  explicit constexpr StreetName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreetName(const StreetName& from);
  StreetName(StreetName&& from) noexcept
    : StreetName() {
    *this = ::std::move(from);
  }

  inline StreetName& operator=(const StreetName& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreetName& operator=(StreetName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StreetName& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreetName* internal_default_instance() {
    return reinterpret_cast<const StreetName*>(
               &_StreetName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StreetName& a, StreetName& b) {
    a.Swap(&b);
  }
  inline void Swap(StreetName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreetName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreetName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreetName>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreetName& from);
  void MergeFrom(const StreetName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreetName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.StreetName";
  }
  protected:
  explicit StreetName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kIsRouteNumberFieldNumber = 2,
  };
  // optional string value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional bool is_route_number = 2;
  bool has_is_route_number() const;
  private:
  bool _internal_has_is_route_number() const;
  public:
  void clear_is_route_number();
  bool is_route_number() const;
  void set_is_route_number(bool value);
  private:
  bool _internal_is_route_number() const;
  void _internal_set_is_route_number(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.StreetName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  bool is_route_number_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class TurnLane final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TurnLane) */ {
 public:
  inline TurnLane() : TurnLane(nullptr) {}
  ~TurnLane() override;
  explicit constexpr TurnLane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TurnLane(const TurnLane& from);
  TurnLane(TurnLane&& from) noexcept
    : TurnLane() {
    *this = ::std::move(from);
  }

  inline TurnLane& operator=(const TurnLane& from) {
    CopyFrom(from);
    return *this;
  }
  inline TurnLane& operator=(TurnLane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TurnLane& default_instance() {
    return *internal_default_instance();
  }
  static inline const TurnLane* internal_default_instance() {
    return reinterpret_cast<const TurnLane*>(
               &_TurnLane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TurnLane& a, TurnLane& b) {
    a.Swap(&b);
  }
  inline void Swap(TurnLane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TurnLane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TurnLane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TurnLane>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TurnLane& from);
  void MergeFrom(const TurnLane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TurnLane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TurnLane";
  }
  protected:
  explicit TurnLane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TurnLane_State State;
  static constexpr State kInvalid =
    TurnLane_State_kInvalid;
  static constexpr State kValid =
    TurnLane_State_kValid;
  static constexpr State kActive =
    TurnLane_State_kActive;
  static inline bool State_IsValid(int value) {
    return TurnLane_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TurnLane_State_State_MIN;
  static constexpr State State_MAX =
    TurnLane_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TurnLane_State_State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TurnLane_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TurnLane_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionsMaskFieldNumber = 1,
    kStateFieldNumber = 2,
    kActiveDirectionFieldNumber = 3,
  };
  // optional uint32 directions_mask = 1;
  bool has_directions_mask() const;
  private:
  bool _internal_has_directions_mask() const;
  public:
  void clear_directions_mask();
  uint32_t directions_mask() const;
  void set_directions_mask(uint32_t value);
  private:
  uint32_t _internal_directions_mask() const;
  void _internal_set_directions_mask(uint32_t value);
  public:

  // optional .valhalla.TurnLane.State state = 2 [default = kInvalid];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::valhalla::TurnLane_State state() const;
  void set_state(::valhalla::TurnLane_State value);
  private:
  ::valhalla::TurnLane_State _internal_state() const;
  void _internal_set_state(::valhalla::TurnLane_State value);
  public:

  // optional uint32 active_direction = 3;
  bool has_active_direction() const;
  private:
  bool _internal_has_active_direction() const;
  public:
  void clear_active_direction();
  uint32_t active_direction() const;
  void set_active_direction(uint32_t value);
  private:
  uint32_t _internal_active_direction() const;
  void _internal_set_active_direction(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TurnLane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t directions_mask_;
  int state_;
  uint32_t active_direction_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// -------------------------------------------------------------------

class TaggedValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.TaggedValue) */ {
 public:
  inline TaggedValue() : TaggedValue(nullptr) {}
  ~TaggedValue() override;
  explicit constexpr TaggedValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaggedValue(const TaggedValue& from);
  TaggedValue(TaggedValue&& from) noexcept
    : TaggedValue() {
    *this = ::std::move(from);
  }

  inline TaggedValue& operator=(const TaggedValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaggedValue& operator=(TaggedValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TaggedValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaggedValue* internal_default_instance() {
    return reinterpret_cast<const TaggedValue*>(
               &_TaggedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TaggedValue& a, TaggedValue& b) {
    a.Swap(&b);
  }
  inline void Swap(TaggedValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaggedValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaggedValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaggedValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TaggedValue& from);
  void MergeFrom(const TaggedValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaggedValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.TaggedValue";
  }
  protected:
  explicit TaggedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TaggedValue_Type Type;
  static constexpr Type kLayer =
    TaggedValue_Type_kLayer;
  static constexpr Type kTunnel =
    TaggedValue_Type_kTunnel;
  static constexpr Type kBridge =
    TaggedValue_Type_kBridge;
  static inline bool Type_IsValid(int value) {
    return TaggedValue_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TaggedValue_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TaggedValue_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TaggedValue_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TaggedValue_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TaggedValue_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .valhalla.TaggedValue.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::TaggedValue_Type type() const;
  void set_type(::valhalla::TaggedValue_Type value);
  private:
  ::valhalla::TaggedValue_Type _internal_type() const;
  void _internal_set_type(::valhalla::TaggedValue_Type value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.TaggedValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int type_;
  friend struct ::TableStruct_tripcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LatLng

// optional double lat = 1;
inline bool LatLng::_internal_has_lat() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LatLng::has_lat() const {
  return _internal_has_lat();
}
inline void LatLng::clear_lat() {
  lat_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double LatLng::_internal_lat() const {
  return lat_;
}
inline double LatLng::lat() const {
  // @@protoc_insertion_point(field_get:valhalla.LatLng.lat)
  return _internal_lat();
}
inline void LatLng::_internal_set_lat(double value) {
  _has_bits_[0] |= 0x00000001u;
  lat_ = value;
}
inline void LatLng::set_lat(double value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:valhalla.LatLng.lat)
}

// optional double lng = 2;
inline bool LatLng::_internal_has_lng() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LatLng::has_lng() const {
  return _internal_has_lng();
}
inline void LatLng::clear_lng() {
  lng_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LatLng::_internal_lng() const {
  return lng_;
}
inline double LatLng::lng() const {
  // @@protoc_insertion_point(field_get:valhalla.LatLng.lng)
  return _internal_lng();
}
inline void LatLng::_internal_set_lng(double value) {
  _has_bits_[0] |= 0x00000002u;
  lng_ = value;
}
inline void LatLng::set_lng(double value) {
  _internal_set_lng(value);
  // @@protoc_insertion_point(field_set:valhalla.LatLng.lng)
}

// -------------------------------------------------------------------

// BoundingBox

// optional .valhalla.LatLng min_ll = 1;
inline bool BoundingBox::_internal_has_min_ll() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || min_ll_ != nullptr);
  return value;
}
inline bool BoundingBox::has_min_ll() const {
  return _internal_has_min_ll();
}
inline void BoundingBox::clear_min_ll() {
  if (min_ll_ != nullptr) min_ll_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& BoundingBox::_internal_min_ll() const {
  const ::valhalla::LatLng* p = min_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& BoundingBox::min_ll() const {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.min_ll)
  return _internal_min_ll();
}
inline void BoundingBox::unsafe_arena_set_allocated_min_ll(
    ::valhalla::LatLng* min_ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_ll_);
  }
  min_ll_ = min_ll;
  if (min_ll) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.BoundingBox.min_ll)
}
inline ::valhalla::LatLng* BoundingBox::release_min_ll() {
  _has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = min_ll_;
  min_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* BoundingBox::unsafe_arena_release_min_ll() {
  // @@protoc_insertion_point(field_release:valhalla.BoundingBox.min_ll)
  _has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = min_ll_;
  min_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* BoundingBox::_internal_mutable_min_ll() {
  _has_bits_[0] |= 0x00000001u;
  if (min_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    min_ll_ = p;
  }
  return min_ll_;
}
inline ::valhalla::LatLng* BoundingBox::mutable_min_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_min_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.BoundingBox.min_ll)
  return _msg;
}
inline void BoundingBox::set_allocated_min_ll(::valhalla::LatLng* min_ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete min_ll_;
  }
  if (min_ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(min_ll);
    if (message_arena != submessage_arena) {
      min_ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  min_ll_ = min_ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.BoundingBox.min_ll)
}

// optional .valhalla.LatLng max_ll = 2;
inline bool BoundingBox::_internal_has_max_ll() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || max_ll_ != nullptr);
  return value;
}
inline bool BoundingBox::has_max_ll() const {
  return _internal_has_max_ll();
}
inline void BoundingBox::clear_max_ll() {
  if (max_ll_ != nullptr) max_ll_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::valhalla::LatLng& BoundingBox::_internal_max_ll() const {
  const ::valhalla::LatLng* p = max_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& BoundingBox::max_ll() const {
  // @@protoc_insertion_point(field_get:valhalla.BoundingBox.max_ll)
  return _internal_max_ll();
}
inline void BoundingBox::unsafe_arena_set_allocated_max_ll(
    ::valhalla::LatLng* max_ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max_ll_);
  }
  max_ll_ = max_ll;
  if (max_ll) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.BoundingBox.max_ll)
}
inline ::valhalla::LatLng* BoundingBox::release_max_ll() {
  _has_bits_[0] &= ~0x00000002u;
  ::valhalla::LatLng* temp = max_ll_;
  max_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* BoundingBox::unsafe_arena_release_max_ll() {
  // @@protoc_insertion_point(field_release:valhalla.BoundingBox.max_ll)
  _has_bits_[0] &= ~0x00000002u;
  ::valhalla::LatLng* temp = max_ll_;
  max_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* BoundingBox::_internal_mutable_max_ll() {
  _has_bits_[0] |= 0x00000002u;
  if (max_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    max_ll_ = p;
  }
  return max_ll_;
}
inline ::valhalla::LatLng* BoundingBox::mutable_max_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_max_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.BoundingBox.max_ll)
  return _msg;
}
inline void BoundingBox::set_allocated_max_ll(::valhalla::LatLng* max_ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete max_ll_;
  }
  if (max_ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(max_ll);
    if (message_arena != submessage_arena) {
      max_ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max_ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  max_ll_ = max_ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.BoundingBox.max_ll)
}

// -------------------------------------------------------------------

// Location_PathEdge

// optional uint64 graph_id = 1;
inline bool Location_PathEdge::_internal_has_graph_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Location_PathEdge::has_graph_id() const {
  return _internal_has_graph_id();
}
inline void Location_PathEdge::clear_graph_id() {
  graph_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Location_PathEdge::_internal_graph_id() const {
  return graph_id_;
}
inline uint64_t Location_PathEdge::graph_id() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.graph_id)
  return _internal_graph_id();
}
inline void Location_PathEdge::_internal_set_graph_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  graph_id_ = value;
}
inline void Location_PathEdge::set_graph_id(uint64_t value) {
  _internal_set_graph_id(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.graph_id)
}

// optional double percent_along = 2;
inline bool Location_PathEdge::_internal_has_percent_along() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Location_PathEdge::has_percent_along() const {
  return _internal_has_percent_along();
}
inline void Location_PathEdge::clear_percent_along() {
  percent_along_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double Location_PathEdge::_internal_percent_along() const {
  return percent_along_;
}
inline double Location_PathEdge::percent_along() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.percent_along)
  return _internal_percent_along();
}
inline void Location_PathEdge::_internal_set_percent_along(double value) {
  _has_bits_[0] |= 0x00000004u;
  percent_along_ = value;
}
inline void Location_PathEdge::set_percent_along(double value) {
  _internal_set_percent_along(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.percent_along)
}

// optional .valhalla.LatLng ll = 3;
inline bool Location_PathEdge::_internal_has_ll() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ll_ != nullptr);
  return value;
}
inline bool Location_PathEdge::has_ll() const {
  return _internal_has_ll();
}
inline void Location_PathEdge::clear_ll() {
  if (ll_ != nullptr) ll_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::valhalla::LatLng& Location_PathEdge::_internal_ll() const {
  const ::valhalla::LatLng* p = ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Location_PathEdge::ll() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.ll)
  return _internal_ll();
}
inline void Location_PathEdge::unsafe_arena_set_allocated_ll(
    ::valhalla::LatLng* ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ll_);
  }
  ll_ = ll;
  if (ll) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.PathEdge.ll)
}
inline ::valhalla::LatLng* Location_PathEdge::release_ll() {
  _has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* Location_PathEdge::unsafe_arena_release_ll() {
  // @@protoc_insertion_point(field_release:valhalla.Location.PathEdge.ll)
  _has_bits_[0] &= ~0x00000001u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Location_PathEdge::_internal_mutable_ll() {
  _has_bits_[0] |= 0x00000001u;
  if (ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    ll_ = p;
  }
  return ll_;
}
inline ::valhalla::LatLng* Location_PathEdge::mutable_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.PathEdge.ll)
  return _msg;
}
inline void Location_PathEdge::set_allocated_ll(::valhalla::LatLng* ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ll_;
  }
  if (ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(ll);
    if (message_arena != submessage_arena) {
      ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ll_ = ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.PathEdge.ll)
}

// optional .valhalla.Location.SideOfStreet side_of_street = 4;
inline bool Location_PathEdge::_internal_has_side_of_street() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Location_PathEdge::has_side_of_street() const {
  return _internal_has_side_of_street();
}
inline void Location_PathEdge::clear_side_of_street() {
  side_of_street_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::valhalla::Location_SideOfStreet Location_PathEdge::_internal_side_of_street() const {
  return static_cast< ::valhalla::Location_SideOfStreet >(side_of_street_);
}
inline ::valhalla::Location_SideOfStreet Location_PathEdge::side_of_street() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.side_of_street)
  return _internal_side_of_street();
}
inline void Location_PathEdge::_internal_set_side_of_street(::valhalla::Location_SideOfStreet value) {
  assert(::valhalla::Location_SideOfStreet_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  side_of_street_ = value;
}
inline void Location_PathEdge::set_side_of_street(::valhalla::Location_SideOfStreet value) {
  _internal_set_side_of_street(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.side_of_street)
}

// optional double distance = 5;
inline bool Location_PathEdge::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Location_PathEdge::has_distance() const {
  return _internal_has_distance();
}
inline void Location_PathEdge::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double Location_PathEdge::_internal_distance() const {
  return distance_;
}
inline double Location_PathEdge::distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.distance)
  return _internal_distance();
}
inline void Location_PathEdge::_internal_set_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  distance_ = value;
}
inline void Location_PathEdge::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.distance)
}

// optional int32 minimum_reachability = 6;
inline bool Location_PathEdge::_internal_has_minimum_reachability() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Location_PathEdge::has_minimum_reachability() const {
  return _internal_has_minimum_reachability();
}
inline void Location_PathEdge::clear_minimum_reachability() {
  minimum_reachability_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t Location_PathEdge::_internal_minimum_reachability() const {
  return minimum_reachability_;
}
inline int32_t Location_PathEdge::minimum_reachability() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.minimum_reachability)
  return _internal_minimum_reachability();
}
inline void Location_PathEdge::_internal_set_minimum_reachability(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  minimum_reachability_ = value;
}
inline void Location_PathEdge::set_minimum_reachability(int32_t value) {
  _internal_set_minimum_reachability(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.minimum_reachability)
}

// optional bool begin_node = 7;
inline bool Location_PathEdge::_internal_has_begin_node() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Location_PathEdge::has_begin_node() const {
  return _internal_has_begin_node();
}
inline void Location_PathEdge::clear_begin_node() {
  begin_node_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Location_PathEdge::_internal_begin_node() const {
  return begin_node_;
}
inline bool Location_PathEdge::begin_node() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.begin_node)
  return _internal_begin_node();
}
inline void Location_PathEdge::_internal_set_begin_node(bool value) {
  _has_bits_[0] |= 0x00000040u;
  begin_node_ = value;
}
inline void Location_PathEdge::set_begin_node(bool value) {
  _internal_set_begin_node(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.begin_node)
}

// optional bool end_node = 8;
inline bool Location_PathEdge::_internal_has_end_node() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Location_PathEdge::has_end_node() const {
  return _internal_has_end_node();
}
inline void Location_PathEdge::clear_end_node() {
  end_node_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Location_PathEdge::_internal_end_node() const {
  return end_node_;
}
inline bool Location_PathEdge::end_node() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.end_node)
  return _internal_end_node();
}
inline void Location_PathEdge::_internal_set_end_node(bool value) {
  _has_bits_[0] |= 0x00000080u;
  end_node_ = value;
}
inline void Location_PathEdge::set_end_node(bool value) {
  _internal_set_end_node(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.end_node)
}

// repeated string names = 10;
inline int Location_PathEdge::_internal_names_size() const {
  return names_.size();
}
inline int Location_PathEdge::names_size() const {
  return _internal_names_size();
}
inline void Location_PathEdge::clear_names() {
  names_.Clear();
}
inline std::string* Location_PathEdge::add_names() {
  std::string* _s = _internal_add_names();
  // @@protoc_insertion_point(field_add_mutable:valhalla.Location.PathEdge.names)
  return _s;
}
inline const std::string& Location_PathEdge::_internal_names(int index) const {
  return names_.Get(index);
}
inline const std::string& Location_PathEdge::names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.names)
  return _internal_names(index);
}
inline std::string* Location_PathEdge::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Location.PathEdge.names)
  return names_.Mutable(index);
}
inline void Location_PathEdge::set_names(int index, const std::string& value) {
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.names)
}
inline void Location_PathEdge::set_names(int index, std::string&& value) {
  names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.names)
}
inline void Location_PathEdge::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.Location.PathEdge.names)
}
inline void Location_PathEdge::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.Location.PathEdge.names)
}
inline std::string* Location_PathEdge::_internal_add_names() {
  return names_.Add();
}
inline void Location_PathEdge::add_names(const std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.Location.PathEdge.names)
}
inline void Location_PathEdge::add_names(std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.Location.PathEdge.names)
}
inline void Location_PathEdge::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.Location.PathEdge.names)
}
inline void Location_PathEdge::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.Location.PathEdge.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Location_PathEdge::names() const {
  // @@protoc_insertion_point(field_list:valhalla.Location.PathEdge.names)
  return names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Location_PathEdge::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Location.PathEdge.names)
  return &names_;
}

// optional int32 outbound_reach = 11;
inline bool Location_PathEdge::_internal_has_outbound_reach() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Location_PathEdge::has_outbound_reach() const {
  return _internal_has_outbound_reach();
}
inline void Location_PathEdge::clear_outbound_reach() {
  outbound_reach_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t Location_PathEdge::_internal_outbound_reach() const {
  return outbound_reach_;
}
inline int32_t Location_PathEdge::outbound_reach() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.outbound_reach)
  return _internal_outbound_reach();
}
inline void Location_PathEdge::_internal_set_outbound_reach(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  outbound_reach_ = value;
}
inline void Location_PathEdge::set_outbound_reach(int32_t value) {
  _internal_set_outbound_reach(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.outbound_reach)
}

// optional int32 inbound_reach = 12;
inline bool Location_PathEdge::_internal_has_inbound_reach() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Location_PathEdge::has_inbound_reach() const {
  return _internal_has_inbound_reach();
}
inline void Location_PathEdge::clear_inbound_reach() {
  inbound_reach_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t Location_PathEdge::_internal_inbound_reach() const {
  return inbound_reach_;
}
inline int32_t Location_PathEdge::inbound_reach() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.PathEdge.inbound_reach)
  return _internal_inbound_reach();
}
inline void Location_PathEdge::_internal_set_inbound_reach(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  inbound_reach_ = value;
}
inline void Location_PathEdge::set_inbound_reach(int32_t value) {
  _internal_set_inbound_reach(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.PathEdge.inbound_reach)
}

// -------------------------------------------------------------------

// Location_SearchFilter

// optional .valhalla.RoadClass min_road_class = 1 [default = kServiceOther];
inline bool Location_SearchFilter::_internal_has_min_road_class() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Location_SearchFilter::has_min_road_class() const {
  return _internal_has_min_road_class();
}
inline void Location_SearchFilter::clear_min_road_class() {
  min_road_class_ = 7;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::valhalla::RoadClass Location_SearchFilter::_internal_min_road_class() const {
  return static_cast< ::valhalla::RoadClass >(min_road_class_);
}
inline ::valhalla::RoadClass Location_SearchFilter::min_road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.SearchFilter.min_road_class)
  return _internal_min_road_class();
}
inline void Location_SearchFilter::_internal_set_min_road_class(::valhalla::RoadClass value) {
  assert(::valhalla::RoadClass_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  min_road_class_ = value;
}
inline void Location_SearchFilter::set_min_road_class(::valhalla::RoadClass value) {
  _internal_set_min_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.SearchFilter.min_road_class)
}

// optional .valhalla.RoadClass max_road_class = 2 [default = kMotorway];
inline bool Location_SearchFilter::_internal_has_max_road_class() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Location_SearchFilter::has_max_road_class() const {
  return _internal_has_max_road_class();
}
inline void Location_SearchFilter::clear_max_road_class() {
  max_road_class_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::valhalla::RoadClass Location_SearchFilter::_internal_max_road_class() const {
  return static_cast< ::valhalla::RoadClass >(max_road_class_);
}
inline ::valhalla::RoadClass Location_SearchFilter::max_road_class() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.SearchFilter.max_road_class)
  return _internal_max_road_class();
}
inline void Location_SearchFilter::_internal_set_max_road_class(::valhalla::RoadClass value) {
  assert(::valhalla::RoadClass_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  max_road_class_ = value;
}
inline void Location_SearchFilter::set_max_road_class(::valhalla::RoadClass value) {
  _internal_set_max_road_class(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.SearchFilter.max_road_class)
}

// optional bool exclude_tunnel = 3;
inline bool Location_SearchFilter::_internal_has_exclude_tunnel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Location_SearchFilter::has_exclude_tunnel() const {
  return _internal_has_exclude_tunnel();
}
inline void Location_SearchFilter::clear_exclude_tunnel() {
  exclude_tunnel_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Location_SearchFilter::_internal_exclude_tunnel() const {
  return exclude_tunnel_;
}
inline bool Location_SearchFilter::exclude_tunnel() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.SearchFilter.exclude_tunnel)
  return _internal_exclude_tunnel();
}
inline void Location_SearchFilter::_internal_set_exclude_tunnel(bool value) {
  _has_bits_[0] |= 0x00000002u;
  exclude_tunnel_ = value;
}
inline void Location_SearchFilter::set_exclude_tunnel(bool value) {
  _internal_set_exclude_tunnel(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.SearchFilter.exclude_tunnel)
}

// optional bool exclude_bridge = 4;
inline bool Location_SearchFilter::_internal_has_exclude_bridge() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Location_SearchFilter::has_exclude_bridge() const {
  return _internal_has_exclude_bridge();
}
inline void Location_SearchFilter::clear_exclude_bridge() {
  exclude_bridge_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Location_SearchFilter::_internal_exclude_bridge() const {
  return exclude_bridge_;
}
inline bool Location_SearchFilter::exclude_bridge() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.SearchFilter.exclude_bridge)
  return _internal_exclude_bridge();
}
inline void Location_SearchFilter::_internal_set_exclude_bridge(bool value) {
  _has_bits_[0] |= 0x00000004u;
  exclude_bridge_ = value;
}
inline void Location_SearchFilter::set_exclude_bridge(bool value) {
  _internal_set_exclude_bridge(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.SearchFilter.exclude_bridge)
}

// optional bool exclude_ramp = 5;
inline bool Location_SearchFilter::_internal_has_exclude_ramp() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Location_SearchFilter::has_exclude_ramp() const {
  return _internal_has_exclude_ramp();
}
inline void Location_SearchFilter::clear_exclude_ramp() {
  exclude_ramp_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Location_SearchFilter::_internal_exclude_ramp() const {
  return exclude_ramp_;
}
inline bool Location_SearchFilter::exclude_ramp() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.SearchFilter.exclude_ramp)
  return _internal_exclude_ramp();
}
inline void Location_SearchFilter::_internal_set_exclude_ramp(bool value) {
  _has_bits_[0] |= 0x00000008u;
  exclude_ramp_ = value;
}
inline void Location_SearchFilter::set_exclude_ramp(bool value) {
  _internal_set_exclude_ramp(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.SearchFilter.exclude_ramp)
}

// optional bool exclude_closures = 6 [default = true];
inline bool Location_SearchFilter::_internal_has_exclude_closures() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Location_SearchFilter::has_exclude_closures() const {
  return _internal_has_exclude_closures();
}
inline void Location_SearchFilter::clear_exclude_closures() {
  exclude_closures_ = true;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Location_SearchFilter::_internal_exclude_closures() const {
  return exclude_closures_;
}
inline bool Location_SearchFilter::exclude_closures() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.SearchFilter.exclude_closures)
  return _internal_exclude_closures();
}
inline void Location_SearchFilter::_internal_set_exclude_closures(bool value) {
  _has_bits_[0] |= 0x00000020u;
  exclude_closures_ = value;
}
inline void Location_SearchFilter::set_exclude_closures(bool value) {
  _internal_set_exclude_closures(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.SearchFilter.exclude_closures)
}

// -------------------------------------------------------------------

// Location

// optional .valhalla.LatLng ll = 1;
inline bool Location::_internal_has_ll() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || ll_ != nullptr);
  return value;
}
inline bool Location::has_ll() const {
  return _internal_has_ll();
}
inline void Location::clear_ll() {
  if (ll_ != nullptr) ll_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::valhalla::LatLng& Location::_internal_ll() const {
  const ::valhalla::LatLng* p = ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Location::ll() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.ll)
  return _internal_ll();
}
inline void Location::unsafe_arena_set_allocated_ll(
    ::valhalla::LatLng* ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ll_);
  }
  ll_ = ll;
  if (ll) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.ll)
}
inline ::valhalla::LatLng* Location::release_ll() {
  _has_bits_[0] &= ~0x00000200u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* Location::unsafe_arena_release_ll() {
  // @@protoc_insertion_point(field_release:valhalla.Location.ll)
  _has_bits_[0] &= ~0x00000200u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Location::_internal_mutable_ll() {
  _has_bits_[0] |= 0x00000200u;
  if (ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    ll_ = p;
  }
  return ll_;
}
inline ::valhalla::LatLng* Location::mutable_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.ll)
  return _msg;
}
inline void Location::set_allocated_ll(::valhalla::LatLng* ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ll_;
  }
  if (ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(ll);
    if (message_arena != submessage_arena) {
      ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  ll_ = ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.ll)
}

// optional .valhalla.Location.Type type = 2 [default = kBreak];
inline bool Location::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Location::has_type() const {
  return _internal_has_type();
}
inline void Location::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::valhalla::Location_Type Location::_internal_type() const {
  return static_cast< ::valhalla::Location_Type >(type_);
}
inline ::valhalla::Location_Type Location::type() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.type)
  return _internal_type();
}
inline void Location::_internal_set_type(::valhalla::Location_Type value) {
  assert(::valhalla::Location_Type_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  type_ = value;
}
inline void Location::set_type(::valhalla::Location_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.type)
}

// optional uint32 heading = 3;
inline bool Location::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Location::has_heading() const {
  return _internal_has_heading();
}
inline void Location::clear_heading() {
  heading_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline uint32_t Location::_internal_heading() const {
  return heading_;
}
inline uint32_t Location::heading() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.heading)
  return _internal_heading();
}
inline void Location::_internal_set_heading(uint32_t value) {
  _has_bits_[0] |= 0x00004000u;
  heading_ = value;
}
inline void Location::set_heading(uint32_t value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.heading)
}

// optional string name = 4;
inline bool Location::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Location::has_name() const {
  return _internal_has_name();
}
inline void Location::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Location::name() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.name)
}
inline std::string* Location::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.name)
  return _s;
}
inline const std::string& Location::_internal_name() const {
  return name_.Get();
}
inline void Location::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.Location.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.name)
}

// optional string street = 5;
inline bool Location::_internal_has_street() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Location::has_street() const {
  return _internal_has_street();
}
inline void Location::clear_street() {
  street_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Location::street() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.street)
  return _internal_street();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_street(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 street_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.street)
}
inline std::string* Location::mutable_street() {
  std::string* _s = _internal_mutable_street();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.street)
  return _s;
}
inline const std::string& Location::_internal_street() const {
  return street_.Get();
}
inline void Location::_internal_set_street(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  street_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_street() {
  _has_bits_[0] |= 0x00000002u;
  return street_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_street() {
  // @@protoc_insertion_point(field_release:valhalla.Location.street)
  if (!_internal_has_street()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = street_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (street_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    street_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_street(std::string* street) {
  if (street != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  street_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), street,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (street_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    street_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.street)
}

// optional string city = 6;
inline bool Location::_internal_has_city() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Location::has_city() const {
  return _internal_has_city();
}
inline void Location::clear_city() {
  city_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Location::city() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_city(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.city)
}
inline std::string* Location::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.city)
  return _s;
}
inline const std::string& Location::_internal_city() const {
  return city_.Get();
}
inline void Location::_internal_set_city(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_city() {
  _has_bits_[0] |= 0x00000004u;
  return city_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_city() {
  // @@protoc_insertion_point(field_release:valhalla.Location.city)
  if (!_internal_has_city()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = city_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  city_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), city,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.city)
}

// optional string state = 7;
inline bool Location::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Location::has_state() const {
  return _internal_has_state();
}
inline void Location::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Location::state() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.state)
}
inline std::string* Location::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.state)
  return _s;
}
inline const std::string& Location::_internal_state() const {
  return state_.Get();
}
inline void Location::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000008u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_state() {
  // @@protoc_insertion_point(field_release:valhalla.Location.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.state)
}

// optional string postal_code = 8;
inline bool Location::_internal_has_postal_code() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Location::has_postal_code() const {
  return _internal_has_postal_code();
}
inline void Location::clear_postal_code() {
  postal_code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Location::postal_code() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.postal_code)
  return _internal_postal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_postal_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 postal_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.postal_code)
}
inline std::string* Location::mutable_postal_code() {
  std::string* _s = _internal_mutable_postal_code();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.postal_code)
  return _s;
}
inline const std::string& Location::_internal_postal_code() const {
  return postal_code_.Get();
}
inline void Location::_internal_set_postal_code(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  postal_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_postal_code() {
  _has_bits_[0] |= 0x00000010u;
  return postal_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_postal_code() {
  // @@protoc_insertion_point(field_release:valhalla.Location.postal_code)
  if (!_internal_has_postal_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = postal_code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (postal_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    postal_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_postal_code(std::string* postal_code) {
  if (postal_code != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  postal_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), postal_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (postal_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    postal_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.postal_code)
}

// optional string country = 9;
inline bool Location::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Location::has_country() const {
  return _internal_has_country();
}
inline void Location::clear_country() {
  country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Location::country() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.country)
}
inline std::string* Location::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.country)
  return _s;
}
inline const std::string& Location::_internal_country() const {
  return country_.Get();
}
inline void Location::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000020u;
  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_country() {
  // @@protoc_insertion_point(field_release:valhalla.Location.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.country)
}

// optional string phone = 10;
inline bool Location::_internal_has_phone() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Location::has_phone() const {
  return _internal_has_phone();
}
inline void Location::clear_phone() {
  phone_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Location::phone() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_phone(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 phone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.phone)
}
inline std::string* Location::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.phone)
  return _s;
}
inline const std::string& Location::_internal_phone() const {
  return phone_.Get();
}
inline void Location::_internal_set_phone(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  phone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_phone() {
  _has_bits_[0] |= 0x00000040u;
  return phone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_phone() {
  // @@protoc_insertion_point(field_release:valhalla.Location.phone)
  if (!_internal_has_phone()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = phone_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (phone_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    phone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  phone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (phone_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    phone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.phone)
}

// optional string url = 11;
inline bool Location::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Location::has_url() const {
  return _internal_has_url();
}
inline void Location::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Location::url() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.url)
}
inline std::string* Location::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.url)
  return _s;
}
inline const std::string& Location::_internal_url() const {
  return url_.Get();
}
inline void Location::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000080u;
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_url() {
  // @@protoc_insertion_point(field_release:valhalla.Location.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.url)
}

// optional string date_time = 12;
inline bool Location::_internal_has_date_time() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Location::has_date_time() const {
  return _internal_has_date_time();
}
inline void Location::clear_date_time() {
  date_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& Location::date_time() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.date_time)
  return _internal_date_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location::set_date_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.Location.date_time)
}
inline std::string* Location::mutable_date_time() {
  std::string* _s = _internal_mutable_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.date_time)
  return _s;
}
inline const std::string& Location::_internal_date_time() const {
  return date_time_.Get();
}
inline void Location::_internal_set_date_time(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location::_internal_mutable_date_time() {
  _has_bits_[0] |= 0x00000100u;
  return date_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location::release_date_time() {
  // @@protoc_insertion_point(field_release:valhalla.Location.date_time)
  if (!_internal_has_date_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = date_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Location::set_allocated_date_time(std::string* date_time) {
  if (date_time != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  date_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.date_time)
}

// optional .valhalla.Location.SideOfStreet side_of_street = 13;
inline bool Location::_internal_has_side_of_street() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Location::has_side_of_street() const {
  return _internal_has_side_of_street();
}
inline void Location::clear_side_of_street() {
  side_of_street_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::valhalla::Location_SideOfStreet Location::_internal_side_of_street() const {
  return static_cast< ::valhalla::Location_SideOfStreet >(side_of_street_);
}
inline ::valhalla::Location_SideOfStreet Location::side_of_street() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.side_of_street)
  return _internal_side_of_street();
}
inline void Location::_internal_set_side_of_street(::valhalla::Location_SideOfStreet value) {
  assert(::valhalla::Location_SideOfStreet_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  side_of_street_ = value;
}
inline void Location::set_side_of_street(::valhalla::Location_SideOfStreet value) {
  _internal_set_side_of_street(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.side_of_street)
}

// optional uint32 heading_tolerance = 14;
inline bool Location::_internal_has_heading_tolerance() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Location::has_heading_tolerance() const {
  return _internal_has_heading_tolerance();
}
inline void Location::clear_heading_tolerance() {
  heading_tolerance_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t Location::_internal_heading_tolerance() const {
  return heading_tolerance_;
}
inline uint32_t Location::heading_tolerance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.heading_tolerance)
  return _internal_heading_tolerance();
}
inline void Location::_internal_set_heading_tolerance(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  heading_tolerance_ = value;
}
inline void Location::set_heading_tolerance(uint32_t value) {
  _internal_set_heading_tolerance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.heading_tolerance)
}

// optional uint32 node_snap_tolerance = 15;
inline bool Location::_internal_has_node_snap_tolerance() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Location::has_node_snap_tolerance() const {
  return _internal_has_node_snap_tolerance();
}
inline void Location::clear_node_snap_tolerance() {
  node_snap_tolerance_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline uint32_t Location::_internal_node_snap_tolerance() const {
  return node_snap_tolerance_;
}
inline uint32_t Location::node_snap_tolerance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.node_snap_tolerance)
  return _internal_node_snap_tolerance();
}
inline void Location::_internal_set_node_snap_tolerance(uint32_t value) {
  _has_bits_[0] |= 0x00040000u;
  node_snap_tolerance_ = value;
}
inline void Location::set_node_snap_tolerance(uint32_t value) {
  _internal_set_node_snap_tolerance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.node_snap_tolerance)
}

// optional uint64 way_id = 16;
inline bool Location::_internal_has_way_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Location::has_way_id() const {
  return _internal_has_way_id();
}
inline void Location::clear_way_id() {
  way_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00020000u;
}
inline uint64_t Location::_internal_way_id() const {
  return way_id_;
}
inline uint64_t Location::way_id() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.way_id)
  return _internal_way_id();
}
inline void Location::_internal_set_way_id(uint64_t value) {
  _has_bits_[0] |= 0x00020000u;
  way_id_ = value;
}
inline void Location::set_way_id(uint64_t value) {
  _internal_set_way_id(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.way_id)
}

// optional uint32 minimum_reachability = 17;
inline bool Location::_internal_has_minimum_reachability() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Location::has_minimum_reachability() const {
  return _internal_has_minimum_reachability();
}
inline void Location::clear_minimum_reachability() {
  minimum_reachability_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline uint32_t Location::_internal_minimum_reachability() const {
  return minimum_reachability_;
}
inline uint32_t Location::minimum_reachability() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.minimum_reachability)
  return _internal_minimum_reachability();
}
inline void Location::_internal_set_minimum_reachability(uint32_t value) {
  _has_bits_[0] |= 0x00080000u;
  minimum_reachability_ = value;
}
inline void Location::set_minimum_reachability(uint32_t value) {
  _internal_set_minimum_reachability(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.minimum_reachability)
}

// optional uint32 radius = 18;
inline bool Location::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Location::has_radius() const {
  return _internal_has_radius();
}
inline void Location::clear_radius() {
  radius_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline uint32_t Location::_internal_radius() const {
  return radius_;
}
inline uint32_t Location::radius() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.radius)
  return _internal_radius();
}
inline void Location::_internal_set_radius(uint32_t value) {
  _has_bits_[0] |= 0x00100000u;
  radius_ = value;
}
inline void Location::set_radius(uint32_t value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.radius)
}

// optional uint32 accuracy = 19;
inline bool Location::_internal_has_accuracy() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Location::has_accuracy() const {
  return _internal_has_accuracy();
}
inline void Location::clear_accuracy() {
  accuracy_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t Location::_internal_accuracy() const {
  return accuracy_;
}
inline uint32_t Location::accuracy() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.accuracy)
  return _internal_accuracy();
}
inline void Location::_internal_set_accuracy(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  accuracy_ = value;
}
inline void Location::set_accuracy(uint32_t value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.accuracy)
}

// optional double time = 20 [default = -1];
inline bool Location::_internal_has_time() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool Location::has_time() const {
  return _internal_has_time();
}
inline void Location::clear_time() {
  time_ = -1;
  _has_bits_[1] &= ~0x00000002u;
}
inline double Location::_internal_time() const {
  return time_;
}
inline double Location::time() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.time)
  return _internal_time();
}
inline void Location::_internal_set_time(double value) {
  _has_bits_[1] |= 0x00000002u;
  time_ = value;
}
inline void Location::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.time)
}

// optional bool rank_candidates = 21 [default = true];
inline bool Location::_internal_has_rank_candidates() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool Location::has_rank_candidates() const {
  return _internal_has_rank_candidates();
}
inline void Location::clear_rank_candidates() {
  rank_candidates_ = true;
  _has_bits_[1] &= ~0x00000001u;
}
inline bool Location::_internal_rank_candidates() const {
  return rank_candidates_;
}
inline bool Location::rank_candidates() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.rank_candidates)
  return _internal_rank_candidates();
}
inline void Location::_internal_set_rank_candidates(bool value) {
  _has_bits_[1] |= 0x00000001u;
  rank_candidates_ = value;
}
inline void Location::set_rank_candidates(bool value) {
  _internal_set_rank_candidates(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.rank_candidates)
}

// repeated .valhalla.Location.PathEdge path_edges = 22;
inline int Location::_internal_path_edges_size() const {
  return path_edges_.size();
}
inline int Location::path_edges_size() const {
  return _internal_path_edges_size();
}
inline void Location::clear_path_edges() {
  path_edges_.Clear();
}
inline ::valhalla::Location_PathEdge* Location::mutable_path_edges(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Location.path_edges)
  return path_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >*
Location::mutable_path_edges() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Location.path_edges)
  return &path_edges_;
}
inline const ::valhalla::Location_PathEdge& Location::_internal_path_edges(int index) const {
  return path_edges_.Get(index);
}
inline const ::valhalla::Location_PathEdge& Location::path_edges(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Location.path_edges)
  return _internal_path_edges(index);
}
inline ::valhalla::Location_PathEdge* Location::_internal_add_path_edges() {
  return path_edges_.Add();
}
inline ::valhalla::Location_PathEdge* Location::add_path_edges() {
  ::valhalla::Location_PathEdge* _add = _internal_add_path_edges();
  // @@protoc_insertion_point(field_add:valhalla.Location.path_edges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >&
Location::path_edges() const {
  // @@protoc_insertion_point(field_list:valhalla.Location.path_edges)
  return path_edges_;
}

// repeated .valhalla.Location.PathEdge filtered_edges = 23;
inline int Location::_internal_filtered_edges_size() const {
  return filtered_edges_.size();
}
inline int Location::filtered_edges_size() const {
  return _internal_filtered_edges_size();
}
inline void Location::clear_filtered_edges() {
  filtered_edges_.Clear();
}
inline ::valhalla::Location_PathEdge* Location::mutable_filtered_edges(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Location.filtered_edges)
  return filtered_edges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >*
Location::mutable_filtered_edges() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Location.filtered_edges)
  return &filtered_edges_;
}
inline const ::valhalla::Location_PathEdge& Location::_internal_filtered_edges(int index) const {
  return filtered_edges_.Get(index);
}
inline const ::valhalla::Location_PathEdge& Location::filtered_edges(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Location.filtered_edges)
  return _internal_filtered_edges(index);
}
inline ::valhalla::Location_PathEdge* Location::_internal_add_filtered_edges() {
  return filtered_edges_.Add();
}
inline ::valhalla::Location_PathEdge* Location::add_filtered_edges() {
  ::valhalla::Location_PathEdge* _add = _internal_add_filtered_edges();
  // @@protoc_insertion_point(field_add:valhalla.Location.filtered_edges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location_PathEdge >&
Location::filtered_edges() const {
  // @@protoc_insertion_point(field_list:valhalla.Location.filtered_edges)
  return filtered_edges_;
}

// optional uint32 original_index = 24;
inline bool Location::_internal_has_original_index() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Location::has_original_index() const {
  return _internal_has_original_index();
}
inline void Location::clear_original_index() {
  original_index_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline uint32_t Location::_internal_original_index() const {
  return original_index_;
}
inline uint32_t Location::original_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.original_index)
  return _internal_original_index();
}
inline void Location::_internal_set_original_index(uint32_t value) {
  _has_bits_[0] |= 0x00400000u;
  original_index_ = value;
}
inline void Location::set_original_index(uint32_t value) {
  _internal_set_original_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.original_index)
}

// optional .valhalla.LatLng projected_ll = 25;
inline bool Location::_internal_has_projected_ll() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || projected_ll_ != nullptr);
  return value;
}
inline bool Location::has_projected_ll() const {
  return _internal_has_projected_ll();
}
inline void Location::clear_projected_ll() {
  if (projected_ll_ != nullptr) projected_ll_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::valhalla::LatLng& Location::_internal_projected_ll() const {
  const ::valhalla::LatLng* p = projected_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Location::projected_ll() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.projected_ll)
  return _internal_projected_ll();
}
inline void Location::unsafe_arena_set_allocated_projected_ll(
    ::valhalla::LatLng* projected_ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(projected_ll_);
  }
  projected_ll_ = projected_ll;
  if (projected_ll) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.projected_ll)
}
inline ::valhalla::LatLng* Location::release_projected_ll() {
  _has_bits_[0] &= ~0x00000400u;
  ::valhalla::LatLng* temp = projected_ll_;
  projected_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* Location::unsafe_arena_release_projected_ll() {
  // @@protoc_insertion_point(field_release:valhalla.Location.projected_ll)
  _has_bits_[0] &= ~0x00000400u;
  ::valhalla::LatLng* temp = projected_ll_;
  projected_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Location::_internal_mutable_projected_ll() {
  _has_bits_[0] |= 0x00000400u;
  if (projected_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    projected_ll_ = p;
  }
  return projected_ll_;
}
inline ::valhalla::LatLng* Location::mutable_projected_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_projected_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.projected_ll)
  return _msg;
}
inline void Location::set_allocated_projected_ll(::valhalla::LatLng* projected_ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete projected_ll_;
  }
  if (projected_ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(projected_ll);
    if (message_arena != submessage_arena) {
      projected_ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, projected_ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  projected_ll_ = projected_ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.projected_ll)
}

// optional uint32 leg_shape_index = 35;
inline bool Location::_internal_has_leg_shape_index() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool Location::has_leg_shape_index() const {
  return _internal_has_leg_shape_index();
}
inline void Location::clear_leg_shape_index() {
  leg_shape_index_ = 0u;
  _has_bits_[0] &= ~0x80000000u;
}
inline uint32_t Location::_internal_leg_shape_index() const {
  return leg_shape_index_;
}
inline uint32_t Location::leg_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.leg_shape_index)
  return _internal_leg_shape_index();
}
inline void Location::_internal_set_leg_shape_index(uint32_t value) {
  _has_bits_[0] |= 0x80000000u;
  leg_shape_index_ = value;
}
inline void Location::set_leg_shape_index(uint32_t value) {
  _internal_set_leg_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.leg_shape_index)
}

// optional double distance_from_leg_origin = 36;
inline bool Location::_internal_has_distance_from_leg_origin() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Location::has_distance_from_leg_origin() const {
  return _internal_has_distance_from_leg_origin();
}
inline void Location::clear_distance_from_leg_origin() {
  distance_from_leg_origin_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline double Location::_internal_distance_from_leg_origin() const {
  return distance_from_leg_origin_;
}
inline double Location::distance_from_leg_origin() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.distance_from_leg_origin)
  return _internal_distance_from_leg_origin();
}
inline void Location::_internal_set_distance_from_leg_origin(double value) {
  _has_bits_[0] |= 0x40000000u;
  distance_from_leg_origin_ = value;
}
inline void Location::set_distance_from_leg_origin(double value) {
  _internal_set_distance_from_leg_origin(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.distance_from_leg_origin)
}

// optional .valhalla.Location.PreferredSide preferred_side = 26 [default = either];
inline bool Location::_internal_has_preferred_side() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Location::has_preferred_side() const {
  return _internal_has_preferred_side();
}
inline void Location::clear_preferred_side() {
  preferred_side_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::valhalla::Location_PreferredSide Location::_internal_preferred_side() const {
  return static_cast< ::valhalla::Location_PreferredSide >(preferred_side_);
}
inline ::valhalla::Location_PreferredSide Location::preferred_side() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.preferred_side)
  return _internal_preferred_side();
}
inline void Location::_internal_set_preferred_side(::valhalla::Location_PreferredSide value) {
  assert(::valhalla::Location_PreferredSide_IsValid(value));
  _has_bits_[0] |= 0x00800000u;
  preferred_side_ = value;
}
inline void Location::set_preferred_side(::valhalla::Location_PreferredSide value) {
  _internal_set_preferred_side(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.preferred_side)
}

// optional .valhalla.LatLng display_ll = 27;
inline bool Location::_internal_has_display_ll() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || display_ll_ != nullptr);
  return value;
}
inline bool Location::has_display_ll() const {
  return _internal_has_display_ll();
}
inline void Location::clear_display_ll() {
  if (display_ll_ != nullptr) display_ll_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::valhalla::LatLng& Location::_internal_display_ll() const {
  const ::valhalla::LatLng* p = display_ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& Location::display_ll() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.display_ll)
  return _internal_display_ll();
}
inline void Location::unsafe_arena_set_allocated_display_ll(
    ::valhalla::LatLng* display_ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(display_ll_);
  }
  display_ll_ = display_ll;
  if (display_ll) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.display_ll)
}
inline ::valhalla::LatLng* Location::release_display_ll() {
  _has_bits_[0] &= ~0x00000800u;
  ::valhalla::LatLng* temp = display_ll_;
  display_ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* Location::unsafe_arena_release_display_ll() {
  // @@protoc_insertion_point(field_release:valhalla.Location.display_ll)
  _has_bits_[0] &= ~0x00000800u;
  ::valhalla::LatLng* temp = display_ll_;
  display_ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* Location::_internal_mutable_display_ll() {
  _has_bits_[0] |= 0x00000800u;
  if (display_ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    display_ll_ = p;
  }
  return display_ll_;
}
inline ::valhalla::LatLng* Location::mutable_display_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_display_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.display_ll)
  return _msg;
}
inline void Location::set_allocated_display_ll(::valhalla::LatLng* display_ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete display_ll_;
  }
  if (display_ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(display_ll);
    if (message_arena != submessage_arena) {
      display_ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, display_ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  display_ll_ = display_ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.display_ll)
}

// optional uint32 search_cutoff = 28;
inline bool Location::_internal_has_search_cutoff() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Location::has_search_cutoff() const {
  return _internal_has_search_cutoff();
}
inline void Location::clear_search_cutoff() {
  search_cutoff_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline uint32_t Location::_internal_search_cutoff() const {
  return search_cutoff_;
}
inline uint32_t Location::search_cutoff() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.search_cutoff)
  return _internal_search_cutoff();
}
inline void Location::_internal_set_search_cutoff(uint32_t value) {
  _has_bits_[0] |= 0x01000000u;
  search_cutoff_ = value;
}
inline void Location::set_search_cutoff(uint32_t value) {
  _internal_set_search_cutoff(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.search_cutoff)
}

// optional uint32 street_side_tolerance = 29;
inline bool Location::_internal_has_street_side_tolerance() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Location::has_street_side_tolerance() const {
  return _internal_has_street_side_tolerance();
}
inline void Location::clear_street_side_tolerance() {
  street_side_tolerance_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline uint32_t Location::_internal_street_side_tolerance() const {
  return street_side_tolerance_;
}
inline uint32_t Location::street_side_tolerance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.street_side_tolerance)
  return _internal_street_side_tolerance();
}
inline void Location::_internal_set_street_side_tolerance(uint32_t value) {
  _has_bits_[0] |= 0x02000000u;
  street_side_tolerance_ = value;
}
inline void Location::set_street_side_tolerance(uint32_t value) {
  _internal_set_street_side_tolerance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.street_side_tolerance)
}

// optional uint32 route_index = 30;
inline bool Location::_internal_has_route_index() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Location::has_route_index() const {
  return _internal_has_route_index();
}
inline void Location::clear_route_index() {
  route_index_ = 0u;
  _has_bits_[0] &= ~0x04000000u;
}
inline uint32_t Location::_internal_route_index() const {
  return route_index_;
}
inline uint32_t Location::route_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.route_index)
  return _internal_route_index();
}
inline void Location::_internal_set_route_index(uint32_t value) {
  _has_bits_[0] |= 0x04000000u;
  route_index_ = value;
}
inline void Location::set_route_index(uint32_t value) {
  _internal_set_route_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.route_index)
}

// optional uint32 waypoint_index = 31;
inline bool Location::_internal_has_waypoint_index() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Location::has_waypoint_index() const {
  return _internal_has_waypoint_index();
}
inline void Location::clear_waypoint_index() {
  waypoint_index_ = 0u;
  _has_bits_[0] &= ~0x08000000u;
}
inline uint32_t Location::_internal_waypoint_index() const {
  return waypoint_index_;
}
inline uint32_t Location::waypoint_index() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.waypoint_index)
  return _internal_waypoint_index();
}
inline void Location::_internal_set_waypoint_index(uint32_t value) {
  _has_bits_[0] |= 0x08000000u;
  waypoint_index_ = value;
}
inline void Location::set_waypoint_index(uint32_t value) {
  _internal_set_waypoint_index(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.waypoint_index)
}

// optional .valhalla.Location.SearchFilter search_filter = 32;
inline bool Location::_internal_has_search_filter() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || search_filter_ != nullptr);
  return value;
}
inline bool Location::has_search_filter() const {
  return _internal_has_search_filter();
}
inline void Location::clear_search_filter() {
  if (search_filter_ != nullptr) search_filter_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::valhalla::Location_SearchFilter& Location::_internal_search_filter() const {
  const ::valhalla::Location_SearchFilter* p = search_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::Location_SearchFilter&>(
      ::valhalla::_Location_SearchFilter_default_instance_);
}
inline const ::valhalla::Location_SearchFilter& Location::search_filter() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.search_filter)
  return _internal_search_filter();
}
inline void Location::unsafe_arena_set_allocated_search_filter(
    ::valhalla::Location_SearchFilter* search_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(search_filter_);
  }
  search_filter_ = search_filter;
  if (search_filter) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.Location.search_filter)
}
inline ::valhalla::Location_SearchFilter* Location::release_search_filter() {
  _has_bits_[0] &= ~0x00001000u;
  ::valhalla::Location_SearchFilter* temp = search_filter_;
  search_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::Location_SearchFilter* Location::unsafe_arena_release_search_filter() {
  // @@protoc_insertion_point(field_release:valhalla.Location.search_filter)
  _has_bits_[0] &= ~0x00001000u;
  ::valhalla::Location_SearchFilter* temp = search_filter_;
  search_filter_ = nullptr;
  return temp;
}
inline ::valhalla::Location_SearchFilter* Location::_internal_mutable_search_filter() {
  _has_bits_[0] |= 0x00001000u;
  if (search_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::Location_SearchFilter>(GetArenaForAllocation());
    search_filter_ = p;
  }
  return search_filter_;
}
inline ::valhalla::Location_SearchFilter* Location::mutable_search_filter() {
  ::valhalla::Location_SearchFilter* _msg = _internal_mutable_search_filter();
  // @@protoc_insertion_point(field_mutable:valhalla.Location.search_filter)
  return _msg;
}
inline void Location::set_allocated_search_filter(::valhalla::Location_SearchFilter* search_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete search_filter_;
  }
  if (search_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::Location_SearchFilter>::GetOwningArena(search_filter);
    if (message_arena != submessage_arena) {
      search_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  search_filter_ = search_filter;
  // @@protoc_insertion_point(field_set_allocated:valhalla.Location.search_filter)
}

// optional uint32 street_side_max_distance = 33;
inline bool Location::_internal_has_street_side_max_distance() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Location::has_street_side_max_distance() const {
  return _internal_has_street_side_max_distance();
}
inline void Location::clear_street_side_max_distance() {
  street_side_max_distance_ = 0u;
  _has_bits_[0] &= ~0x10000000u;
}
inline uint32_t Location::_internal_street_side_max_distance() const {
  return street_side_max_distance_;
}
inline uint32_t Location::street_side_max_distance() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.street_side_max_distance)
  return _internal_street_side_max_distance();
}
inline void Location::_internal_set_street_side_max_distance(uint32_t value) {
  _has_bits_[0] |= 0x10000000u;
  street_side_max_distance_ = value;
}
inline void Location::set_street_side_max_distance(uint32_t value) {
  _internal_set_street_side_max_distance(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.street_side_max_distance)
}

// optional int32 preferred_layer = 34;
inline bool Location::_internal_has_preferred_layer() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Location::has_preferred_layer() const {
  return _internal_has_preferred_layer();
}
inline void Location::clear_preferred_layer() {
  preferred_layer_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline int32_t Location::_internal_preferred_layer() const {
  return preferred_layer_;
}
inline int32_t Location::preferred_layer() const {
  // @@protoc_insertion_point(field_get:valhalla.Location.preferred_layer)
  return _internal_preferred_layer();
}
inline void Location::_internal_set_preferred_layer(int32_t value) {
  _has_bits_[0] |= 0x20000000u;
  preferred_layer_ = value;
}
inline void Location::set_preferred_layer(int32_t value) {
  _internal_set_preferred_layer(value);
  // @@protoc_insertion_point(field_set:valhalla.Location.preferred_layer)
}

// -------------------------------------------------------------------

// TransitEgressInfo

// optional string onestop_id = 1;
inline bool TransitEgressInfo::_internal_has_onestop_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransitEgressInfo::has_onestop_id() const {
  return _internal_has_onestop_id();
}
inline void TransitEgressInfo::clear_onestop_id() {
  onestop_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitEgressInfo::onestop_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitEgressInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitEgressInfo::set_onestop_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitEgressInfo.onestop_id)
}
inline std::string* TransitEgressInfo::mutable_onestop_id() {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitEgressInfo.onestop_id)
  return _s;
}
inline const std::string& TransitEgressInfo::_internal_onestop_id() const {
  return onestop_id_.Get();
}
inline void TransitEgressInfo::_internal_set_onestop_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitEgressInfo::_internal_mutable_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
  return onestop_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitEgressInfo::release_onestop_id() {
  // @@protoc_insertion_point(field_release:valhalla.TransitEgressInfo.onestop_id)
  if (!_internal_has_onestop_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = onestop_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitEgressInfo::set_allocated_onestop_id(std::string* onestop_id) {
  if (onestop_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  onestop_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), onestop_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitEgressInfo.onestop_id)
}

// optional string name = 2;
inline bool TransitEgressInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransitEgressInfo::has_name() const {
  return _internal_has_name();
}
inline void TransitEgressInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitEgressInfo::name() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitEgressInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitEgressInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitEgressInfo.name)
}
inline std::string* TransitEgressInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitEgressInfo.name)
  return _s;
}
inline const std::string& TransitEgressInfo::_internal_name() const {
  return name_.Get();
}
inline void TransitEgressInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitEgressInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitEgressInfo::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.TransitEgressInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitEgressInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitEgressInfo.name)
}

// optional .valhalla.LatLng ll = 3;
inline bool TransitEgressInfo::_internal_has_ll() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || ll_ != nullptr);
  return value;
}
inline bool TransitEgressInfo::has_ll() const {
  return _internal_has_ll();
}
inline void TransitEgressInfo::clear_ll() {
  if (ll_ != nullptr) ll_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::valhalla::LatLng& TransitEgressInfo::_internal_ll() const {
  const ::valhalla::LatLng* p = ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& TransitEgressInfo::ll() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitEgressInfo.ll)
  return _internal_ll();
}
inline void TransitEgressInfo::unsafe_arena_set_allocated_ll(
    ::valhalla::LatLng* ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ll_);
  }
  ll_ = ll;
  if (ll) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TransitEgressInfo.ll)
}
inline ::valhalla::LatLng* TransitEgressInfo::release_ll() {
  _has_bits_[0] &= ~0x00000004u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* TransitEgressInfo::unsafe_arena_release_ll() {
  // @@protoc_insertion_point(field_release:valhalla.TransitEgressInfo.ll)
  _has_bits_[0] &= ~0x00000004u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* TransitEgressInfo::_internal_mutable_ll() {
  _has_bits_[0] |= 0x00000004u;
  if (ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    ll_ = p;
  }
  return ll_;
}
inline ::valhalla::LatLng* TransitEgressInfo::mutable_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitEgressInfo.ll)
  return _msg;
}
inline void TransitEgressInfo::set_allocated_ll(::valhalla::LatLng* ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ll_;
  }
  if (ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(ll);
    if (message_arena != submessage_arena) {
      ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ll_ = ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitEgressInfo.ll)
}

// -------------------------------------------------------------------

// TransitStationInfo

// optional string onestop_id = 1;
inline bool TransitStationInfo::_internal_has_onestop_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransitStationInfo::has_onestop_id() const {
  return _internal_has_onestop_id();
}
inline void TransitStationInfo::clear_onestop_id() {
  onestop_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitStationInfo::onestop_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitStationInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitStationInfo::set_onestop_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitStationInfo.onestop_id)
}
inline std::string* TransitStationInfo::mutable_onestop_id() {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitStationInfo.onestop_id)
  return _s;
}
inline const std::string& TransitStationInfo::_internal_onestop_id() const {
  return onestop_id_.Get();
}
inline void TransitStationInfo::_internal_set_onestop_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitStationInfo::_internal_mutable_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
  return onestop_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitStationInfo::release_onestop_id() {
  // @@protoc_insertion_point(field_release:valhalla.TransitStationInfo.onestop_id)
  if (!_internal_has_onestop_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = onestop_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitStationInfo::set_allocated_onestop_id(std::string* onestop_id) {
  if (onestop_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  onestop_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), onestop_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitStationInfo.onestop_id)
}

// optional string name = 2;
inline bool TransitStationInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransitStationInfo::has_name() const {
  return _internal_has_name();
}
inline void TransitStationInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitStationInfo::name() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitStationInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitStationInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitStationInfo.name)
}
inline std::string* TransitStationInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitStationInfo.name)
  return _s;
}
inline const std::string& TransitStationInfo::_internal_name() const {
  return name_.Get();
}
inline void TransitStationInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitStationInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitStationInfo::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.TransitStationInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitStationInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitStationInfo.name)
}

// optional .valhalla.LatLng ll = 3;
inline bool TransitStationInfo::_internal_has_ll() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || ll_ != nullptr);
  return value;
}
inline bool TransitStationInfo::has_ll() const {
  return _internal_has_ll();
}
inline void TransitStationInfo::clear_ll() {
  if (ll_ != nullptr) ll_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::valhalla::LatLng& TransitStationInfo::_internal_ll() const {
  const ::valhalla::LatLng* p = ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& TransitStationInfo::ll() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitStationInfo.ll)
  return _internal_ll();
}
inline void TransitStationInfo::unsafe_arena_set_allocated_ll(
    ::valhalla::LatLng* ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ll_);
  }
  ll_ = ll;
  if (ll) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TransitStationInfo.ll)
}
inline ::valhalla::LatLng* TransitStationInfo::release_ll() {
  _has_bits_[0] &= ~0x00000004u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* TransitStationInfo::unsafe_arena_release_ll() {
  // @@protoc_insertion_point(field_release:valhalla.TransitStationInfo.ll)
  _has_bits_[0] &= ~0x00000004u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* TransitStationInfo::_internal_mutable_ll() {
  _has_bits_[0] |= 0x00000004u;
  if (ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    ll_ = p;
  }
  return ll_;
}
inline ::valhalla::LatLng* TransitStationInfo::mutable_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitStationInfo.ll)
  return _msg;
}
inline void TransitStationInfo::set_allocated_ll(::valhalla::LatLng* ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ll_;
  }
  if (ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(ll);
    if (message_arena != submessage_arena) {
      ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ll_ = ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitStationInfo.ll)
}

// -------------------------------------------------------------------

// TransitPlatformInfo

// optional .valhalla.TransitPlatformInfo.Type type = 1;
inline bool TransitPlatformInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_type() const {
  return _internal_has_type();
}
inline void TransitPlatformInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::valhalla::TransitPlatformInfo_Type TransitPlatformInfo::_internal_type() const {
  return static_cast< ::valhalla::TransitPlatformInfo_Type >(type_);
}
inline ::valhalla::TransitPlatformInfo_Type TransitPlatformInfo::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.type)
  return _internal_type();
}
inline void TransitPlatformInfo::_internal_set_type(::valhalla::TransitPlatformInfo_Type value) {
  assert(::valhalla::TransitPlatformInfo_Type_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  type_ = value;
}
inline void TransitPlatformInfo::set_type(::valhalla::TransitPlatformInfo_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.type)
}

// optional string onestop_id = 2;
inline bool TransitPlatformInfo::_internal_has_onestop_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_onestop_id() const {
  return _internal_has_onestop_id();
}
inline void TransitPlatformInfo::clear_onestop_id() {
  onestop_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransitPlatformInfo::onestop_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitPlatformInfo::set_onestop_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.onestop_id)
}
inline std::string* TransitPlatformInfo::mutable_onestop_id() {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.onestop_id)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_onestop_id() const {
  return onestop_id_.Get();
}
inline void TransitPlatformInfo::_internal_set_onestop_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::_internal_mutable_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
  return onestop_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::release_onestop_id() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.onestop_id)
  if (!_internal_has_onestop_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = onestop_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitPlatformInfo::set_allocated_onestop_id(std::string* onestop_id) {
  if (onestop_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  onestop_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), onestop_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.onestop_id)
}

// optional string name = 3;
inline bool TransitPlatformInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_name() const {
  return _internal_has_name();
}
inline void TransitPlatformInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransitPlatformInfo::name() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitPlatformInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.name)
}
inline std::string* TransitPlatformInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.name)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_name() const {
  return name_.Get();
}
inline void TransitPlatformInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::release_name() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitPlatformInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.name)
}

// optional string arrival_date_time = 4;
inline bool TransitPlatformInfo::_internal_has_arrival_date_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_arrival_date_time() const {
  return _internal_has_arrival_date_time();
}
inline void TransitPlatformInfo::clear_arrival_date_time() {
  arrival_date_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TransitPlatformInfo::arrival_date_time() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.arrival_date_time)
  return _internal_arrival_date_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitPlatformInfo::set_arrival_date_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 arrival_date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.arrival_date_time)
}
inline std::string* TransitPlatformInfo::mutable_arrival_date_time() {
  std::string* _s = _internal_mutable_arrival_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.arrival_date_time)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_arrival_date_time() const {
  return arrival_date_time_.Get();
}
inline void TransitPlatformInfo::_internal_set_arrival_date_time(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  arrival_date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::_internal_mutable_arrival_date_time() {
  _has_bits_[0] |= 0x00000004u;
  return arrival_date_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::release_arrival_date_time() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.arrival_date_time)
  if (!_internal_has_arrival_date_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = arrival_date_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (arrival_date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    arrival_date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitPlatformInfo::set_allocated_arrival_date_time(std::string* arrival_date_time) {
  if (arrival_date_time != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  arrival_date_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arrival_date_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (arrival_date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    arrival_date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.arrival_date_time)
}

// optional string departure_date_time = 5;
inline bool TransitPlatformInfo::_internal_has_departure_date_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_departure_date_time() const {
  return _internal_has_departure_date_time();
}
inline void TransitPlatformInfo::clear_departure_date_time() {
  departure_date_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TransitPlatformInfo::departure_date_time() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.departure_date_time)
  return _internal_departure_date_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitPlatformInfo::set_departure_date_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 departure_date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.departure_date_time)
}
inline std::string* TransitPlatformInfo::mutable_departure_date_time() {
  std::string* _s = _internal_mutable_departure_date_time();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.departure_date_time)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_departure_date_time() const {
  return departure_date_time_.Get();
}
inline void TransitPlatformInfo::_internal_set_departure_date_time(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  departure_date_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::_internal_mutable_departure_date_time() {
  _has_bits_[0] |= 0x00000008u;
  return departure_date_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::release_departure_date_time() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.departure_date_time)
  if (!_internal_has_departure_date_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = departure_date_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (departure_date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    departure_date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitPlatformInfo::set_allocated_departure_date_time(std::string* departure_date_time) {
  if (departure_date_time != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  departure_date_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), departure_date_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (departure_date_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    departure_date_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.departure_date_time)
}

// optional bool assumed_schedule = 6;
inline bool TransitPlatformInfo::_internal_has_assumed_schedule() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_assumed_schedule() const {
  return _internal_has_assumed_schedule();
}
inline void TransitPlatformInfo::clear_assumed_schedule() {
  assumed_schedule_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool TransitPlatformInfo::_internal_assumed_schedule() const {
  return assumed_schedule_;
}
inline bool TransitPlatformInfo::assumed_schedule() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.assumed_schedule)
  return _internal_assumed_schedule();
}
inline void TransitPlatformInfo::_internal_set_assumed_schedule(bool value) {
  _has_bits_[0] |= 0x00000100u;
  assumed_schedule_ = value;
}
inline void TransitPlatformInfo::set_assumed_schedule(bool value) {
  _internal_set_assumed_schedule(value);
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.assumed_schedule)
}

// optional .valhalla.LatLng ll = 7;
inline bool TransitPlatformInfo::_internal_has_ll() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || ll_ != nullptr);
  return value;
}
inline bool TransitPlatformInfo::has_ll() const {
  return _internal_has_ll();
}
inline void TransitPlatformInfo::clear_ll() {
  if (ll_ != nullptr) ll_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::valhalla::LatLng& TransitPlatformInfo::_internal_ll() const {
  const ::valhalla::LatLng* p = ll_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::LatLng&>(
      ::valhalla::_LatLng_default_instance_);
}
inline const ::valhalla::LatLng& TransitPlatformInfo::ll() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.ll)
  return _internal_ll();
}
inline void TransitPlatformInfo::unsafe_arena_set_allocated_ll(
    ::valhalla::LatLng* ll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ll_);
  }
  ll_ = ll;
  if (ll) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.TransitPlatformInfo.ll)
}
inline ::valhalla::LatLng* TransitPlatformInfo::release_ll() {
  _has_bits_[0] &= ~0x00000040u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::LatLng* TransitPlatformInfo::unsafe_arena_release_ll() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.ll)
  _has_bits_[0] &= ~0x00000040u;
  ::valhalla::LatLng* temp = ll_;
  ll_ = nullptr;
  return temp;
}
inline ::valhalla::LatLng* TransitPlatformInfo::_internal_mutable_ll() {
  _has_bits_[0] |= 0x00000040u;
  if (ll_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::LatLng>(GetArenaForAllocation());
    ll_ = p;
  }
  return ll_;
}
inline ::valhalla::LatLng* TransitPlatformInfo::mutable_ll() {
  ::valhalla::LatLng* _msg = _internal_mutable_ll();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.ll)
  return _msg;
}
inline void TransitPlatformInfo::set_allocated_ll(::valhalla::LatLng* ll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ll_;
  }
  if (ll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::LatLng>::GetOwningArena(ll);
    if (message_arena != submessage_arena) {
      ll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  ll_ = ll;
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.ll)
}

// optional string station_onestop_id = 8;
inline bool TransitPlatformInfo::_internal_has_station_onestop_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_station_onestop_id() const {
  return _internal_has_station_onestop_id();
}
inline void TransitPlatformInfo::clear_station_onestop_id() {
  station_onestop_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TransitPlatformInfo::station_onestop_id() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.station_onestop_id)
  return _internal_station_onestop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitPlatformInfo::set_station_onestop_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 station_onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.station_onestop_id)
}
inline std::string* TransitPlatformInfo::mutable_station_onestop_id() {
  std::string* _s = _internal_mutable_station_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.station_onestop_id)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_station_onestop_id() const {
  return station_onestop_id_.Get();
}
inline void TransitPlatformInfo::_internal_set_station_onestop_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  station_onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::_internal_mutable_station_onestop_id() {
  _has_bits_[0] |= 0x00000010u;
  return station_onestop_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::release_station_onestop_id() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.station_onestop_id)
  if (!_internal_has_station_onestop_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = station_onestop_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (station_onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    station_onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitPlatformInfo::set_allocated_station_onestop_id(std::string* station_onestop_id) {
  if (station_onestop_id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  station_onestop_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), station_onestop_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (station_onestop_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    station_onestop_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.station_onestop_id)
}

// optional string station_name = 9;
inline bool TransitPlatformInfo::_internal_has_station_name() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TransitPlatformInfo::has_station_name() const {
  return _internal_has_station_name();
}
inline void TransitPlatformInfo::clear_station_name() {
  station_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TransitPlatformInfo::station_name() const {
  // @@protoc_insertion_point(field_get:valhalla.TransitPlatformInfo.station_name)
  return _internal_station_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransitPlatformInfo::set_station_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 station_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TransitPlatformInfo.station_name)
}
inline std::string* TransitPlatformInfo::mutable_station_name() {
  std::string* _s = _internal_mutable_station_name();
  // @@protoc_insertion_point(field_mutable:valhalla.TransitPlatformInfo.station_name)
  return _s;
}
inline const std::string& TransitPlatformInfo::_internal_station_name() const {
  return station_name_.Get();
}
inline void TransitPlatformInfo::_internal_set_station_name(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  station_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::_internal_mutable_station_name() {
  _has_bits_[0] |= 0x00000020u;
  return station_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransitPlatformInfo::release_station_name() {
  // @@protoc_insertion_point(field_release:valhalla.TransitPlatformInfo.station_name)
  if (!_internal_has_station_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = station_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (station_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    station_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TransitPlatformInfo::set_allocated_station_name(std::string* station_name) {
  if (station_name != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  station_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), station_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (station_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    station_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TransitPlatformInfo.station_name)
}

// -------------------------------------------------------------------

// StreetName

// optional string value = 1;
inline bool StreetName::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StreetName::has_value() const {
  return _internal_has_value();
}
inline void StreetName::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreetName::value() const {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreetName::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.StreetName.value)
}
inline std::string* StreetName::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:valhalla.StreetName.value)
  return _s;
}
inline const std::string& StreetName::_internal_value() const {
  return value_.Get();
}
inline void StreetName::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreetName::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreetName::release_value() {
  // @@protoc_insertion_point(field_release:valhalla.StreetName.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StreetName::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.StreetName.value)
}

// optional bool is_route_number = 2;
inline bool StreetName::_internal_has_is_route_number() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StreetName::has_is_route_number() const {
  return _internal_has_is_route_number();
}
inline void StreetName::clear_is_route_number() {
  is_route_number_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StreetName::_internal_is_route_number() const {
  return is_route_number_;
}
inline bool StreetName::is_route_number() const {
  // @@protoc_insertion_point(field_get:valhalla.StreetName.is_route_number)
  return _internal_is_route_number();
}
inline void StreetName::_internal_set_is_route_number(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_route_number_ = value;
}
inline void StreetName::set_is_route_number(bool value) {
  _internal_set_is_route_number(value);
  // @@protoc_insertion_point(field_set:valhalla.StreetName.is_route_number)
}

// -------------------------------------------------------------------

// TurnLane

// optional uint32 directions_mask = 1;
inline bool TurnLane::_internal_has_directions_mask() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TurnLane::has_directions_mask() const {
  return _internal_has_directions_mask();
}
inline void TurnLane::clear_directions_mask() {
  directions_mask_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t TurnLane::_internal_directions_mask() const {
  return directions_mask_;
}
inline uint32_t TurnLane::directions_mask() const {
  // @@protoc_insertion_point(field_get:valhalla.TurnLane.directions_mask)
  return _internal_directions_mask();
}
inline void TurnLane::_internal_set_directions_mask(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  directions_mask_ = value;
}
inline void TurnLane::set_directions_mask(uint32_t value) {
  _internal_set_directions_mask(value);
  // @@protoc_insertion_point(field_set:valhalla.TurnLane.directions_mask)
}

// optional .valhalla.TurnLane.State state = 2 [default = kInvalid];
inline bool TurnLane::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TurnLane::has_state() const {
  return _internal_has_state();
}
inline void TurnLane::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::valhalla::TurnLane_State TurnLane::_internal_state() const {
  return static_cast< ::valhalla::TurnLane_State >(state_);
}
inline ::valhalla::TurnLane_State TurnLane::state() const {
  // @@protoc_insertion_point(field_get:valhalla.TurnLane.state)
  return _internal_state();
}
inline void TurnLane::_internal_set_state(::valhalla::TurnLane_State value) {
  assert(::valhalla::TurnLane_State_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void TurnLane::set_state(::valhalla::TurnLane_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:valhalla.TurnLane.state)
}

// optional uint32 active_direction = 3;
inline bool TurnLane::_internal_has_active_direction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TurnLane::has_active_direction() const {
  return _internal_has_active_direction();
}
inline void TurnLane::clear_active_direction() {
  active_direction_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t TurnLane::_internal_active_direction() const {
  return active_direction_;
}
inline uint32_t TurnLane::active_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.TurnLane.active_direction)
  return _internal_active_direction();
}
inline void TurnLane::_internal_set_active_direction(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  active_direction_ = value;
}
inline void TurnLane::set_active_direction(uint32_t value) {
  _internal_set_active_direction(value);
  // @@protoc_insertion_point(field_set:valhalla.TurnLane.active_direction)
}

// -------------------------------------------------------------------

// TaggedValue

// optional string value = 1;
inline bool TaggedValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TaggedValue::has_value() const {
  return _internal_has_value();
}
inline void TaggedValue::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaggedValue::value() const {
  // @@protoc_insertion_point(field_get:valhalla.TaggedValue.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaggedValue::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.TaggedValue.value)
}
inline std::string* TaggedValue::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:valhalla.TaggedValue.value)
  return _s;
}
inline const std::string& TaggedValue::_internal_value() const {
  return value_.Get();
}
inline void TaggedValue::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaggedValue::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaggedValue::release_value() {
  // @@protoc_insertion_point(field_release:valhalla.TaggedValue.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TaggedValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:valhalla.TaggedValue.value)
}

// optional .valhalla.TaggedValue.Type type = 2;
inline bool TaggedValue::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TaggedValue::has_type() const {
  return _internal_has_type();
}
inline void TaggedValue::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::valhalla::TaggedValue_Type TaggedValue::_internal_type() const {
  return static_cast< ::valhalla::TaggedValue_Type >(type_);
}
inline ::valhalla::TaggedValue_Type TaggedValue::type() const {
  // @@protoc_insertion_point(field_get:valhalla.TaggedValue.type)
  return _internal_type();
}
inline void TaggedValue::_internal_set_type(::valhalla::TaggedValue_Type value) {
  assert(::valhalla::TaggedValue_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void TaggedValue::set_type(::valhalla::TaggedValue_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.TaggedValue.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::Location_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Location_SideOfStreet> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::Location_PreferredSide> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TransitPlatformInfo_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TurnLane_State> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::TaggedValue_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::RoadClass> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tripcommon_2eproto
