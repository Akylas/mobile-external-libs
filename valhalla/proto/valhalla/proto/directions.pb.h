// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_directions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_directions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "tripcommon.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_directions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_directions_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace valhalla {
class Directions;
struct DirectionsDefaultTypeInternal;
extern DirectionsDefaultTypeInternal _Directions_default_instance_;
class DirectionsLeg;
struct DirectionsLegDefaultTypeInternal;
extern DirectionsLegDefaultTypeInternal _DirectionsLeg_default_instance_;
class DirectionsLeg_GuidanceView;
struct DirectionsLeg_GuidanceViewDefaultTypeInternal;
extern DirectionsLeg_GuidanceViewDefaultTypeInternal _DirectionsLeg_GuidanceView_default_instance_;
class DirectionsLeg_Maneuver;
struct DirectionsLeg_ManeuverDefaultTypeInternal;
extern DirectionsLeg_ManeuverDefaultTypeInternal _DirectionsLeg_Maneuver_default_instance_;
class DirectionsLeg_Maneuver_Sign;
struct DirectionsLeg_Maneuver_SignDefaultTypeInternal;
extern DirectionsLeg_Maneuver_SignDefaultTypeInternal _DirectionsLeg_Maneuver_Sign_default_instance_;
class DirectionsLeg_Maneuver_SignElement;
struct DirectionsLeg_Maneuver_SignElementDefaultTypeInternal;
extern DirectionsLeg_Maneuver_SignElementDefaultTypeInternal _DirectionsLeg_Maneuver_SignElement_default_instance_;
class DirectionsLeg_Summary;
struct DirectionsLeg_SummaryDefaultTypeInternal;
extern DirectionsLeg_SummaryDefaultTypeInternal _DirectionsLeg_Summary_default_instance_;
class DirectionsLeg_TransitInfo;
struct DirectionsLeg_TransitInfoDefaultTypeInternal;
extern DirectionsLeg_TransitInfoDefaultTypeInternal _DirectionsLeg_TransitInfo_default_instance_;
class DirectionsRoute;
struct DirectionsRouteDefaultTypeInternal;
extern DirectionsRouteDefaultTypeInternal _DirectionsRoute_default_instance_;
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> ::valhalla::Directions* Arena::CreateMaybeMessage<::valhalla::Directions>(Arena*);
template<> ::valhalla::DirectionsLeg* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg>(Arena*);
template<> ::valhalla::DirectionsLeg_GuidanceView* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_GuidanceView>(Arena*);
template<> ::valhalla::DirectionsLeg_Maneuver* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Maneuver>(Arena*);
template<> ::valhalla::DirectionsLeg_Maneuver_Sign* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Maneuver_Sign>(Arena*);
template<> ::valhalla::DirectionsLeg_Maneuver_SignElement* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Maneuver_SignElement>(Arena*);
template<> ::valhalla::DirectionsLeg_Summary* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_Summary>(Arena*);
template<> ::valhalla::DirectionsLeg_TransitInfo* Arena::CreateMaybeMessage<::valhalla::DirectionsLeg_TransitInfo>(Arena*);
template<> ::valhalla::DirectionsRoute* Arena::CreateMaybeMessage<::valhalla::DirectionsRoute>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace valhalla {

enum DirectionsLeg_GuidanceView_Type : int {
  DirectionsLeg_GuidanceView_Type_kJunction = 0,
  DirectionsLeg_GuidanceView_Type_kSapa = 1,
  DirectionsLeg_GuidanceView_Type_kTollbranch = 2,
  DirectionsLeg_GuidanceView_Type_kAftertoll = 3,
  DirectionsLeg_GuidanceView_Type_kEnt = 4,
  DirectionsLeg_GuidanceView_Type_kExit = 5,
  DirectionsLeg_GuidanceView_Type_kCityreal = 6,
  DirectionsLeg_GuidanceView_Type_kDirectionboard = 7,
  DirectionsLeg_GuidanceView_Type_kSignboard = 8
};
bool DirectionsLeg_GuidanceView_Type_IsValid(int value);
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MIN = DirectionsLeg_GuidanceView_Type_kJunction;
constexpr DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView_Type_Type_MAX = DirectionsLeg_GuidanceView_Type_kSignboard;
constexpr int DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE = DirectionsLeg_GuidanceView_Type_Type_MAX + 1;

const std::string& DirectionsLeg_GuidanceView_Type_Name(DirectionsLeg_GuidanceView_Type value);
template<typename T>
inline const std::string& DirectionsLeg_GuidanceView_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_GuidanceView_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_GuidanceView_Type_Name.");
  return DirectionsLeg_GuidanceView_Type_Name(static_cast<DirectionsLeg_GuidanceView_Type>(enum_t_value));
}
bool DirectionsLeg_GuidanceView_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_GuidanceView_Type* value);
enum DirectionsLeg_Maneuver_CardinalDirection : int {
  DirectionsLeg_Maneuver_CardinalDirection_kNorth = 0,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthEast = 1,
  DirectionsLeg_Maneuver_CardinalDirection_kEast = 2,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthEast = 3,
  DirectionsLeg_Maneuver_CardinalDirection_kSouth = 4,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthWest = 5,
  DirectionsLeg_Maneuver_CardinalDirection_kWest = 6,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthWest = 7
};
bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value);
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
constexpr DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
constexpr int DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX + 1;

const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(DirectionsLeg_Maneuver_CardinalDirection value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_CardinalDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_CardinalDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_CardinalDirection_Name.");
  return DirectionsLeg_Maneuver_CardinalDirection_Name(static_cast<DirectionsLeg_Maneuver_CardinalDirection>(enum_t_value));
}
bool DirectionsLeg_Maneuver_CardinalDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_CardinalDirection* value);
enum DirectionsLeg_Maneuver_Type : int {
  DirectionsLeg_Maneuver_Type_kNone = 0,
  DirectionsLeg_Maneuver_Type_kStart = 1,
  DirectionsLeg_Maneuver_Type_kStartRight = 2,
  DirectionsLeg_Maneuver_Type_kStartLeft = 3,
  DirectionsLeg_Maneuver_Type_kDestination = 4,
  DirectionsLeg_Maneuver_Type_kDestinationRight = 5,
  DirectionsLeg_Maneuver_Type_kDestinationLeft = 6,
  DirectionsLeg_Maneuver_Type_kBecomes = 7,
  DirectionsLeg_Maneuver_Type_kContinue = 8,
  DirectionsLeg_Maneuver_Type_kSlightRight = 9,
  DirectionsLeg_Maneuver_Type_kRight = 10,
  DirectionsLeg_Maneuver_Type_kSharpRight = 11,
  DirectionsLeg_Maneuver_Type_kUturnRight = 12,
  DirectionsLeg_Maneuver_Type_kUturnLeft = 13,
  DirectionsLeg_Maneuver_Type_kSharpLeft = 14,
  DirectionsLeg_Maneuver_Type_kLeft = 15,
  DirectionsLeg_Maneuver_Type_kSlightLeft = 16,
  DirectionsLeg_Maneuver_Type_kRampStraight = 17,
  DirectionsLeg_Maneuver_Type_kRampRight = 18,
  DirectionsLeg_Maneuver_Type_kRampLeft = 19,
  DirectionsLeg_Maneuver_Type_kExitRight = 20,
  DirectionsLeg_Maneuver_Type_kExitLeft = 21,
  DirectionsLeg_Maneuver_Type_kStayStraight = 22,
  DirectionsLeg_Maneuver_Type_kStayRight = 23,
  DirectionsLeg_Maneuver_Type_kStayLeft = 24,
  DirectionsLeg_Maneuver_Type_kMerge = 25,
  DirectionsLeg_Maneuver_Type_kRoundaboutEnter = 26,
  DirectionsLeg_Maneuver_Type_kRoundaboutExit = 27,
  DirectionsLeg_Maneuver_Type_kFerryEnter = 28,
  DirectionsLeg_Maneuver_Type_kFerryExit = 29,
  DirectionsLeg_Maneuver_Type_kTransit = 30,
  DirectionsLeg_Maneuver_Type_kTransitTransfer = 31,
  DirectionsLeg_Maneuver_Type_kTransitRemainOn = 32,
  DirectionsLeg_Maneuver_Type_kTransitConnectionStart = 33,
  DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer = 34,
  DirectionsLeg_Maneuver_Type_kTransitConnectionDestination = 35,
  DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination = 36,
  DirectionsLeg_Maneuver_Type_kMergeRight = 37,
  DirectionsLeg_Maneuver_Type_kMergeLeft = 38
};
bool DirectionsLeg_Maneuver_Type_IsValid(int value);
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MIN = DirectionsLeg_Maneuver_Type_kNone;
constexpr DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MAX = DirectionsLeg_Maneuver_Type_kMergeLeft;
constexpr int DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE = DirectionsLeg_Maneuver_Type_Type_MAX + 1;

const std::string& DirectionsLeg_Maneuver_Type_Name(DirectionsLeg_Maneuver_Type value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_Type_Name.");
  return DirectionsLeg_Maneuver_Type_Name(static_cast<DirectionsLeg_Maneuver_Type>(enum_t_value));
}
bool DirectionsLeg_Maneuver_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_Type* value);
enum DirectionsLeg_Maneuver_BssManeuverType : int {
  DirectionsLeg_Maneuver_BssManeuverType_kNoneAction = 1,
  DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare = 2,
  DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare = 3
};
bool DirectionsLeg_Maneuver_BssManeuverType_IsValid(int value);
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN = DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
constexpr DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX = DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
constexpr int DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE = DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX + 1;

const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(DirectionsLeg_Maneuver_BssManeuverType value);
template<typename T>
inline const std::string& DirectionsLeg_Maneuver_BssManeuverType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_Maneuver_BssManeuverType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_Maneuver_BssManeuverType_Name.");
  return DirectionsLeg_Maneuver_BssManeuverType_Name(static_cast<DirectionsLeg_Maneuver_BssManeuverType>(enum_t_value));
}
bool DirectionsLeg_Maneuver_BssManeuverType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_Maneuver_BssManeuverType* value);
enum DirectionsLeg_TravelMode : int {
  DirectionsLeg_TravelMode_kDrive = 0,
  DirectionsLeg_TravelMode_kPedestrian = 1,
  DirectionsLeg_TravelMode_kBicycle = 2,
  DirectionsLeg_TravelMode_kTransit = 3
};
bool DirectionsLeg_TravelMode_IsValid(int value);
constexpr DirectionsLeg_TravelMode DirectionsLeg_TravelMode_TravelMode_MIN = DirectionsLeg_TravelMode_kDrive;
constexpr DirectionsLeg_TravelMode DirectionsLeg_TravelMode_TravelMode_MAX = DirectionsLeg_TravelMode_kTransit;
constexpr int DirectionsLeg_TravelMode_TravelMode_ARRAYSIZE = DirectionsLeg_TravelMode_TravelMode_MAX + 1;

const std::string& DirectionsLeg_TravelMode_Name(DirectionsLeg_TravelMode value);
template<typename T>
inline const std::string& DirectionsLeg_TravelMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_TravelMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_TravelMode_Name.");
  return DirectionsLeg_TravelMode_Name(static_cast<DirectionsLeg_TravelMode>(enum_t_value));
}
bool DirectionsLeg_TravelMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_TravelMode* value);
enum DirectionsLeg_VehicleType : int {
  DirectionsLeg_VehicleType_kCar = 0,
  DirectionsLeg_VehicleType_kMotorcycle = 1,
  DirectionsLeg_VehicleType_kAutoBus = 2,
  DirectionsLeg_VehicleType_kTractorTrailer = 3,
  DirectionsLeg_VehicleType_kMotorScooter = 4
};
bool DirectionsLeg_VehicleType_IsValid(int value);
constexpr DirectionsLeg_VehicleType DirectionsLeg_VehicleType_VehicleType_MIN = DirectionsLeg_VehicleType_kCar;
constexpr DirectionsLeg_VehicleType DirectionsLeg_VehicleType_VehicleType_MAX = DirectionsLeg_VehicleType_kMotorScooter;
constexpr int DirectionsLeg_VehicleType_VehicleType_ARRAYSIZE = DirectionsLeg_VehicleType_VehicleType_MAX + 1;

const std::string& DirectionsLeg_VehicleType_Name(DirectionsLeg_VehicleType value);
template<typename T>
inline const std::string& DirectionsLeg_VehicleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_VehicleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_VehicleType_Name.");
  return DirectionsLeg_VehicleType_Name(static_cast<DirectionsLeg_VehicleType>(enum_t_value));
}
bool DirectionsLeg_VehicleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_VehicleType* value);
enum DirectionsLeg_PedestrianType : int {
  DirectionsLeg_PedestrianType_kFoot = 0,
  DirectionsLeg_PedestrianType_kWheelchair = 1,
  DirectionsLeg_PedestrianType_kSegway = 2
};
bool DirectionsLeg_PedestrianType_IsValid(int value);
constexpr DirectionsLeg_PedestrianType DirectionsLeg_PedestrianType_PedestrianType_MIN = DirectionsLeg_PedestrianType_kFoot;
constexpr DirectionsLeg_PedestrianType DirectionsLeg_PedestrianType_PedestrianType_MAX = DirectionsLeg_PedestrianType_kSegway;
constexpr int DirectionsLeg_PedestrianType_PedestrianType_ARRAYSIZE = DirectionsLeg_PedestrianType_PedestrianType_MAX + 1;

const std::string& DirectionsLeg_PedestrianType_Name(DirectionsLeg_PedestrianType value);
template<typename T>
inline const std::string& DirectionsLeg_PedestrianType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_PedestrianType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_PedestrianType_Name.");
  return DirectionsLeg_PedestrianType_Name(static_cast<DirectionsLeg_PedestrianType>(enum_t_value));
}
bool DirectionsLeg_PedestrianType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_PedestrianType* value);
enum DirectionsLeg_BicycleType : int {
  DirectionsLeg_BicycleType_kRoad = 0,
  DirectionsLeg_BicycleType_kCross = 1,
  DirectionsLeg_BicycleType_kHybrid = 2,
  DirectionsLeg_BicycleType_kMountain = 3
};
bool DirectionsLeg_BicycleType_IsValid(int value);
constexpr DirectionsLeg_BicycleType DirectionsLeg_BicycleType_BicycleType_MIN = DirectionsLeg_BicycleType_kRoad;
constexpr DirectionsLeg_BicycleType DirectionsLeg_BicycleType_BicycleType_MAX = DirectionsLeg_BicycleType_kMountain;
constexpr int DirectionsLeg_BicycleType_BicycleType_ARRAYSIZE = DirectionsLeg_BicycleType_BicycleType_MAX + 1;

const std::string& DirectionsLeg_BicycleType_Name(DirectionsLeg_BicycleType value);
template<typename T>
inline const std::string& DirectionsLeg_BicycleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_BicycleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_BicycleType_Name.");
  return DirectionsLeg_BicycleType_Name(static_cast<DirectionsLeg_BicycleType>(enum_t_value));
}
bool DirectionsLeg_BicycleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_BicycleType* value);
enum DirectionsLeg_TransitType : int {
  DirectionsLeg_TransitType_kTram = 0,
  DirectionsLeg_TransitType_kMetro = 1,
  DirectionsLeg_TransitType_kRail = 2,
  DirectionsLeg_TransitType_kBus = 3,
  DirectionsLeg_TransitType_kFerry = 4,
  DirectionsLeg_TransitType_kCableCar = 5,
  DirectionsLeg_TransitType_kGondola = 6,
  DirectionsLeg_TransitType_kFunicular = 7
};
bool DirectionsLeg_TransitType_IsValid(int value);
constexpr DirectionsLeg_TransitType DirectionsLeg_TransitType_TransitType_MIN = DirectionsLeg_TransitType_kTram;
constexpr DirectionsLeg_TransitType DirectionsLeg_TransitType_TransitType_MAX = DirectionsLeg_TransitType_kFunicular;
constexpr int DirectionsLeg_TransitType_TransitType_ARRAYSIZE = DirectionsLeg_TransitType_TransitType_MAX + 1;

const std::string& DirectionsLeg_TransitType_Name(DirectionsLeg_TransitType value);
template<typename T>
inline const std::string& DirectionsLeg_TransitType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionsLeg_TransitType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionsLeg_TransitType_Name.");
  return DirectionsLeg_TransitType_Name(static_cast<DirectionsLeg_TransitType>(enum_t_value));
}
bool DirectionsLeg_TransitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionsLeg_TransitType* value);
// ===================================================================

class DirectionsLeg_Summary final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Summary) */ {
 public:
  inline DirectionsLeg_Summary() : DirectionsLeg_Summary(nullptr) {}
  ~DirectionsLeg_Summary() override;
  explicit constexpr DirectionsLeg_Summary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Summary(const DirectionsLeg_Summary& from);
  DirectionsLeg_Summary(DirectionsLeg_Summary&& from) noexcept
    : DirectionsLeg_Summary() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Summary& operator=(const DirectionsLeg_Summary& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Summary& operator=(DirectionsLeg_Summary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_Summary& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Summary* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Summary*>(
               &_DirectionsLeg_Summary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DirectionsLeg_Summary& a, DirectionsLeg_Summary& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Summary* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Summary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Summary* New() const final {
    return new DirectionsLeg_Summary();
  }

  DirectionsLeg_Summary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_Summary>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Summary& from);
  void MergeFrom(const DirectionsLeg_Summary& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Summary* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Summary";
  }
  protected:
  explicit DirectionsLeg_Summary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBboxFieldNumber = 3,
    kTimeFieldNumber = 2,
    kLengthFieldNumber = 1,
    kHasTimeRestrictionsFieldNumber = 4,
  };
  // optional .valhalla.BoundingBox bbox = 3;
  bool has_bbox() const;
  private:
  bool _internal_has_bbox() const;
  public:
  void clear_bbox();
  const ::valhalla::BoundingBox& bbox() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::BoundingBox* release_bbox();
  ::valhalla::BoundingBox* mutable_bbox();
  void set_allocated_bbox(::valhalla::BoundingBox* bbox);
  private:
  const ::valhalla::BoundingBox& _internal_bbox() const;
  ::valhalla::BoundingBox* _internal_mutable_bbox();
  public:
  void unsafe_arena_set_allocated_bbox(
      ::valhalla::BoundingBox* bbox);
  ::valhalla::BoundingBox* unsafe_arena_release_bbox();

  // optional double time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // optional float length = 1;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // optional bool has_time_restrictions = 4;
  bool has_has_time_restrictions() const;
  private:
  bool _internal_has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Summary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::valhalla::BoundingBox* bbox_;
  double time_;
  float length_;
  bool has_time_restrictions_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_TransitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.TransitInfo) */ {
 public:
  inline DirectionsLeg_TransitInfo() : DirectionsLeg_TransitInfo(nullptr) {}
  ~DirectionsLeg_TransitInfo() override;
  explicit constexpr DirectionsLeg_TransitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_TransitInfo(const DirectionsLeg_TransitInfo& from);
  DirectionsLeg_TransitInfo(DirectionsLeg_TransitInfo&& from) noexcept
    : DirectionsLeg_TransitInfo() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_TransitInfo& operator=(const DirectionsLeg_TransitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_TransitInfo& operator=(DirectionsLeg_TransitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_TransitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_TransitInfo* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_TransitInfo*>(
               &_DirectionsLeg_TransitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DirectionsLeg_TransitInfo& a, DirectionsLeg_TransitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_TransitInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_TransitInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_TransitInfo* New() const final {
    return new DirectionsLeg_TransitInfo();
  }

  DirectionsLeg_TransitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_TransitInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_TransitInfo& from);
  void MergeFrom(const DirectionsLeg_TransitInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_TransitInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.TransitInfo";
  }
  protected:
  explicit DirectionsLeg_TransitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransitStopsFieldNumber = 11,
    kOnestopIdFieldNumber = 1,
    kShortNameFieldNumber = 2,
    kLongNameFieldNumber = 3,
    kHeadsignFieldNumber = 4,
    kDescriptionFieldNumber = 7,
    kOperatorOnestopIdFieldNumber = 8,
    kOperatorNameFieldNumber = 9,
    kOperatorUrlFieldNumber = 10,
    kColorFieldNumber = 5,
    kTextColorFieldNumber = 6,
  };
  // repeated .valhalla.TransitPlatformInfo transit_stops = 11;
  int transit_stops_size() const;
  private:
  int _internal_transit_stops_size() const;
  public:
  void clear_transit_stops();
  ::valhalla::TransitPlatformInfo* mutable_transit_stops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TransitPlatformInfo >*
      mutable_transit_stops();
  private:
  const ::valhalla::TransitPlatformInfo& _internal_transit_stops(int index) const;
  ::valhalla::TransitPlatformInfo* _internal_add_transit_stops();
  public:
  const ::valhalla::TransitPlatformInfo& transit_stops(int index) const;
  ::valhalla::TransitPlatformInfo* add_transit_stops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TransitPlatformInfo >&
      transit_stops() const;

  // optional string onestop_id = 1;
  bool has_onestop_id() const;
  private:
  bool _internal_has_onestop_id() const;
  public:
  void clear_onestop_id();
  const std::string& onestop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_onestop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_onestop_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_onestop_id();
  void set_allocated_onestop_id(std::string* onestop_id);
  private:
  const std::string& _internal_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_onestop_id(const std::string& value);
  std::string* _internal_mutable_onestop_id();
  public:

  // optional string short_name = 2;
  bool has_short_name() const;
  private:
  bool _internal_has_short_name() const;
  public:
  void clear_short_name();
  const std::string& short_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_short_name();
  void set_allocated_short_name(std::string* short_name);
  private:
  const std::string& _internal_short_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_name(const std::string& value);
  std::string* _internal_mutable_short_name();
  public:

  // optional string long_name = 3;
  bool has_long_name() const;
  private:
  bool _internal_has_long_name() const;
  public:
  void clear_long_name();
  const std::string& long_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_long_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_long_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_long_name();
  void set_allocated_long_name(std::string* long_name);
  private:
  const std::string& _internal_long_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_long_name(const std::string& value);
  std::string* _internal_mutable_long_name();
  public:

  // optional string headsign = 4;
  bool has_headsign() const;
  private:
  bool _internal_has_headsign() const;
  public:
  void clear_headsign();
  const std::string& headsign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headsign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headsign();
  PROTOBUF_MUST_USE_RESULT std::string* release_headsign();
  void set_allocated_headsign(std::string* headsign);
  private:
  const std::string& _internal_headsign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headsign(const std::string& value);
  std::string* _internal_mutable_headsign();
  public:

  // optional string description = 7;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string operator_onestop_id = 8;
  bool has_operator_onestop_id() const;
  private:
  bool _internal_has_operator_onestop_id() const;
  public:
  void clear_operator_onestop_id();
  const std::string& operator_onestop_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operator_onestop_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operator_onestop_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_operator_onestop_id();
  void set_allocated_operator_onestop_id(std::string* operator_onestop_id);
  private:
  const std::string& _internal_operator_onestop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_onestop_id(const std::string& value);
  std::string* _internal_mutable_operator_onestop_id();
  public:

  // optional string operator_name = 9;
  bool has_operator_name() const;
  private:
  bool _internal_has_operator_name() const;
  public:
  void clear_operator_name();
  const std::string& operator_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operator_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operator_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_operator_name();
  void set_allocated_operator_name(std::string* operator_name);
  private:
  const std::string& _internal_operator_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_name(const std::string& value);
  std::string* _internal_mutable_operator_name();
  public:

  // optional string operator_url = 10;
  bool has_operator_url() const;
  private:
  bool _internal_has_operator_url() const;
  public:
  void clear_operator_url();
  const std::string& operator_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operator_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operator_url();
  PROTOBUF_MUST_USE_RESULT std::string* release_operator_url();
  void set_allocated_operator_url(std::string* operator_url);
  private:
  const std::string& _internal_operator_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_url(const std::string& value);
  std::string* _internal_mutable_operator_url();
  public:

  // optional uint32 color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::uint32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 text_color = 6;
  bool has_text_color() const;
  private:
  bool _internal_has_text_color() const;
  public:
  void clear_text_color();
  ::PROTOBUF_NAMESPACE_ID::uint32 text_color() const;
  void set_text_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_text_color() const;
  void _internal_set_text_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.TransitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TransitPlatformInfo > transit_stops_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr onestop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr long_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headsign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_onestop_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_url_;
  ::PROTOBUF_NAMESPACE_ID::uint32 color_;
  ::PROTOBUF_NAMESPACE_ID::uint32 text_color_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_GuidanceView final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.GuidanceView) */ {
 public:
  inline DirectionsLeg_GuidanceView() : DirectionsLeg_GuidanceView(nullptr) {}
  ~DirectionsLeg_GuidanceView() override;
  explicit constexpr DirectionsLeg_GuidanceView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_GuidanceView(const DirectionsLeg_GuidanceView& from);
  DirectionsLeg_GuidanceView(DirectionsLeg_GuidanceView&& from) noexcept
    : DirectionsLeg_GuidanceView() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_GuidanceView& operator=(const DirectionsLeg_GuidanceView& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_GuidanceView& operator=(DirectionsLeg_GuidanceView&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_GuidanceView& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_GuidanceView* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_GuidanceView*>(
               &_DirectionsLeg_GuidanceView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DirectionsLeg_GuidanceView& a, DirectionsLeg_GuidanceView& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_GuidanceView* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_GuidanceView* New() const final {
    return new DirectionsLeg_GuidanceView();
  }

  DirectionsLeg_GuidanceView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_GuidanceView>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_GuidanceView& from);
  void MergeFrom(const DirectionsLeg_GuidanceView& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_GuidanceView* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.GuidanceView";
  }
  protected:
  explicit DirectionsLeg_GuidanceView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_GuidanceView_Type Type;
  static constexpr Type kJunction =
    DirectionsLeg_GuidanceView_Type_kJunction;
  static constexpr Type kSapa =
    DirectionsLeg_GuidanceView_Type_kSapa;
  static constexpr Type kTollbranch =
    DirectionsLeg_GuidanceView_Type_kTollbranch;
  static constexpr Type kAftertoll =
    DirectionsLeg_GuidanceView_Type_kAftertoll;
  static constexpr Type kEnt =
    DirectionsLeg_GuidanceView_Type_kEnt;
  static constexpr Type kExit =
    DirectionsLeg_GuidanceView_Type_kExit;
  static constexpr Type kCityreal =
    DirectionsLeg_GuidanceView_Type_kCityreal;
  static constexpr Type kDirectionboard =
    DirectionsLeg_GuidanceView_Type_kDirectionboard;
  static constexpr Type kSignboard =
    DirectionsLeg_GuidanceView_Type_kSignboard;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_GuidanceView_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DirectionsLeg_GuidanceView_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DirectionsLeg_GuidanceView_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DirectionsLeg_GuidanceView_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DirectionsLeg_GuidanceView_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DirectionsLeg_GuidanceView_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOverlayIdsFieldNumber = 4,
    kDataIdFieldNumber = 1,
    kBaseIdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // repeated string overlay_ids = 4;
  int overlay_ids_size() const;
  private:
  int _internal_overlay_ids_size() const;
  public:
  void clear_overlay_ids();
  const std::string& overlay_ids(int index) const;
  std::string* mutable_overlay_ids(int index);
  void set_overlay_ids(int index, const std::string& value);
  void set_overlay_ids(int index, std::string&& value);
  void set_overlay_ids(int index, const char* value);
  void set_overlay_ids(int index, const char* value, size_t size);
  std::string* add_overlay_ids();
  void add_overlay_ids(const std::string& value);
  void add_overlay_ids(std::string&& value);
  void add_overlay_ids(const char* value);
  void add_overlay_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& overlay_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_overlay_ids();
  private:
  const std::string& _internal_overlay_ids(int index) const;
  std::string* _internal_add_overlay_ids();
  public:

  // optional string data_id = 1;
  bool has_data_id() const;
  private:
  bool _internal_has_data_id() const;
  public:
  void clear_data_id();
  const std::string& data_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_id();
  void set_allocated_data_id(std::string* data_id);
  private:
  const std::string& _internal_data_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_id(const std::string& value);
  std::string* _internal_mutable_data_id();
  public:

  // optional string base_id = 3;
  bool has_base_id() const;
  private:
  bool _internal_has_base_id() const;
  public:
  void clear_base_id();
  const std::string& base_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_base_id();
  void set_allocated_base_id(std::string* base_id);
  private:
  const std::string& _internal_base_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_id(const std::string& value);
  std::string* _internal_mutable_base_id();
  public:

  // optional .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::DirectionsLeg_GuidanceView_Type type() const;
  void set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);
  private:
  ::valhalla::DirectionsLeg_GuidanceView_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.GuidanceView)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> overlay_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_id_;
  int type_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver_SignElement final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver.SignElement) */ {
 public:
  inline DirectionsLeg_Maneuver_SignElement() : DirectionsLeg_Maneuver_SignElement(nullptr) {}
  ~DirectionsLeg_Maneuver_SignElement() override;
  explicit constexpr DirectionsLeg_Maneuver_SignElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Maneuver_SignElement(const DirectionsLeg_Maneuver_SignElement& from);
  DirectionsLeg_Maneuver_SignElement(DirectionsLeg_Maneuver_SignElement&& from) noexcept
    : DirectionsLeg_Maneuver_SignElement() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Maneuver_SignElement& operator=(const DirectionsLeg_Maneuver_SignElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Maneuver_SignElement& operator=(DirectionsLeg_Maneuver_SignElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_Maneuver_SignElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Maneuver_SignElement* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Maneuver_SignElement*>(
               &_DirectionsLeg_Maneuver_SignElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DirectionsLeg_Maneuver_SignElement& a, DirectionsLeg_Maneuver_SignElement& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Maneuver_SignElement* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Maneuver_SignElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Maneuver_SignElement* New() const final {
    return new DirectionsLeg_Maneuver_SignElement();
  }

  DirectionsLeg_Maneuver_SignElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_Maneuver_SignElement>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Maneuver_SignElement& from);
  void MergeFrom(const DirectionsLeg_Maneuver_SignElement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Maneuver_SignElement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Maneuver.SignElement";
  }
  protected:
  explicit DirectionsLeg_Maneuver_SignElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kIsRouteNumberFieldNumber = 2,
    kConsecutiveCountFieldNumber = 3,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional bool is_route_number = 2;
  bool has_is_route_number() const;
  private:
  bool _internal_has_is_route_number() const;
  public:
  void clear_is_route_number();
  bool is_route_number() const;
  void set_is_route_number(bool value);
  private:
  bool _internal_is_route_number() const;
  void _internal_set_is_route_number(bool value);
  public:

  // optional uint32 consecutive_count = 3;
  bool has_consecutive_count() const;
  private:
  bool _internal_has_consecutive_count() const;
  public:
  void clear_consecutive_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 consecutive_count() const;
  void set_consecutive_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_consecutive_count() const;
  void _internal_set_consecutive_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver.SignElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  bool is_route_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 consecutive_count_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver_Sign final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver.Sign) */ {
 public:
  inline DirectionsLeg_Maneuver_Sign() : DirectionsLeg_Maneuver_Sign(nullptr) {}
  ~DirectionsLeg_Maneuver_Sign() override;
  explicit constexpr DirectionsLeg_Maneuver_Sign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Maneuver_Sign(const DirectionsLeg_Maneuver_Sign& from);
  DirectionsLeg_Maneuver_Sign(DirectionsLeg_Maneuver_Sign&& from) noexcept
    : DirectionsLeg_Maneuver_Sign() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Maneuver_Sign& operator=(const DirectionsLeg_Maneuver_Sign& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Maneuver_Sign& operator=(DirectionsLeg_Maneuver_Sign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_Maneuver_Sign& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Maneuver_Sign* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Maneuver_Sign*>(
               &_DirectionsLeg_Maneuver_Sign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DirectionsLeg_Maneuver_Sign& a, DirectionsLeg_Maneuver_Sign& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Maneuver_Sign* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Maneuver_Sign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Maneuver_Sign* New() const final {
    return new DirectionsLeg_Maneuver_Sign();
  }

  DirectionsLeg_Maneuver_Sign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_Maneuver_Sign>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Maneuver_Sign& from);
  void MergeFrom(const DirectionsLeg_Maneuver_Sign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Maneuver_Sign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Maneuver.Sign";
  }
  protected:
  explicit DirectionsLeg_Maneuver_Sign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExitNumbersFieldNumber = 1,
    kExitOntoStreetsFieldNumber = 2,
    kExitTowardLocationsFieldNumber = 3,
    kExitNamesFieldNumber = 4,
    kGuideOntoStreetsFieldNumber = 5,
    kGuideTowardLocationsFieldNumber = 6,
    kJunctionNamesFieldNumber = 7,
  };
  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
  int exit_numbers_size() const;
  private:
  int _internal_exit_numbers_size() const;
  public:
  void clear_exit_numbers();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_numbers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_numbers();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_exit_numbers(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_exit_numbers();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_numbers(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_numbers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_numbers() const;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
  int exit_onto_streets_size() const;
  private:
  int _internal_exit_onto_streets_size() const;
  public:
  void clear_exit_onto_streets();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_onto_streets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_onto_streets();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_exit_onto_streets(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_exit_onto_streets();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_onto_streets(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_onto_streets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_onto_streets() const;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
  int exit_toward_locations_size() const;
  private:
  int _internal_exit_toward_locations_size() const;
  public:
  void clear_exit_toward_locations();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_toward_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_toward_locations();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_exit_toward_locations(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_exit_toward_locations();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_toward_locations(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_toward_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_toward_locations() const;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
  int exit_names_size() const;
  private:
  int _internal_exit_names_size() const;
  public:
  void clear_exit_names();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_names();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_exit_names(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_exit_names();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_names(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_names() const;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement guide_onto_streets = 5;
  int guide_onto_streets_size() const;
  private:
  int _internal_guide_onto_streets_size() const;
  public:
  void clear_guide_onto_streets();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_guide_onto_streets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_guide_onto_streets();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_guide_onto_streets(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_guide_onto_streets();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& guide_onto_streets(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_guide_onto_streets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      guide_onto_streets() const;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement guide_toward_locations = 6;
  int guide_toward_locations_size() const;
  private:
  int _internal_guide_toward_locations_size() const;
  public:
  void clear_guide_toward_locations();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_guide_toward_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_guide_toward_locations();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_guide_toward_locations(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_guide_toward_locations();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& guide_toward_locations(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_guide_toward_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      guide_toward_locations() const;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement junction_names = 7;
  int junction_names_size() const;
  private:
  int _internal_junction_names_size() const;
  public:
  void clear_junction_names();
  ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_junction_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_junction_names();
  private:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& _internal_junction_names(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _internal_add_junction_names();
  public:
  const ::valhalla::DirectionsLeg_Maneuver_SignElement& junction_names(int index) const;
  ::valhalla::DirectionsLeg_Maneuver_SignElement* add_junction_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      junction_names() const;

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver.Sign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_numbers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_onto_streets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_toward_locations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > guide_onto_streets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > guide_toward_locations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > junction_names_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg.Maneuver) */ {
 public:
  inline DirectionsLeg_Maneuver() : DirectionsLeg_Maneuver(nullptr) {}
  ~DirectionsLeg_Maneuver() override;
  explicit constexpr DirectionsLeg_Maneuver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from);
  DirectionsLeg_Maneuver(DirectionsLeg_Maneuver&& from) noexcept
    : DirectionsLeg_Maneuver() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg_Maneuver& operator=(const DirectionsLeg_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg_Maneuver& operator=(DirectionsLeg_Maneuver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg_Maneuver& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg_Maneuver* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg_Maneuver*>(
               &_DirectionsLeg_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DirectionsLeg_Maneuver& a, DirectionsLeg_Maneuver& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg_Maneuver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg_Maneuver* New() const final {
    return new DirectionsLeg_Maneuver();
  }

  DirectionsLeg_Maneuver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg_Maneuver>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg_Maneuver& from);
  void MergeFrom(const DirectionsLeg_Maneuver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg_Maneuver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg.Maneuver";
  }
  protected:
  explicit DirectionsLeg_Maneuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Maneuver_SignElement SignElement;
  typedef DirectionsLeg_Maneuver_Sign Sign;

  typedef DirectionsLeg_Maneuver_CardinalDirection CardinalDirection;
  static constexpr CardinalDirection kNorth =
    DirectionsLeg_Maneuver_CardinalDirection_kNorth;
  static constexpr CardinalDirection kNorthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthEast;
  static constexpr CardinalDirection kEast =
    DirectionsLeg_Maneuver_CardinalDirection_kEast;
  static constexpr CardinalDirection kSouthEast =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthEast;
  static constexpr CardinalDirection kSouth =
    DirectionsLeg_Maneuver_CardinalDirection_kSouth;
  static constexpr CardinalDirection kSouthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kSouthWest;
  static constexpr CardinalDirection kWest =
    DirectionsLeg_Maneuver_CardinalDirection_kWest;
  static constexpr CardinalDirection kNorthWest =
    DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return DirectionsLeg_Maneuver_CardinalDirection_IsValid(value);
  }
  static constexpr CardinalDirection CardinalDirection_MIN =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static constexpr CardinalDirection CardinalDirection_MAX =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static constexpr int CardinalDirection_ARRAYSIZE =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CardinalDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CardinalDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CardinalDirection_Name.");
    return DirectionsLeg_Maneuver_CardinalDirection_Name(enum_t_value);
  }
  static inline bool CardinalDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CardinalDirection* value) {
    return DirectionsLeg_Maneuver_CardinalDirection_Parse(name, value);
  }

  typedef DirectionsLeg_Maneuver_Type Type;
  static constexpr Type kNone =
    DirectionsLeg_Maneuver_Type_kNone;
  static constexpr Type kStart =
    DirectionsLeg_Maneuver_Type_kStart;
  static constexpr Type kStartRight =
    DirectionsLeg_Maneuver_Type_kStartRight;
  static constexpr Type kStartLeft =
    DirectionsLeg_Maneuver_Type_kStartLeft;
  static constexpr Type kDestination =
    DirectionsLeg_Maneuver_Type_kDestination;
  static constexpr Type kDestinationRight =
    DirectionsLeg_Maneuver_Type_kDestinationRight;
  static constexpr Type kDestinationLeft =
    DirectionsLeg_Maneuver_Type_kDestinationLeft;
  static constexpr Type kBecomes =
    DirectionsLeg_Maneuver_Type_kBecomes;
  static constexpr Type kContinue =
    DirectionsLeg_Maneuver_Type_kContinue;
  static constexpr Type kSlightRight =
    DirectionsLeg_Maneuver_Type_kSlightRight;
  static constexpr Type kRight =
    DirectionsLeg_Maneuver_Type_kRight;
  static constexpr Type kSharpRight =
    DirectionsLeg_Maneuver_Type_kSharpRight;
  static constexpr Type kUturnRight =
    DirectionsLeg_Maneuver_Type_kUturnRight;
  static constexpr Type kUturnLeft =
    DirectionsLeg_Maneuver_Type_kUturnLeft;
  static constexpr Type kSharpLeft =
    DirectionsLeg_Maneuver_Type_kSharpLeft;
  static constexpr Type kLeft =
    DirectionsLeg_Maneuver_Type_kLeft;
  static constexpr Type kSlightLeft =
    DirectionsLeg_Maneuver_Type_kSlightLeft;
  static constexpr Type kRampStraight =
    DirectionsLeg_Maneuver_Type_kRampStraight;
  static constexpr Type kRampRight =
    DirectionsLeg_Maneuver_Type_kRampRight;
  static constexpr Type kRampLeft =
    DirectionsLeg_Maneuver_Type_kRampLeft;
  static constexpr Type kExitRight =
    DirectionsLeg_Maneuver_Type_kExitRight;
  static constexpr Type kExitLeft =
    DirectionsLeg_Maneuver_Type_kExitLeft;
  static constexpr Type kStayStraight =
    DirectionsLeg_Maneuver_Type_kStayStraight;
  static constexpr Type kStayRight =
    DirectionsLeg_Maneuver_Type_kStayRight;
  static constexpr Type kStayLeft =
    DirectionsLeg_Maneuver_Type_kStayLeft;
  static constexpr Type kMerge =
    DirectionsLeg_Maneuver_Type_kMerge;
  static constexpr Type kRoundaboutEnter =
    DirectionsLeg_Maneuver_Type_kRoundaboutEnter;
  static constexpr Type kRoundaboutExit =
    DirectionsLeg_Maneuver_Type_kRoundaboutExit;
  static constexpr Type kFerryEnter =
    DirectionsLeg_Maneuver_Type_kFerryEnter;
  static constexpr Type kFerryExit =
    DirectionsLeg_Maneuver_Type_kFerryExit;
  static constexpr Type kTransit =
    DirectionsLeg_Maneuver_Type_kTransit;
  static constexpr Type kTransitTransfer =
    DirectionsLeg_Maneuver_Type_kTransitTransfer;
  static constexpr Type kTransitRemainOn =
    DirectionsLeg_Maneuver_Type_kTransitRemainOn;
  static constexpr Type kTransitConnectionStart =
    DirectionsLeg_Maneuver_Type_kTransitConnectionStart;
  static constexpr Type kTransitConnectionTransfer =
    DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer;
  static constexpr Type kTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kTransitConnectionDestination;
  static constexpr Type kPostTransitConnectionDestination =
    DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination;
  static constexpr Type kMergeRight =
    DirectionsLeg_Maneuver_Type_kMergeRight;
  static constexpr Type kMergeLeft =
    DirectionsLeg_Maneuver_Type_kMergeLeft;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_Maneuver_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DirectionsLeg_Maneuver_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DirectionsLeg_Maneuver_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DirectionsLeg_Maneuver_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DirectionsLeg_Maneuver_Type_Parse(name, value);
  }

  typedef DirectionsLeg_Maneuver_BssManeuverType BssManeuverType;
  static constexpr BssManeuverType kNoneAction =
    DirectionsLeg_Maneuver_BssManeuverType_kNoneAction;
  static constexpr BssManeuverType kRentBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kRentBikeAtBikeShare;
  static constexpr BssManeuverType kReturnBikeAtBikeShare =
    DirectionsLeg_Maneuver_BssManeuverType_kReturnBikeAtBikeShare;
  static inline bool BssManeuverType_IsValid(int value) {
    return DirectionsLeg_Maneuver_BssManeuverType_IsValid(value);
  }
  static constexpr BssManeuverType BssManeuverType_MIN =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MIN;
  static constexpr BssManeuverType BssManeuverType_MAX =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_MAX;
  static constexpr int BssManeuverType_ARRAYSIZE =
    DirectionsLeg_Maneuver_BssManeuverType_BssManeuverType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BssManeuverType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BssManeuverType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BssManeuverType_Name.");
    return DirectionsLeg_Maneuver_BssManeuverType_Name(enum_t_value);
  }
  static inline bool BssManeuverType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BssManeuverType* value) {
    return DirectionsLeg_Maneuver_BssManeuverType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStreetNameFieldNumber = 3,
    kBeginStreetNameFieldNumber = 15,
    kRoundaboutExitStreetNamesFieldNumber = 32,
    kGuidanceViewsFieldNumber = 35,
    kTextInstructionFieldNumber = 2,
    kVerbalTransitionAlertInstructionFieldNumber = 12,
    kVerbalPreTransitionInstructionFieldNumber = 13,
    kVerbalPostTransitionInstructionFieldNumber = 14,
    kDepartInstructionFieldNumber = 18,
    kVerbalDepartInstructionFieldNumber = 19,
    kArriveInstructionFieldNumber = 20,
    kVerbalArriveInstructionFieldNumber = 21,
    kSignFieldNumber = 16,
    kTransitInfoFieldNumber = 22,
    kTypeFieldNumber = 1,
    kLengthFieldNumber = 4,
    kTimeFieldNumber = 5,
    kBeginCardinalDirectionFieldNumber = 6,
    kBeginHeadingFieldNumber = 7,
    kBeginShapeIndexFieldNumber = 8,
    kEndShapeIndexFieldNumber = 9,
    kRoundaboutExitCountFieldNumber = 17,
    kPortionsTollFieldNumber = 10,
    kPortionsUnpavedFieldNumber = 11,
    kVerbalMultiCueFieldNumber = 23,
    kToStayOnFieldNumber = 31,
    kTravelModeFieldNumber = 24,
    kVehicleTypeFieldNumber = 25,
    kPedestrianTypeFieldNumber = 26,
    kBicycleTypeFieldNumber = 27,
    kTransitTypeFieldNumber = 28,
    kBeginPathIndexFieldNumber = 29,
    kEndPathIndexFieldNumber = 30,
    kTurnDegreeFieldNumber = 33,
    kHasTimeRestrictionsFieldNumber = 34,
    kBssManeuverTypeFieldNumber = 36,
  };
  // repeated .valhalla.StreetName street_name = 3;
  int street_name_size() const;
  private:
  int _internal_street_name_size() const;
  public:
  void clear_street_name();
  ::valhalla::StreetName* mutable_street_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_name();
  private:
  const ::valhalla::StreetName& _internal_street_name(int index) const;
  ::valhalla::StreetName* _internal_add_street_name();
  public:
  const ::valhalla::StreetName& street_name(int index) const;
  ::valhalla::StreetName* add_street_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      street_name() const;

  // repeated .valhalla.StreetName begin_street_name = 15;
  int begin_street_name_size() const;
  private:
  int _internal_begin_street_name_size() const;
  public:
  void clear_begin_street_name();
  ::valhalla::StreetName* mutable_begin_street_name(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_begin_street_name();
  private:
  const ::valhalla::StreetName& _internal_begin_street_name(int index) const;
  ::valhalla::StreetName* _internal_add_begin_street_name();
  public:
  const ::valhalla::StreetName& begin_street_name(int index) const;
  ::valhalla::StreetName* add_begin_street_name();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      begin_street_name() const;

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  int roundabout_exit_street_names_size() const;
  private:
  int _internal_roundabout_exit_street_names_size() const;
  public:
  void clear_roundabout_exit_street_names();
  ::valhalla::StreetName* mutable_roundabout_exit_street_names(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_roundabout_exit_street_names();
  private:
  const ::valhalla::StreetName& _internal_roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* _internal_add_roundabout_exit_street_names();
  public:
  const ::valhalla::StreetName& roundabout_exit_street_names(int index) const;
  ::valhalla::StreetName* add_roundabout_exit_street_names();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
      roundabout_exit_street_names() const;

  // repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
  int guidance_views_size() const;
  private:
  int _internal_guidance_views_size() const;
  public:
  void clear_guidance_views();
  ::valhalla::DirectionsLeg_GuidanceView* mutable_guidance_views(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
      mutable_guidance_views();
  private:
  const ::valhalla::DirectionsLeg_GuidanceView& _internal_guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* _internal_add_guidance_views();
  public:
  const ::valhalla::DirectionsLeg_GuidanceView& guidance_views(int index) const;
  ::valhalla::DirectionsLeg_GuidanceView* add_guidance_views();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
      guidance_views() const;

  // optional string text_instruction = 2;
  bool has_text_instruction() const;
  private:
  bool _internal_has_text_instruction() const;
  public:
  void clear_text_instruction();
  const std::string& text_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_text_instruction();
  void set_allocated_text_instruction(std::string* text_instruction);
  private:
  const std::string& _internal_text_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_instruction(const std::string& value);
  std::string* _internal_mutable_text_instruction();
  public:

  // optional string verbal_transition_alert_instruction = 12;
  bool has_verbal_transition_alert_instruction() const;
  private:
  bool _internal_has_verbal_transition_alert_instruction() const;
  public:
  void clear_verbal_transition_alert_instruction();
  const std::string& verbal_transition_alert_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_transition_alert_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_transition_alert_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_transition_alert_instruction();
  void set_allocated_verbal_transition_alert_instruction(std::string* verbal_transition_alert_instruction);
  private:
  const std::string& _internal_verbal_transition_alert_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_transition_alert_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_transition_alert_instruction();
  public:

  // optional string verbal_pre_transition_instruction = 13;
  bool has_verbal_pre_transition_instruction() const;
  private:
  bool _internal_has_verbal_pre_transition_instruction() const;
  public:
  void clear_verbal_pre_transition_instruction();
  const std::string& verbal_pre_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_pre_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_pre_transition_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_pre_transition_instruction();
  void set_allocated_verbal_pre_transition_instruction(std::string* verbal_pre_transition_instruction);
  private:
  const std::string& _internal_verbal_pre_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_pre_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_pre_transition_instruction();
  public:

  // optional string verbal_post_transition_instruction = 14;
  bool has_verbal_post_transition_instruction() const;
  private:
  bool _internal_has_verbal_post_transition_instruction() const;
  public:
  void clear_verbal_post_transition_instruction();
  const std::string& verbal_post_transition_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_post_transition_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_post_transition_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_post_transition_instruction();
  void set_allocated_verbal_post_transition_instruction(std::string* verbal_post_transition_instruction);
  private:
  const std::string& _internal_verbal_post_transition_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_post_transition_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_post_transition_instruction();
  public:

  // optional string depart_instruction = 18;
  bool has_depart_instruction() const;
  private:
  bool _internal_has_depart_instruction() const;
  public:
  void clear_depart_instruction();
  const std::string& depart_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_depart_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_depart_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_depart_instruction();
  void set_allocated_depart_instruction(std::string* depart_instruction);
  private:
  const std::string& _internal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_depart_instruction(const std::string& value);
  std::string* _internal_mutable_depart_instruction();
  public:

  // optional string verbal_depart_instruction = 19;
  bool has_verbal_depart_instruction() const;
  private:
  bool _internal_has_verbal_depart_instruction() const;
  public:
  void clear_verbal_depart_instruction();
  const std::string& verbal_depart_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_depart_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_depart_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_depart_instruction();
  void set_allocated_verbal_depart_instruction(std::string* verbal_depart_instruction);
  private:
  const std::string& _internal_verbal_depart_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_depart_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_depart_instruction();
  public:

  // optional string arrive_instruction = 20;
  bool has_arrive_instruction() const;
  private:
  bool _internal_has_arrive_instruction() const;
  public:
  void clear_arrive_instruction();
  const std::string& arrive_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arrive_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arrive_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_arrive_instruction();
  void set_allocated_arrive_instruction(std::string* arrive_instruction);
  private:
  const std::string& _internal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrive_instruction(const std::string& value);
  std::string* _internal_mutable_arrive_instruction();
  public:

  // optional string verbal_arrive_instruction = 21;
  bool has_verbal_arrive_instruction() const;
  private:
  bool _internal_has_verbal_arrive_instruction() const;
  public:
  void clear_verbal_arrive_instruction();
  const std::string& verbal_arrive_instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_verbal_arrive_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_verbal_arrive_instruction();
  PROTOBUF_MUST_USE_RESULT std::string* release_verbal_arrive_instruction();
  void set_allocated_verbal_arrive_instruction(std::string* verbal_arrive_instruction);
  private:
  const std::string& _internal_verbal_arrive_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verbal_arrive_instruction(const std::string& value);
  std::string* _internal_mutable_verbal_arrive_instruction();
  public:

  // optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const ::valhalla::DirectionsLeg_Maneuver_Sign& sign() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::DirectionsLeg_Maneuver_Sign* release_sign();
  ::valhalla::DirectionsLeg_Maneuver_Sign* mutable_sign();
  void set_allocated_sign(::valhalla::DirectionsLeg_Maneuver_Sign* sign);
  private:
  const ::valhalla::DirectionsLeg_Maneuver_Sign& _internal_sign() const;
  ::valhalla::DirectionsLeg_Maneuver_Sign* _internal_mutable_sign();
  public:
  void unsafe_arena_set_allocated_sign(
      ::valhalla::DirectionsLeg_Maneuver_Sign* sign);
  ::valhalla::DirectionsLeg_Maneuver_Sign* unsafe_arena_release_sign();

  // optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
  bool has_transit_info() const;
  private:
  bool _internal_has_transit_info() const;
  public:
  void clear_transit_info();
  const ::valhalla::DirectionsLeg_TransitInfo& transit_info() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::DirectionsLeg_TransitInfo* release_transit_info();
  ::valhalla::DirectionsLeg_TransitInfo* mutable_transit_info();
  void set_allocated_transit_info(::valhalla::DirectionsLeg_TransitInfo* transit_info);
  private:
  const ::valhalla::DirectionsLeg_TransitInfo& _internal_transit_info() const;
  ::valhalla::DirectionsLeg_TransitInfo* _internal_mutable_transit_info();
  public:
  void unsafe_arena_set_allocated_transit_info(
      ::valhalla::DirectionsLeg_TransitInfo* transit_info);
  ::valhalla::DirectionsLeg_TransitInfo* unsafe_arena_release_transit_info();

  // optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::valhalla::DirectionsLeg_Maneuver_Type type() const;
  void set_type(::valhalla::DirectionsLeg_Maneuver_Type value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_Type _internal_type() const;
  void _internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value);
  public:

  // optional float length = 4;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // optional double time = 5;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  bool has_begin_cardinal_direction() const;
  private:
  bool _internal_has_begin_cardinal_direction() const;
  public:
  void clear_begin_cardinal_direction();
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection begin_cardinal_direction() const;
  void set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_CardinalDirection _internal_begin_cardinal_direction() const;
  void _internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);
  public:

  // optional uint32 begin_heading = 7;
  bool has_begin_heading() const;
  private:
  bool _internal_has_begin_heading() const;
  public:
  void clear_begin_heading();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_heading() const;
  void set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_heading() const;
  void _internal_set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 begin_shape_index = 8;
  bool has_begin_shape_index() const;
  private:
  bool _internal_has_begin_shape_index() const;
  public:
  void clear_begin_shape_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_shape_index() const;
  void set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_shape_index() const;
  void _internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 end_shape_index = 9;
  bool has_end_shape_index() const;
  private:
  bool _internal_has_end_shape_index() const;
  public:
  void clear_end_shape_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_shape_index() const;
  void set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_shape_index() const;
  void _internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 roundabout_exit_count = 17;
  bool has_roundabout_exit_count() const;
  private:
  bool _internal_has_roundabout_exit_count() const;
  public:
  void clear_roundabout_exit_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 roundabout_exit_count() const;
  void set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_roundabout_exit_count() const;
  void _internal_set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool portions_toll = 10;
  bool has_portions_toll() const;
  private:
  bool _internal_has_portions_toll() const;
  public:
  void clear_portions_toll();
  bool portions_toll() const;
  void set_portions_toll(bool value);
  private:
  bool _internal_portions_toll() const;
  void _internal_set_portions_toll(bool value);
  public:

  // optional bool portions_unpaved = 11;
  bool has_portions_unpaved() const;
  private:
  bool _internal_has_portions_unpaved() const;
  public:
  void clear_portions_unpaved();
  bool portions_unpaved() const;
  void set_portions_unpaved(bool value);
  private:
  bool _internal_portions_unpaved() const;
  void _internal_set_portions_unpaved(bool value);
  public:

  // optional bool verbal_multi_cue = 23;
  bool has_verbal_multi_cue() const;
  private:
  bool _internal_has_verbal_multi_cue() const;
  public:
  void clear_verbal_multi_cue();
  bool verbal_multi_cue() const;
  void set_verbal_multi_cue(bool value);
  private:
  bool _internal_verbal_multi_cue() const;
  void _internal_set_verbal_multi_cue(bool value);
  public:

  // optional bool to_stay_on = 31;
  bool has_to_stay_on() const;
  private:
  bool _internal_has_to_stay_on() const;
  public:
  void clear_to_stay_on();
  bool to_stay_on() const;
  void set_to_stay_on(bool value);
  private:
  bool _internal_to_stay_on() const;
  void _internal_set_to_stay_on(bool value);
  public:

  // optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
  bool has_travel_mode() const;
  private:
  bool _internal_has_travel_mode() const;
  public:
  void clear_travel_mode();
  ::valhalla::DirectionsLeg_TravelMode travel_mode() const;
  void set_travel_mode(::valhalla::DirectionsLeg_TravelMode value);
  private:
  ::valhalla::DirectionsLeg_TravelMode _internal_travel_mode() const;
  void _internal_set_travel_mode(::valhalla::DirectionsLeg_TravelMode value);
  public:

  // optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
  bool has_vehicle_type() const;
  private:
  bool _internal_has_vehicle_type() const;
  public:
  void clear_vehicle_type();
  ::valhalla::DirectionsLeg_VehicleType vehicle_type() const;
  void set_vehicle_type(::valhalla::DirectionsLeg_VehicleType value);
  private:
  ::valhalla::DirectionsLeg_VehicleType _internal_vehicle_type() const;
  void _internal_set_vehicle_type(::valhalla::DirectionsLeg_VehicleType value);
  public:

  // optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
  bool has_pedestrian_type() const;
  private:
  bool _internal_has_pedestrian_type() const;
  public:
  void clear_pedestrian_type();
  ::valhalla::DirectionsLeg_PedestrianType pedestrian_type() const;
  void set_pedestrian_type(::valhalla::DirectionsLeg_PedestrianType value);
  private:
  ::valhalla::DirectionsLeg_PedestrianType _internal_pedestrian_type() const;
  void _internal_set_pedestrian_type(::valhalla::DirectionsLeg_PedestrianType value);
  public:

  // optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
  bool has_bicycle_type() const;
  private:
  bool _internal_has_bicycle_type() const;
  public:
  void clear_bicycle_type();
  ::valhalla::DirectionsLeg_BicycleType bicycle_type() const;
  void set_bicycle_type(::valhalla::DirectionsLeg_BicycleType value);
  private:
  ::valhalla::DirectionsLeg_BicycleType _internal_bicycle_type() const;
  void _internal_set_bicycle_type(::valhalla::DirectionsLeg_BicycleType value);
  public:

  // optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
  bool has_transit_type() const;
  private:
  bool _internal_has_transit_type() const;
  public:
  void clear_transit_type();
  ::valhalla::DirectionsLeg_TransitType transit_type() const;
  void set_transit_type(::valhalla::DirectionsLeg_TransitType value);
  private:
  ::valhalla::DirectionsLeg_TransitType _internal_transit_type() const;
  void _internal_set_transit_type(::valhalla::DirectionsLeg_TransitType value);
  public:

  // optional uint32 begin_path_index = 29;
  bool has_begin_path_index() const;
  private:
  bool _internal_has_begin_path_index() const;
  public:
  void clear_begin_path_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_path_index() const;
  void set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_path_index() const;
  void _internal_set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 end_path_index = 30;
  bool has_end_path_index() const;
  private:
  bool _internal_has_end_path_index() const;
  public:
  void clear_end_path_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_path_index() const;
  void set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_path_index() const;
  void _internal_set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 turn_degree = 33;
  bool has_turn_degree() const;
  private:
  bool _internal_has_turn_degree() const;
  public:
  void clear_turn_degree();
  ::PROTOBUF_NAMESPACE_ID::uint32 turn_degree() const;
  void set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_turn_degree() const;
  void _internal_set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool has_time_restrictions = 34;
  bool has_has_time_restrictions() const;
  private:
  bool _internal_has_has_time_restrictions() const;
  public:
  void clear_has_time_restrictions();
  bool has_time_restrictions() const;
  void set_has_time_restrictions(bool value);
  private:
  bool _internal_has_time_restrictions() const;
  void _internal_set_has_time_restrictions(bool value);
  public:

  // optional .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
  bool has_bss_maneuver_type() const;
  private:
  bool _internal_has_bss_maneuver_type() const;
  public:
  void clear_bss_maneuver_type();
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType bss_maneuver_type() const;
  void set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);
  private:
  ::valhalla::DirectionsLeg_Maneuver_BssManeuverType _internal_bss_maneuver_type() const;
  void _internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > street_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > begin_street_name_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName > roundabout_exit_street_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView > guidance_views_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_transition_alert_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_pre_transition_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_post_transition_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr depart_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_depart_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arrive_instruction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbal_arrive_instruction_;
  ::valhalla::DirectionsLeg_Maneuver_Sign* sign_;
  ::valhalla::DirectionsLeg_TransitInfo* transit_info_;
  int type_;
  float length_;
  double time_;
  int begin_cardinal_direction_;
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_heading_;
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_shape_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 end_shape_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 roundabout_exit_count_;
  bool portions_toll_;
  bool portions_unpaved_;
  bool verbal_multi_cue_;
  bool to_stay_on_;
  int travel_mode_;
  int vehicle_type_;
  int pedestrian_type_;
  int bicycle_type_;
  int transit_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_path_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 end_path_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 turn_degree_;
  bool has_time_restrictions_;
  int bss_maneuver_type_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsLeg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsLeg) */ {
 public:
  inline DirectionsLeg() : DirectionsLeg(nullptr) {}
  ~DirectionsLeg() override;
  explicit constexpr DirectionsLeg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsLeg(const DirectionsLeg& from);
  DirectionsLeg(DirectionsLeg&& from) noexcept
    : DirectionsLeg() {
    *this = ::std::move(from);
  }

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsLeg& operator=(DirectionsLeg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsLeg& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsLeg* internal_default_instance() {
    return reinterpret_cast<const DirectionsLeg*>(
               &_DirectionsLeg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DirectionsLeg& a, DirectionsLeg& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsLeg* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsLeg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsLeg* New() const final {
    return new DirectionsLeg();
  }

  DirectionsLeg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsLeg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsLeg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsLeg";
  }
  protected:
  explicit DirectionsLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Summary Summary;
  typedef DirectionsLeg_TransitInfo TransitInfo;
  typedef DirectionsLeg_GuidanceView GuidanceView;
  typedef DirectionsLeg_Maneuver Maneuver;

  typedef DirectionsLeg_TravelMode TravelMode;
  static constexpr TravelMode kDrive =
    DirectionsLeg_TravelMode_kDrive;
  static constexpr TravelMode kPedestrian =
    DirectionsLeg_TravelMode_kPedestrian;
  static constexpr TravelMode kBicycle =
    DirectionsLeg_TravelMode_kBicycle;
  static constexpr TravelMode kTransit =
    DirectionsLeg_TravelMode_kTransit;
  static inline bool TravelMode_IsValid(int value) {
    return DirectionsLeg_TravelMode_IsValid(value);
  }
  static constexpr TravelMode TravelMode_MIN =
    DirectionsLeg_TravelMode_TravelMode_MIN;
  static constexpr TravelMode TravelMode_MAX =
    DirectionsLeg_TravelMode_TravelMode_MAX;
  static constexpr int TravelMode_ARRAYSIZE =
    DirectionsLeg_TravelMode_TravelMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TravelMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TravelMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TravelMode_Name.");
    return DirectionsLeg_TravelMode_Name(enum_t_value);
  }
  static inline bool TravelMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TravelMode* value) {
    return DirectionsLeg_TravelMode_Parse(name, value);
  }

  typedef DirectionsLeg_VehicleType VehicleType;
  static constexpr VehicleType kCar =
    DirectionsLeg_VehicleType_kCar;
  static constexpr VehicleType kMotorcycle =
    DirectionsLeg_VehicleType_kMotorcycle;
  static constexpr VehicleType kAutoBus =
    DirectionsLeg_VehicleType_kAutoBus;
  static constexpr VehicleType kTractorTrailer =
    DirectionsLeg_VehicleType_kTractorTrailer;
  static constexpr VehicleType kMotorScooter =
    DirectionsLeg_VehicleType_kMotorScooter;
  static inline bool VehicleType_IsValid(int value) {
    return DirectionsLeg_VehicleType_IsValid(value);
  }
  static constexpr VehicleType VehicleType_MIN =
    DirectionsLeg_VehicleType_VehicleType_MIN;
  static constexpr VehicleType VehicleType_MAX =
    DirectionsLeg_VehicleType_VehicleType_MAX;
  static constexpr int VehicleType_ARRAYSIZE =
    DirectionsLeg_VehicleType_VehicleType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& VehicleType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VehicleType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VehicleType_Name.");
    return DirectionsLeg_VehicleType_Name(enum_t_value);
  }
  static inline bool VehicleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      VehicleType* value) {
    return DirectionsLeg_VehicleType_Parse(name, value);
  }

  typedef DirectionsLeg_PedestrianType PedestrianType;
  static constexpr PedestrianType kFoot =
    DirectionsLeg_PedestrianType_kFoot;
  static constexpr PedestrianType kWheelchair =
    DirectionsLeg_PedestrianType_kWheelchair;
  static constexpr PedestrianType kSegway =
    DirectionsLeg_PedestrianType_kSegway;
  static inline bool PedestrianType_IsValid(int value) {
    return DirectionsLeg_PedestrianType_IsValid(value);
  }
  static constexpr PedestrianType PedestrianType_MIN =
    DirectionsLeg_PedestrianType_PedestrianType_MIN;
  static constexpr PedestrianType PedestrianType_MAX =
    DirectionsLeg_PedestrianType_PedestrianType_MAX;
  static constexpr int PedestrianType_ARRAYSIZE =
    DirectionsLeg_PedestrianType_PedestrianType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PedestrianType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PedestrianType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PedestrianType_Name.");
    return DirectionsLeg_PedestrianType_Name(enum_t_value);
  }
  static inline bool PedestrianType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PedestrianType* value) {
    return DirectionsLeg_PedestrianType_Parse(name, value);
  }

  typedef DirectionsLeg_BicycleType BicycleType;
  static constexpr BicycleType kRoad =
    DirectionsLeg_BicycleType_kRoad;
  static constexpr BicycleType kCross =
    DirectionsLeg_BicycleType_kCross;
  static constexpr BicycleType kHybrid =
    DirectionsLeg_BicycleType_kHybrid;
  static constexpr BicycleType kMountain =
    DirectionsLeg_BicycleType_kMountain;
  static inline bool BicycleType_IsValid(int value) {
    return DirectionsLeg_BicycleType_IsValid(value);
  }
  static constexpr BicycleType BicycleType_MIN =
    DirectionsLeg_BicycleType_BicycleType_MIN;
  static constexpr BicycleType BicycleType_MAX =
    DirectionsLeg_BicycleType_BicycleType_MAX;
  static constexpr int BicycleType_ARRAYSIZE =
    DirectionsLeg_BicycleType_BicycleType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BicycleType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BicycleType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BicycleType_Name.");
    return DirectionsLeg_BicycleType_Name(enum_t_value);
  }
  static inline bool BicycleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BicycleType* value) {
    return DirectionsLeg_BicycleType_Parse(name, value);
  }

  typedef DirectionsLeg_TransitType TransitType;
  static constexpr TransitType kTram =
    DirectionsLeg_TransitType_kTram;
  static constexpr TransitType kMetro =
    DirectionsLeg_TransitType_kMetro;
  static constexpr TransitType kRail =
    DirectionsLeg_TransitType_kRail;
  static constexpr TransitType kBus =
    DirectionsLeg_TransitType_kBus;
  static constexpr TransitType kFerry =
    DirectionsLeg_TransitType_kFerry;
  static constexpr TransitType kCableCar =
    DirectionsLeg_TransitType_kCableCar;
  static constexpr TransitType kGondola =
    DirectionsLeg_TransitType_kGondola;
  static constexpr TransitType kFunicular =
    DirectionsLeg_TransitType_kFunicular;
  static inline bool TransitType_IsValid(int value) {
    return DirectionsLeg_TransitType_IsValid(value);
  }
  static constexpr TransitType TransitType_MIN =
    DirectionsLeg_TransitType_TransitType_MIN;
  static constexpr TransitType TransitType_MAX =
    DirectionsLeg_TransitType_TransitType_MAX;
  static constexpr int TransitType_ARRAYSIZE =
    DirectionsLeg_TransitType_TransitType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TransitType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TransitType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TransitType_Name.");
    return DirectionsLeg_TransitType_Name(enum_t_value);
  }
  static inline bool TransitType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TransitType* value) {
    return DirectionsLeg_TransitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 4,
    kManeuverFieldNumber = 6,
    kShapeFieldNumber = 7,
    kSummaryFieldNumber = 5,
    kTripIdFieldNumber = 1,
    kLegIdFieldNumber = 2,
    kLegCountFieldNumber = 3,
  };
  // repeated .valhalla.Location location = 4;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::valhalla::Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();
  private:
  const ::valhalla::Location& _internal_location(int index) const;
  ::valhalla::Location* _internal_add_location();
  public:
  const ::valhalla::Location& location(int index) const;
  ::valhalla::Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
      location() const;

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  int maneuver_size() const;
  private:
  int _internal_maneuver_size() const;
  public:
  void clear_maneuver();
  ::valhalla::DirectionsLeg_Maneuver* mutable_maneuver(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
      mutable_maneuver();
  private:
  const ::valhalla::DirectionsLeg_Maneuver& _internal_maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* _internal_add_maneuver();
  public:
  const ::valhalla::DirectionsLeg_Maneuver& maneuver(int index) const;
  ::valhalla::DirectionsLeg_Maneuver* add_maneuver();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
      maneuver() const;

  // optional string shape = 7;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const std::string& shape() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape();
  PROTOBUF_MUST_USE_RESULT std::string* release_shape();
  void set_allocated_shape(std::string* shape);
  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(const std::string& value);
  std::string* _internal_mutable_shape();
  public:

  // optional .valhalla.DirectionsLeg.Summary summary = 5;
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const ::valhalla::DirectionsLeg_Summary& summary() const;
  PROTOBUF_MUST_USE_RESULT ::valhalla::DirectionsLeg_Summary* release_summary();
  ::valhalla::DirectionsLeg_Summary* mutable_summary();
  void set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary);
  private:
  const ::valhalla::DirectionsLeg_Summary& _internal_summary() const;
  ::valhalla::DirectionsLeg_Summary* _internal_mutable_summary();
  public:
  void unsafe_arena_set_allocated_summary(
      ::valhalla::DirectionsLeg_Summary* summary);
  ::valhalla::DirectionsLeg_Summary* unsafe_arena_release_summary();

  // optional uint64 trip_id = 1;
  bool has_trip_id() const;
  private:
  bool _internal_has_trip_id() const;
  public:
  void clear_trip_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 trip_id() const;
  void set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_trip_id() const;
  void _internal_set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 leg_id = 2;
  bool has_leg_id() const;
  private:
  bool _internal_has_leg_id() const;
  public:
  void clear_leg_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 leg_id() const;
  void set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leg_id() const;
  void _internal_set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 leg_count = 3;
  bool has_leg_count() const;
  private:
  bool _internal_has_leg_count() const;
  public:
  void clear_leg_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 leg_count() const;
  void set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leg_count() const;
  void _internal_set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location > location_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver > maneuver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_;
  ::valhalla::DirectionsLeg_Summary* summary_;
  ::PROTOBUF_NAMESPACE_ID::uint64 trip_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leg_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leg_count_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class DirectionsRoute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.DirectionsRoute) */ {
 public:
  inline DirectionsRoute() : DirectionsRoute(nullptr) {}
  ~DirectionsRoute() override;
  explicit constexpr DirectionsRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectionsRoute(const DirectionsRoute& from);
  DirectionsRoute(DirectionsRoute&& from) noexcept
    : DirectionsRoute() {
    *this = ::std::move(from);
  }

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectionsRoute& operator=(DirectionsRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DirectionsRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectionsRoute* internal_default_instance() {
    return reinterpret_cast<const DirectionsRoute*>(
               &_DirectionsRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DirectionsRoute& a, DirectionsRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectionsRoute* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectionsRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectionsRoute* New() const final {
    return new DirectionsRoute();
  }

  DirectionsRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectionsRoute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectionsRoute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.DirectionsRoute";
  }
  protected:
  explicit DirectionsRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegsFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsLeg legs = 1;
  int legs_size() const;
  private:
  int _internal_legs_size() const;
  public:
  void clear_legs();
  ::valhalla::DirectionsLeg* mutable_legs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >*
      mutable_legs();
  private:
  const ::valhalla::DirectionsLeg& _internal_legs(int index) const;
  ::valhalla::DirectionsLeg* _internal_add_legs();
  public:
  const ::valhalla::DirectionsLeg& legs(int index) const;
  ::valhalla::DirectionsLeg* add_legs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >&
      legs() const;

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg > legs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_directions_2eproto;
};
// -------------------------------------------------------------------

class Directions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:valhalla.Directions) */ {
 public:
  inline Directions() : Directions(nullptr) {}
  ~Directions() override;
  explicit constexpr Directions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Directions(const Directions& from);
  Directions(Directions&& from) noexcept
    : Directions() {
    *this = ::std::move(from);
  }

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }
  inline Directions& operator=(Directions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Directions& default_instance() {
    return *internal_default_instance();
  }
  static inline const Directions* internal_default_instance() {
    return reinterpret_cast<const Directions*>(
               &_Directions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Directions& a, Directions& b) {
    a.Swap(&b);
  }
  inline void Swap(Directions* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Directions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Directions* New() const final {
    return new Directions();
  }

  Directions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Directions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Directions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "valhalla.Directions";
  }
  protected:
  explicit Directions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutesFieldNumber = 1,
  };
  // repeated .valhalla.DirectionsRoute routes = 1;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::valhalla::DirectionsRoute* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >*
      mutable_routes();
  private:
  const ::valhalla::DirectionsRoute& _internal_routes(int index) const;
  ::valhalla::DirectionsRoute* _internal_add_routes();
  public:
  const ::valhalla::DirectionsRoute& routes(int index) const;
  ::valhalla::DirectionsRoute* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >&
      routes() const;

  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute > routes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_directions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DirectionsLeg_Summary

// optional float length = 1;
inline bool DirectionsLeg_Summary::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionsLeg_Summary::has_length() const {
  return _internal_has_length();
}
inline void DirectionsLeg_Summary::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float DirectionsLeg_Summary::_internal_length() const {
  return length_;
}
inline float DirectionsLeg_Summary::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.length)
  return _internal_length();
}
inline void DirectionsLeg_Summary::_internal_set_length(float value) {
  _has_bits_[0] |= 0x00000004u;
  length_ = value;
}
inline void DirectionsLeg_Summary::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.length)
}

// optional double time = 2;
inline bool DirectionsLeg_Summary::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectionsLeg_Summary::has_time() const {
  return _internal_has_time();
}
inline void DirectionsLeg_Summary::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double DirectionsLeg_Summary::_internal_time() const {
  return time_;
}
inline double DirectionsLeg_Summary::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.time)
  return _internal_time();
}
inline void DirectionsLeg_Summary::_internal_set_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  time_ = value;
}
inline void DirectionsLeg_Summary::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.time)
}

// optional .valhalla.BoundingBox bbox = 3;
inline bool DirectionsLeg_Summary::_internal_has_bbox() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bbox_ != nullptr);
  return value;
}
inline bool DirectionsLeg_Summary::has_bbox() const {
  return _internal_has_bbox();
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::_internal_bbox() const {
  const ::valhalla::BoundingBox* p = bbox_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::BoundingBox&>(
      ::valhalla::_BoundingBox_default_instance_);
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::bbox() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.bbox)
  return _internal_bbox();
}
inline void DirectionsLeg_Summary::unsafe_arena_set_allocated_bbox(
    ::valhalla::BoundingBox* bbox) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox_);
  }
  bbox_ = bbox;
  if (bbox) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::release_bbox() {
  _has_bits_[0] &= ~0x00000001u;
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::unsafe_arena_release_bbox() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Summary.bbox)
  _has_bits_[0] &= ~0x00000001u;
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = nullptr;
  return temp;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::_internal_mutable_bbox() {
  _has_bits_[0] |= 0x00000001u;
  if (bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::BoundingBox>(GetArenaForAllocation());
    bbox_ = p;
  }
  return bbox_;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::mutable_bbox() {
  ::valhalla::BoundingBox* _msg = _internal_mutable_bbox();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Summary.bbox)
  return _msg;
}
inline void DirectionsLeg_Summary::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox_);
  }
  if (bbox) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bbox));
    if (message_arena != submessage_arena) {
      bbox = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bbox, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bbox_ = bbox;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Summary.bbox)
}

// optional bool has_time_restrictions = 4;
inline bool DirectionsLeg_Summary::_internal_has_has_time_restrictions() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DirectionsLeg_Summary::has_has_time_restrictions() const {
  return _internal_has_has_time_restrictions();
}
inline void DirectionsLeg_Summary::clear_has_time_restrictions() {
  has_time_restrictions_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DirectionsLeg_Summary::_internal_has_time_restrictions() const {
  return has_time_restrictions_;
}
inline bool DirectionsLeg_Summary::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Summary.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Summary::_internal_set_has_time_restrictions(bool value) {
  _has_bits_[0] |= 0x00000008u;
  has_time_restrictions_ = value;
}
inline void DirectionsLeg_Summary::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Summary.has_time_restrictions)
}

// -------------------------------------------------------------------

// DirectionsLeg_TransitInfo

// optional string onestop_id = 1;
inline bool DirectionsLeg_TransitInfo::_internal_has_onestop_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_onestop_id() const {
  return _internal_has_onestop_id();
}
inline void DirectionsLeg_TransitInfo::clear_onestop_id() {
  onestop_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectionsLeg_TransitInfo::onestop_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.onestop_id)
  return _internal_onestop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_onestop_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.onestop_id)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_onestop_id() {
  std::string* _s = _internal_mutable_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.onestop_id)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_onestop_id() const {
  return onestop_id_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_onestop_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
  return onestop_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_onestop_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.onestop_id)
  if (!_internal_has_onestop_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return onestop_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_onestop_id(std::string* onestop_id) {
  if (onestop_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  onestop_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), onestop_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.onestop_id)
}

// optional string short_name = 2;
inline bool DirectionsLeg_TransitInfo::_internal_has_short_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_short_name() const {
  return _internal_has_short_name();
}
inline void DirectionsLeg_TransitInfo::clear_short_name() {
  short_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DirectionsLeg_TransitInfo::short_name() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.short_name)
  return _internal_short_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_short_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 short_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.short_name)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_short_name() {
  std::string* _s = _internal_mutable_short_name();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.short_name)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_short_name() const {
  return short_name_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_short_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  short_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_short_name() {
  _has_bits_[0] |= 0x00000002u;
  return short_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_short_name() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.short_name)
  if (!_internal_has_short_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return short_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_short_name(std::string* short_name) {
  if (short_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  short_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), short_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.short_name)
}

// optional string long_name = 3;
inline bool DirectionsLeg_TransitInfo::_internal_has_long_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_long_name() const {
  return _internal_has_long_name();
}
inline void DirectionsLeg_TransitInfo::clear_long_name() {
  long_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DirectionsLeg_TransitInfo::long_name() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.long_name)
  return _internal_long_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_long_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 long_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.long_name)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_long_name() {
  std::string* _s = _internal_mutable_long_name();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.long_name)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_long_name() const {
  return long_name_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_long_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  long_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_long_name() {
  _has_bits_[0] |= 0x00000004u;
  return long_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_long_name() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.long_name)
  if (!_internal_has_long_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return long_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_long_name(std::string* long_name) {
  if (long_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  long_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), long_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.long_name)
}

// optional string headsign = 4;
inline bool DirectionsLeg_TransitInfo::_internal_has_headsign() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_headsign() const {
  return _internal_has_headsign();
}
inline void DirectionsLeg_TransitInfo::clear_headsign() {
  headsign_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DirectionsLeg_TransitInfo::headsign() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.headsign)
  return _internal_headsign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_headsign(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 headsign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.headsign)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_headsign() {
  std::string* _s = _internal_mutable_headsign();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.headsign)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_headsign() const {
  return headsign_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_headsign(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  headsign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_headsign() {
  _has_bits_[0] |= 0x00000008u;
  return headsign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_headsign() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.headsign)
  if (!_internal_has_headsign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return headsign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_headsign(std::string* headsign) {
  if (headsign != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  headsign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headsign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.headsign)
}

// optional uint32 color = 5;
inline bool DirectionsLeg_TransitInfo::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_color() const {
  return _internal_has_color();
}
inline void DirectionsLeg_TransitInfo::clear_color() {
  color_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_TransitInfo::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_TransitInfo::color() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.color)
  return _internal_color();
}
inline void DirectionsLeg_TransitInfo::_internal_set_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  color_ = value;
}
inline void DirectionsLeg_TransitInfo::set_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.color)
}

// optional uint32 text_color = 6;
inline bool DirectionsLeg_TransitInfo::_internal_has_text_color() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_text_color() const {
  return _internal_has_text_color();
}
inline void DirectionsLeg_TransitInfo::clear_text_color() {
  text_color_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_TransitInfo::_internal_text_color() const {
  return text_color_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_TransitInfo::text_color() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.text_color)
  return _internal_text_color();
}
inline void DirectionsLeg_TransitInfo::_internal_set_text_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  text_color_ = value;
}
inline void DirectionsLeg_TransitInfo::set_text_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_text_color(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.text_color)
}

// optional string description = 7;
inline bool DirectionsLeg_TransitInfo::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_description() const {
  return _internal_has_description();
}
inline void DirectionsLeg_TransitInfo::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DirectionsLeg_TransitInfo::description() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.description)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.description)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_description() const {
  return description_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000010u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_description() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.description)
}

// optional string operator_onestop_id = 8;
inline bool DirectionsLeg_TransitInfo::_internal_has_operator_onestop_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_operator_onestop_id() const {
  return _internal_has_operator_onestop_id();
}
inline void DirectionsLeg_TransitInfo::clear_operator_onestop_id() {
  operator_onestop_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DirectionsLeg_TransitInfo::operator_onestop_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.operator_onestop_id)
  return _internal_operator_onestop_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_operator_onestop_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 operator_onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.operator_onestop_id)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_operator_onestop_id() {
  std::string* _s = _internal_mutable_operator_onestop_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.operator_onestop_id)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_operator_onestop_id() const {
  return operator_onestop_id_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_operator_onestop_id(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  operator_onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_operator_onestop_id() {
  _has_bits_[0] |= 0x00000020u;
  return operator_onestop_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_operator_onestop_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.operator_onestop_id)
  if (!_internal_has_operator_onestop_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return operator_onestop_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_operator_onestop_id(std::string* operator_onestop_id) {
  if (operator_onestop_id != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  operator_onestop_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operator_onestop_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.operator_onestop_id)
}

// optional string operator_name = 9;
inline bool DirectionsLeg_TransitInfo::_internal_has_operator_name() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_operator_name() const {
  return _internal_has_operator_name();
}
inline void DirectionsLeg_TransitInfo::clear_operator_name() {
  operator_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DirectionsLeg_TransitInfo::operator_name() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.operator_name)
  return _internal_operator_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_operator_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 operator_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.operator_name)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_operator_name() {
  std::string* _s = _internal_mutable_operator_name();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.operator_name)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_operator_name() const {
  return operator_name_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_operator_name(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  operator_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_operator_name() {
  _has_bits_[0] |= 0x00000040u;
  return operator_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_operator_name() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.operator_name)
  if (!_internal_has_operator_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return operator_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_operator_name(std::string* operator_name) {
  if (operator_name != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  operator_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operator_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.operator_name)
}

// optional string operator_url = 10;
inline bool DirectionsLeg_TransitInfo::_internal_has_operator_url() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DirectionsLeg_TransitInfo::has_operator_url() const {
  return _internal_has_operator_url();
}
inline void DirectionsLeg_TransitInfo::clear_operator_url() {
  operator_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DirectionsLeg_TransitInfo::operator_url() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.operator_url)
  return _internal_operator_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_TransitInfo::set_operator_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 operator_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.TransitInfo.operator_url)
}
inline std::string* DirectionsLeg_TransitInfo::mutable_operator_url() {
  std::string* _s = _internal_mutable_operator_url();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.operator_url)
  return _s;
}
inline const std::string& DirectionsLeg_TransitInfo::_internal_operator_url() const {
  return operator_url_.Get();
}
inline void DirectionsLeg_TransitInfo::_internal_set_operator_url(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  operator_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::_internal_mutable_operator_url() {
  _has_bits_[0] |= 0x00000080u;
  return operator_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_TransitInfo::release_operator_url() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.TransitInfo.operator_url)
  if (!_internal_has_operator_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return operator_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_TransitInfo::set_allocated_operator_url(std::string* operator_url) {
  if (operator_url != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  operator_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operator_url,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.TransitInfo.operator_url)
}

// repeated .valhalla.TransitPlatformInfo transit_stops = 11;
inline int DirectionsLeg_TransitInfo::_internal_transit_stops_size() const {
  return transit_stops_.size();
}
inline int DirectionsLeg_TransitInfo::transit_stops_size() const {
  return _internal_transit_stops_size();
}
inline ::valhalla::TransitPlatformInfo* DirectionsLeg_TransitInfo::mutable_transit_stops(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.TransitInfo.transit_stops)
  return transit_stops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TransitPlatformInfo >*
DirectionsLeg_TransitInfo::mutable_transit_stops() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.TransitInfo.transit_stops)
  return &transit_stops_;
}
inline const ::valhalla::TransitPlatformInfo& DirectionsLeg_TransitInfo::_internal_transit_stops(int index) const {
  return transit_stops_.Get(index);
}
inline const ::valhalla::TransitPlatformInfo& DirectionsLeg_TransitInfo::transit_stops(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.TransitInfo.transit_stops)
  return _internal_transit_stops(index);
}
inline ::valhalla::TransitPlatformInfo* DirectionsLeg_TransitInfo::_internal_add_transit_stops() {
  return transit_stops_.Add();
}
inline ::valhalla::TransitPlatformInfo* DirectionsLeg_TransitInfo::add_transit_stops() {
  ::valhalla::TransitPlatformInfo* _add = _internal_add_transit_stops();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.TransitInfo.transit_stops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::TransitPlatformInfo >&
DirectionsLeg_TransitInfo::transit_stops() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.TransitInfo.transit_stops)
  return transit_stops_;
}

// -------------------------------------------------------------------

// DirectionsLeg_GuidanceView

// optional string data_id = 1;
inline bool DirectionsLeg_GuidanceView::_internal_has_data_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectionsLeg_GuidanceView::has_data_id() const {
  return _internal_has_data_id();
}
inline void DirectionsLeg_GuidanceView::clear_data_id() {
  data_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectionsLeg_GuidanceView::data_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _internal_data_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_GuidanceView::set_data_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.data_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_data_id() {
  std::string* _s = _internal_mutable_data_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.data_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_data_id() const {
  return data_id_.Get();
}
inline void DirectionsLeg_GuidanceView::_internal_set_data_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_data_id() {
  _has_bits_[0] |= 0x00000001u;
  return data_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::release_data_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.data_id)
  if (!_internal_has_data_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_GuidanceView::set_allocated_data_id(std::string* data_id) {
  if (data_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.data_id)
}

// optional .valhalla.DirectionsLeg.GuidanceView.Type type = 2;
inline bool DirectionsLeg_GuidanceView::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionsLeg_GuidanceView::has_type() const {
  return _internal_has_type();
}
inline void DirectionsLeg_GuidanceView::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::_internal_type() const {
  return static_cast< ::valhalla::DirectionsLeg_GuidanceView_Type >(type_);
}
inline ::valhalla::DirectionsLeg_GuidanceView_Type DirectionsLeg_GuidanceView::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.type)
  return _internal_type();
}
inline void DirectionsLeg_GuidanceView::_internal_set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  assert(::valhalla::DirectionsLeg_GuidanceView_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void DirectionsLeg_GuidanceView::set_type(::valhalla::DirectionsLeg_GuidanceView_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.type)
}

// optional string base_id = 3;
inline bool DirectionsLeg_GuidanceView::_internal_has_base_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectionsLeg_GuidanceView::has_base_id() const {
  return _internal_has_base_id();
}
inline void DirectionsLeg_GuidanceView::clear_base_id() {
  base_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DirectionsLeg_GuidanceView::base_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _internal_base_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_GuidanceView::set_base_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 base_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.base_id)
}
inline std::string* DirectionsLeg_GuidanceView::mutable_base_id() {
  std::string* _s = _internal_mutable_base_id();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.base_id)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_base_id() const {
  return base_id_.Get();
}
inline void DirectionsLeg_GuidanceView::_internal_set_base_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  base_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::_internal_mutable_base_id() {
  _has_bits_[0] |= 0x00000002u;
  return base_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_GuidanceView::release_base_id() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.GuidanceView.base_id)
  if (!_internal_has_base_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return base_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_GuidanceView::set_allocated_base_id(std::string* base_id) {
  if (base_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  base_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), base_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.GuidanceView.base_id)
}

// repeated string overlay_ids = 4;
inline int DirectionsLeg_GuidanceView::_internal_overlay_ids_size() const {
  return overlay_ids_.size();
}
inline int DirectionsLeg_GuidanceView::overlay_ids_size() const {
  return _internal_overlay_ids_size();
}
inline void DirectionsLeg_GuidanceView::clear_overlay_ids() {
  overlay_ids_.Clear();
}
inline std::string* DirectionsLeg_GuidanceView::add_overlay_ids() {
  std::string* _s = _internal_add_overlay_ids();
  // @@protoc_insertion_point(field_add_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _s;
}
inline const std::string& DirectionsLeg_GuidanceView::_internal_overlay_ids(int index) const {
  return overlay_ids_.Get(index);
}
inline const std::string& DirectionsLeg_GuidanceView::overlay_ids(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return _internal_overlay_ids(index);
}
inline std::string* DirectionsLeg_GuidanceView::mutable_overlay_ids(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_.Mutable(index);
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const std::string& value) {
  overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, std::string&& value) {
  overlay_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  overlay_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::set_overlay_ids(int index, const char* value, size_t size) {
  overlay_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline std::string* DirectionsLeg_GuidanceView::_internal_add_overlay_ids() {
  return overlay_ids_.Add();
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const std::string& value) {
  overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(std::string&& value) {
  overlay_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  overlay_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline void DirectionsLeg_GuidanceView::add_overlay_ids(const char* value, size_t size) {
  overlay_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DirectionsLeg_GuidanceView::overlay_ids() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return overlay_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DirectionsLeg_GuidanceView::mutable_overlay_ids() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.GuidanceView.overlay_ids)
  return &overlay_ids_;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver_SignElement

// optional string text = 1;
inline bool DirectionsLeg_Maneuver_SignElement::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver_SignElement::has_text() const {
  return _internal_has_text();
}
inline void DirectionsLeg_Maneuver_SignElement::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectionsLeg_Maneuver_SignElement::text() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.SignElement.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver_SignElement::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.SignElement.text)
}
inline std::string* DirectionsLeg_Maneuver_SignElement::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.SignElement.text)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver_SignElement::_internal_text() const {
  return text_.Get();
}
inline void DirectionsLeg_Maneuver_SignElement::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver_SignElement::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver_SignElement::release_text() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.SignElement.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver_SignElement::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.SignElement.text)
}

// optional bool is_route_number = 2;
inline bool DirectionsLeg_Maneuver_SignElement::_internal_has_is_route_number() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver_SignElement::has_is_route_number() const {
  return _internal_has_is_route_number();
}
inline void DirectionsLeg_Maneuver_SignElement::clear_is_route_number() {
  is_route_number_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool DirectionsLeg_Maneuver_SignElement::_internal_is_route_number() const {
  return is_route_number_;
}
inline bool DirectionsLeg_Maneuver_SignElement::is_route_number() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.SignElement.is_route_number)
  return _internal_is_route_number();
}
inline void DirectionsLeg_Maneuver_SignElement::_internal_set_is_route_number(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_route_number_ = value;
}
inline void DirectionsLeg_Maneuver_SignElement::set_is_route_number(bool value) {
  _internal_set_is_route_number(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.SignElement.is_route_number)
}

// optional uint32 consecutive_count = 3;
inline bool DirectionsLeg_Maneuver_SignElement::_internal_has_consecutive_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver_SignElement::has_consecutive_count() const {
  return _internal_has_consecutive_count();
}
inline void DirectionsLeg_Maneuver_SignElement::clear_consecutive_count() {
  consecutive_count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver_SignElement::_internal_consecutive_count() const {
  return consecutive_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver_SignElement::consecutive_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.SignElement.consecutive_count)
  return _internal_consecutive_count();
}
inline void DirectionsLeg_Maneuver_SignElement::_internal_set_consecutive_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  consecutive_count_ = value;
}
inline void DirectionsLeg_Maneuver_SignElement::set_consecutive_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_consecutive_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.SignElement.consecutive_count)
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver_Sign

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
inline int DirectionsLeg_Maneuver_Sign::_internal_exit_numbers_size() const {
  return exit_numbers_.size();
}
inline int DirectionsLeg_Maneuver_Sign::exit_numbers_size() const {
  return _internal_exit_numbers_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_numbers() {
  exit_numbers_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_numbers(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.exit_numbers)
  return exit_numbers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_numbers() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_numbers)
  return &exit_numbers_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_exit_numbers(int index) const {
  return exit_numbers_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_numbers(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.exit_numbers)
  return _internal_exit_numbers(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_exit_numbers() {
  return exit_numbers_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_numbers() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_exit_numbers();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.exit_numbers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_numbers() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_numbers)
  return exit_numbers_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
inline int DirectionsLeg_Maneuver_Sign::_internal_exit_onto_streets_size() const {
  return exit_onto_streets_.size();
}
inline int DirectionsLeg_Maneuver_Sign::exit_onto_streets_size() const {
  return _internal_exit_onto_streets_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_onto_streets() {
  exit_onto_streets_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_onto_streets(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.exit_onto_streets)
  return exit_onto_streets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_onto_streets() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_onto_streets)
  return &exit_onto_streets_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_exit_onto_streets(int index) const {
  return exit_onto_streets_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_onto_streets(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.exit_onto_streets)
  return _internal_exit_onto_streets(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_exit_onto_streets() {
  return exit_onto_streets_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_onto_streets() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_exit_onto_streets();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.exit_onto_streets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_onto_streets() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_onto_streets)
  return exit_onto_streets_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
inline int DirectionsLeg_Maneuver_Sign::_internal_exit_toward_locations_size() const {
  return exit_toward_locations_.size();
}
inline int DirectionsLeg_Maneuver_Sign::exit_toward_locations_size() const {
  return _internal_exit_toward_locations_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_toward_locations() {
  exit_toward_locations_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_toward_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.exit_toward_locations)
  return exit_toward_locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_toward_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_toward_locations)
  return &exit_toward_locations_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_exit_toward_locations(int index) const {
  return exit_toward_locations_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_toward_locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.exit_toward_locations)
  return _internal_exit_toward_locations(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_exit_toward_locations() {
  return exit_toward_locations_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_toward_locations() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_exit_toward_locations();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.exit_toward_locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_toward_locations() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_toward_locations)
  return exit_toward_locations_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
inline int DirectionsLeg_Maneuver_Sign::_internal_exit_names_size() const {
  return exit_names_.size();
}
inline int DirectionsLeg_Maneuver_Sign::exit_names_size() const {
  return _internal_exit_names_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_names() {
  exit_names_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.exit_names)
  return exit_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_names)
  return &exit_names_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_exit_names(int index) const {
  return exit_names_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.exit_names)
  return _internal_exit_names(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_exit_names() {
  return exit_names_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_names() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_exit_names();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.exit_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_names() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.exit_names)
  return exit_names_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement guide_onto_streets = 5;
inline int DirectionsLeg_Maneuver_Sign::_internal_guide_onto_streets_size() const {
  return guide_onto_streets_.size();
}
inline int DirectionsLeg_Maneuver_Sign::guide_onto_streets_size() const {
  return _internal_guide_onto_streets_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_guide_onto_streets() {
  guide_onto_streets_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_guide_onto_streets(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.guide_onto_streets)
  return guide_onto_streets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_guide_onto_streets() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.guide_onto_streets)
  return &guide_onto_streets_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_guide_onto_streets(int index) const {
  return guide_onto_streets_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::guide_onto_streets(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.guide_onto_streets)
  return _internal_guide_onto_streets(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_guide_onto_streets() {
  return guide_onto_streets_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_guide_onto_streets() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_guide_onto_streets();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.guide_onto_streets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::guide_onto_streets() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.guide_onto_streets)
  return guide_onto_streets_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement guide_toward_locations = 6;
inline int DirectionsLeg_Maneuver_Sign::_internal_guide_toward_locations_size() const {
  return guide_toward_locations_.size();
}
inline int DirectionsLeg_Maneuver_Sign::guide_toward_locations_size() const {
  return _internal_guide_toward_locations_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_guide_toward_locations() {
  guide_toward_locations_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_guide_toward_locations(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.guide_toward_locations)
  return guide_toward_locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_guide_toward_locations() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.guide_toward_locations)
  return &guide_toward_locations_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_guide_toward_locations(int index) const {
  return guide_toward_locations_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::guide_toward_locations(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.guide_toward_locations)
  return _internal_guide_toward_locations(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_guide_toward_locations() {
  return guide_toward_locations_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_guide_toward_locations() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_guide_toward_locations();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.guide_toward_locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::guide_toward_locations() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.guide_toward_locations)
  return guide_toward_locations_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement junction_names = 7;
inline int DirectionsLeg_Maneuver_Sign::_internal_junction_names_size() const {
  return junction_names_.size();
}
inline int DirectionsLeg_Maneuver_Sign::junction_names_size() const {
  return _internal_junction_names_size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_junction_names() {
  junction_names_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_junction_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.Sign.junction_names)
  return junction_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_junction_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.Sign.junction_names)
  return &junction_names_;
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::_internal_junction_names(int index) const {
  return junction_names_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::junction_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.Sign.junction_names)
  return _internal_junction_names(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::_internal_add_junction_names() {
  return junction_names_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_junction_names() {
  ::valhalla::DirectionsLeg_Maneuver_SignElement* _add = _internal_add_junction_names();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.Sign.junction_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::junction_names() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.Sign.junction_names)
  return junction_names_;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver

// optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
inline bool DirectionsLeg_Maneuver::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_type() const {
  return _internal_has_type();
}
inline void DirectionsLeg_Maneuver::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::_internal_type() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(type_);
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.type)
  return _internal_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  assert(::valhalla::DirectionsLeg_Maneuver_Type_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  type_ = value;
}
inline void DirectionsLeg_Maneuver::set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.type)
}

// optional string text_instruction = 2;
inline bool DirectionsLeg_Maneuver::_internal_has_text_instruction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_text_instruction() const {
  return _internal_has_text_instruction();
}
inline void DirectionsLeg_Maneuver::clear_text_instruction() {
  text_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectionsLeg_Maneuver::text_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _internal_text_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_text_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.text_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_text_instruction() {
  std::string* _s = _internal_mutable_text_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.text_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_text_instruction() const {
  return text_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_text_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_text_instruction() {
  _has_bits_[0] |= 0x00000001u;
  return text_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_text_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.text_instruction)
  if (!_internal_has_text_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_text_instruction(std::string* text_instruction) {
  if (text_instruction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.text_instruction)
}

// repeated .valhalla.StreetName street_name = 3;
inline int DirectionsLeg_Maneuver::_internal_street_name_size() const {
  return street_name_.size();
}
inline int DirectionsLeg_Maneuver::street_name_size() const {
  return _internal_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return &street_name_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_street_name(int index) const {
  return street_name_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.street_name)
  return _internal_street_name(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_street_name() {
  return street_name_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_street_name() {
  ::valhalla::StreetName* _add = _internal_add_street_name();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.street_name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.street_name)
  return street_name_;
}

// optional float length = 4;
inline bool DirectionsLeg_Maneuver::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_length() const {
  return _internal_has_length();
}
inline void DirectionsLeg_Maneuver::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float DirectionsLeg_Maneuver::_internal_length() const {
  return length_;
}
inline float DirectionsLeg_Maneuver::length() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.length)
  return _internal_length();
}
inline void DirectionsLeg_Maneuver::_internal_set_length(float value) {
  _has_bits_[0] |= 0x00000800u;
  length_ = value;
}
inline void DirectionsLeg_Maneuver::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.length)
}

// optional double time = 5;
inline bool DirectionsLeg_Maneuver::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_time() const {
  return _internal_has_time();
}
inline void DirectionsLeg_Maneuver::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline double DirectionsLeg_Maneuver::_internal_time() const {
  return time_;
}
inline double DirectionsLeg_Maneuver::time() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.time)
  return _internal_time();
}
inline void DirectionsLeg_Maneuver::_internal_set_time(double value) {
  _has_bits_[0] |= 0x00001000u;
  time_ = value;
}
inline void DirectionsLeg_Maneuver::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.time)
}

// optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_cardinal_direction() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_begin_cardinal_direction() const {
  return _internal_has_begin_cardinal_direction();
}
inline void DirectionsLeg_Maneuver::clear_begin_cardinal_direction() {
  begin_cardinal_direction_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::_internal_begin_cardinal_direction() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(begin_cardinal_direction_);
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::begin_cardinal_direction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
  return _internal_begin_cardinal_direction();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  assert(::valhalla::DirectionsLeg_Maneuver_CardinalDirection_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  begin_cardinal_direction_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  _internal_set_begin_cardinal_direction(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_cardinal_direction)
}

// optional uint32 begin_heading = 7;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_heading() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_begin_heading() const {
  return _internal_has_begin_heading();
}
inline void DirectionsLeg_Maneuver::clear_begin_heading() {
  begin_heading_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_begin_heading() const {
  return begin_heading_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::begin_heading() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_heading)
  return _internal_begin_heading();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  begin_heading_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_heading(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_heading(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_heading)
}

// optional uint32 begin_shape_index = 8;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_shape_index() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_begin_shape_index() const {
  return _internal_has_begin_shape_index();
}
inline void DirectionsLeg_Maneuver::clear_begin_shape_index() {
  begin_shape_index_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_begin_shape_index() const {
  return begin_shape_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::begin_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
  return _internal_begin_shape_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  begin_shape_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_shape_index)
}

// optional uint32 end_shape_index = 9;
inline bool DirectionsLeg_Maneuver::_internal_has_end_shape_index() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_end_shape_index() const {
  return _internal_has_end_shape_index();
}
inline void DirectionsLeg_Maneuver::clear_end_shape_index() {
  end_shape_index_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_end_shape_index() const {
  return end_shape_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::end_shape_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_shape_index)
  return _internal_end_shape_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  end_shape_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_end_shape_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_shape_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_shape_index)
}

// optional bool portions_toll = 10;
inline bool DirectionsLeg_Maneuver::_internal_has_portions_toll() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_portions_toll() const {
  return _internal_has_portions_toll();
}
inline void DirectionsLeg_Maneuver::clear_portions_toll() {
  portions_toll_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool DirectionsLeg_Maneuver::_internal_portions_toll() const {
  return portions_toll_;
}
inline bool DirectionsLeg_Maneuver::portions_toll() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_toll)
  return _internal_portions_toll();
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_toll(bool value) {
  _has_bits_[0] |= 0x00040000u;
  portions_toll_ = value;
}
inline void DirectionsLeg_Maneuver::set_portions_toll(bool value) {
  _internal_set_portions_toll(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_toll)
}

// optional bool portions_unpaved = 11;
inline bool DirectionsLeg_Maneuver::_internal_has_portions_unpaved() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_portions_unpaved() const {
  return _internal_has_portions_unpaved();
}
inline void DirectionsLeg_Maneuver::clear_portions_unpaved() {
  portions_unpaved_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool DirectionsLeg_Maneuver::_internal_portions_unpaved() const {
  return portions_unpaved_;
}
inline bool DirectionsLeg_Maneuver::portions_unpaved() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
  return _internal_portions_unpaved();
}
inline void DirectionsLeg_Maneuver::_internal_set_portions_unpaved(bool value) {
  _has_bits_[0] |= 0x00080000u;
  portions_unpaved_ = value;
}
inline void DirectionsLeg_Maneuver::set_portions_unpaved(bool value) {
  _internal_set_portions_unpaved(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.portions_unpaved)
}

// optional string verbal_transition_alert_instruction = 12;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_transition_alert_instruction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_verbal_transition_alert_instruction() const {
  return _internal_has_verbal_transition_alert_instruction();
}
inline void DirectionsLeg_Maneuver::clear_verbal_transition_alert_instruction() {
  verbal_transition_alert_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DirectionsLeg_Maneuver::verbal_transition_alert_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _internal_verbal_transition_alert_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 verbal_transition_alert_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_transition_alert_instruction() {
  std::string* _s = _internal_mutable_verbal_transition_alert_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_transition_alert_instruction() const {
  return verbal_transition_alert_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_transition_alert_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  verbal_transition_alert_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_transition_alert_instruction() {
  _has_bits_[0] |= 0x00000002u;
  return verbal_transition_alert_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_transition_alert_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
  if (!_internal_has_verbal_transition_alert_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return verbal_transition_alert_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_transition_alert_instruction(std::string* verbal_transition_alert_instruction) {
  if (verbal_transition_alert_instruction != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  verbal_transition_alert_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verbal_transition_alert_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_transition_alert_instruction)
}

// optional string verbal_pre_transition_instruction = 13;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_pre_transition_instruction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_verbal_pre_transition_instruction() const {
  return _internal_has_verbal_pre_transition_instruction();
}
inline void DirectionsLeg_Maneuver::clear_verbal_pre_transition_instruction() {
  verbal_pre_transition_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DirectionsLeg_Maneuver::verbal_pre_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _internal_verbal_pre_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 verbal_pre_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_pre_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_pre_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_pre_transition_instruction() const {
  return verbal_pre_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_pre_transition_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  verbal_pre_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_pre_transition_instruction() {
  _has_bits_[0] |= 0x00000004u;
  return verbal_pre_transition_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_pre_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
  if (!_internal_has_verbal_pre_transition_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return verbal_pre_transition_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_pre_transition_instruction(std::string* verbal_pre_transition_instruction) {
  if (verbal_pre_transition_instruction != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  verbal_pre_transition_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verbal_pre_transition_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_pre_transition_instruction)
}

// optional string verbal_post_transition_instruction = 14;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_post_transition_instruction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_verbal_post_transition_instruction() const {
  return _internal_has_verbal_post_transition_instruction();
}
inline void DirectionsLeg_Maneuver::clear_verbal_post_transition_instruction() {
  verbal_post_transition_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DirectionsLeg_Maneuver::verbal_post_transition_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _internal_verbal_post_transition_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 verbal_post_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_post_transition_instruction() {
  std::string* _s = _internal_mutable_verbal_post_transition_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_post_transition_instruction() const {
  return verbal_post_transition_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_post_transition_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  verbal_post_transition_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_post_transition_instruction() {
  _has_bits_[0] |= 0x00000008u;
  return verbal_post_transition_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_post_transition_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
  if (!_internal_has_verbal_post_transition_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return verbal_post_transition_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_post_transition_instruction(std::string* verbal_post_transition_instruction) {
  if (verbal_post_transition_instruction != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  verbal_post_transition_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verbal_post_transition_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_post_transition_instruction)
}

// repeated .valhalla.StreetName begin_street_name = 15;
inline int DirectionsLeg_Maneuver::_internal_begin_street_name_size() const {
  return begin_street_name_.size();
}
inline int DirectionsLeg_Maneuver::begin_street_name_size() const {
  return _internal_begin_street_name_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_begin_street_name(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_begin_street_name() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return &begin_street_name_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_begin_street_name(int index) const {
  return begin_street_name_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::begin_street_name(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _internal_begin_street_name(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_begin_street_name() {
  return begin_street_name_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_begin_street_name() {
  ::valhalla::StreetName* _add = _internal_add_begin_street_name();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::begin_street_name() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.begin_street_name)
  return begin_street_name_;
}

// optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
inline bool DirectionsLeg_Maneuver::_internal_has_sign() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || sign_ != nullptr);
  return value;
}
inline bool DirectionsLeg_Maneuver::has_sign() const {
  return _internal_has_sign();
}
inline void DirectionsLeg_Maneuver::clear_sign() {
  if (sign_ != nullptr) sign_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::valhalla::DirectionsLeg_Maneuver_Sign& DirectionsLeg_Maneuver::_internal_sign() const {
  const ::valhalla::DirectionsLeg_Maneuver_Sign* p = sign_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::DirectionsLeg_Maneuver_Sign&>(
      ::valhalla::_DirectionsLeg_Maneuver_Sign_default_instance_);
}
inline const ::valhalla::DirectionsLeg_Maneuver_Sign& DirectionsLeg_Maneuver::sign() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.sign)
  return _internal_sign();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_sign(
    ::valhalla::DirectionsLeg_Maneuver_Sign* sign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sign_);
  }
  sign_ = sign;
  if (sign) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}
inline ::valhalla::DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver::release_sign() {
  _has_bits_[0] &= ~0x00000100u;
  ::valhalla::DirectionsLeg_Maneuver_Sign* temp = sign_;
  sign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver::unsafe_arena_release_sign() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.sign)
  _has_bits_[0] &= ~0x00000100u;
  ::valhalla::DirectionsLeg_Maneuver_Sign* temp = sign_;
  sign_ = nullptr;
  return temp;
}
inline ::valhalla::DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver::_internal_mutable_sign() {
  _has_bits_[0] |= 0x00000100u;
  if (sign_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::DirectionsLeg_Maneuver_Sign>(GetArenaForAllocation());
    sign_ = p;
  }
  return sign_;
}
inline ::valhalla::DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver::mutable_sign() {
  ::valhalla::DirectionsLeg_Maneuver_Sign* _msg = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.sign)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_sign(::valhalla::DirectionsLeg_Maneuver_Sign* sign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sign_;
  }
  if (sign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::DirectionsLeg_Maneuver_Sign>::GetOwningArena(sign);
    if (message_arena != submessage_arena) {
      sign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sign, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  sign_ = sign;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.sign)
}

// optional uint32 roundabout_exit_count = 17;
inline bool DirectionsLeg_Maneuver::_internal_has_roundabout_exit_count() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_roundabout_exit_count() const {
  return _internal_has_roundabout_exit_count();
}
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_count() {
  roundabout_exit_count_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_roundabout_exit_count() const {
  return roundabout_exit_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::roundabout_exit_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
  return _internal_roundabout_exit_count();
}
inline void DirectionsLeg_Maneuver::_internal_set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00020000u;
  roundabout_exit_count_ = value;
}
inline void DirectionsLeg_Maneuver::set_roundabout_exit_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_roundabout_exit_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.roundabout_exit_count)
}

// optional string depart_instruction = 18;
inline bool DirectionsLeg_Maneuver::_internal_has_depart_instruction() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_depart_instruction() const {
  return _internal_has_depart_instruction();
}
inline void DirectionsLeg_Maneuver::clear_depart_instruction() {
  depart_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DirectionsLeg_Maneuver::depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _internal_depart_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_depart_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_depart_instruction() {
  std::string* _s = _internal_mutable_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_depart_instruction() const {
  return depart_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_depart_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_depart_instruction() {
  _has_bits_[0] |= 0x00000010u;
  return depart_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.depart_instruction)
  if (!_internal_has_depart_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return depart_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_depart_instruction(std::string* depart_instruction) {
  if (depart_instruction != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  depart_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), depart_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.depart_instruction)
}

// optional string verbal_depart_instruction = 19;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_depart_instruction() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_verbal_depart_instruction() const {
  return _internal_has_verbal_depart_instruction();
}
inline void DirectionsLeg_Maneuver::clear_verbal_depart_instruction() {
  verbal_depart_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DirectionsLeg_Maneuver::verbal_depart_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _internal_verbal_depart_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_depart_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 verbal_depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_depart_instruction() {
  std::string* _s = _internal_mutable_verbal_depart_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_depart_instruction() const {
  return verbal_depart_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_depart_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  verbal_depart_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_depart_instruction() {
  _has_bits_[0] |= 0x00000020u;
  return verbal_depart_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_depart_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
  if (!_internal_has_verbal_depart_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return verbal_depart_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_depart_instruction(std::string* verbal_depart_instruction) {
  if (verbal_depart_instruction != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  verbal_depart_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verbal_depart_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_depart_instruction)
}

// optional string arrive_instruction = 20;
inline bool DirectionsLeg_Maneuver::_internal_has_arrive_instruction() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_arrive_instruction() const {
  return _internal_has_arrive_instruction();
}
inline void DirectionsLeg_Maneuver::clear_arrive_instruction() {
  arrive_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DirectionsLeg_Maneuver::arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _internal_arrive_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_arrive_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_arrive_instruction() {
  std::string* _s = _internal_mutable_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_arrive_instruction() const {
  return arrive_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_arrive_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_arrive_instruction() {
  _has_bits_[0] |= 0x00000040u;
  return arrive_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
  if (!_internal_has_arrive_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return arrive_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_arrive_instruction(std::string* arrive_instruction) {
  if (arrive_instruction != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  arrive_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arrive_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.arrive_instruction)
}

// optional string verbal_arrive_instruction = 21;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_arrive_instruction() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_verbal_arrive_instruction() const {
  return _internal_has_verbal_arrive_instruction();
}
inline void DirectionsLeg_Maneuver::clear_verbal_arrive_instruction() {
  verbal_arrive_instruction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DirectionsLeg_Maneuver::verbal_arrive_instruction() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _internal_verbal_arrive_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 verbal_arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}
inline std::string* DirectionsLeg_Maneuver::mutable_verbal_arrive_instruction() {
  std::string* _s = _internal_mutable_verbal_arrive_instruction();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  return _s;
}
inline const std::string& DirectionsLeg_Maneuver::_internal_verbal_arrive_instruction() const {
  return verbal_arrive_instruction_.Get();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_arrive_instruction(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  verbal_arrive_instruction_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::_internal_mutable_verbal_arrive_instruction() {
  _has_bits_[0] |= 0x00000080u;
  return verbal_arrive_instruction_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg_Maneuver::release_verbal_arrive_instruction() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
  if (!_internal_has_verbal_arrive_instruction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return verbal_arrive_instruction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_arrive_instruction(std::string* verbal_arrive_instruction) {
  if (verbal_arrive_instruction != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  verbal_arrive_instruction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verbal_arrive_instruction,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.verbal_arrive_instruction)
}

// optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
inline bool DirectionsLeg_Maneuver::_internal_has_transit_info() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || transit_info_ != nullptr);
  return value;
}
inline bool DirectionsLeg_Maneuver::has_transit_info() const {
  return _internal_has_transit_info();
}
inline void DirectionsLeg_Maneuver::clear_transit_info() {
  if (transit_info_ != nullptr) transit_info_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::valhalla::DirectionsLeg_TransitInfo& DirectionsLeg_Maneuver::_internal_transit_info() const {
  const ::valhalla::DirectionsLeg_TransitInfo* p = transit_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::DirectionsLeg_TransitInfo&>(
      ::valhalla::_DirectionsLeg_TransitInfo_default_instance_);
}
inline const ::valhalla::DirectionsLeg_TransitInfo& DirectionsLeg_Maneuver::transit_info() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _internal_transit_info();
}
inline void DirectionsLeg_Maneuver::unsafe_arena_set_allocated_transit_info(
    ::valhalla::DirectionsLeg_TransitInfo* transit_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transit_info_);
  }
  transit_info_ = transit_info;
  if (transit_info) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}
inline ::valhalla::DirectionsLeg_TransitInfo* DirectionsLeg_Maneuver::release_transit_info() {
  _has_bits_[0] &= ~0x00000200u;
  ::valhalla::DirectionsLeg_TransitInfo* temp = transit_info_;
  transit_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::DirectionsLeg_TransitInfo* DirectionsLeg_Maneuver::unsafe_arena_release_transit_info() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.Maneuver.transit_info)
  _has_bits_[0] &= ~0x00000200u;
  ::valhalla::DirectionsLeg_TransitInfo* temp = transit_info_;
  transit_info_ = nullptr;
  return temp;
}
inline ::valhalla::DirectionsLeg_TransitInfo* DirectionsLeg_Maneuver::_internal_mutable_transit_info() {
  _has_bits_[0] |= 0x00000200u;
  if (transit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::DirectionsLeg_TransitInfo>(GetArenaForAllocation());
    transit_info_ = p;
  }
  return transit_info_;
}
inline ::valhalla::DirectionsLeg_TransitInfo* DirectionsLeg_Maneuver::mutable_transit_info() {
  ::valhalla::DirectionsLeg_TransitInfo* _msg = _internal_mutable_transit_info();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.transit_info)
  return _msg;
}
inline void DirectionsLeg_Maneuver::set_allocated_transit_info(::valhalla::DirectionsLeg_TransitInfo* transit_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transit_info_;
  }
  if (transit_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::DirectionsLeg_TransitInfo>::GetOwningArena(transit_info);
    if (message_arena != submessage_arena) {
      transit_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transit_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  transit_info_ = transit_info;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.Maneuver.transit_info)
}

// optional bool verbal_multi_cue = 23;
inline bool DirectionsLeg_Maneuver::_internal_has_verbal_multi_cue() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_verbal_multi_cue() const {
  return _internal_has_verbal_multi_cue();
}
inline void DirectionsLeg_Maneuver::clear_verbal_multi_cue() {
  verbal_multi_cue_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool DirectionsLeg_Maneuver::_internal_verbal_multi_cue() const {
  return verbal_multi_cue_;
}
inline bool DirectionsLeg_Maneuver::verbal_multi_cue() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
  return _internal_verbal_multi_cue();
}
inline void DirectionsLeg_Maneuver::_internal_set_verbal_multi_cue(bool value) {
  _has_bits_[0] |= 0x00100000u;
  verbal_multi_cue_ = value;
}
inline void DirectionsLeg_Maneuver::set_verbal_multi_cue(bool value) {
  _internal_set_verbal_multi_cue(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.verbal_multi_cue)
}

// optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
inline bool DirectionsLeg_Maneuver::_internal_has_travel_mode() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_travel_mode() const {
  return _internal_has_travel_mode();
}
inline void DirectionsLeg_Maneuver::clear_travel_mode() {
  travel_mode_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::valhalla::DirectionsLeg_TravelMode DirectionsLeg_Maneuver::_internal_travel_mode() const {
  return static_cast< ::valhalla::DirectionsLeg_TravelMode >(travel_mode_);
}
inline ::valhalla::DirectionsLeg_TravelMode DirectionsLeg_Maneuver::travel_mode() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.travel_mode)
  return _internal_travel_mode();
}
inline void DirectionsLeg_Maneuver::_internal_set_travel_mode(::valhalla::DirectionsLeg_TravelMode value) {
  assert(::valhalla::DirectionsLeg_TravelMode_IsValid(value));
  _has_bits_[0] |= 0x00400000u;
  travel_mode_ = value;
}
inline void DirectionsLeg_Maneuver::set_travel_mode(::valhalla::DirectionsLeg_TravelMode value) {
  _internal_set_travel_mode(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.travel_mode)
}

// optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
inline bool DirectionsLeg_Maneuver::_internal_has_vehicle_type() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_vehicle_type() const {
  return _internal_has_vehicle_type();
}
inline void DirectionsLeg_Maneuver::clear_vehicle_type() {
  vehicle_type_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::valhalla::DirectionsLeg_VehicleType DirectionsLeg_Maneuver::_internal_vehicle_type() const {
  return static_cast< ::valhalla::DirectionsLeg_VehicleType >(vehicle_type_);
}
inline ::valhalla::DirectionsLeg_VehicleType DirectionsLeg_Maneuver::vehicle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.vehicle_type)
  return _internal_vehicle_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_vehicle_type(::valhalla::DirectionsLeg_VehicleType value) {
  assert(::valhalla::DirectionsLeg_VehicleType_IsValid(value));
  _has_bits_[0] |= 0x00800000u;
  vehicle_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_vehicle_type(::valhalla::DirectionsLeg_VehicleType value) {
  _internal_set_vehicle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.vehicle_type)
}

// optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
inline bool DirectionsLeg_Maneuver::_internal_has_pedestrian_type() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_pedestrian_type() const {
  return _internal_has_pedestrian_type();
}
inline void DirectionsLeg_Maneuver::clear_pedestrian_type() {
  pedestrian_type_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::valhalla::DirectionsLeg_PedestrianType DirectionsLeg_Maneuver::_internal_pedestrian_type() const {
  return static_cast< ::valhalla::DirectionsLeg_PedestrianType >(pedestrian_type_);
}
inline ::valhalla::DirectionsLeg_PedestrianType DirectionsLeg_Maneuver::pedestrian_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
  return _internal_pedestrian_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_pedestrian_type(::valhalla::DirectionsLeg_PedestrianType value) {
  assert(::valhalla::DirectionsLeg_PedestrianType_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  pedestrian_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_pedestrian_type(::valhalla::DirectionsLeg_PedestrianType value) {
  _internal_set_pedestrian_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.pedestrian_type)
}

// optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
inline bool DirectionsLeg_Maneuver::_internal_has_bicycle_type() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_bicycle_type() const {
  return _internal_has_bicycle_type();
}
inline void DirectionsLeg_Maneuver::clear_bicycle_type() {
  bicycle_type_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::valhalla::DirectionsLeg_BicycleType DirectionsLeg_Maneuver::_internal_bicycle_type() const {
  return static_cast< ::valhalla::DirectionsLeg_BicycleType >(bicycle_type_);
}
inline ::valhalla::DirectionsLeg_BicycleType DirectionsLeg_Maneuver::bicycle_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bicycle_type)
  return _internal_bicycle_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_bicycle_type(::valhalla::DirectionsLeg_BicycleType value) {
  assert(::valhalla::DirectionsLeg_BicycleType_IsValid(value));
  _has_bits_[0] |= 0x02000000u;
  bicycle_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_bicycle_type(::valhalla::DirectionsLeg_BicycleType value) {
  _internal_set_bicycle_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bicycle_type)
}

// optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
inline bool DirectionsLeg_Maneuver::_internal_has_transit_type() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_transit_type() const {
  return _internal_has_transit_type();
}
inline void DirectionsLeg_Maneuver::clear_transit_type() {
  transit_type_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::valhalla::DirectionsLeg_TransitType DirectionsLeg_Maneuver::_internal_transit_type() const {
  return static_cast< ::valhalla::DirectionsLeg_TransitType >(transit_type_);
}
inline ::valhalla::DirectionsLeg_TransitType DirectionsLeg_Maneuver::transit_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.transit_type)
  return _internal_transit_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_transit_type(::valhalla::DirectionsLeg_TransitType value) {
  assert(::valhalla::DirectionsLeg_TransitType_IsValid(value));
  _has_bits_[0] |= 0x04000000u;
  transit_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_transit_type(::valhalla::DirectionsLeg_TransitType value) {
  _internal_set_transit_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.transit_type)
}

// optional uint32 begin_path_index = 29;
inline bool DirectionsLeg_Maneuver::_internal_has_begin_path_index() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_begin_path_index() const {
  return _internal_has_begin_path_index();
}
inline void DirectionsLeg_Maneuver::clear_begin_path_index() {
  begin_path_index_ = 0u;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_begin_path_index() const {
  return begin_path_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::begin_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.begin_path_index)
  return _internal_begin_path_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x08000000u;
  begin_path_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_begin_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.begin_path_index)
}

// optional uint32 end_path_index = 30;
inline bool DirectionsLeg_Maneuver::_internal_has_end_path_index() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_end_path_index() const {
  return _internal_has_end_path_index();
}
inline void DirectionsLeg_Maneuver::clear_end_path_index() {
  end_path_index_ = 0u;
  _has_bits_[0] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_end_path_index() const {
  return end_path_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::end_path_index() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.end_path_index)
  return _internal_end_path_index();
}
inline void DirectionsLeg_Maneuver::_internal_set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x10000000u;
  end_path_index_ = value;
}
inline void DirectionsLeg_Maneuver::set_end_path_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_path_index(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.end_path_index)
}

// optional bool to_stay_on = 31;
inline bool DirectionsLeg_Maneuver::_internal_has_to_stay_on() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_to_stay_on() const {
  return _internal_has_to_stay_on();
}
inline void DirectionsLeg_Maneuver::clear_to_stay_on() {
  to_stay_on_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool DirectionsLeg_Maneuver::_internal_to_stay_on() const {
  return to_stay_on_;
}
inline bool DirectionsLeg_Maneuver::to_stay_on() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.to_stay_on)
  return _internal_to_stay_on();
}
inline void DirectionsLeg_Maneuver::_internal_set_to_stay_on(bool value) {
  _has_bits_[0] |= 0x00200000u;
  to_stay_on_ = value;
}
inline void DirectionsLeg_Maneuver::set_to_stay_on(bool value) {
  _internal_set_to_stay_on(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.to_stay_on)
}

// repeated .valhalla.StreetName roundabout_exit_street_names = 32;
inline int DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names_size() const {
  return roundabout_exit_street_names_.size();
}
inline int DirectionsLeg_Maneuver::roundabout_exit_street_names_size() const {
  return _internal_roundabout_exit_street_names_size();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return &roundabout_exit_street_names_;
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::_internal_roundabout_exit_street_names(int index) const {
  return roundabout_exit_street_names_.Get(index);
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::roundabout_exit_street_names(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _internal_roundabout_exit_street_names(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::_internal_add_roundabout_exit_street_names() {
  return roundabout_exit_street_names_.Add();
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_roundabout_exit_street_names() {
  ::valhalla::StreetName* _add = _internal_add_roundabout_exit_street_names();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::roundabout_exit_street_names() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.roundabout_exit_street_names)
  return roundabout_exit_street_names_;
}

// optional uint32 turn_degree = 33;
inline bool DirectionsLeg_Maneuver::_internal_has_turn_degree() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_turn_degree() const {
  return _internal_has_turn_degree();
}
inline void DirectionsLeg_Maneuver::clear_turn_degree() {
  turn_degree_ = 0u;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::_internal_turn_degree() const {
  return turn_degree_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg_Maneuver::turn_degree() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.turn_degree)
  return _internal_turn_degree();
}
inline void DirectionsLeg_Maneuver::_internal_set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x20000000u;
  turn_degree_ = value;
}
inline void DirectionsLeg_Maneuver::set_turn_degree(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_turn_degree(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.turn_degree)
}

// optional bool has_time_restrictions = 34;
inline bool DirectionsLeg_Maneuver::_internal_has_has_time_restrictions() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_has_time_restrictions() const {
  return _internal_has_has_time_restrictions();
}
inline void DirectionsLeg_Maneuver::clear_has_time_restrictions() {
  has_time_restrictions_ = false;
  _has_bits_[0] &= ~0x40000000u;
}
inline bool DirectionsLeg_Maneuver::_internal_has_time_restrictions() const {
  return has_time_restrictions_;
}
inline bool DirectionsLeg_Maneuver::has_time_restrictions() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
  return _internal_has_time_restrictions();
}
inline void DirectionsLeg_Maneuver::_internal_set_has_time_restrictions(bool value) {
  _has_bits_[0] |= 0x40000000u;
  has_time_restrictions_ = value;
}
inline void DirectionsLeg_Maneuver::set_has_time_restrictions(bool value) {
  _internal_set_has_time_restrictions(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.has_time_restrictions)
}

// repeated .valhalla.DirectionsLeg.GuidanceView guidance_views = 35;
inline int DirectionsLeg_Maneuver::_internal_guidance_views_size() const {
  return guidance_views_.size();
}
inline int DirectionsLeg_Maneuver::guidance_views_size() const {
  return _internal_guidance_views_size();
}
inline void DirectionsLeg_Maneuver::clear_guidance_views() {
  guidance_views_.Clear();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::mutable_guidance_views(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >*
DirectionsLeg_Maneuver::mutable_guidance_views() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return &guidance_views_;
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::_internal_guidance_views(int index) const {
  return guidance_views_.Get(index);
}
inline const ::valhalla::DirectionsLeg_GuidanceView& DirectionsLeg_Maneuver::guidance_views(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _internal_guidance_views(index);
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::_internal_add_guidance_views() {
  return guidance_views_.Add();
}
inline ::valhalla::DirectionsLeg_GuidanceView* DirectionsLeg_Maneuver::add_guidance_views() {
  ::valhalla::DirectionsLeg_GuidanceView* _add = _internal_add_guidance_views();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_GuidanceView >&
DirectionsLeg_Maneuver::guidance_views() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.Maneuver.guidance_views)
  return guidance_views_;
}

// optional .valhalla.DirectionsLeg.Maneuver.BssManeuverType bss_maneuver_type = 36;
inline bool DirectionsLeg_Maneuver::_internal_has_bss_maneuver_type() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool DirectionsLeg_Maneuver::has_bss_maneuver_type() const {
  return _internal_has_bss_maneuver_type();
}
inline void DirectionsLeg_Maneuver::clear_bss_maneuver_type() {
  bss_maneuver_type_ = 1;
  _has_bits_[0] &= ~0x80000000u;
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::_internal_bss_maneuver_type() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType >(bss_maneuver_type_);
}
inline ::valhalla::DirectionsLeg_Maneuver_BssManeuverType DirectionsLeg_Maneuver::bss_maneuver_type() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
  return _internal_bss_maneuver_type();
}
inline void DirectionsLeg_Maneuver::_internal_set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  assert(::valhalla::DirectionsLeg_Maneuver_BssManeuverType_IsValid(value));
  _has_bits_[0] |= 0x80000000u;
  bss_maneuver_type_ = value;
}
inline void DirectionsLeg_Maneuver::set_bss_maneuver_type(::valhalla::DirectionsLeg_Maneuver_BssManeuverType value) {
  _internal_set_bss_maneuver_type(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.Maneuver.bss_maneuver_type)
}

// -------------------------------------------------------------------

// DirectionsLeg

// optional uint64 trip_id = 1;
inline bool DirectionsLeg::_internal_has_trip_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectionsLeg::has_trip_id() const {
  return _internal_has_trip_id();
}
inline void DirectionsLeg::clear_trip_id() {
  trip_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DirectionsLeg::_internal_trip_id() const {
  return trip_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DirectionsLeg::trip_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.trip_id)
  return _internal_trip_id();
}
inline void DirectionsLeg::_internal_set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  trip_id_ = value;
}
inline void DirectionsLeg::set_trip_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_trip_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.trip_id)
}

// optional uint32 leg_id = 2;
inline bool DirectionsLeg::_internal_has_leg_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DirectionsLeg::has_leg_id() const {
  return _internal_has_leg_id();
}
inline void DirectionsLeg::clear_leg_id() {
  leg_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::_internal_leg_id() const {
  return leg_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::leg_id() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_id)
  return _internal_leg_id();
}
inline void DirectionsLeg::_internal_set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  leg_id_ = value;
}
inline void DirectionsLeg::set_leg_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leg_id(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_id)
}

// optional uint32 leg_count = 3;
inline bool DirectionsLeg::_internal_has_leg_count() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DirectionsLeg::has_leg_count() const {
  return _internal_has_leg_count();
}
inline void DirectionsLeg::clear_leg_count() {
  leg_count_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::_internal_leg_count() const {
  return leg_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DirectionsLeg::leg_count() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.leg_count)
  return _internal_leg_count();
}
inline void DirectionsLeg::_internal_set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  leg_count_ = value;
}
inline void DirectionsLeg::set_leg_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leg_count(value);
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.leg_count)
}

// repeated .valhalla.Location location = 4;
inline int DirectionsLeg::_internal_location_size() const {
  return location_.size();
}
inline int DirectionsLeg::location_size() const {
  return _internal_location_size();
}
inline ::valhalla::Location* DirectionsLeg::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.location)
  return location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >*
DirectionsLeg::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.location)
  return &location_;
}
inline const ::valhalla::Location& DirectionsLeg::_internal_location(int index) const {
  return location_.Get(index);
}
inline const ::valhalla::Location& DirectionsLeg::location(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.location)
  return _internal_location(index);
}
inline ::valhalla::Location* DirectionsLeg::_internal_add_location() {
  return location_.Add();
}
inline ::valhalla::Location* DirectionsLeg::add_location() {
  ::valhalla::Location* _add = _internal_add_location();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.location)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::Location >&
DirectionsLeg::location() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.location)
  return location_;
}

// optional .valhalla.DirectionsLeg.Summary summary = 5;
inline bool DirectionsLeg::_internal_has_summary() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || summary_ != nullptr);
  return value;
}
inline bool DirectionsLeg::has_summary() const {
  return _internal_has_summary();
}
inline void DirectionsLeg::clear_summary() {
  if (summary_ != nullptr) summary_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::_internal_summary() const {
  const ::valhalla::DirectionsLeg_Summary* p = summary_;
  return p != nullptr ? *p : reinterpret_cast<const ::valhalla::DirectionsLeg_Summary&>(
      ::valhalla::_DirectionsLeg_Summary_default_instance_);
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::summary() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.summary)
  return _internal_summary();
}
inline void DirectionsLeg::unsafe_arena_set_allocated_summary(
    ::valhalla::DirectionsLeg_Summary* summary) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(summary_);
  }
  summary_ = summary;
  if (summary) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:valhalla.DirectionsLeg.summary)
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::release_summary() {
  _has_bits_[0] &= ~0x00000002u;
  ::valhalla::DirectionsLeg_Summary* temp = summary_;
  summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::unsafe_arena_release_summary() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.summary)
  _has_bits_[0] &= ~0x00000002u;
  ::valhalla::DirectionsLeg_Summary* temp = summary_;
  summary_ = nullptr;
  return temp;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::_internal_mutable_summary() {
  _has_bits_[0] |= 0x00000002u;
  if (summary_ == nullptr) {
    auto* p = CreateMaybeMessage<::valhalla::DirectionsLeg_Summary>(GetArenaForAllocation());
    summary_ = p;
  }
  return summary_;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::mutable_summary() {
  ::valhalla::DirectionsLeg_Summary* _msg = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.summary)
  return _msg;
}
inline void DirectionsLeg::set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete summary_;
  }
  if (summary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::valhalla::DirectionsLeg_Summary>::GetOwningArena(summary);
    if (message_arena != submessage_arena) {
      summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  summary_ = summary;
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.summary)
}

// repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
inline int DirectionsLeg::_internal_maneuver_size() const {
  return maneuver_.size();
}
inline int DirectionsLeg::maneuver_size() const {
  return _internal_maneuver_size();
}
inline void DirectionsLeg::clear_maneuver() {
  maneuver_.Clear();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::mutable_maneuver(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.maneuver)
  return maneuver_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
DirectionsLeg::mutable_maneuver() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsLeg.maneuver)
  return &maneuver_;
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::_internal_maneuver(int index) const {
  return maneuver_.Get(index);
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::maneuver(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.maneuver)
  return _internal_maneuver(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::_internal_add_maneuver() {
  return maneuver_.Add();
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::add_maneuver() {
  ::valhalla::DirectionsLeg_Maneuver* _add = _internal_add_maneuver();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsLeg.maneuver)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
DirectionsLeg::maneuver() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsLeg.maneuver)
  return maneuver_;
}

// optional string shape = 7;
inline bool DirectionsLeg::_internal_has_shape() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectionsLeg::has_shape() const {
  return _internal_has_shape();
}
inline void DirectionsLeg::clear_shape() {
  shape_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectionsLeg::shape() const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsLeg.shape)
  return _internal_shape();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectionsLeg::set_shape(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 shape_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:valhalla.DirectionsLeg.shape)
}
inline std::string* DirectionsLeg::mutable_shape() {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsLeg.shape)
  return _s;
}
inline const std::string& DirectionsLeg::_internal_shape() const {
  return shape_.Get();
}
inline void DirectionsLeg::_internal_set_shape(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  shape_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectionsLeg::_internal_mutable_shape() {
  _has_bits_[0] |= 0x00000001u;
  return shape_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectionsLeg::release_shape() {
  // @@protoc_insertion_point(field_release:valhalla.DirectionsLeg.shape)
  if (!_internal_has_shape()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return shape_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectionsLeg::set_allocated_shape(std::string* shape) {
  if (shape != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  shape_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shape,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:valhalla.DirectionsLeg.shape)
}

// -------------------------------------------------------------------

// DirectionsRoute

// repeated .valhalla.DirectionsLeg legs = 1;
inline int DirectionsRoute::_internal_legs_size() const {
  return legs_.size();
}
inline int DirectionsRoute::legs_size() const {
  return _internal_legs_size();
}
inline void DirectionsRoute::clear_legs() {
  legs_.Clear();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::mutable_legs(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.DirectionsRoute.legs)
  return legs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >*
DirectionsRoute::mutable_legs() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.DirectionsRoute.legs)
  return &legs_;
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::_internal_legs(int index) const {
  return legs_.Get(index);
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::legs(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.DirectionsRoute.legs)
  return _internal_legs(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::_internal_add_legs() {
  return legs_.Add();
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::add_legs() {
  ::valhalla::DirectionsLeg* _add = _internal_add_legs();
  // @@protoc_insertion_point(field_add:valhalla.DirectionsRoute.legs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsLeg >&
DirectionsRoute::legs() const {
  // @@protoc_insertion_point(field_list:valhalla.DirectionsRoute.legs)
  return legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.DirectionsRoute routes = 1;
inline int Directions::_internal_routes_size() const {
  return routes_.size();
}
inline int Directions::routes_size() const {
  return _internal_routes_size();
}
inline void Directions::clear_routes() {
  routes_.Clear();
}
inline ::valhalla::DirectionsRoute* Directions::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:valhalla.Directions.routes)
  return routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >*
Directions::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:valhalla.Directions.routes)
  return &routes_;
}
inline const ::valhalla::DirectionsRoute& Directions::_internal_routes(int index) const {
  return routes_.Get(index);
}
inline const ::valhalla::DirectionsRoute& Directions::routes(int index) const {
  // @@protoc_insertion_point(field_get:valhalla.Directions.routes)
  return _internal_routes(index);
}
inline ::valhalla::DirectionsRoute* Directions::_internal_add_routes() {
  return routes_.Add();
}
inline ::valhalla::DirectionsRoute* Directions::add_routes() {
  ::valhalla::DirectionsRoute* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:valhalla.Directions.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::valhalla::DirectionsRoute >&
Directions::routes() const {
  // @@protoc_insertion_point(field_list:valhalla.Directions.routes)
  return routes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::valhalla::DirectionsLeg_GuidanceView_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_Maneuver_BssManeuverType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_TravelMode> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_VehicleType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_PedestrianType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_BicycleType> : ::std::true_type {};
template <> struct is_proto_enum< ::valhalla::DirectionsLeg_TransitType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_directions_2eproto
