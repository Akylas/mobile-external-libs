// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#include "trip.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace valhalla {
constexpr TripLeg_SignElement::TripLeg_SignElement(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , is_route_number_(false){}
struct TripLeg_SignElementDefaultTypeInternal {
  constexpr TripLeg_SignElementDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_SignElementDefaultTypeInternal() {}
  union {
    TripLeg_SignElement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_SignElementDefaultTypeInternal _TripLeg_SignElement_default_instance_;
constexpr TripLeg_Sign::TripLeg_Sign(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : exit_numbers_()
  , exit_onto_streets_()
  , exit_toward_locations_()
  , exit_names_()
  , guide_onto_streets_()
  , guide_toward_locations_()
  , junction_names_()
  , guidance_view_junctions_()
  , guidance_view_signboards_(){}
struct TripLeg_SignDefaultTypeInternal {
  constexpr TripLeg_SignDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_SignDefaultTypeInternal() {}
  union {
    TripLeg_Sign _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_SignDefaultTypeInternal _TripLeg_Sign_default_instance_;
constexpr TripLeg_TransitRouteInfo::TripLeg_TransitRouteInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : onestop_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , short_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , long_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , headsign_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , operator_onestop_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , operator_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , operator_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , block_id_(0u)
  , trip_id_(0u)
  , color_(0u)
  , text_color_(0u){}
struct TripLeg_TransitRouteInfoDefaultTypeInternal {
  constexpr TripLeg_TransitRouteInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_TransitRouteInfoDefaultTypeInternal() {}
  union {
    TripLeg_TransitRouteInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_TransitRouteInfoDefaultTypeInternal _TripLeg_TransitRouteInfo_default_instance_;
constexpr TripLeg_BikeShareStationInfo::TripLeg_BikeShareStationInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ref_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , capacity_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , network_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , operator__(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rent_cost_(0)
  , return_cost_(0){}
struct TripLeg_BikeShareStationInfoDefaultTypeInternal {
  constexpr TripLeg_BikeShareStationInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_BikeShareStationInfoDefaultTypeInternal() {}
  union {
    TripLeg_BikeShareStationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_BikeShareStationInfoDefaultTypeInternal _TripLeg_BikeShareStationInfo_default_instance_;
constexpr TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : from_lanes_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , to_lanes_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , from_way_id_(uint64_t{0u}){}
struct TripLeg_LaneConnectivityDefaultTypeInternal {
  constexpr TripLeg_LaneConnectivityDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_LaneConnectivityDefaultTypeInternal() {}
  union {
    TripLeg_LaneConnectivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_LaneConnectivityDefaultTypeInternal _TripLeg_LaneConnectivity_default_instance_;
constexpr TripLeg_TrafficSegment::TripLeg_TrafficSegment(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : segment_id_(uint64_t{0u})
  , begin_percent_(0)
  , end_percent_(0)
  , starts_segment_(false)
  , ends_segment_(false){}
struct TripLeg_TrafficSegmentDefaultTypeInternal {
  constexpr TripLeg_TrafficSegmentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_TrafficSegmentDefaultTypeInternal() {}
  union {
    TripLeg_TrafficSegment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_TrafficSegmentDefaultTypeInternal _TripLeg_TrafficSegment_default_instance_;
constexpr TripLeg_Restriction::TripLeg_Restriction(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0u){}
struct TripLeg_RestrictionDefaultTypeInternal {
  constexpr TripLeg_RestrictionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_RestrictionDefaultTypeInternal() {}
  union {
    TripLeg_Restriction _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_RestrictionDefaultTypeInternal _TripLeg_Restriction_default_instance_;
constexpr TripLeg_Edge::TripLeg_Edge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_()
  , lane_connectivity_()
  , traffic_segment_()
  , turn_lanes_()
  , tagged_name_()
  , sign_(nullptr)
  , transit_route_info_(nullptr)
  , restriction_(nullptr)
  , length_km_(0)
  , speed_(0)
  , road_class_(0)

  , begin_heading_(0u)
  , end_heading_(0u)
  , begin_shape_index_(0u)
  , end_shape_index_(0u)
  , traversability_(0)

  , use_(0)

  , toll_(false)
  , unpaved_(false)
  , tunnel_(false)
  , bridge_(false)
  , surface_(0)

  , travel_mode_(0)

  , vehicle_type_(0)

  , pedestrian_type_(0)

  , bicycle_type_(0)

  , transit_type_(0)

  , id_(uint64_t{0u})
  , way_id_(uint64_t{0u})
  , weighted_grade_(0)
  , roundabout_(false)
  , internal_intersection_(false)
  , truck_route_(false)
  , has_time_restrictions_(false)
  , max_upward_grade_(0)
  , max_downward_grade_(0)
  , lane_count_(0u)
  , cycle_lane_(0)

  , bicycle_network_(0u)
  , sidewalk_(0)

  , density_(0u)
  , speed_limit_(0u)
  , truck_speed_(0)
  , mean_elevation_(0)
  , default_speed_(0)
  , destination_only_(false)
  , is_urban_(false)
  , shoulder_(false)
  , source_along_edge_(0)
  , target_along_edge_(0)
  , sac_scale_(0)

  , drive_on_right_(true){}
struct TripLeg_EdgeDefaultTypeInternal {
  constexpr TripLeg_EdgeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_EdgeDefaultTypeInternal() {}
  union {
    TripLeg_Edge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_EdgeDefaultTypeInternal _TripLeg_Edge_default_instance_;
constexpr TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : begin_heading_(0u)
  , prev_name_consistency_(false)
  , curr_name_consistency_(false)
  , driveability_(0)

  , cyclability_(0)

  , walkability_(0)

  , use_(0)

  , road_class_(0)
{}
struct TripLeg_IntersectingEdgeDefaultTypeInternal {
  constexpr TripLeg_IntersectingEdgeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_IntersectingEdgeDefaultTypeInternal() {}
  union {
    TripLeg_IntersectingEdge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_IntersectingEdgeDefaultTypeInternal _TripLeg_IntersectingEdge_default_instance_;
constexpr TripLeg_Cost::TripLeg_Cost(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : seconds_(0)
  , cost_(0){}
struct TripLeg_CostDefaultTypeInternal {
  constexpr TripLeg_CostDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_CostDefaultTypeInternal() {}
  union {
    TripLeg_Cost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_CostDefaultTypeInternal _TripLeg_Cost_default_instance_;
constexpr TripLeg_PathCost::TripLeg_PathCost(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : elapsed_cost_(nullptr)
  , transition_cost_(nullptr){}
struct TripLeg_PathCostDefaultTypeInternal {
  constexpr TripLeg_PathCostDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_PathCostDefaultTypeInternal() {}
  union {
    TripLeg_PathCost _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_PathCostDefaultTypeInternal _TripLeg_PathCost_default_instance_;
constexpr TripLeg_Node::TripLeg_Node(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : intersecting_edge_()
  , recosts_()
  , time_zone_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , edge_(nullptr)
  , transit_platform_info_(nullptr)
  , transit_station_info_(nullptr)
  , transit_egress_info_(nullptr)
  , cost_(nullptr)
  , bss_info_(nullptr)
  , admin_index_(0u)
  , type_(0)

  , fork_(false){}
struct TripLeg_NodeDefaultTypeInternal {
  constexpr TripLeg_NodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_NodeDefaultTypeInternal() {}
  union {
    TripLeg_Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_NodeDefaultTypeInternal _TripLeg_Node_default_instance_;
constexpr TripLeg_Admin::TripLeg_Admin(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : country_code_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , country_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_code_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct TripLeg_AdminDefaultTypeInternal {
  constexpr TripLeg_AdminDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_AdminDefaultTypeInternal() {}
  union {
    TripLeg_Admin _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_AdminDefaultTypeInternal _TripLeg_Admin_default_instance_;
constexpr TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : time_()
  , _time_cached_byte_size_(0)
  , length_()
  , _length_cached_byte_size_(0)
  , speed_()
  , _speed_cached_byte_size_(0)
  , speed_limit_()
  , _speed_limit_cached_byte_size_(0){}
struct TripLeg_ShapeAttributesDefaultTypeInternal {
  constexpr TripLeg_ShapeAttributesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_ShapeAttributesDefaultTypeInternal() {}
  union {
    TripLeg_ShapeAttributes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_ShapeAttributesDefaultTypeInternal _TripLeg_ShapeAttributes_default_instance_;
constexpr TripLeg_Incident::TripLeg_Incident(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : metadata_(nullptr)
  , begin_shape_index_(0u)
  , end_shape_index_(0u){}
struct TripLeg_IncidentDefaultTypeInternal {
  constexpr TripLeg_IncidentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_IncidentDefaultTypeInternal() {}
  union {
    TripLeg_Incident _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_IncidentDefaultTypeInternal _TripLeg_Incident_default_instance_;
constexpr TripLeg_Closure::TripLeg_Closure(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : begin_shape_index_(0u)
  , end_shape_index_(0u){}
struct TripLeg_ClosureDefaultTypeInternal {
  constexpr TripLeg_ClosureDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLeg_ClosureDefaultTypeInternal() {}
  union {
    TripLeg_Closure _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLeg_ClosureDefaultTypeInternal _TripLeg_Closure_default_instance_;
constexpr TripLeg::TripLeg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : location_()
  , node_()
  , admin_()
  , incidents_()
  , algorithms_()
  , closures_()
  , shape_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , bbox_(nullptr)
  , shape_attributes_(nullptr)
  , osm_changeset_(uint64_t{0u})
  , trip_id_(uint64_t{0u})
  , leg_id_(0u)
  , leg_count_(0u){}
struct TripLegDefaultTypeInternal {
  constexpr TripLegDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripLegDefaultTypeInternal() {}
  union {
    TripLeg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripLegDefaultTypeInternal _TripLeg_default_instance_;
constexpr TripRoute::TripRoute(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : legs_(){}
struct TripRouteDefaultTypeInternal {
  constexpr TripRouteDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripRouteDefaultTypeInternal() {}
  union {
    TripRoute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripRouteDefaultTypeInternal _TripRoute_default_instance_;
constexpr Trip::Trip(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : routes_(){}
struct TripDefaultTypeInternal {
  constexpr TripDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TripDefaultTypeInternal() {}
  union {
    Trip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace valhalla
namespace valhalla {
bool TripLeg_Node_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Node_Type_strings[13] = {};

static const char TripLeg_Node_Type_names[] =
  "kBikeShare"
  "kBollard"
  "kBorderControl"
  "kGate"
  "kMotorwayJunction"
  "kParking"
  "kStreetIntersection"
  "kSumpBuster"
  "kTollBooth"
  "kTollGantry"
  "kTransitEgress"
  "kTransitPlatform"
  "kTransitStation";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Node_Type_entries[] = {
  { {TripLeg_Node_Type_names + 0, 10}, 7 },
  { {TripLeg_Node_Type_names + 10, 8}, 2 },
  { {TripLeg_Node_Type_names + 18, 14}, 10 },
  { {TripLeg_Node_Type_names + 32, 5}, 1 },
  { {TripLeg_Node_Type_names + 37, 17}, 9 },
  { {TripLeg_Node_Type_names + 54, 8}, 8 },
  { {TripLeg_Node_Type_names + 62, 19}, 0 },
  { {TripLeg_Node_Type_names + 81, 11}, 12 },
  { {TripLeg_Node_Type_names + 92, 10}, 3 },
  { {TripLeg_Node_Type_names + 102, 11}, 11 },
  { {TripLeg_Node_Type_names + 113, 14}, 4 },
  { {TripLeg_Node_Type_names + 127, 16}, 6 },
  { {TripLeg_Node_Type_names + 143, 15}, 5 },
};

static const int TripLeg_Node_Type_entries_by_number[] = {
  6, // 0 -> kStreetIntersection
  3, // 1 -> kGate
  1, // 2 -> kBollard
  8, // 3 -> kTollBooth
  10, // 4 -> kTransitEgress
  12, // 5 -> kTransitStation
  11, // 6 -> kTransitPlatform
  0, // 7 -> kBikeShare
  5, // 8 -> kParking
  4, // 9 -> kMotorwayJunction
  2, // 10 -> kBorderControl
  9, // 11 -> kTollGantry
  7, // 12 -> kSumpBuster
};

const std::string& TripLeg_Node_Type_Name(
    TripLeg_Node_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Node_Type_entries,
          TripLeg_Node_Type_entries_by_number,
          13, TripLeg_Node_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Node_Type_entries,
      TripLeg_Node_Type_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Node_Type_strings[idx].get();
}
bool TripLeg_Node_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Node_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Node_Type_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Node_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
constexpr TripLeg_Node_Type TripLeg_Node::kGate;
constexpr TripLeg_Node_Type TripLeg_Node::kBollard;
constexpr TripLeg_Node_Type TripLeg_Node::kTollBooth;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitEgress;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitStation;
constexpr TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
constexpr TripLeg_Node_Type TripLeg_Node::kBikeShare;
constexpr TripLeg_Node_Type TripLeg_Node::kParking;
constexpr TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
constexpr TripLeg_Node_Type TripLeg_Node::kBorderControl;
constexpr TripLeg_Node_Type TripLeg_Node::kTollGantry;
constexpr TripLeg_Node_Type TripLeg_Node::kSumpBuster;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MIN;
constexpr TripLeg_Node_Type TripLeg_Node::Type_MAX;
constexpr int TripLeg_Node::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_Traversability_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Traversability_strings[4] = {};

static const char TripLeg_Traversability_names[] =
  "kBackward"
  "kBoth"
  "kForward"
  "kNone";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Traversability_entries[] = {
  { {TripLeg_Traversability_names + 0, 9}, 2 },
  { {TripLeg_Traversability_names + 9, 5}, 3 },
  { {TripLeg_Traversability_names + 14, 8}, 1 },
  { {TripLeg_Traversability_names + 22, 5}, 0 },
};

static const int TripLeg_Traversability_entries_by_number[] = {
  3, // 0 -> kNone
  2, // 1 -> kForward
  0, // 2 -> kBackward
  1, // 3 -> kBoth
};

const std::string& TripLeg_Traversability_Name(
    TripLeg_Traversability value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Traversability_entries,
          TripLeg_Traversability_entries_by_number,
          4, TripLeg_Traversability_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Traversability_entries,
      TripLeg_Traversability_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Traversability_strings[idx].get();
}
bool TripLeg_Traversability_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Traversability* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Traversability_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Traversability>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_Traversability TripLeg::kNone;
constexpr TripLeg_Traversability TripLeg::kForward;
constexpr TripLeg_Traversability TripLeg::kBackward;
constexpr TripLeg_Traversability TripLeg::kBoth;
constexpr TripLeg_Traversability TripLeg::Traversability_MIN;
constexpr TripLeg_Traversability TripLeg::Traversability_MAX;
constexpr int TripLeg::Traversability_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_Use_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 40:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Use_strings[31] = {};

static const char TripLeg_Use_names[] =
  "kAlleyUse"
  "kBridlewayUse"
  "kBusUse"
  "kCuldesacUse"
  "kCyclewayUse"
  "kDriveThruUse"
  "kDrivewayUse"
  "kEgressConnectionUse"
  "kEmergencyAccessUse"
  "kFerryUse"
  "kFootwayUse"
  "kLivingStreetUse"
  "kMountainBikeUse"
  "kOtherUse"
  "kParkingAisleUse"
  "kPathUse"
  "kPedestrianCrossingUse"
  "kPedestrianUse"
  "kPlatformConnectionUse"
  "kRailFerryUse"
  "kRailUse"
  "kRampUse"
  "kRestAreaUse"
  "kRoadUse"
  "kServiceAreaUse"
  "kServiceRoadUse"
  "kSidewalkUse"
  "kStepsUse"
  "kTrackUse"
  "kTransitConnectionUse"
  "kTurnChannelUse";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Use_entries[] = {
  { {TripLeg_Use_names + 0, 9}, 5 },
  { {TripLeg_Use_names + 9, 13}, 29 },
  { {TripLeg_Use_names + 22, 7}, 51 },
  { {TripLeg_Use_names + 29, 12}, 9 },
  { {TripLeg_Use_names + 41, 12}, 20 },
  { {TripLeg_Use_names + 53, 13}, 8 },
  { {TripLeg_Use_names + 66, 12}, 4 },
  { {TripLeg_Use_names + 78, 20}, 52 },
  { {TripLeg_Use_names + 98, 19}, 7 },
  { {TripLeg_Use_names + 117, 9}, 41 },
  { {TripLeg_Use_names + 126, 11}, 25 },
  { {TripLeg_Use_names + 137, 16}, 10 },
  { {TripLeg_Use_names + 153, 16}, 21 },
  { {TripLeg_Use_names + 169, 9}, 40 },
  { {TripLeg_Use_names + 178, 16}, 6 },
  { {TripLeg_Use_names + 194, 8}, 27 },
  { {TripLeg_Use_names + 202, 22}, 32 },
  { {TripLeg_Use_names + 224, 14}, 28 },
  { {TripLeg_Use_names + 238, 22}, 53 },
  { {TripLeg_Use_names + 260, 13}, 42 },
  { {TripLeg_Use_names + 273, 8}, 50 },
  { {TripLeg_Use_names + 281, 8}, 1 },
  { {TripLeg_Use_names + 289, 12}, 30 },
  { {TripLeg_Use_names + 301, 8}, 0 },
  { {TripLeg_Use_names + 309, 15}, 31 },
  { {TripLeg_Use_names + 324, 15}, 11 },
  { {TripLeg_Use_names + 339, 12}, 24 },
  { {TripLeg_Use_names + 351, 9}, 26 },
  { {TripLeg_Use_names + 360, 9}, 3 },
  { {TripLeg_Use_names + 369, 21}, 54 },
  { {TripLeg_Use_names + 390, 15}, 2 },
};

static const int TripLeg_Use_entries_by_number[] = {
  23, // 0 -> kRoadUse
  21, // 1 -> kRampUse
  30, // 2 -> kTurnChannelUse
  28, // 3 -> kTrackUse
  6, // 4 -> kDrivewayUse
  0, // 5 -> kAlleyUse
  14, // 6 -> kParkingAisleUse
  8, // 7 -> kEmergencyAccessUse
  5, // 8 -> kDriveThruUse
  3, // 9 -> kCuldesacUse
  11, // 10 -> kLivingStreetUse
  25, // 11 -> kServiceRoadUse
  4, // 20 -> kCyclewayUse
  12, // 21 -> kMountainBikeUse
  26, // 24 -> kSidewalkUse
  10, // 25 -> kFootwayUse
  27, // 26 -> kStepsUse
  15, // 27 -> kPathUse
  17, // 28 -> kPedestrianUse
  1, // 29 -> kBridlewayUse
  22, // 30 -> kRestAreaUse
  24, // 31 -> kServiceAreaUse
  16, // 32 -> kPedestrianCrossingUse
  13, // 40 -> kOtherUse
  9, // 41 -> kFerryUse
  19, // 42 -> kRailFerryUse
  20, // 50 -> kRailUse
  2, // 51 -> kBusUse
  7, // 52 -> kEgressConnectionUse
  18, // 53 -> kPlatformConnectionUse
  29, // 54 -> kTransitConnectionUse
};

const std::string& TripLeg_Use_Name(
    TripLeg_Use value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Use_entries,
          TripLeg_Use_entries_by_number,
          31, TripLeg_Use_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Use_entries,
      TripLeg_Use_entries_by_number,
      31, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Use_strings[idx].get();
}
bool TripLeg_Use_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Use* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Use_entries, 31, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Use>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_Use TripLeg::kRoadUse;
constexpr TripLeg_Use TripLeg::kRampUse;
constexpr TripLeg_Use TripLeg::kTurnChannelUse;
constexpr TripLeg_Use TripLeg::kTrackUse;
constexpr TripLeg_Use TripLeg::kDrivewayUse;
constexpr TripLeg_Use TripLeg::kAlleyUse;
constexpr TripLeg_Use TripLeg::kParkingAisleUse;
constexpr TripLeg_Use TripLeg::kEmergencyAccessUse;
constexpr TripLeg_Use TripLeg::kDriveThruUse;
constexpr TripLeg_Use TripLeg::kCuldesacUse;
constexpr TripLeg_Use TripLeg::kLivingStreetUse;
constexpr TripLeg_Use TripLeg::kServiceRoadUse;
constexpr TripLeg_Use TripLeg::kCyclewayUse;
constexpr TripLeg_Use TripLeg::kMountainBikeUse;
constexpr TripLeg_Use TripLeg::kSidewalkUse;
constexpr TripLeg_Use TripLeg::kFootwayUse;
constexpr TripLeg_Use TripLeg::kStepsUse;
constexpr TripLeg_Use TripLeg::kPathUse;
constexpr TripLeg_Use TripLeg::kPedestrianUse;
constexpr TripLeg_Use TripLeg::kBridlewayUse;
constexpr TripLeg_Use TripLeg::kPedestrianCrossingUse;
constexpr TripLeg_Use TripLeg::kRestAreaUse;
constexpr TripLeg_Use TripLeg::kServiceAreaUse;
constexpr TripLeg_Use TripLeg::kOtherUse;
constexpr TripLeg_Use TripLeg::kFerryUse;
constexpr TripLeg_Use TripLeg::kRailFerryUse;
constexpr TripLeg_Use TripLeg::kRailUse;
constexpr TripLeg_Use TripLeg::kBusUse;
constexpr TripLeg_Use TripLeg::kEgressConnectionUse;
constexpr TripLeg_Use TripLeg::kPlatformConnectionUse;
constexpr TripLeg_Use TripLeg::kTransitConnectionUse;
constexpr TripLeg_Use TripLeg::Use_MIN;
constexpr TripLeg_Use TripLeg::Use_MAX;
constexpr int TripLeg::Use_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_Surface_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Surface_strings[8] = {};

static const char TripLeg_Surface_names[] =
  "kCompacted"
  "kDirt"
  "kGravel"
  "kImpassable"
  "kPath"
  "kPaved"
  "kPavedRough"
  "kPavedSmooth";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Surface_entries[] = {
  { {TripLeg_Surface_names + 0, 10}, 3 },
  { {TripLeg_Surface_names + 10, 5}, 4 },
  { {TripLeg_Surface_names + 15, 7}, 5 },
  { {TripLeg_Surface_names + 22, 11}, 7 },
  { {TripLeg_Surface_names + 33, 5}, 6 },
  { {TripLeg_Surface_names + 38, 6}, 1 },
  { {TripLeg_Surface_names + 44, 11}, 2 },
  { {TripLeg_Surface_names + 55, 12}, 0 },
};

static const int TripLeg_Surface_entries_by_number[] = {
  7, // 0 -> kPavedSmooth
  5, // 1 -> kPaved
  6, // 2 -> kPavedRough
  0, // 3 -> kCompacted
  1, // 4 -> kDirt
  2, // 5 -> kGravel
  4, // 6 -> kPath
  3, // 7 -> kImpassable
};

const std::string& TripLeg_Surface_Name(
    TripLeg_Surface value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Surface_entries,
          TripLeg_Surface_entries_by_number,
          8, TripLeg_Surface_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Surface_entries,
      TripLeg_Surface_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Surface_strings[idx].get();
}
bool TripLeg_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Surface* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Surface_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Surface>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_Surface TripLeg::kPavedSmooth;
constexpr TripLeg_Surface TripLeg::kPaved;
constexpr TripLeg_Surface TripLeg::kPavedRough;
constexpr TripLeg_Surface TripLeg::kCompacted;
constexpr TripLeg_Surface TripLeg::kDirt;
constexpr TripLeg_Surface TripLeg::kGravel;
constexpr TripLeg_Surface TripLeg::kPath;
constexpr TripLeg_Surface TripLeg::kImpassable;
constexpr TripLeg_Surface TripLeg::Surface_MIN;
constexpr TripLeg_Surface TripLeg::Surface_MAX;
constexpr int TripLeg::Surface_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_TravelMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_TravelMode_strings[4] = {};

static const char TripLeg_TravelMode_names[] =
  "kBicycle"
  "kDrive"
  "kPedestrian"
  "kTransit";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_TravelMode_entries[] = {
  { {TripLeg_TravelMode_names + 0, 8}, 2 },
  { {TripLeg_TravelMode_names + 8, 6}, 0 },
  { {TripLeg_TravelMode_names + 14, 11}, 1 },
  { {TripLeg_TravelMode_names + 25, 8}, 3 },
};

static const int TripLeg_TravelMode_entries_by_number[] = {
  1, // 0 -> kDrive
  2, // 1 -> kPedestrian
  0, // 2 -> kBicycle
  3, // 3 -> kTransit
};

const std::string& TripLeg_TravelMode_Name(
    TripLeg_TravelMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_TravelMode_entries,
          TripLeg_TravelMode_entries_by_number,
          4, TripLeg_TravelMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_TravelMode_entries,
      TripLeg_TravelMode_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_TravelMode_strings[idx].get();
}
bool TripLeg_TravelMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_TravelMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_TravelMode_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_TravelMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_TravelMode TripLeg::kDrive;
constexpr TripLeg_TravelMode TripLeg::kPedestrian;
constexpr TripLeg_TravelMode TripLeg::kBicycle;
constexpr TripLeg_TravelMode TripLeg::kTransit;
constexpr TripLeg_TravelMode TripLeg::TravelMode_MIN;
constexpr TripLeg_TravelMode TripLeg::TravelMode_MAX;
constexpr int TripLeg::TravelMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_VehicleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_VehicleType_strings[5] = {};

static const char TripLeg_VehicleType_names[] =
  "kAutoBus"
  "kCar"
  "kMotorScooter"
  "kMotorcycle"
  "kTractorTrailer";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_VehicleType_entries[] = {
  { {TripLeg_VehicleType_names + 0, 8}, 2 },
  { {TripLeg_VehicleType_names + 8, 4}, 0 },
  { {TripLeg_VehicleType_names + 12, 13}, 4 },
  { {TripLeg_VehicleType_names + 25, 11}, 1 },
  { {TripLeg_VehicleType_names + 36, 15}, 3 },
};

static const int TripLeg_VehicleType_entries_by_number[] = {
  1, // 0 -> kCar
  3, // 1 -> kMotorcycle
  0, // 2 -> kAutoBus
  4, // 3 -> kTractorTrailer
  2, // 4 -> kMotorScooter
};

const std::string& TripLeg_VehicleType_Name(
    TripLeg_VehicleType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_VehicleType_entries,
          TripLeg_VehicleType_entries_by_number,
          5, TripLeg_VehicleType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_VehicleType_entries,
      TripLeg_VehicleType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_VehicleType_strings[idx].get();
}
bool TripLeg_VehicleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_VehicleType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_VehicleType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_VehicleType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_VehicleType TripLeg::kCar;
constexpr TripLeg_VehicleType TripLeg::kMotorcycle;
constexpr TripLeg_VehicleType TripLeg::kAutoBus;
constexpr TripLeg_VehicleType TripLeg::kTractorTrailer;
constexpr TripLeg_VehicleType TripLeg::kMotorScooter;
constexpr TripLeg_VehicleType TripLeg::VehicleType_MIN;
constexpr TripLeg_VehicleType TripLeg::VehicleType_MAX;
constexpr int TripLeg::VehicleType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_PedestrianType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_PedestrianType_strings[3] = {};

static const char TripLeg_PedestrianType_names[] =
  "kFoot"
  "kSegway"
  "kWheelchair";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_PedestrianType_entries[] = {
  { {TripLeg_PedestrianType_names + 0, 5}, 0 },
  { {TripLeg_PedestrianType_names + 5, 7}, 2 },
  { {TripLeg_PedestrianType_names + 12, 11}, 1 },
};

static const int TripLeg_PedestrianType_entries_by_number[] = {
  0, // 0 -> kFoot
  2, // 1 -> kWheelchair
  1, // 2 -> kSegway
};

const std::string& TripLeg_PedestrianType_Name(
    TripLeg_PedestrianType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_PedestrianType_entries,
          TripLeg_PedestrianType_entries_by_number,
          3, TripLeg_PedestrianType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_PedestrianType_entries,
      TripLeg_PedestrianType_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_PedestrianType_strings[idx].get();
}
bool TripLeg_PedestrianType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_PedestrianType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_PedestrianType_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_PedestrianType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_PedestrianType TripLeg::kFoot;
constexpr TripLeg_PedestrianType TripLeg::kWheelchair;
constexpr TripLeg_PedestrianType TripLeg::kSegway;
constexpr TripLeg_PedestrianType TripLeg::PedestrianType_MIN;
constexpr TripLeg_PedestrianType TripLeg::PedestrianType_MAX;
constexpr int TripLeg::PedestrianType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_BicycleType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_BicycleType_strings[4] = {};

static const char TripLeg_BicycleType_names[] =
  "kCross"
  "kHybrid"
  "kMountain"
  "kRoad";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_BicycleType_entries[] = {
  { {TripLeg_BicycleType_names + 0, 6}, 1 },
  { {TripLeg_BicycleType_names + 6, 7}, 2 },
  { {TripLeg_BicycleType_names + 13, 9}, 3 },
  { {TripLeg_BicycleType_names + 22, 5}, 0 },
};

static const int TripLeg_BicycleType_entries_by_number[] = {
  3, // 0 -> kRoad
  0, // 1 -> kCross
  1, // 2 -> kHybrid
  2, // 3 -> kMountain
};

const std::string& TripLeg_BicycleType_Name(
    TripLeg_BicycleType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_BicycleType_entries,
          TripLeg_BicycleType_entries_by_number,
          4, TripLeg_BicycleType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_BicycleType_entries,
      TripLeg_BicycleType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_BicycleType_strings[idx].get();
}
bool TripLeg_BicycleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_BicycleType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_BicycleType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_BicycleType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_BicycleType TripLeg::kRoad;
constexpr TripLeg_BicycleType TripLeg::kCross;
constexpr TripLeg_BicycleType TripLeg::kHybrid;
constexpr TripLeg_BicycleType TripLeg::kMountain;
constexpr TripLeg_BicycleType TripLeg::BicycleType_MIN;
constexpr TripLeg_BicycleType TripLeg::BicycleType_MAX;
constexpr int TripLeg::BicycleType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_TransitType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_TransitType_strings[8] = {};

static const char TripLeg_TransitType_names[] =
  "kBus"
  "kCableCar"
  "kFerry"
  "kFunicular"
  "kGondola"
  "kMetro"
  "kRail"
  "kTram";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_TransitType_entries[] = {
  { {TripLeg_TransitType_names + 0, 4}, 3 },
  { {TripLeg_TransitType_names + 4, 9}, 5 },
  { {TripLeg_TransitType_names + 13, 6}, 4 },
  { {TripLeg_TransitType_names + 19, 10}, 7 },
  { {TripLeg_TransitType_names + 29, 8}, 6 },
  { {TripLeg_TransitType_names + 37, 6}, 1 },
  { {TripLeg_TransitType_names + 43, 5}, 2 },
  { {TripLeg_TransitType_names + 48, 5}, 0 },
};

static const int TripLeg_TransitType_entries_by_number[] = {
  7, // 0 -> kTram
  5, // 1 -> kMetro
  6, // 2 -> kRail
  0, // 3 -> kBus
  2, // 4 -> kFerry
  1, // 5 -> kCableCar
  4, // 6 -> kGondola
  3, // 7 -> kFunicular
};

const std::string& TripLeg_TransitType_Name(
    TripLeg_TransitType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_TransitType_entries,
          TripLeg_TransitType_entries_by_number,
          8, TripLeg_TransitType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_TransitType_entries,
      TripLeg_TransitType_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_TransitType_strings[idx].get();
}
bool TripLeg_TransitType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_TransitType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_TransitType_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_TransitType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_TransitType TripLeg::kTram;
constexpr TripLeg_TransitType TripLeg::kMetro;
constexpr TripLeg_TransitType TripLeg::kRail;
constexpr TripLeg_TransitType TripLeg::kBus;
constexpr TripLeg_TransitType TripLeg::kFerry;
constexpr TripLeg_TransitType TripLeg::kCableCar;
constexpr TripLeg_TransitType TripLeg::kGondola;
constexpr TripLeg_TransitType TripLeg::kFunicular;
constexpr TripLeg_TransitType TripLeg::TransitType_MIN;
constexpr TripLeg_TransitType TripLeg::TransitType_MAX;
constexpr int TripLeg::TransitType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_CycleLane_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_CycleLane_strings[4] = {};

static const char TripLeg_CycleLane_names[] =
  "kDedicated"
  "kNoCycleLane"
  "kSeparated"
  "kShared";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_CycleLane_entries[] = {
  { {TripLeg_CycleLane_names + 0, 10}, 2 },
  { {TripLeg_CycleLane_names + 10, 12}, 0 },
  { {TripLeg_CycleLane_names + 22, 10}, 3 },
  { {TripLeg_CycleLane_names + 32, 7}, 1 },
};

static const int TripLeg_CycleLane_entries_by_number[] = {
  1, // 0 -> kNoCycleLane
  3, // 1 -> kShared
  0, // 2 -> kDedicated
  2, // 3 -> kSeparated
};

const std::string& TripLeg_CycleLane_Name(
    TripLeg_CycleLane value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_CycleLane_entries,
          TripLeg_CycleLane_entries_by_number,
          4, TripLeg_CycleLane_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_CycleLane_entries,
      TripLeg_CycleLane_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_CycleLane_strings[idx].get();
}
bool TripLeg_CycleLane_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_CycleLane* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_CycleLane_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_CycleLane>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_CycleLane TripLeg::kNoCycleLane;
constexpr TripLeg_CycleLane TripLeg::kShared;
constexpr TripLeg_CycleLane TripLeg::kDedicated;
constexpr TripLeg_CycleLane TripLeg::kSeparated;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MIN;
constexpr TripLeg_CycleLane TripLeg::CycleLane_MAX;
constexpr int TripLeg::CycleLane_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_SacScale_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_SacScale_strings[7] = {};

static const char TripLeg_SacScale_names[] =
  "kAlpineHiking"
  "kDemandingAlpineHiking"
  "kDemandingMountainHiking"
  "kDifficultAlpineHiking"
  "kHiking"
  "kMountainHiking"
  "kNoSacScale";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_SacScale_entries[] = {
  { {TripLeg_SacScale_names + 0, 13}, 4 },
  { {TripLeg_SacScale_names + 13, 22}, 5 },
  { {TripLeg_SacScale_names + 35, 24}, 3 },
  { {TripLeg_SacScale_names + 59, 22}, 6 },
  { {TripLeg_SacScale_names + 81, 7}, 1 },
  { {TripLeg_SacScale_names + 88, 15}, 2 },
  { {TripLeg_SacScale_names + 103, 11}, 0 },
};

static const int TripLeg_SacScale_entries_by_number[] = {
  6, // 0 -> kNoSacScale
  4, // 1 -> kHiking
  5, // 2 -> kMountainHiking
  2, // 3 -> kDemandingMountainHiking
  0, // 4 -> kAlpineHiking
  1, // 5 -> kDemandingAlpineHiking
  3, // 6 -> kDifficultAlpineHiking
};

const std::string& TripLeg_SacScale_Name(
    TripLeg_SacScale value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_SacScale_entries,
          TripLeg_SacScale_entries_by_number,
          7, TripLeg_SacScale_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_SacScale_entries,
      TripLeg_SacScale_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_SacScale_strings[idx].get();
}
bool TripLeg_SacScale_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_SacScale* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_SacScale_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_SacScale>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_SacScale TripLeg::kNoSacScale;
constexpr TripLeg_SacScale TripLeg::kHiking;
constexpr TripLeg_SacScale TripLeg::kMountainHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingMountainHiking;
constexpr TripLeg_SacScale TripLeg::kAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDemandingAlpineHiking;
constexpr TripLeg_SacScale TripLeg::kDifficultAlpineHiking;
constexpr TripLeg_SacScale TripLeg::SacScale_MIN;
constexpr TripLeg_SacScale TripLeg::SacScale_MAX;
constexpr int TripLeg::SacScale_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TripLeg_Sidewalk_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TripLeg_Sidewalk_strings[4] = {};

static const char TripLeg_Sidewalk_names[] =
  "kBothSides"
  "kLeft"
  "kNoSidewalk"
  "kRight";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TripLeg_Sidewalk_entries[] = {
  { {TripLeg_Sidewalk_names + 0, 10}, 3 },
  { {TripLeg_Sidewalk_names + 10, 5}, 1 },
  { {TripLeg_Sidewalk_names + 15, 11}, 0 },
  { {TripLeg_Sidewalk_names + 26, 6}, 2 },
};

static const int TripLeg_Sidewalk_entries_by_number[] = {
  2, // 0 -> kNoSidewalk
  1, // 1 -> kLeft
  3, // 2 -> kRight
  0, // 3 -> kBothSides
};

const std::string& TripLeg_Sidewalk_Name(
    TripLeg_Sidewalk value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TripLeg_Sidewalk_entries,
          TripLeg_Sidewalk_entries_by_number,
          4, TripLeg_Sidewalk_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TripLeg_Sidewalk_entries,
      TripLeg_Sidewalk_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TripLeg_Sidewalk_strings[idx].get();
}
bool TripLeg_Sidewalk_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TripLeg_Sidewalk* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TripLeg_Sidewalk_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<TripLeg_Sidewalk>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TripLeg_Sidewalk TripLeg::kNoSidewalk;
constexpr TripLeg_Sidewalk TripLeg::kLeft;
constexpr TripLeg_Sidewalk TripLeg::kRight;
constexpr TripLeg_Sidewalk TripLeg::kBothSides;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
constexpr TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
constexpr int TripLeg::Sidewalk_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

class TripLeg_SignElement::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_SignElement>()._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_route_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TripLeg_SignElement::TripLeg_SignElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.SignElement)
}
TripLeg_SignElement::TripLeg_SignElement(const TripLeg_SignElement& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_text()) {
    text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_text(), 
      GetArenaForAllocation());
  }
  is_route_number_ = from.is_route_number_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.SignElement)
}

inline void TripLeg_SignElement::SharedCtor() {
text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
is_route_number_ = false;
}

TripLeg_SignElement::~TripLeg_SignElement() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.SignElement)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_SignElement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_SignElement::ArenaDtor(void* object) {
  TripLeg_SignElement* _this = reinterpret_cast< TripLeg_SignElement* >(object);
  (void)_this;
}
void TripLeg_SignElement::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_SignElement::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_SignElement::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.SignElement)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    text_.ClearNonDefaultToEmpty();
  }
  is_route_number_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_SignElement::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_route_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_route_number(&has_bits);
          is_route_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_SignElement::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.SignElement)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  // optional bool is_route_number = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_route_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.SignElement)
  return target;
}

size_t TripLeg_SignElement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.SignElement)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text());
    }

    // optional bool is_route_number = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_SignElement::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_SignElement*>(
      &from));
}

void TripLeg_SignElement::MergeFrom(const TripLeg_SignElement& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.SignElement)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      is_route_number_ = from.is_route_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_SignElement::CopyFrom(const TripLeg_SignElement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.SignElement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_SignElement::IsInitialized() const {
  return true;
}

void TripLeg_SignElement::InternalSwap(TripLeg_SignElement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &text_, GetArenaForAllocation(),
      &other->text_, other->GetArenaForAllocation()
  );
  swap(is_route_number_, other->is_route_number_);
}

std::string TripLeg_SignElement::GetTypeName() const {
  return "valhalla.TripLeg.SignElement";
}


// ===================================================================

class TripLeg_Sign::_Internal {
 public:
};

TripLeg_Sign::TripLeg_Sign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  exit_numbers_(arena),
  exit_onto_streets_(arena),
  exit_toward_locations_(arena),
  exit_names_(arena),
  guide_onto_streets_(arena),
  guide_toward_locations_(arena),
  junction_names_(arena),
  guidance_view_junctions_(arena),
  guidance_view_signboards_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Sign)
}
TripLeg_Sign::TripLeg_Sign(const TripLeg_Sign& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      exit_numbers_(from.exit_numbers_),
      exit_onto_streets_(from.exit_onto_streets_),
      exit_toward_locations_(from.exit_toward_locations_),
      exit_names_(from.exit_names_),
      guide_onto_streets_(from.guide_onto_streets_),
      guide_toward_locations_(from.guide_toward_locations_),
      junction_names_(from.junction_names_),
      guidance_view_junctions_(from.guidance_view_junctions_),
      guidance_view_signboards_(from.guidance_view_signboards_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Sign)
}

inline void TripLeg_Sign::SharedCtor() {
}

TripLeg_Sign::~TripLeg_Sign() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Sign)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Sign::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Sign::ArenaDtor(void* object) {
  TripLeg_Sign* _this = reinterpret_cast< TripLeg_Sign* >(object);
  (void)_this;
}
void TripLeg_Sign::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Sign::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Sign::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Sign)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  exit_numbers_.Clear();
  exit_onto_streets_.Clear();
  exit_toward_locations_.Clear();
  exit_names_.Clear();
  guide_onto_streets_.Clear();
  guide_toward_locations_.Clear();
  junction_names_.Clear();
  guidance_view_junctions_.Clear();
  guidance_view_signboards_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Sign::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exit_numbers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exit_onto_streets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exit_toward_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement exit_names = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_exit_names(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement guide_onto_streets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_guide_onto_streets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement guide_toward_locations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_guide_toward_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement junction_names = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_junction_names(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement guidance_view_junctions = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_guidance_view_junctions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.SignElement guidance_view_signboards = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_guidance_view_signboards(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Sign::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Sign)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_exit_numbers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_exit_numbers(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_exit_onto_streets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_exit_onto_streets(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_exit_toward_locations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_exit_toward_locations(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement exit_names = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_exit_names_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_exit_names(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement guide_onto_streets = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_guide_onto_streets_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_guide_onto_streets(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement guide_toward_locations = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_guide_toward_locations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_guide_toward_locations(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement junction_names = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_junction_names_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_junction_names(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement guidance_view_junctions = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_guidance_view_junctions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_guidance_view_junctions(i), target, stream);
  }

  // repeated .valhalla.TripLeg.SignElement guidance_view_signboards = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_guidance_view_signboards_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_guidance_view_signboards(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Sign)
  return target;
}

size_t TripLeg_Sign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Sign)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
  total_size += 1UL * this->_internal_exit_numbers_size();
  for (const auto& msg : this->exit_numbers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
  total_size += 1UL * this->_internal_exit_onto_streets_size();
  for (const auto& msg : this->exit_onto_streets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
  total_size += 1UL * this->_internal_exit_toward_locations_size();
  for (const auto& msg : this->exit_toward_locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement exit_names = 4;
  total_size += 1UL * this->_internal_exit_names_size();
  for (const auto& msg : this->exit_names_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement guide_onto_streets = 5;
  total_size += 1UL * this->_internal_guide_onto_streets_size();
  for (const auto& msg : this->guide_onto_streets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement guide_toward_locations = 6;
  total_size += 1UL * this->_internal_guide_toward_locations_size();
  for (const auto& msg : this->guide_toward_locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement junction_names = 7;
  total_size += 1UL * this->_internal_junction_names_size();
  for (const auto& msg : this->junction_names_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement guidance_view_junctions = 8;
  total_size += 1UL * this->_internal_guidance_view_junctions_size();
  for (const auto& msg : this->guidance_view_junctions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.SignElement guidance_view_signboards = 9;
  total_size += 1UL * this->_internal_guidance_view_signboards_size();
  for (const auto& msg : this->guidance_view_signboards_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Sign::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Sign*>(
      &from));
}

void TripLeg_Sign::MergeFrom(const TripLeg_Sign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Sign)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  exit_numbers_.MergeFrom(from.exit_numbers_);
  exit_onto_streets_.MergeFrom(from.exit_onto_streets_);
  exit_toward_locations_.MergeFrom(from.exit_toward_locations_);
  exit_names_.MergeFrom(from.exit_names_);
  guide_onto_streets_.MergeFrom(from.guide_onto_streets_);
  guide_toward_locations_.MergeFrom(from.guide_toward_locations_);
  junction_names_.MergeFrom(from.junction_names_);
  guidance_view_junctions_.MergeFrom(from.guidance_view_junctions_);
  guidance_view_signboards_.MergeFrom(from.guidance_view_signboards_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Sign::CopyFrom(const TripLeg_Sign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Sign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Sign::IsInitialized() const {
  return true;
}

void TripLeg_Sign::InternalSwap(TripLeg_Sign* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  exit_numbers_.InternalSwap(&other->exit_numbers_);
  exit_onto_streets_.InternalSwap(&other->exit_onto_streets_);
  exit_toward_locations_.InternalSwap(&other->exit_toward_locations_);
  exit_names_.InternalSwap(&other->exit_names_);
  guide_onto_streets_.InternalSwap(&other->guide_onto_streets_);
  guide_toward_locations_.InternalSwap(&other->guide_toward_locations_);
  junction_names_.InternalSwap(&other->junction_names_);
  guidance_view_junctions_.InternalSwap(&other->guidance_view_junctions_);
  guidance_view_signboards_.InternalSwap(&other->guidance_view_signboards_);
}

std::string TripLeg_Sign::GetTypeName() const {
  return "valhalla.TripLeg.Sign";
}


// ===================================================================

class TripLeg_TransitRouteInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_TransitRouteInfo>()._has_bits_);
  static void set_has_onestop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_block_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_trip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_short_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_long_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_headsign(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_text_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_operator_onestop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_operator_name(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_operator_url(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

TripLeg_TransitRouteInfo::TripLeg_TransitRouteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TransitRouteInfo)
}
TripLeg_TransitRouteInfo::TripLeg_TransitRouteInfo(const TripLeg_TransitRouteInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  onestop_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_onestop_id()) {
    onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_onestop_id(), 
      GetArenaForAllocation());
  }
  short_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_short_name()) {
    short_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_short_name(), 
      GetArenaForAllocation());
  }
  long_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_long_name()) {
    long_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_long_name(), 
      GetArenaForAllocation());
  }
  headsign_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_headsign()) {
    headsign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_headsign(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  operator_onestop_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_operator_onestop_id()) {
    operator_onestop_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_operator_onestop_id(), 
      GetArenaForAllocation());
  }
  operator_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_operator_name()) {
    operator_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_operator_name(), 
      GetArenaForAllocation());
  }
  operator_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_operator_url()) {
    operator_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_operator_url(), 
      GetArenaForAllocation());
  }
  ::memcpy(&block_id_, &from.block_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&text_color_) -
    reinterpret_cast<char*>(&block_id_)) + sizeof(text_color_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TransitRouteInfo)
}

inline void TripLeg_TransitRouteInfo::SharedCtor() {
onestop_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
short_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
long_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
headsign_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
operator_onestop_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
operator_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
operator_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&block_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&text_color_) -
    reinterpret_cast<char*>(&block_id_)) + sizeof(text_color_));
}

TripLeg_TransitRouteInfo::~TripLeg_TransitRouteInfo() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TransitRouteInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_TransitRouteInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  onestop_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  short_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  long_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  headsign_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  operator_onestop_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  operator_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  operator_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_TransitRouteInfo::ArenaDtor(void* object) {
  TripLeg_TransitRouteInfo* _this = reinterpret_cast< TripLeg_TransitRouteInfo* >(object);
  (void)_this;
}
void TripLeg_TransitRouteInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_TransitRouteInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_TransitRouteInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TransitRouteInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      onestop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      short_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      long_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      headsign_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      operator_onestop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      operator_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      operator_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&block_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&text_color_) -
        reinterpret_cast<char*>(&block_id_)) + sizeof(text_color_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_TransitRouteInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string onestop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_onestop_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 block_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_block_id(&has_bits);
          block_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 trip_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_trip_id(&has_bits);
          trip_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string short_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_short_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string long_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_long_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string headsign = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_headsign();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 color = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 text_color = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_text_color(&has_bits);
          text_color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string description = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string operator_onestop_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_operator_onestop_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string operator_name = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_operator_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string operator_url = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_operator_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_TransitRouteInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TransitRouteInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string onestop_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_onestop_id(), target);
  }

  // optional uint32 block_id = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_block_id(), target);
  }

  // optional uint32 trip_id = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_trip_id(), target);
  }

  // optional string short_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_short_name(), target);
  }

  // optional string long_name = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_long_name(), target);
  }

  // optional string headsign = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_headsign(), target);
  }

  // optional uint32 color = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_color(), target);
  }

  // optional uint32 text_color = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_text_color(), target);
  }

  // optional string description = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_description(), target);
  }

  // optional string operator_onestop_id = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_operator_onestop_id(), target);
  }

  // optional string operator_name = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_operator_name(), target);
  }

  // optional string operator_url = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_operator_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TransitRouteInfo)
  return target;
}

size_t TripLeg_TransitRouteInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TransitRouteInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string onestop_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_onestop_id());
    }

    // optional string short_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_short_name());
    }

    // optional string long_name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_long_name());
    }

    // optional string headsign = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_headsign());
    }

    // optional string description = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string operator_onestop_id = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_operator_onestop_id());
    }

    // optional string operator_name = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_operator_name());
    }

    // optional string operator_url = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_operator_url());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 block_id = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_block_id());
    }

    // optional uint32 trip_id = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_trip_id());
    }

    // optional uint32 color = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_color());
    }

    // optional uint32 text_color = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_text_color());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_TransitRouteInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_TransitRouteInfo*>(
      &from));
}

void TripLeg_TransitRouteInfo::MergeFrom(const TripLeg_TransitRouteInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TransitRouteInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_onestop_id(from._internal_onestop_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_short_name(from._internal_short_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_long_name(from._internal_long_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_headsign(from._internal_headsign());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_operator_onestop_id(from._internal_operator_onestop_id());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_operator_name(from._internal_operator_name());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_operator_url(from._internal_operator_url());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      block_id_ = from.block_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      trip_id_ = from.trip_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000800u) {
      text_color_ = from.text_color_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TransitRouteInfo::CopyFrom(const TripLeg_TransitRouteInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TransitRouteInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TransitRouteInfo::IsInitialized() const {
  return true;
}

void TripLeg_TransitRouteInfo::InternalSwap(TripLeg_TransitRouteInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &onestop_id_, GetArenaForAllocation(),
      &other->onestop_id_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &short_name_, GetArenaForAllocation(),
      &other->short_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &long_name_, GetArenaForAllocation(),
      &other->long_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &headsign_, GetArenaForAllocation(),
      &other->headsign_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, GetArenaForAllocation(),
      &other->description_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &operator_onestop_id_, GetArenaForAllocation(),
      &other->operator_onestop_id_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &operator_name_, GetArenaForAllocation(),
      &other->operator_name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &operator_url_, GetArenaForAllocation(),
      &other->operator_url_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TransitRouteInfo, text_color_)
      + sizeof(TripLeg_TransitRouteInfo::text_color_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TransitRouteInfo, block_id_)>(
          reinterpret_cast<char*>(&block_id_),
          reinterpret_cast<char*>(&other->block_id_));
}

std::string TripLeg_TransitRouteInfo::GetTypeName() const {
  return "valhalla.TripLeg.TransitRouteInfo";
}


// ===================================================================

class TripLeg_BikeShareStationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_BikeShareStationInfo>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_capacity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_network(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_operator_(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_rent_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_return_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

TripLeg_BikeShareStationInfo::TripLeg_BikeShareStationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.BikeShareStationInfo)
}
TripLeg_BikeShareStationInfo::TripLeg_BikeShareStationInfo(const TripLeg_BikeShareStationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ref()) {
    ref_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ref(), 
      GetArenaForAllocation());
  }
  capacity_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_capacity()) {
    capacity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_capacity(), 
      GetArenaForAllocation());
  }
  network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_network()) {
    network_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_network(), 
      GetArenaForAllocation());
  }
  operator__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_operator_()) {
    operator__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_operator_(), 
      GetArenaForAllocation());
  }
  ::memcpy(&rent_cost_, &from.rent_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&return_cost_) -
    reinterpret_cast<char*>(&rent_cost_)) + sizeof(return_cost_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.BikeShareStationInfo)
}

inline void TripLeg_BikeShareStationInfo::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
ref_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
capacity_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
network_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
operator__.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&rent_cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&return_cost_) -
    reinterpret_cast<char*>(&rent_cost_)) + sizeof(return_cost_));
}

TripLeg_BikeShareStationInfo::~TripLeg_BikeShareStationInfo() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.BikeShareStationInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_BikeShareStationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ref_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  capacity_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  network_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  operator__.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_BikeShareStationInfo::ArenaDtor(void* object) {
  TripLeg_BikeShareStationInfo* _this = reinterpret_cast< TripLeg_BikeShareStationInfo* >(object);
  (void)_this;
}
void TripLeg_BikeShareStationInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_BikeShareStationInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_BikeShareStationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.BikeShareStationInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ref_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      capacity_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      network_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      operator__.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&rent_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&return_cost_) -
        reinterpret_cast<char*>(&rent_cost_)) + sizeof(return_cost_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_BikeShareStationInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string ref = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_ref();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string capacity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_capacity();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string network = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_network();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string operator = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_operator_();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float rent_cost = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_rent_cost(&has_bits);
          rent_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float return_cost = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_return_cost(&has_bits);
          return_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_BikeShareStationInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.BikeShareStationInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string ref = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ref(), target);
  }

  // optional string capacity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_capacity(), target);
  }

  // optional string network = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_network(), target);
  }

  // optional string operator = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_operator_(), target);
  }

  // optional float rent_cost = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_rent_cost(), target);
  }

  // optional float return_cost = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_return_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.BikeShareStationInfo)
  return target;
}

size_t TripLeg_BikeShareStationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.BikeShareStationInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string ref = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ref());
    }

    // optional string capacity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_capacity());
    }

    // optional string network = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_network());
    }

    // optional string operator = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_operator_());
    }

    // optional float rent_cost = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float return_cost = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_BikeShareStationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_BikeShareStationInfo*>(
      &from));
}

void TripLeg_BikeShareStationInfo::MergeFrom(const TripLeg_BikeShareStationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.BikeShareStationInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ref(from._internal_ref());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_capacity(from._internal_capacity());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_network(from._internal_network());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_operator_(from._internal_operator_());
    }
    if (cached_has_bits & 0x00000020u) {
      rent_cost_ = from.rent_cost_;
    }
    if (cached_has_bits & 0x00000040u) {
      return_cost_ = from.return_cost_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_BikeShareStationInfo::CopyFrom(const TripLeg_BikeShareStationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.BikeShareStationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_BikeShareStationInfo::IsInitialized() const {
  return true;
}

void TripLeg_BikeShareStationInfo::InternalSwap(TripLeg_BikeShareStationInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, GetArenaForAllocation(),
      &other->name_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ref_, GetArenaForAllocation(),
      &other->ref_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &capacity_, GetArenaForAllocation(),
      &other->capacity_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &network_, GetArenaForAllocation(),
      &other->network_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &operator__, GetArenaForAllocation(),
      &other->operator__, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_BikeShareStationInfo, return_cost_)
      + sizeof(TripLeg_BikeShareStationInfo::return_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_BikeShareStationInfo, rent_cost_)>(
          reinterpret_cast<char*>(&rent_cost_),
          reinterpret_cast<char*>(&other->rent_cost_));
}

std::string TripLeg_BikeShareStationInfo::GetTypeName() const {
  return "valhalla.TripLeg.BikeShareStationInfo";
}


// ===================================================================

class TripLeg_LaneConnectivity::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_LaneConnectivity>()._has_bits_);
  static void set_has_from_way_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_from_lanes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_to_lanes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.LaneConnectivity)
}
TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  from_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_from_lanes()) {
    from_lanes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_from_lanes(), 
      GetArenaForAllocation());
  }
  to_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_to_lanes()) {
    to_lanes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_to_lanes(), 
      GetArenaForAllocation());
  }
  from_way_id_ = from.from_way_id_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.LaneConnectivity)
}

inline void TripLeg_LaneConnectivity::SharedCtor() {
from_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
to_lanes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
from_way_id_ = uint64_t{0u};
}

TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.LaneConnectivity)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_LaneConnectivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  from_lanes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  to_lanes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_LaneConnectivity::ArenaDtor(void* object) {
  TripLeg_LaneConnectivity* _this = reinterpret_cast< TripLeg_LaneConnectivity* >(object);
  (void)_this;
}
void TripLeg_LaneConnectivity::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_LaneConnectivity::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.LaneConnectivity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      from_lanes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      to_lanes_.ClearNonDefaultToEmpty();
    }
  }
  from_way_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_LaneConnectivity::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 from_way_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_from_way_id(&has_bits);
          from_way_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string from_lanes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_from_lanes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string to_lanes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_to_lanes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_LaneConnectivity::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.LaneConnectivity)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 from_way_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_from_way_id(), target);
  }

  // optional string from_lanes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_from_lanes(), target);
  }

  // optional string to_lanes = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_to_lanes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.LaneConnectivity)
  return target;
}

size_t TripLeg_LaneConnectivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.LaneConnectivity)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string from_lanes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_from_lanes());
    }

    // optional string to_lanes = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_to_lanes());
    }

    // optional uint64 from_way_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_from_way_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_LaneConnectivity*>(
      &from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.LaneConnectivity)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_from_lanes(from._internal_from_lanes());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_to_lanes(from._internal_to_lanes());
    }
    if (cached_has_bits & 0x00000004u) {
      from_way_id_ = from.from_way_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.LaneConnectivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_LaneConnectivity::IsInitialized() const {
  return true;
}

void TripLeg_LaneConnectivity::InternalSwap(TripLeg_LaneConnectivity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &from_lanes_, GetArenaForAllocation(),
      &other->from_lanes_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &to_lanes_, GetArenaForAllocation(),
      &other->to_lanes_, other->GetArenaForAllocation()
  );
  swap(from_way_id_, other->from_way_id_);
}

std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}


// ===================================================================

class TripLeg_TrafficSegment::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_TrafficSegment>()._has_bits_);
  static void set_has_segment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_begin_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_end_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_starts_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ends_segment(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TripLeg_TrafficSegment::TripLeg_TrafficSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.TrafficSegment)
}
TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&segment_id_, &from.segment_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&ends_segment_) -
    reinterpret_cast<char*>(&segment_id_)) + sizeof(ends_segment_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.TrafficSegment)
}

inline void TripLeg_TrafficSegment::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&segment_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ends_segment_) -
    reinterpret_cast<char*>(&segment_id_)) + sizeof(ends_segment_));
}

TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.TrafficSegment)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_TrafficSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_TrafficSegment::ArenaDtor(void* object) {
  TripLeg_TrafficSegment* _this = reinterpret_cast< TripLeg_TrafficSegment* >(object);
  (void)_this;
}
void TripLeg_TrafficSegment::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_TrafficSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.TrafficSegment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&segment_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ends_segment_) -
        reinterpret_cast<char*>(&segment_id_)) + sizeof(ends_segment_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_TrafficSegment::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 segment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_segment_id(&has_bits);
          segment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float begin_percent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_begin_percent(&has_bits);
          begin_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float end_percent = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_end_percent(&has_bits);
          end_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool starts_segment = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_starts_segment(&has_bits);
          starts_segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ends_segment = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ends_segment(&has_bits);
          ends_segment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_TrafficSegment::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.TrafficSegment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 segment_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_segment_id(), target);
  }

  // optional float begin_percent = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_begin_percent(), target);
  }

  // optional float end_percent = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_end_percent(), target);
  }

  // optional bool starts_segment = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_starts_segment(), target);
  }

  // optional bool ends_segment = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_ends_segment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.TrafficSegment)
  return target;
}

size_t TripLeg_TrafficSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.TrafficSegment)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 segment_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_segment_id());
    }

    // optional float begin_percent = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float end_percent = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional bool starts_segment = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool ends_segment = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_TrafficSegment*>(
      &from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.TrafficSegment)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      segment_id_ = from.segment_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      begin_percent_ = from.begin_percent_;
    }
    if (cached_has_bits & 0x00000004u) {
      end_percent_ = from.end_percent_;
    }
    if (cached_has_bits & 0x00000008u) {
      starts_segment_ = from.starts_segment_;
    }
    if (cached_has_bits & 0x00000010u) {
      ends_segment_ = from.ends_segment_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.TrafficSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TrafficSegment::IsInitialized() const {
  return true;
}

void TripLeg_TrafficSegment::InternalSwap(TripLeg_TrafficSegment* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, ends_segment_)
      + sizeof(TripLeg_TrafficSegment::ends_segment_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_TrafficSegment, segment_id_)>(
          reinterpret_cast<char*>(&segment_id_),
          reinterpret_cast<char*>(&other->segment_id_));
}

std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}


// ===================================================================

class TripLeg_Restriction::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Restriction>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TripLeg_Restriction::TripLeg_Restriction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Restriction)
}
TripLeg_Restriction::TripLeg_Restriction(const TripLeg_Restriction& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Restriction)
}

inline void TripLeg_Restriction::SharedCtor() {
type_ = 0u;
}

TripLeg_Restriction::~TripLeg_Restriction() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Restriction)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Restriction::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Restriction::ArenaDtor(void* object) {
  TripLeg_Restriction* _this = reinterpret_cast< TripLeg_Restriction* >(object);
  (void)_this;
}
void TripLeg_Restriction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Restriction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Restriction::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Restriction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Restriction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Restriction::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Restriction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Restriction)
  return target;
}

size_t TripLeg_Restriction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Restriction)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Restriction::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Restriction*>(
      &from));
}

void TripLeg_Restriction::MergeFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Restriction)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_type()) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Restriction::CopyFrom(const TripLeg_Restriction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Restriction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Restriction::IsInitialized() const {
  return true;
}

void TripLeg_Restriction::InternalSwap(TripLeg_Restriction* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(type_, other->type_);
}

std::string TripLeg_Restriction::GetTypeName() const {
  return "valhalla.TripLeg.Restriction";
}


// ===================================================================

class TripLeg_Edge::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Edge>()._has_bits_);
  static void set_has_length_km(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_road_class(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_begin_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_end_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_begin_shape_index(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_end_shape_index(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_traversability(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_use(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_toll(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_unpaved(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_tunnel(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_bridge(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_roundabout(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_internal_intersection(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_drive_on_right(HasBits* has_bits) {
    (*has_bits)[1] |= 16384u;
  }
  static void set_has_surface(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::valhalla::TripLeg_Sign& sign(const TripLeg_Edge* msg);
  static void set_has_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_travel_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_vehicle_type(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_pedestrian_type(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_bicycle_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_transit_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::valhalla::TripLeg_TransitRouteInfo& transit_route_info(const TripLeg_Edge* msg);
  static void set_has_transit_route_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_way_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_weighted_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_max_upward_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_max_downward_grade(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_lane_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_cycle_lane(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static void set_has_bicycle_network(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_sidewalk(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
  static void set_has_density(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static void set_has_speed_limit(HasBits* has_bits) {
    (*has_bits)[1] |= 16u;
  }
  static void set_has_truck_speed(HasBits* has_bits) {
    (*has_bits)[1] |= 32u;
  }
  static void set_has_truck_route(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_mean_elevation(HasBits* has_bits) {
    (*has_bits)[1] |= 64u;
  }
  static void set_has_has_time_restrictions(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_default_speed(HasBits* has_bits) {
    (*has_bits)[1] |= 128u;
  }
  static const ::valhalla::TripLeg_Restriction& restriction(const TripLeg_Edge* msg);
  static void set_has_restriction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_destination_only(HasBits* has_bits) {
    (*has_bits)[1] |= 256u;
  }
  static void set_has_is_urban(HasBits* has_bits) {
    (*has_bits)[1] |= 512u;
  }
  static void set_has_source_along_edge(HasBits* has_bits) {
    (*has_bits)[1] |= 2048u;
  }
  static void set_has_target_along_edge(HasBits* has_bits) {
    (*has_bits)[1] |= 4096u;
  }
  static void set_has_sac_scale(HasBits* has_bits) {
    (*has_bits)[1] |= 8192u;
  }
  static void set_has_shoulder(HasBits* has_bits) {
    (*has_bits)[1] |= 1024u;
  }
};

const ::valhalla::TripLeg_Sign&
TripLeg_Edge::_Internal::sign(const TripLeg_Edge* msg) {
  return *msg->sign_;
}
const ::valhalla::TripLeg_TransitRouteInfo&
TripLeg_Edge::_Internal::transit_route_info(const TripLeg_Edge* msg) {
  return *msg->transit_route_info_;
}
const ::valhalla::TripLeg_Restriction&
TripLeg_Edge::_Internal::restriction(const TripLeg_Edge* msg) {
  return *msg->restriction_;
}
void TripLeg_Edge::clear_name() {
  name_.Clear();
}
void TripLeg_Edge::clear_turn_lanes() {
  turn_lanes_.Clear();
}
void TripLeg_Edge::clear_tagged_name() {
  tagged_name_.Clear();
}
TripLeg_Edge::TripLeg_Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  name_(arena),
  lane_connectivity_(arena),
  traffic_segment_(arena),
  turn_lanes_(arena),
  tagged_name_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Edge)
}
TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      name_(from.name_),
      lane_connectivity_(from.lane_connectivity_),
      traffic_segment_(from.traffic_segment_),
      turn_lanes_(from.turn_lanes_),
      tagged_name_(from.tagged_name_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sign()) {
    sign_ = new ::valhalla::TripLeg_Sign(*from.sign_);
  } else {
    sign_ = nullptr;
  }
  if (from._internal_has_transit_route_info()) {
    transit_route_info_ = new ::valhalla::TripLeg_TransitRouteInfo(*from.transit_route_info_);
  } else {
    transit_route_info_ = nullptr;
  }
  if (from._internal_has_restriction()) {
    restriction_ = new ::valhalla::TripLeg_Restriction(*from.restriction_);
  } else {
    restriction_ = nullptr;
  }
  ::memcpy(&length_km_, &from.length_km_,
    static_cast<size_t>(reinterpret_cast<char*>(&drive_on_right_) -
    reinterpret_cast<char*>(&length_km_)) + sizeof(drive_on_right_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Edge)
}

inline void TripLeg_Edge::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sign_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sac_scale_) -
    reinterpret_cast<char*>(&sign_)) + sizeof(sac_scale_));
drive_on_right_ = true;
}

TripLeg_Edge::~TripLeg_Edge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Edge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Edge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sign_;
  if (this != internal_default_instance()) delete transit_route_info_;
  if (this != internal_default_instance()) delete restriction_;
}

void TripLeg_Edge::ArenaDtor(void* object) {
  TripLeg_Edge* _this = reinterpret_cast< TripLeg_Edge* >(object);
  (void)_this;
}
void TripLeg_Edge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Edge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Edge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.Clear();
  lane_connectivity_.Clear();
  traffic_segment_.Clear();
  turn_lanes_.Clear();
  tagged_name_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sign_ != nullptr);
      sign_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(transit_route_info_ != nullptr);
      transit_route_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(restriction_ != nullptr);
      restriction_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&length_km_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_heading_) -
        reinterpret_cast<char*>(&length_km_)) + sizeof(end_heading_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&begin_shape_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bridge_) -
        reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(bridge_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&surface_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&way_id_) -
        reinterpret_cast<char*>(&surface_)) + sizeof(way_id_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&weighted_grade_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lane_count_) -
        reinterpret_cast<char*>(&weighted_grade_)) + sizeof(lane_count_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&cycle_lane_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&default_speed_) -
        reinterpret_cast<char*>(&cycle_lane_)) + sizeof(default_speed_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&destination_only_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sac_scale_) -
        reinterpret_cast<char*>(&destination_only_)) + sizeof(sac_scale_));
    drive_on_right_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Edge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.StreetName name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_name(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional float length_km = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_length_km(&_has_bits_);
          length_km_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_speed(&_has_bits_);
          speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.RoadClass road_class = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::RoadClass_IsValid(val))) {
            _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 begin_heading = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_begin_heading(&_has_bits_);
          begin_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 end_heading = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_end_heading(&_has_bits_);
          end_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 begin_shape_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_begin_shape_index(&_has_bits_);
          begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 end_shape_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_end_shape_index(&_has_bits_);
          end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Traversability traversability = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Traversability_IsValid(val))) {
            _internal_set_traversability(static_cast<::valhalla::TripLeg_Traversability>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Use use = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Use_IsValid(val))) {
            _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool toll = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_toll(&_has_bits_);
          toll_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool unpaved = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_unpaved(&_has_bits_);
          unpaved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool tunnel = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_tunnel(&_has_bits_);
          tunnel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool bridge = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_bridge(&_has_bits_);
          bridge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool roundabout = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_roundabout(&_has_bits_);
          roundabout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool internal_intersection = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_internal_intersection(&_has_bits_);
          internal_intersection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool drive_on_right = 17 [default = true];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_drive_on_right(&_has_bits_);
          drive_on_right_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Surface surface = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Surface_IsValid(val))) {
            _internal_set_surface(static_cast<::valhalla::TripLeg_Surface>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Sign sign = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_sign(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_TravelMode_IsValid(val))) {
            _internal_set_travel_mode(static_cast<::valhalla::TripLeg_TravelMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_VehicleType_IsValid(val))) {
            _internal_set_vehicle_type(static_cast<::valhalla::TripLeg_VehicleType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_PedestrianType_IsValid(val))) {
            _internal_set_pedestrian_type(static_cast<::valhalla::TripLeg_PedestrianType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_BicycleType_IsValid(val))) {
            _internal_set_bicycle_type(static_cast<::valhalla::TripLeg_BicycleType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(23, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.TransitType transit_type = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_TransitType_IsValid(val))) {
            _internal_set_transit_type(static_cast<::valhalla::TripLeg_TransitType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(24, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_route_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 id = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_id(&_has_bits_);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 way_id = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          _Internal::set_has_way_id(&_has_bits_);
          way_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float weighted_grade = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 229)) {
          _Internal::set_has_weighted_grade(&_has_bits_);
          weighted_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional int32 max_upward_grade = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_max_upward_grade(&_has_bits_);
          max_upward_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 max_downward_grade = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_max_downward_grade(&_has_bits_);
          max_downward_grade_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lane_count = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          _Internal::set_has_lane_count(&_has_bits_);
          lane_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_CycleLane_IsValid(val))) {
            _internal_set_cycle_lane(static_cast<::valhalla::TripLeg_CycleLane>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(32, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 bicycle_network = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bicycle_network(&_has_bits_);
          bicycle_network_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Sidewalk_IsValid(val))) {
            _internal_set_sidewalk(static_cast<::valhalla::TripLeg_Sidewalk>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(34, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 density = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_density(&_has_bits_);
          density_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 speed_limit = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_speed_limit(&_has_bits_);
          speed_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float truck_speed = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_truck_speed(&_has_bits_);
          truck_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool truck_route = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_truck_route(&_has_bits_);
          truck_route_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_lane_connectivity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<314>(ptr));
        } else goto handle_unusual;
        continue;
      // optional int32 mean_elevation = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_mean_elevation(&_has_bits_);
          mean_elevation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_traffic_segment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<330>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TurnLane turn_lanes = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_turn_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<338>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool has_time_restrictions = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_has_time_restrictions(&_has_bits_);
          has_time_restrictions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float default_speed = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_default_speed(&_has_bits_);
          default_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Restriction restriction = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_restriction(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool destination_only = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_destination_only(&_has_bits_);
          destination_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_urban = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_is_urban(&_has_bits_);
          is_urban_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TaggedName tagged_name = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_tagged_name(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<386>(ptr));
        } else goto handle_unusual;
        continue;
      // optional float source_along_edge = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_source_along_edge(&_has_bits_);
          source_along_edge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float target_along_edge = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_target_along_edge(&_has_bits_);
          target_along_edge_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.SacScale sac_scale = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_SacScale_IsValid(val))) {
            _internal_set_sac_scale(static_cast<::valhalla::TripLeg_SacScale>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(51, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool shoulder = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_shoulder(&_has_bits_);
          shoulder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Edge::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Edge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_name_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_name(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional float length_km = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_length_km(), target);
  }

  // optional float speed = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_speed(), target);
  }

  // optional .valhalla.RoadClass road_class = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_road_class(), target);
  }

  // optional uint32 begin_heading = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_begin_heading(), target);
  }

  // optional uint32 end_heading = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_end_heading(), target);
  }

  // optional uint32 begin_shape_index = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_begin_shape_index(), target);
  }

  // optional uint32 end_shape_index = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_end_shape_index(), target);
  }

  // optional .valhalla.TripLeg.Traversability traversability = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_traversability(), target);
  }

  // optional .valhalla.TripLeg.Use use = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_use(), target);
  }

  // optional bool toll = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_toll(), target);
  }

  // optional bool unpaved = 12;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_unpaved(), target);
  }

  // optional bool tunnel = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_tunnel(), target);
  }

  // optional bool bridge = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_bridge(), target);
  }

  // optional bool roundabout = 15;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_roundabout(), target);
  }

  // optional bool internal_intersection = 16;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_internal_intersection(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool drive_on_right = 17 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_drive_on_right(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .valhalla.TripLeg.Surface surface = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      18, this->_internal_surface(), target);
  }

  // optional .valhalla.TripLeg.Sign sign = 19;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::sign(this), target, stream);
  }

  // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->_internal_travel_mode(), target);
  }

  // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      21, this->_internal_vehicle_type(), target);
  }

  // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      22, this->_internal_pedestrian_type(), target);
  }

  // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      23, this->_internal_bicycle_type(), target);
  }

  // optional .valhalla.TripLeg.TransitType transit_type = 24;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      24, this->_internal_transit_type(), target);
  }

  // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::transit_route_info(this), target, stream);
  }

  // optional uint64 id = 26;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(26, this->_internal_id(), target);
  }

  // optional uint64 way_id = 27;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(27, this->_internal_way_id(), target);
  }

  // optional float weighted_grade = 28;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(28, this->_internal_weighted_grade(), target);
  }

  // optional int32 max_upward_grade = 29;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_max_upward_grade(), target);
  }

  // optional int32 max_downward_grade = 30;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(30, this->_internal_max_downward_grade(), target);
  }

  // optional uint32 lane_count = 31;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(31, this->_internal_lane_count(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      32, this->_internal_cycle_lane(), target);
  }

  // optional uint32 bicycle_network = 33;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(33, this->_internal_bicycle_network(), target);
  }

  // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      34, this->_internal_sidewalk(), target);
  }

  // optional uint32 density = 35;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(35, this->_internal_density(), target);
  }

  // optional uint32 speed_limit = 36;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(36, this->_internal_speed_limit(), target);
  }

  // optional float truck_speed = 37;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(37, this->_internal_truck_speed(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool truck_route = 38;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(38, this->_internal_truck_route(), target);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_lane_connectivity_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(39, this->_internal_lane_connectivity(i), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 mean_elevation = 40;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(40, this->_internal_mean_elevation(), target);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_traffic_segment_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(41, this->_internal_traffic_segment(i), target, stream);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_turn_lanes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(42, this->_internal_turn_lanes(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool has_time_restrictions = 43;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(43, this->_internal_has_time_restrictions(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional float default_speed = 44;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(44, this->_internal_default_speed(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .valhalla.TripLeg.Restriction restriction = 45;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        45, _Internal::restriction(this), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool destination_only = 46;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(46, this->_internal_destination_only(), target);
  }

  // optional bool is_urban = 47;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(47, this->_internal_is_urban(), target);
  }

  // repeated .valhalla.TaggedName tagged_name = 48;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tagged_name_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(48, this->_internal_tagged_name(i), target, stream);
  }

  // optional float source_along_edge = 49;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(49, this->_internal_source_along_edge(), target);
  }

  // optional float target_along_edge = 50;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(50, this->_internal_target_along_edge(), target);
  }

  // optional .valhalla.TripLeg.SacScale sac_scale = 51;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      51, this->_internal_sac_scale(), target);
  }

  // optional bool shoulder = 52;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(52, this->_internal_shoulder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Edge)
  return target;
}

size_t TripLeg_Edge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Edge)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.StreetName name = 1;
  total_size += 1UL * this->_internal_name_size();
  for (const auto& msg : this->name_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2UL * this->_internal_lane_connectivity_size();
  for (const auto& msg : this->lane_connectivity_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2UL * this->_internal_traffic_segment_size();
  for (const auto& msg : this->traffic_segment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2UL * this->_internal_turn_lanes_size();
  for (const auto& msg : this->turn_lanes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TaggedName tagged_name = 48;
  total_size += 2UL * this->_internal_tagged_name_size();
  for (const auto& msg : this->tagged_name_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .valhalla.TripLeg.Sign sign = 19;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sign_);
    }

    // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transit_route_info_);
    }

    // optional .valhalla.TripLeg.Restriction restriction = 45;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *restriction_);
    }

    // optional float length_km = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional .valhalla.RoadClass road_class = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_road_class());
    }

    // optional uint32 begin_heading = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_begin_heading());
    }

    // optional uint32 end_heading = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_end_heading());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 begin_shape_index = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_begin_shape_index());
    }

    // optional uint32 end_shape_index = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_end_shape_index());
    }

    // optional .valhalla.TripLeg.Traversability traversability = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_traversability());
    }

    // optional .valhalla.TripLeg.Use use = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_use());
    }

    // optional bool toll = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool unpaved = 12;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool tunnel = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool bridge = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .valhalla.TripLeg.Surface surface = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_surface());
    }

    // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_travel_mode());
    }

    // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_vehicle_type());
    }

    // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_pedestrian_type());
    }

    // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_bicycle_type());
    }

    // optional .valhalla.TripLeg.TransitType transit_type = 24;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_transit_type());
    }

    // optional uint64 id = 26;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_id());
    }

    // optional uint64 way_id = 27;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_way_id());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional float weighted_grade = 28;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 4;
    }

    // optional bool roundabout = 15;
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 + 1;
    }

    // optional bool internal_intersection = 16;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool truck_route = 38;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool has_time_restrictions = 43;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional int32 max_upward_grade = 29;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_upward_grade());
    }

    // optional int32 max_downward_grade = 30;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_max_downward_grade());
    }

    // optional uint32 lane_count = 31;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lane_count());
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cycle_lane());
    }

    // optional uint32 bicycle_network = 33;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_bicycle_network());
    }

    // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_sidewalk());
    }

    // optional uint32 density = 35;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_density());
    }

    // optional uint32 speed_limit = 36;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_speed_limit());
    }

    // optional float truck_speed = 37;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + 4;
    }

    // optional int32 mean_elevation = 40;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_mean_elevation());
    }

    // optional float default_speed = 44;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool destination_only = 46;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool is_urban = 47;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool shoulder = 52;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional float source_along_edge = 49;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 4;
    }

    // optional float target_along_edge = 50;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 4;
    }

    // optional .valhalla.TripLeg.SacScale sac_scale = 51;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_sac_scale());
    }

    // optional bool drive_on_right = 17 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Edge*>(
      &from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Edge)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  name_.MergeFrom(from.name_);
  lane_connectivity_.MergeFrom(from.lane_connectivity_);
  traffic_segment_.MergeFrom(from.traffic_segment_);
  turn_lanes_.MergeFrom(from.turn_lanes_);
  tagged_name_.MergeFrom(from.tagged_name_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sign()->::valhalla::TripLeg_Sign::MergeFrom(from._internal_sign());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_transit_route_info()->::valhalla::TripLeg_TransitRouteInfo::MergeFrom(from._internal_transit_route_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_restriction()->::valhalla::TripLeg_Restriction::MergeFrom(from._internal_restriction());
    }
    if (cached_has_bits & 0x00000008u) {
      length_km_ = from.length_km_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_ = from.speed_;
    }
    if (cached_has_bits & 0x00000020u) {
      road_class_ = from.road_class_;
    }
    if (cached_has_bits & 0x00000040u) {
      begin_heading_ = from.begin_heading_;
    }
    if (cached_has_bits & 0x00000080u) {
      end_heading_ = from.end_heading_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      begin_shape_index_ = from.begin_shape_index_;
    }
    if (cached_has_bits & 0x00000200u) {
      end_shape_index_ = from.end_shape_index_;
    }
    if (cached_has_bits & 0x00000400u) {
      traversability_ = from.traversability_;
    }
    if (cached_has_bits & 0x00000800u) {
      use_ = from.use_;
    }
    if (cached_has_bits & 0x00001000u) {
      toll_ = from.toll_;
    }
    if (cached_has_bits & 0x00002000u) {
      unpaved_ = from.unpaved_;
    }
    if (cached_has_bits & 0x00004000u) {
      tunnel_ = from.tunnel_;
    }
    if (cached_has_bits & 0x00008000u) {
      bridge_ = from.bridge_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      surface_ = from.surface_;
    }
    if (cached_has_bits & 0x00020000u) {
      travel_mode_ = from.travel_mode_;
    }
    if (cached_has_bits & 0x00040000u) {
      vehicle_type_ = from.vehicle_type_;
    }
    if (cached_has_bits & 0x00080000u) {
      pedestrian_type_ = from.pedestrian_type_;
    }
    if (cached_has_bits & 0x00100000u) {
      bicycle_type_ = from.bicycle_type_;
    }
    if (cached_has_bits & 0x00200000u) {
      transit_type_ = from.transit_type_;
    }
    if (cached_has_bits & 0x00400000u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00800000u) {
      way_id_ = from.way_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      weighted_grade_ = from.weighted_grade_;
    }
    if (cached_has_bits & 0x02000000u) {
      roundabout_ = from.roundabout_;
    }
    if (cached_has_bits & 0x04000000u) {
      internal_intersection_ = from.internal_intersection_;
    }
    if (cached_has_bits & 0x08000000u) {
      truck_route_ = from.truck_route_;
    }
    if (cached_has_bits & 0x10000000u) {
      has_time_restrictions_ = from.has_time_restrictions_;
    }
    if (cached_has_bits & 0x20000000u) {
      max_upward_grade_ = from.max_upward_grade_;
    }
    if (cached_has_bits & 0x40000000u) {
      max_downward_grade_ = from.max_downward_grade_;
    }
    if (cached_has_bits & 0x80000000u) {
      lane_count_ = from.lane_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      cycle_lane_ = from.cycle_lane_;
    }
    if (cached_has_bits & 0x00000002u) {
      bicycle_network_ = from.bicycle_network_;
    }
    if (cached_has_bits & 0x00000004u) {
      sidewalk_ = from.sidewalk_;
    }
    if (cached_has_bits & 0x00000008u) {
      density_ = from.density_;
    }
    if (cached_has_bits & 0x00000010u) {
      speed_limit_ = from.speed_limit_;
    }
    if (cached_has_bits & 0x00000020u) {
      truck_speed_ = from.truck_speed_;
    }
    if (cached_has_bits & 0x00000040u) {
      mean_elevation_ = from.mean_elevation_;
    }
    if (cached_has_bits & 0x00000080u) {
      default_speed_ = from.default_speed_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      destination_only_ = from.destination_only_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_urban_ = from.is_urban_;
    }
    if (cached_has_bits & 0x00000400u) {
      shoulder_ = from.shoulder_;
    }
    if (cached_has_bits & 0x00000800u) {
      source_along_edge_ = from.source_along_edge_;
    }
    if (cached_has_bits & 0x00001000u) {
      target_along_edge_ = from.target_along_edge_;
    }
    if (cached_has_bits & 0x00002000u) {
      sac_scale_ = from.sac_scale_;
    }
    if (cached_has_bits & 0x00004000u) {
      drive_on_right_ = from.drive_on_right_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Edge::IsInitialized() const {
  return true;
}

void TripLeg_Edge::InternalSwap(TripLeg_Edge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  name_.InternalSwap(&other->name_);
  lane_connectivity_.InternalSwap(&other->lane_connectivity_);
  traffic_segment_.InternalSwap(&other->traffic_segment_);
  turn_lanes_.InternalSwap(&other->turn_lanes_);
  tagged_name_.InternalSwap(&other->tagged_name_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Edge, sac_scale_)
      + sizeof(TripLeg_Edge::sac_scale_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Edge, sign_)>(
          reinterpret_cast<char*>(&sign_),
          reinterpret_cast<char*>(&other->sign_));
  swap(drive_on_right_, other->drive_on_right_);
}

std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}


// ===================================================================

class TripLeg_IntersectingEdge::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_IntersectingEdge>()._has_bits_);
  static void set_has_begin_heading(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prev_name_consistency(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_curr_name_consistency(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_driveability(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cyclability(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_walkability(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_use(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_road_class(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.IntersectingEdge)
}
TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&begin_heading_, &from.begin_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&road_class_) -
    reinterpret_cast<char*>(&begin_heading_)) + sizeof(road_class_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.IntersectingEdge)
}

inline void TripLeg_IntersectingEdge::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&begin_heading_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&road_class_) -
    reinterpret_cast<char*>(&begin_heading_)) + sizeof(road_class_));
}

TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.IntersectingEdge)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_IntersectingEdge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_IntersectingEdge::ArenaDtor(void* object) {
  TripLeg_IntersectingEdge* _this = reinterpret_cast< TripLeg_IntersectingEdge* >(object);
  (void)_this;
}
void TripLeg_IntersectingEdge::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_IntersectingEdge::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.IntersectingEdge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&begin_heading_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&road_class_) -
        reinterpret_cast<char*>(&begin_heading_)) + sizeof(road_class_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_IntersectingEdge::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 begin_heading = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_begin_heading(&has_bits);
          begin_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool prev_name_consistency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_prev_name_consistency(&has_bits);
          prev_name_consistency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool curr_name_consistency = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_curr_name_consistency(&has_bits);
          curr_name_consistency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Traversability driveability = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Traversability_IsValid(val))) {
            _internal_set_driveability(static_cast<::valhalla::TripLeg_Traversability>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Traversability cyclability = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Traversability_IsValid(val))) {
            _internal_set_cyclability(static_cast<::valhalla::TripLeg_Traversability>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Traversability walkability = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Traversability_IsValid(val))) {
            _internal_set_walkability(static_cast<::valhalla::TripLeg_Traversability>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Use use = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Use_IsValid(val))) {
            _internal_set_use(static_cast<::valhalla::TripLeg_Use>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .valhalla.RoadClass road_class = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::RoadClass_IsValid(val))) {
            _internal_set_road_class(static_cast<::valhalla::RoadClass>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_IntersectingEdge::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.IntersectingEdge)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 begin_heading = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_heading(), target);
  }

  // optional bool prev_name_consistency = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_prev_name_consistency(), target);
  }

  // optional bool curr_name_consistency = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_curr_name_consistency(), target);
  }

  // optional .valhalla.TripLeg.Traversability driveability = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_driveability(), target);
  }

  // optional .valhalla.TripLeg.Traversability cyclability = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_cyclability(), target);
  }

  // optional .valhalla.TripLeg.Traversability walkability = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_walkability(), target);
  }

  // optional .valhalla.TripLeg.Use use = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_use(), target);
  }

  // optional .valhalla.RoadClass road_class = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_road_class(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.IntersectingEdge)
  return target;
}

size_t TripLeg_IntersectingEdge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.IntersectingEdge)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional uint32 begin_heading = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_begin_heading());
    }

    // optional bool prev_name_consistency = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool curr_name_consistency = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .valhalla.TripLeg.Traversability driveability = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_driveability());
    }

    // optional .valhalla.TripLeg.Traversability cyclability = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cyclability());
    }

    // optional .valhalla.TripLeg.Traversability walkability = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_walkability());
    }

    // optional .valhalla.TripLeg.Use use = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_use());
    }

    // optional .valhalla.RoadClass road_class = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_road_class());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_IntersectingEdge*>(
      &from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.IntersectingEdge)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      begin_heading_ = from.begin_heading_;
    }
    if (cached_has_bits & 0x00000002u) {
      prev_name_consistency_ = from.prev_name_consistency_;
    }
    if (cached_has_bits & 0x00000004u) {
      curr_name_consistency_ = from.curr_name_consistency_;
    }
    if (cached_has_bits & 0x00000008u) {
      driveability_ = from.driveability_;
    }
    if (cached_has_bits & 0x00000010u) {
      cyclability_ = from.cyclability_;
    }
    if (cached_has_bits & 0x00000020u) {
      walkability_ = from.walkability_;
    }
    if (cached_has_bits & 0x00000040u) {
      use_ = from.use_;
    }
    if (cached_has_bits & 0x00000080u) {
      road_class_ = from.road_class_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.IntersectingEdge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_IntersectingEdge::IsInitialized() const {
  return true;
}

void TripLeg_IntersectingEdge::InternalSwap(TripLeg_IntersectingEdge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, road_class_)
      + sizeof(TripLeg_IntersectingEdge::road_class_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_IntersectingEdge, begin_heading_)>(
          reinterpret_cast<char*>(&begin_heading_),
          reinterpret_cast<char*>(&other->begin_heading_));
}

std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}


// ===================================================================

class TripLeg_Cost::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Cost>()._has_bits_);
  static void set_has_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TripLeg_Cost::TripLeg_Cost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Cost)
}
TripLeg_Cost::TripLeg_Cost(const TripLeg_Cost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&seconds_, &from.seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&cost_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(cost_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Cost)
}

inline void TripLeg_Cost::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cost_) -
    reinterpret_cast<char*>(&seconds_)) + sizeof(cost_));
}

TripLeg_Cost::~TripLeg_Cost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Cost)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Cost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Cost::ArenaDtor(void* object) {
  TripLeg_Cost* _this = reinterpret_cast< TripLeg_Cost* >(object);
  (void)_this;
}
void TripLeg_Cost::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Cost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Cost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Cost)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cost_) -
        reinterpret_cast<char*>(&seconds_)) + sizeof(cost_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Cost::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          _Internal::set_has_seconds(&has_bits);
          seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional double cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          _Internal::set_has_cost(&has_bits);
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Cost::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Cost)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_seconds(), target);
  }

  // optional double cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_cost(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Cost)
  return target;
}

size_t TripLeg_Cost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Cost)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional double seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double cost = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Cost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Cost*>(
      &from));
}

void TripLeg_Cost::MergeFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Cost)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      seconds_ = from.seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      cost_ = from.cost_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Cost::CopyFrom(const TripLeg_Cost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Cost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Cost::IsInitialized() const {
  return true;
}

void TripLeg_Cost::InternalSwap(TripLeg_Cost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Cost, cost_)
      + sizeof(TripLeg_Cost::cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Cost, seconds_)>(
          reinterpret_cast<char*>(&seconds_),
          reinterpret_cast<char*>(&other->seconds_));
}

std::string TripLeg_Cost::GetTypeName() const {
  return "valhalla.TripLeg.Cost";
}


// ===================================================================

class TripLeg_PathCost::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_PathCost>()._has_bits_);
  static const ::valhalla::TripLeg_Cost& elapsed_cost(const TripLeg_PathCost* msg);
  static void set_has_elapsed_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::TripLeg_Cost& transition_cost(const TripLeg_PathCost* msg);
  static void set_has_transition_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::elapsed_cost(const TripLeg_PathCost* msg) {
  return *msg->elapsed_cost_;
}
const ::valhalla::TripLeg_Cost&
TripLeg_PathCost::_Internal::transition_cost(const TripLeg_PathCost* msg) {
  return *msg->transition_cost_;
}
TripLeg_PathCost::TripLeg_PathCost(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.PathCost)
}
TripLeg_PathCost::TripLeg_PathCost(const TripLeg_PathCost& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_elapsed_cost()) {
    elapsed_cost_ = new ::valhalla::TripLeg_Cost(*from.elapsed_cost_);
  } else {
    elapsed_cost_ = nullptr;
  }
  if (from._internal_has_transition_cost()) {
    transition_cost_ = new ::valhalla::TripLeg_Cost(*from.transition_cost_);
  } else {
    transition_cost_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.PathCost)
}

inline void TripLeg_PathCost::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&elapsed_cost_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transition_cost_) -
    reinterpret_cast<char*>(&elapsed_cost_)) + sizeof(transition_cost_));
}

TripLeg_PathCost::~TripLeg_PathCost() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.PathCost)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_PathCost::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete elapsed_cost_;
  if (this != internal_default_instance()) delete transition_cost_;
}

void TripLeg_PathCost::ArenaDtor(void* object) {
  TripLeg_PathCost* _this = reinterpret_cast< TripLeg_PathCost* >(object);
  (void)_this;
}
void TripLeg_PathCost::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_PathCost::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_PathCost::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.PathCost)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(elapsed_cost_ != nullptr);
      elapsed_cost_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(transition_cost_ != nullptr);
      transition_cost_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_PathCost::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_elapsed_cost(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Cost transition_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_transition_cost(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_PathCost::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.PathCost)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::elapsed_cost(this), target, stream);
  }

  // optional .valhalla.TripLeg.Cost transition_cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::transition_cost(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.PathCost)
  return target;
}

size_t TripLeg_PathCost::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.PathCost)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .valhalla.TripLeg.Cost elapsed_cost = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *elapsed_cost_);
    }

    // optional .valhalla.TripLeg.Cost transition_cost = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transition_cost_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_PathCost::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_PathCost*>(
      &from));
}

void TripLeg_PathCost::MergeFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.PathCost)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_elapsed_cost()->::valhalla::TripLeg_Cost::MergeFrom(from._internal_elapsed_cost());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_transition_cost()->::valhalla::TripLeg_Cost::MergeFrom(from._internal_transition_cost());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_PathCost::CopyFrom(const TripLeg_PathCost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.PathCost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_PathCost::IsInitialized() const {
  return true;
}

void TripLeg_PathCost::InternalSwap(TripLeg_PathCost* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, transition_cost_)
      + sizeof(TripLeg_PathCost::transition_cost_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_PathCost, elapsed_cost_)>(
          reinterpret_cast<char*>(&elapsed_cost_),
          reinterpret_cast<char*>(&other->elapsed_cost_));
}

std::string TripLeg_PathCost::GetTypeName() const {
  return "valhalla.TripLeg.PathCost";
}


// ===================================================================

class TripLeg_Node::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Node>()._has_bits_);
  static const ::valhalla::TripLeg_Edge& edge(const TripLeg_Node* msg);
  static void set_has_edge(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_admin_index(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_fork(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::valhalla::TransitPlatformInfo& transit_platform_info(const TripLeg_Node* msg);
  static void set_has_transit_platform_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::valhalla::TransitStationInfo& transit_station_info(const TripLeg_Node* msg);
  static void set_has_transit_station_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::valhalla::TransitEgressInfo& transit_egress_info(const TripLeg_Node* msg);
  static void set_has_transit_egress_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_time_zone(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::TripLeg_PathCost& cost(const TripLeg_Node* msg);
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::valhalla::TripLeg_BikeShareStationInfo& bss_info(const TripLeg_Node* msg);
  static void set_has_bss_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::valhalla::TripLeg_Edge&
TripLeg_Node::_Internal::edge(const TripLeg_Node* msg) {
  return *msg->edge_;
}
const ::valhalla::TransitPlatformInfo&
TripLeg_Node::_Internal::transit_platform_info(const TripLeg_Node* msg) {
  return *msg->transit_platform_info_;
}
const ::valhalla::TransitStationInfo&
TripLeg_Node::_Internal::transit_station_info(const TripLeg_Node* msg) {
  return *msg->transit_station_info_;
}
const ::valhalla::TransitEgressInfo&
TripLeg_Node::_Internal::transit_egress_info(const TripLeg_Node* msg) {
  return *msg->transit_egress_info_;
}
const ::valhalla::TripLeg_PathCost&
TripLeg_Node::_Internal::cost(const TripLeg_Node* msg) {
  return *msg->cost_;
}
const ::valhalla::TripLeg_BikeShareStationInfo&
TripLeg_Node::_Internal::bss_info(const TripLeg_Node* msg) {
  return *msg->bss_info_;
}
void TripLeg_Node::clear_transit_platform_info() {
  if (transit_platform_info_ != nullptr) transit_platform_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void TripLeg_Node::clear_transit_station_info() {
  if (transit_station_info_ != nullptr) transit_station_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void TripLeg_Node::clear_transit_egress_info() {
  if (transit_egress_info_ != nullptr) transit_egress_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
TripLeg_Node::TripLeg_Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  intersecting_edge_(arena),
  recosts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Node)
}
TripLeg_Node::TripLeg_Node(const TripLeg_Node& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      intersecting_edge_(from.intersecting_edge_),
      recosts_(from.recosts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  time_zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_time_zone()) {
    time_zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_time_zone(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_edge()) {
    edge_ = new ::valhalla::TripLeg_Edge(*from.edge_);
  } else {
    edge_ = nullptr;
  }
  if (from._internal_has_transit_platform_info()) {
    transit_platform_info_ = new ::valhalla::TransitPlatformInfo(*from.transit_platform_info_);
  } else {
    transit_platform_info_ = nullptr;
  }
  if (from._internal_has_transit_station_info()) {
    transit_station_info_ = new ::valhalla::TransitStationInfo(*from.transit_station_info_);
  } else {
    transit_station_info_ = nullptr;
  }
  if (from._internal_has_transit_egress_info()) {
    transit_egress_info_ = new ::valhalla::TransitEgressInfo(*from.transit_egress_info_);
  } else {
    transit_egress_info_ = nullptr;
  }
  if (from._internal_has_cost()) {
    cost_ = new ::valhalla::TripLeg_PathCost(*from.cost_);
  } else {
    cost_ = nullptr;
  }
  if (from._internal_has_bss_info()) {
    bss_info_ = new ::valhalla::TripLeg_BikeShareStationInfo(*from.bss_info_);
  } else {
    bss_info_ = nullptr;
  }
  ::memcpy(&admin_index_, &from.admin_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&fork_) -
    reinterpret_cast<char*>(&admin_index_)) + sizeof(fork_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Node)
}

inline void TripLeg_Node::SharedCtor() {
time_zone_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&edge_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fork_) -
    reinterpret_cast<char*>(&edge_)) + sizeof(fork_));
}

TripLeg_Node::~TripLeg_Node() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Node)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  time_zone_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete edge_;
  if (this != internal_default_instance()) delete transit_platform_info_;
  if (this != internal_default_instance()) delete transit_station_info_;
  if (this != internal_default_instance()) delete transit_egress_info_;
  if (this != internal_default_instance()) delete cost_;
  if (this != internal_default_instance()) delete bss_info_;
}

void TripLeg_Node::ArenaDtor(void* object) {
  TripLeg_Node* _this = reinterpret_cast< TripLeg_Node* >(object);
  (void)_this;
}
void TripLeg_Node::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Node::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Node::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Node)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  intersecting_edge_.Clear();
  recosts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      time_zone_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(edge_ != nullptr);
      edge_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(transit_platform_info_ != nullptr);
      transit_platform_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(transit_station_info_ != nullptr);
      transit_station_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(transit_egress_info_ != nullptr);
      transit_egress_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(cost_ != nullptr);
      cost_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(bss_info_ != nullptr);
      bss_info_->Clear();
    }
  }
  admin_index_ = 0u;
  if (cached_has_bits & 0x00000300u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fork_) -
        reinterpret_cast<char*>(&type_)) + sizeof(fork_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Node::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .valhalla.TripLeg.Edge edge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_intersecting_edge(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 admin_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_admin_index(&has_bits);
          admin_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.Node.Type type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::valhalla::TripLeg_Node_Type_IsValid(val))) {
            _internal_set_type(static_cast<::valhalla::TripLeg_Node_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool fork = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_fork(&has_bits);
          fork_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_platform_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TransitStationInfo transit_station_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_station_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_transit_egress_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string time_zone = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_time_zone();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.PathCost cost = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_cost(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.PathCost recosts = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_recosts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.BikeShareStationInfo bss_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_bss_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Node::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Node)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .valhalla.TripLeg.Edge edge = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::edge(this), target, stream);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_intersecting_edge_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_intersecting_edge(i), target, stream);
  }

  // optional uint32 admin_index = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_admin_index(), target);
  }

  // optional .valhalla.TripLeg.Node.Type type = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_type(), target);
  }

  // optional bool fork = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_fork(), target);
  }

  // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::transit_platform_info(this), target, stream);
  }

  // optional .valhalla.TransitStationInfo transit_station_info = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::transit_station_info(this), target, stream);
  }

  // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::transit_egress_info(this), target, stream);
  }

  // optional string time_zone = 11;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_time_zone(), target);
  }

  // optional .valhalla.TripLeg.PathCost cost = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::cost(this), target, stream);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_recosts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_recosts(i), target, stream);
  }

  // optional .valhalla.TripLeg.BikeShareStationInfo bss_info = 14;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::bss_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Node)
  return target;
}

size_t TripLeg_Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Node)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1UL * this->_internal_intersecting_edge_size();
  for (const auto& msg : this->intersecting_edge_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.PathCost recosts = 13;
  total_size += 1UL * this->_internal_recosts_size();
  for (const auto& msg : this->recosts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string time_zone = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_time_zone());
    }

    // optional .valhalla.TripLeg.Edge edge = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *edge_);
    }

    // optional .valhalla.TransitPlatformInfo transit_platform_info = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transit_platform_info_);
    }

    // optional .valhalla.TransitStationInfo transit_station_info = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transit_station_info_);
    }

    // optional .valhalla.TransitEgressInfo transit_egress_info = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transit_egress_info_);
    }

    // optional .valhalla.TripLeg.PathCost cost = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cost_);
    }

    // optional .valhalla.TripLeg.BikeShareStationInfo bss_info = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bss_info_);
    }

    // optional uint32 admin_index = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_admin_index());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .valhalla.TripLeg.Node.Type type = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool fork = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Node*>(
      &from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Node)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  intersecting_edge_.MergeFrom(from.intersecting_edge_);
  recosts_.MergeFrom(from.recosts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_time_zone(from._internal_time_zone());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(from._internal_edge());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(from._internal_transit_platform_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(from._internal_transit_station_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(from._internal_transit_egress_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_cost()->::valhalla::TripLeg_PathCost::MergeFrom(from._internal_cost());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_bss_info()->::valhalla::TripLeg_BikeShareStationInfo::MergeFrom(from._internal_bss_info());
    }
    if (cached_has_bits & 0x00000080u) {
      admin_index_ = from.admin_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000200u) {
      fork_ = from.fork_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Node::IsInitialized() const {
  return true;
}

void TripLeg_Node::InternalSwap(TripLeg_Node* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  intersecting_edge_.InternalSwap(&other->intersecting_edge_);
  recosts_.InternalSwap(&other->recosts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &time_zone_, GetArenaForAllocation(),
      &other->time_zone_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Node, fork_)
      + sizeof(TripLeg_Node::fork_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Node, edge_)>(
          reinterpret_cast<char*>(&edge_),
          reinterpret_cast<char*>(&other->edge_));
}

std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}


// ===================================================================

class TripLeg_Admin::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Admin>()._has_bits_);
  static void set_has_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_country_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state_code(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_state_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TripLeg_Admin::TripLeg_Admin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Admin)
}
TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  country_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_country_code()) {
    country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country_code(), 
      GetArenaForAllocation());
  }
  country_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_country_text()) {
    country_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country_text(), 
      GetArenaForAllocation());
  }
  state_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_state_code()) {
    state_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state_code(), 
      GetArenaForAllocation());
  }
  state_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_state_text()) {
    state_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Admin)
}

inline void TripLeg_Admin::SharedCtor() {
country_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
country_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
state_code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
state_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TripLeg_Admin::~TripLeg_Admin() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Admin)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Admin::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  country_code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  country_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TripLeg_Admin::ArenaDtor(void* object) {
  TripLeg_Admin* _this = reinterpret_cast< TripLeg_Admin* >(object);
  (void)_this;
}
void TripLeg_Admin::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Admin::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Admin::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Admin)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      country_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      country_text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      state_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      state_text_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Admin::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string country_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_country_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string country_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_country_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string state_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_state_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string state_text = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_state_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Admin::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Admin)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string country_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_country_code(), target);
  }

  // optional string country_text = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_country_text(), target);
  }

  // optional string state_code = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_state_code(), target);
  }

  // optional string state_text = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_state_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Admin)
  return target;
}

size_t TripLeg_Admin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Admin)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string country_code = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_code());
    }

    // optional string country_text = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_text());
    }

    // optional string state_code = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state_code());
    }

    // optional string state_text = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state_text());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Admin*>(
      &from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Admin)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_country_code(from._internal_country_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_country_text(from._internal_country_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_state_code(from._internal_state_code());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_state_text(from._internal_state_text());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Admin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Admin::IsInitialized() const {
  return true;
}

void TripLeg_Admin::InternalSwap(TripLeg_Admin* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_code_, GetArenaForAllocation(),
      &other->country_code_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_text_, GetArenaForAllocation(),
      &other->country_text_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_code_, GetArenaForAllocation(),
      &other->state_code_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_text_, GetArenaForAllocation(),
      &other->state_text_, other->GetArenaForAllocation()
  );
}

std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}


// ===================================================================

class TripLeg_ShapeAttributes::_Internal {
 public:
};

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  time_(arena),
  length_(arena),
  speed_(arena),
  speed_limit_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.ShapeAttributes)
}
TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      time_(from.time_),
      length_(from.length_),
      speed_(from.speed_),
      speed_limit_(from.speed_limit_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.ShapeAttributes)
}

inline void TripLeg_ShapeAttributes::SharedCtor() {
}

TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.ShapeAttributes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_ShapeAttributes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_ShapeAttributes::ArenaDtor(void* object) {
  TripLeg_ShapeAttributes* _this = reinterpret_cast< TripLeg_ShapeAttributes* >(object);
  (void)_this;
}
void TripLeg_ShapeAttributes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_ShapeAttributes::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.ShapeAttributes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  time_.Clear();
  length_.Clear();
  speed_.Clear();
  speed_limit_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_ShapeAttributes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 time = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_time(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8) {
          _internal_add_time(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 length = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_length(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          _internal_add_length(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 speed = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24) {
          _internal_add_speed(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 speed_limit = 5 [packed = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_speed_limit(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40) {
          _internal_add_speed_limit(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_ShapeAttributes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.ShapeAttributes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    int byte_size = _time_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_time(), byte_size, target);
    }
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int byte_size = _length_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_length(), byte_size, target);
    }
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int byte_size = _speed_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_speed(), byte_size, target);
    }
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    int byte_size = _speed_limit_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          5, _internal_speed_limit(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.ShapeAttributes)
  return target;
}

size_t TripLeg_ShapeAttributes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.ShapeAttributes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 time = 1 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->time_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _time_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 length = 2 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->length_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _length_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->speed_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _speed_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated uint32 speed_limit = 5 [packed = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->speed_limit_);
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _speed_limit_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_ShapeAttributes*>(
      &from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.ShapeAttributes)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  time_.MergeFrom(from.time_);
  length_.MergeFrom(from.length_);
  speed_.MergeFrom(from.speed_);
  speed_limit_.MergeFrom(from.speed_limit_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.ShapeAttributes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_ShapeAttributes::IsInitialized() const {
  return true;
}

void TripLeg_ShapeAttributes::InternalSwap(TripLeg_ShapeAttributes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  time_.InternalSwap(&other->time_);
  length_.InternalSwap(&other->length_);
  speed_.InternalSwap(&other->speed_);
  speed_limit_.InternalSwap(&other->speed_limit_);
}

std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}


// ===================================================================

class TripLeg_Incident::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Incident>()._has_bits_);
  static const ::valhalla::IncidentsTile_Metadata& metadata(const TripLeg_Incident* msg);
  static void set_has_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_begin_shape_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_end_shape_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::valhalla::IncidentsTile_Metadata&
TripLeg_Incident::_Internal::metadata(const TripLeg_Incident* msg) {
  return *msg->metadata_;
}
void TripLeg_Incident::clear_metadata() {
  if (metadata_ != nullptr) metadata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
TripLeg_Incident::TripLeg_Incident(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Incident)
}
TripLeg_Incident::TripLeg_Incident(const TripLeg_Incident& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_metadata()) {
    metadata_ = new ::valhalla::IncidentsTile_Metadata(*from.metadata_);
  } else {
    metadata_ = nullptr;
  }
  ::memcpy(&begin_shape_index_, &from.begin_shape_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_shape_index_) -
    reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Incident)
}

inline void TripLeg_Incident::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&metadata_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_shape_index_) -
    reinterpret_cast<char*>(&metadata_)) + sizeof(end_shape_index_));
}

TripLeg_Incident::~TripLeg_Incident() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Incident)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Incident::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete metadata_;
}

void TripLeg_Incident::ArenaDtor(void* object) {
  TripLeg_Incident* _this = reinterpret_cast< TripLeg_Incident* >(object);
  (void)_this;
}
void TripLeg_Incident::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Incident::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Incident::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Incident)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(metadata_ != nullptr);
    metadata_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&begin_shape_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_shape_index_) -
        reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Incident::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .valhalla.IncidentsTile.Metadata metadata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 begin_shape_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_begin_shape_index(&has_bits);
          begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 end_shape_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_end_shape_index(&has_bits);
          end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Incident::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Incident)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .valhalla.IncidentsTile.Metadata metadata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::metadata(this), target, stream);
  }

  // optional uint32 begin_shape_index = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_begin_shape_index(), target);
  }

  // optional uint32 end_shape_index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Incident)
  return target;
}

size_t TripLeg_Incident::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Incident)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .valhalla.IncidentsTile.Metadata metadata = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_);
    }

    // optional uint32 begin_shape_index = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_begin_shape_index());
    }

    // optional uint32 end_shape_index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_end_shape_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Incident::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Incident*>(
      &from));
}

void TripLeg_Incident::MergeFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Incident)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_metadata()->::valhalla::IncidentsTile_Metadata::MergeFrom(from._internal_metadata());
    }
    if (cached_has_bits & 0x00000002u) {
      begin_shape_index_ = from.begin_shape_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      end_shape_index_ = from.end_shape_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Incident::CopyFrom(const TripLeg_Incident& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Incident)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Incident::IsInitialized() const {
  return true;
}

void TripLeg_Incident::InternalSwap(TripLeg_Incident* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Incident, end_shape_index_)
      + sizeof(TripLeg_Incident::end_shape_index_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Incident, metadata_)>(
          reinterpret_cast<char*>(&metadata_),
          reinterpret_cast<char*>(&other->metadata_));
}

std::string TripLeg_Incident::GetTypeName() const {
  return "valhalla.TripLeg.Incident";
}


// ===================================================================

class TripLeg_Closure::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg_Closure>()._has_bits_);
  static void set_has_begin_shape_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_shape_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TripLeg_Closure::TripLeg_Closure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg.Closure)
}
TripLeg_Closure::TripLeg_Closure(const TripLeg_Closure& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&begin_shape_index_, &from.begin_shape_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_shape_index_) -
    reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg.Closure)
}

inline void TripLeg_Closure::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&begin_shape_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&end_shape_index_) -
    reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
}

TripLeg_Closure::~TripLeg_Closure() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg.Closure)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg_Closure::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripLeg_Closure::ArenaDtor(void* object) {
  TripLeg_Closure* _this = reinterpret_cast< TripLeg_Closure* >(object);
  (void)_this;
}
void TripLeg_Closure::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg_Closure::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg_Closure::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg.Closure)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&begin_shape_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_shape_index_) -
        reinterpret_cast<char*>(&begin_shape_index_)) + sizeof(end_shape_index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg_Closure::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 begin_shape_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_begin_shape_index(&has_bits);
          begin_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 end_shape_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_end_shape_index(&has_bits);
          end_shape_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg_Closure::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg.Closure)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 begin_shape_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_begin_shape_index(), target);
  }

  // optional uint32 end_shape_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_end_shape_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg.Closure)
  return target;
}

size_t TripLeg_Closure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg.Closure)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 begin_shape_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_begin_shape_index());
    }

    // optional uint32 end_shape_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_end_shape_index());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg_Closure::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg_Closure*>(
      &from));
}

void TripLeg_Closure::MergeFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg.Closure)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      begin_shape_index_ = from.begin_shape_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      end_shape_index_ = from.end_shape_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg_Closure::CopyFrom(const TripLeg_Closure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg.Closure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Closure::IsInitialized() const {
  return true;
}

void TripLeg_Closure::InternalSwap(TripLeg_Closure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg_Closure, end_shape_index_)
      + sizeof(TripLeg_Closure::end_shape_index_)
      - PROTOBUF_FIELD_OFFSET(TripLeg_Closure, begin_shape_index_)>(
          reinterpret_cast<char*>(&begin_shape_index_),
          reinterpret_cast<char*>(&other->begin_shape_index_));
}

std::string TripLeg_Closure::GetTypeName() const {
  return "valhalla.TripLeg.Closure";
}


// ===================================================================

class TripLeg::_Internal {
 public:
  using HasBits = decltype(std::declval<TripLeg>()._has_bits_);
  static void set_has_osm_changeset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_trip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_leg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_leg_count(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::valhalla::BoundingBox& bbox(const TripLeg* msg);
  static void set_has_bbox(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::valhalla::TripLeg_ShapeAttributes& shape_attributes(const TripLeg* msg);
  static void set_has_shape_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::valhalla::BoundingBox&
TripLeg::_Internal::bbox(const TripLeg* msg) {
  return *msg->bbox_;
}
const ::valhalla::TripLeg_ShapeAttributes&
TripLeg::_Internal::shape_attributes(const TripLeg* msg) {
  return *msg->shape_attributes_;
}
void TripLeg::clear_location() {
  location_.Clear();
}
void TripLeg::clear_bbox() {
  if (bbox_ != nullptr) bbox_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
TripLeg::TripLeg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  location_(arena),
  node_(arena),
  admin_(arena),
  incidents_(arena),
  algorithms_(arena),
  closures_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripLeg)
}
TripLeg::TripLeg(const TripLeg& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      location_(from.location_),
      node_(from.node_),
      admin_(from.admin_),
      incidents_(from.incidents_),
      algorithms_(from.algorithms_),
      closures_(from.closures_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_shape()) {
    shape_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_shape(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_bbox()) {
    bbox_ = new ::valhalla::BoundingBox(*from.bbox_);
  } else {
    bbox_ = nullptr;
  }
  if (from._internal_has_shape_attributes()) {
    shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes(*from.shape_attributes_);
  } else {
    shape_attributes_ = nullptr;
  }
  ::memcpy(&osm_changeset_, &from.osm_changeset_,
    static_cast<size_t>(reinterpret_cast<char*>(&leg_count_) -
    reinterpret_cast<char*>(&osm_changeset_)) + sizeof(leg_count_));
  // @@protoc_insertion_point(copy_constructor:valhalla.TripLeg)
}

inline void TripLeg::SharedCtor() {
shape_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&bbox_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&leg_count_) -
    reinterpret_cast<char*>(&bbox_)) + sizeof(leg_count_));
}

TripLeg::~TripLeg() {
  // @@protoc_insertion_point(destructor:valhalla.TripLeg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripLeg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  shape_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete bbox_;
  if (this != internal_default_instance()) delete shape_attributes_;
}

void TripLeg::ArenaDtor(void* object) {
  TripLeg* _this = reinterpret_cast< TripLeg* >(object);
  (void)_this;
}
void TripLeg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripLeg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripLeg::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripLeg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  location_.Clear();
  node_.Clear();
  admin_.Clear();
  incidents_.Clear();
  algorithms_.Clear();
  closures_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shape_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(bbox_ != nullptr);
      bbox_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(shape_attributes_ != nullptr);
      shape_attributes_->Clear();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&osm_changeset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&leg_count_) -
        reinterpret_cast<char*>(&osm_changeset_)) + sizeof(leg_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripLeg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 osm_changeset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_osm_changeset(&has_bits);
          osm_changeset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 trip_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_trip_id(&has_bits);
          trip_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leg_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_leg_id(&has_bits);
          leg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 leg_count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_leg_count(&has_bits);
          leg_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.Location location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_location(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Node node = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Admin admin = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_admin(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string shape = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_shape();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.BoundingBox bbox = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bbox(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape_attributes(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Incident incidents = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incidents(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string algorithms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_algorithms();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .valhalla.TripLeg.Closure closures = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_closures(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripLeg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripLeg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 osm_changeset = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_osm_changeset(), target);
  }

  // optional uint64 trip_id = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_trip_id(), target);
  }

  // optional uint32 leg_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_leg_id(), target);
  }

  // optional uint32 leg_count = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_leg_count(), target);
  }

  // repeated .valhalla.Location location = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_location_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_location(i), target, stream);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_node_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_node(i), target, stream);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_admin_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_admin(i), target, stream);
  }

  // optional string shape = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_shape(), target);
  }

  // optional .valhalla.BoundingBox bbox = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::bbox(this), target, stream);
  }

  // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::shape_attributes(this), target, stream);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_incidents_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_incidents(i), target, stream);
  }

  // repeated string algorithms = 12;
  for (int i = 0, n = this->_internal_algorithms_size(); i < n; i++) {
    const auto& s = this->_internal_algorithms(i);
    target = stream->WriteString(12, s, target);
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_closures_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_closures(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripLeg)
  return target;
}

size_t TripLeg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripLeg)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.Location location = 5;
  total_size += 1UL * this->_internal_location_size();
  for (const auto& msg : this->location_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->node_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1UL * this->_internal_admin_size();
  for (const auto& msg : this->admin_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .valhalla.TripLeg.Incident incidents = 11;
  total_size += 1UL * this->_internal_incidents_size();
  for (const auto& msg : this->incidents_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string algorithms = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(algorithms_.size());
  for (int i = 0, n = algorithms_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      algorithms_.Get(i));
  }

  // repeated .valhalla.TripLeg.Closure closures = 13;
  total_size += 1UL * this->_internal_closures_size();
  for (const auto& msg : this->closures_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string shape = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_shape());
    }

    // optional .valhalla.BoundingBox bbox = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bbox_);
    }

    // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *shape_attributes_);
    }

    // optional uint64 osm_changeset = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_osm_changeset());
    }

    // optional uint64 trip_id = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_trip_id());
    }

    // optional uint32 leg_id = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_leg_id());
    }

    // optional uint32 leg_count = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_leg_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripLeg*>(
      &from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripLeg)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  location_.MergeFrom(from.location_);
  node_.MergeFrom(from.node_);
  admin_.MergeFrom(from.admin_);
  incidents_.MergeFrom(from.incidents_);
  algorithms_.MergeFrom(from.algorithms_);
  closures_.MergeFrom(from.closures_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_shape(from._internal_shape());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_bbox()->::valhalla::BoundingBox::MergeFrom(from._internal_bbox());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(from._internal_shape_attributes());
    }
    if (cached_has_bits & 0x00000008u) {
      osm_changeset_ = from.osm_changeset_;
    }
    if (cached_has_bits & 0x00000010u) {
      trip_id_ = from.trip_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      leg_id_ = from.leg_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      leg_count_ = from.leg_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripLeg::CopyFrom(const TripLeg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripLeg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg::IsInitialized() const {
  return true;
}

void TripLeg::InternalSwap(TripLeg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  location_.InternalSwap(&other->location_);
  node_.InternalSwap(&other->node_);
  admin_.InternalSwap(&other->admin_);
  incidents_.InternalSwap(&other->incidents_);
  algorithms_.InternalSwap(&other->algorithms_);
  closures_.InternalSwap(&other->closures_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &shape_, GetArenaForAllocation(),
      &other->shape_, other->GetArenaForAllocation()
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripLeg, leg_count_)
      + sizeof(TripLeg::leg_count_)
      - PROTOBUF_FIELD_OFFSET(TripLeg, bbox_)>(
          reinterpret_cast<char*>(&bbox_),
          reinterpret_cast<char*>(&other->bbox_));
}

std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}


// ===================================================================

class TripRoute::_Internal {
 public:
};

TripRoute::TripRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  legs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.TripRoute)
}
TripRoute::TripRoute(const TripRoute& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      legs_(from.legs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.TripRoute)
}

inline void TripRoute::SharedCtor() {
}

TripRoute::~TripRoute() {
  // @@protoc_insertion_point(destructor:valhalla.TripRoute)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void TripRoute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TripRoute::ArenaDtor(void* object) {
  TripRoute* _this = reinterpret_cast< TripRoute* >(object);
  (void)_this;
}
void TripRoute::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TripRoute::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TripRoute::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.TripRoute)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  legs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TripRoute::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripLeg legs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_legs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TripRoute::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.TripRoute)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_legs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_legs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.TripRoute)
  return target;
}

size_t TripRoute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.TripRoute)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1UL * this->_internal_legs_size();
  for (const auto& msg : this->legs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TripRoute*>(
      &from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.TripRoute)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  legs_.MergeFrom(from.legs_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.TripRoute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripRoute::IsInitialized() const {
  return true;
}

void TripRoute::InternalSwap(TripRoute* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  legs_.InternalSwap(&other->legs_);
}

std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}


// ===================================================================

class Trip::_Internal {
 public:
};

Trip::Trip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  routes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:valhalla.Trip)
}
Trip::Trip(const Trip& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      routes_(from.routes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:valhalla.Trip)
}

inline void Trip::SharedCtor() {
}

Trip::~Trip() {
  // @@protoc_insertion_point(destructor:valhalla.Trip)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

inline void Trip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Trip::ArenaDtor(void* object) {
  Trip* _this = reinterpret_cast< Trip* >(object);
  (void)_this;
}
void Trip::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Trip::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Trip::Clear() {
// @@protoc_insertion_point(message_clear_start:valhalla.Trip)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  routes_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Trip::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .valhalla.TripRoute routes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_routes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
          CHK_(ptr);
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Trip::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:valhalla.Trip)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_routes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_routes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:valhalla.Trip)
  return target;
}

size_t Trip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:valhalla.Trip)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1UL * this->_internal_routes_size();
  for (const auto& msg : this->routes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Trip*>(
      &from));
}

void Trip::MergeFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:valhalla.Trip)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  routes_.MergeFrom(from.routes_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Trip::CopyFrom(const Trip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:valhalla.Trip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trip::IsInitialized() const {
  return true;
}

void Trip::InternalSwap(Trip* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  routes_.InternalSwap(&other->routes_);
}

std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace valhalla
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_SignElement* Arena::CreateMaybeMessage< ::valhalla::TripLeg_SignElement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_SignElement >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Sign* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Sign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Sign >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_TransitRouteInfo* Arena::CreateMaybeMessage< ::valhalla::TripLeg_TransitRouteInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_TransitRouteInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_BikeShareStationInfo* Arena::CreateMaybeMessage< ::valhalla::TripLeg_BikeShareStationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_BikeShareStationInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_LaneConnectivity* Arena::CreateMaybeMessage< ::valhalla::TripLeg_LaneConnectivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_LaneConnectivity >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_TrafficSegment* Arena::CreateMaybeMessage< ::valhalla::TripLeg_TrafficSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_TrafficSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Restriction* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Restriction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Restriction >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Edge* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Edge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Edge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_IntersectingEdge* Arena::CreateMaybeMessage< ::valhalla::TripLeg_IntersectingEdge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_IntersectingEdge >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Cost* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Cost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Cost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_PathCost* Arena::CreateMaybeMessage< ::valhalla::TripLeg_PathCost >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_PathCost >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Node* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Node >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Admin* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Admin >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Admin >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_ShapeAttributes* Arena::CreateMaybeMessage< ::valhalla::TripLeg_ShapeAttributes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_ShapeAttributes >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Incident* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Incident >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Incident >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg_Closure* Arena::CreateMaybeMessage< ::valhalla::TripLeg_Closure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg_Closure >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripLeg* Arena::CreateMaybeMessage< ::valhalla::TripLeg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripLeg >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::TripRoute* Arena::CreateMaybeMessage< ::valhalla::TripRoute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::TripRoute >(arena);
}
template<> PROTOBUF_NOINLINE ::valhalla::Trip* Arena::CreateMaybeMessage< ::valhalla::Trip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::valhalla::Trip >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
