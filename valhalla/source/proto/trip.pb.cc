// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "trip.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

void protobuf_ShutdownFile_trip_2eproto() {
  delete TripLeg::default_instance_;
  delete TripLeg_SignElement::default_instance_;
  delete TripLeg_Sign::default_instance_;
  delete TripLeg_TransitRouteInfo::default_instance_;
  delete TripLeg_LaneConnectivity::default_instance_;
  delete TripLeg_TrafficSegment::default_instance_;
  delete TripLeg_Edge::default_instance_;
  delete TripLeg_IntersectingEdge::default_instance_;
  delete TripLeg_Node::default_instance_;
  delete TripLeg_Admin::default_instance_;
  delete TripLeg_ShapeAttributes::default_instance_;
  delete TripRoute::default_instance_;
  delete Trip::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_trip_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_trip_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::valhalla::protobuf_AddDesc_tripcommon_2eproto();
  TripLeg::default_instance_ = new TripLeg();
  TripLeg_SignElement::default_instance_ = new TripLeg_SignElement();
  TripLeg_Sign::default_instance_ = new TripLeg_Sign();
  TripLeg_TransitRouteInfo::default_instance_ = new TripLeg_TransitRouteInfo();
  TripLeg_LaneConnectivity::default_instance_ = new TripLeg_LaneConnectivity();
  TripLeg_TrafficSegment::default_instance_ = new TripLeg_TrafficSegment();
  TripLeg_Edge::default_instance_ = new TripLeg_Edge();
  TripLeg_IntersectingEdge::default_instance_ = new TripLeg_IntersectingEdge();
  TripLeg_Node::default_instance_ = new TripLeg_Node();
  TripLeg_Admin::default_instance_ = new TripLeg_Admin();
  TripLeg_ShapeAttributes::default_instance_ = new TripLeg_ShapeAttributes();
  TripRoute::default_instance_ = new TripRoute();
  Trip::default_instance_ = new Trip();
  TripLeg::default_instance_->InitAsDefaultInstance();
  TripLeg_SignElement::default_instance_->InitAsDefaultInstance();
  TripLeg_Sign::default_instance_->InitAsDefaultInstance();
  TripLeg_TransitRouteInfo::default_instance_->InitAsDefaultInstance();
  TripLeg_LaneConnectivity::default_instance_->InitAsDefaultInstance();
  TripLeg_TrafficSegment::default_instance_->InitAsDefaultInstance();
  TripLeg_Edge::default_instance_->InitAsDefaultInstance();
  TripLeg_IntersectingEdge::default_instance_->InitAsDefaultInstance();
  TripLeg_Node::default_instance_->InitAsDefaultInstance();
  TripLeg_Admin::default_instance_->InitAsDefaultInstance();
  TripLeg_ShapeAttributes::default_instance_->InitAsDefaultInstance();
  TripRoute::default_instance_->InitAsDefaultInstance();
  Trip::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_trip_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_trip_2eproto_once_);
void protobuf_AddDesc_trip_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_trip_2eproto_once_,
                 &protobuf_AddDesc_trip_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_trip_2eproto {
  StaticDescriptorInitializer_trip_2eproto() {
    protobuf_AddDesc_trip_2eproto();
  }
} static_descriptor_initializer_trip_2eproto_;
#endif

// ===================================================================

bool TripLeg_Traversability_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_Traversability TripLeg::kNone;
const TripLeg_Traversability TripLeg::kForward;
const TripLeg_Traversability TripLeg::kBackward;
const TripLeg_Traversability TripLeg::kBoth;
const TripLeg_Traversability TripLeg::Traversability_MIN;
const TripLeg_Traversability TripLeg::Traversability_MAX;
const int TripLeg::Traversability_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_RoadClass_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_RoadClass TripLeg::kMotorway;
const TripLeg_RoadClass TripLeg::kTrunk;
const TripLeg_RoadClass TripLeg::kPrimary;
const TripLeg_RoadClass TripLeg::kSecondary;
const TripLeg_RoadClass TripLeg::kTertiary;
const TripLeg_RoadClass TripLeg::kUnclassified;
const TripLeg_RoadClass TripLeg::kResidential;
const TripLeg_RoadClass TripLeg::kServiceOther;
const TripLeg_RoadClass TripLeg::RoadClass_MIN;
const TripLeg_RoadClass TripLeg::RoadClass_MAX;
const int TripLeg::RoadClass_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_Use_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 20:
    case 21:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 40:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_Use TripLeg::kRoadUse;
const TripLeg_Use TripLeg::kRampUse;
const TripLeg_Use TripLeg::kTurnChannelUse;
const TripLeg_Use TripLeg::kTrackUse;
const TripLeg_Use TripLeg::kDrivewayUse;
const TripLeg_Use TripLeg::kAlleyUse;
const TripLeg_Use TripLeg::kParkingAisleUse;
const TripLeg_Use TripLeg::kEmergencyAccessUse;
const TripLeg_Use TripLeg::kDriveThruUse;
const TripLeg_Use TripLeg::kCuldesacUse;
const TripLeg_Use TripLeg::kCyclewayUse;
const TripLeg_Use TripLeg::kMountainBikeUse;
const TripLeg_Use TripLeg::kSidewalkUse;
const TripLeg_Use TripLeg::kFootwayUse;
const TripLeg_Use TripLeg::kStepsUse;
const TripLeg_Use TripLeg::kPathUse;
const TripLeg_Use TripLeg::kPedestrianUse;
const TripLeg_Use TripLeg::kBridlewayUse;
const TripLeg_Use TripLeg::kOtherUse;
const TripLeg_Use TripLeg::kFerryUse;
const TripLeg_Use TripLeg::kRailFerryUse;
const TripLeg_Use TripLeg::kRailUse;
const TripLeg_Use TripLeg::kBusUse;
const TripLeg_Use TripLeg::kEgressConnectionUse;
const TripLeg_Use TripLeg::kPlatformConnectionUse;
const TripLeg_Use TripLeg::kTransitConnectionUse;
const TripLeg_Use TripLeg::Use_MIN;
const TripLeg_Use TripLeg::Use_MAX;
const int TripLeg::Use_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_Surface_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_Surface TripLeg::kPavedSmooth;
const TripLeg_Surface TripLeg::kPaved;
const TripLeg_Surface TripLeg::kPavedRough;
const TripLeg_Surface TripLeg::kCompacted;
const TripLeg_Surface TripLeg::kDirt;
const TripLeg_Surface TripLeg::kGravel;
const TripLeg_Surface TripLeg::kPath;
const TripLeg_Surface TripLeg::kImpassable;
const TripLeg_Surface TripLeg::Surface_MIN;
const TripLeg_Surface TripLeg::Surface_MAX;
const int TripLeg::Surface_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_TravelMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_TravelMode TripLeg::kDrive;
const TripLeg_TravelMode TripLeg::kPedestrian;
const TripLeg_TravelMode TripLeg::kBicycle;
const TripLeg_TravelMode TripLeg::kTransit;
const TripLeg_TravelMode TripLeg::TravelMode_MIN;
const TripLeg_TravelMode TripLeg::TravelMode_MAX;
const int TripLeg::TravelMode_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_VehicleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_VehicleType TripLeg::kCar;
const TripLeg_VehicleType TripLeg::kMotorcycle;
const TripLeg_VehicleType TripLeg::kAutoBus;
const TripLeg_VehicleType TripLeg::kTractorTrailer;
const TripLeg_VehicleType TripLeg::kMotorScooter;
const TripLeg_VehicleType TripLeg::VehicleType_MIN;
const TripLeg_VehicleType TripLeg::VehicleType_MAX;
const int TripLeg::VehicleType_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_PedestrianType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_PedestrianType TripLeg::kFoot;
const TripLeg_PedestrianType TripLeg::kWheelchair;
const TripLeg_PedestrianType TripLeg::kSegway;
const TripLeg_PedestrianType TripLeg::PedestrianType_MIN;
const TripLeg_PedestrianType TripLeg::PedestrianType_MAX;
const int TripLeg::PedestrianType_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_BicycleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_BicycleType TripLeg::kRoad;
const TripLeg_BicycleType TripLeg::kCross;
const TripLeg_BicycleType TripLeg::kHybrid;
const TripLeg_BicycleType TripLeg::kMountain;
const TripLeg_BicycleType TripLeg::BicycleType_MIN;
const TripLeg_BicycleType TripLeg::BicycleType_MAX;
const int TripLeg::BicycleType_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_TransitType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_TransitType TripLeg::kTram;
const TripLeg_TransitType TripLeg::kMetro;
const TripLeg_TransitType TripLeg::kRail;
const TripLeg_TransitType TripLeg::kBus;
const TripLeg_TransitType TripLeg::kFerry;
const TripLeg_TransitType TripLeg::kCableCar;
const TripLeg_TransitType TripLeg::kGondola;
const TripLeg_TransitType TripLeg::kFunicular;
const TripLeg_TransitType TripLeg::TransitType_MIN;
const TripLeg_TransitType TripLeg::TransitType_MAX;
const int TripLeg::TransitType_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_CycleLane_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_CycleLane TripLeg::kNoCycleLane;
const TripLeg_CycleLane TripLeg::kShared;
const TripLeg_CycleLane TripLeg::kDedicated;
const TripLeg_CycleLane TripLeg::kSeparated;
const TripLeg_CycleLane TripLeg::CycleLane_MIN;
const TripLeg_CycleLane TripLeg::CycleLane_MAX;
const int TripLeg::CycleLane_ARRAYSIZE;
#endif  // _MSC_VER
bool TripLeg_Sidewalk_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_Sidewalk TripLeg::kNoSidewalk;
const TripLeg_Sidewalk TripLeg::kLeft;
const TripLeg_Sidewalk TripLeg::kRight;
const TripLeg_Sidewalk TripLeg::kBothSides;
const TripLeg_Sidewalk TripLeg::Sidewalk_MIN;
const TripLeg_Sidewalk TripLeg::Sidewalk_MAX;
const int TripLeg::Sidewalk_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TripLeg_SignElement::kTextFieldNumber;
const int TripLeg_SignElement::kIsRouteNumberFieldNumber;
#endif  // !_MSC_VER

TripLeg_SignElement::TripLeg_SignElement()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_SignElement::InitAsDefaultInstance() {
}

TripLeg_SignElement::TripLeg_SignElement(const TripLeg_SignElement& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_SignElement::SharedCtor() {
  _cached_size_ = 0;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_route_number_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_SignElement::~TripLeg_SignElement() {
  SharedDtor();
}

void TripLeg_SignElement::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_SignElement::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_SignElement& TripLeg_SignElement::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_SignElement* TripLeg_SignElement::default_instance_ = NULL;

TripLeg_SignElement* TripLeg_SignElement::New() const {
  return new TripLeg_SignElement;
}

void TripLeg_SignElement::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    is_route_number_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_SignElement::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_route_number;
        break;
      }

      // optional bool is_route_number = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_route_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_route_number_)));
          set_has_is_route_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_SignElement::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->text(), output);
  }

  // optional bool is_route_number = 2;
  if (has_is_route_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_route_number(), output);
  }

}

int TripLeg_SignElement::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string text = 1;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional bool is_route_number = 2;
    if (has_is_route_number()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_SignElement::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_SignElement*>(&from));
}

void TripLeg_SignElement::MergeFrom(const TripLeg_SignElement& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_is_route_number()) {
      set_is_route_number(from.is_route_number());
    }
  }
}

void TripLeg_SignElement::CopyFrom(const TripLeg_SignElement& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_SignElement::IsInitialized() const {

  return true;
}

void TripLeg_SignElement::Swap(TripLeg_SignElement* other) {
  if (other != this) {
    std::swap(text_, other->text_);
    std::swap(is_route_number_, other->is_route_number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_SignElement::GetTypeName() const {
  return "valhalla.TripLeg.SignElement";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_Sign::kExitNumbersFieldNumber;
const int TripLeg_Sign::kExitOntoStreetsFieldNumber;
const int TripLeg_Sign::kExitTowardLocationsFieldNumber;
const int TripLeg_Sign::kExitNamesFieldNumber;
#endif  // !_MSC_VER

TripLeg_Sign::TripLeg_Sign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_Sign::InitAsDefaultInstance() {
}

TripLeg_Sign::TripLeg_Sign(const TripLeg_Sign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_Sign::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_Sign::~TripLeg_Sign() {
  SharedDtor();
}

void TripLeg_Sign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_Sign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Sign& TripLeg_Sign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Sign* TripLeg_Sign::default_instance_ = NULL;

TripLeg_Sign* TripLeg_Sign::New() const {
  return new TripLeg_Sign;
}

void TripLeg_Sign::Clear() {
  exit_numbers_.Clear();
  exit_onto_streets_.Clear();
  exit_toward_locations_.Clear();
  exit_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_Sign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_numbers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_numbers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_exit_numbers;
        if (input->ExpectTag(18)) goto parse_exit_onto_streets;
        break;
      }

      // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_onto_streets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_onto_streets()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_exit_onto_streets;
        if (input->ExpectTag(26)) goto parse_exit_toward_locations;
        break;
      }

      // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_toward_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_toward_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exit_toward_locations;
        if (input->ExpectTag(34)) goto parse_exit_names;
        break;
      }

      // repeated .valhalla.TripLeg.SignElement exit_names = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_names()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_exit_names;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_Sign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
  for (int i = 0; i < this->exit_numbers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->exit_numbers(i), output);
  }

  // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
  for (int i = 0; i < this->exit_onto_streets_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->exit_onto_streets(i), output);
  }

  // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
  for (int i = 0; i < this->exit_toward_locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->exit_toward_locations(i), output);
  }

  // repeated .valhalla.TripLeg.SignElement exit_names = 4;
  for (int i = 0; i < this->exit_names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->exit_names(i), output);
  }

}

int TripLeg_Sign::ByteSize() const {
  int total_size = 0;

  // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
  total_size += 1 * this->exit_numbers_size();
  for (int i = 0; i < this->exit_numbers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_numbers(i));
  }

  // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
  total_size += 1 * this->exit_onto_streets_size();
  for (int i = 0; i < this->exit_onto_streets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_onto_streets(i));
  }

  // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
  total_size += 1 * this->exit_toward_locations_size();
  for (int i = 0; i < this->exit_toward_locations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_toward_locations(i));
  }

  // repeated .valhalla.TripLeg.SignElement exit_names = 4;
  total_size += 1 * this->exit_names_size();
  for (int i = 0; i < this->exit_names_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_names(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Sign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Sign*>(&from));
}

void TripLeg_Sign::MergeFrom(const TripLeg_Sign& from) {
  GOOGLE_CHECK_NE(&from, this);
  exit_numbers_.MergeFrom(from.exit_numbers_);
  exit_onto_streets_.MergeFrom(from.exit_onto_streets_);
  exit_toward_locations_.MergeFrom(from.exit_toward_locations_);
  exit_names_.MergeFrom(from.exit_names_);
}

void TripLeg_Sign::CopyFrom(const TripLeg_Sign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Sign::IsInitialized() const {

  return true;
}

void TripLeg_Sign::Swap(TripLeg_Sign* other) {
  if (other != this) {
    exit_numbers_.Swap(&other->exit_numbers_);
    exit_onto_streets_.Swap(&other->exit_onto_streets_);
    exit_toward_locations_.Swap(&other->exit_toward_locations_);
    exit_names_.Swap(&other->exit_names_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_Sign::GetTypeName() const {
  return "valhalla.TripLeg.Sign";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_TransitRouteInfo::kOnestopIdFieldNumber;
const int TripLeg_TransitRouteInfo::kBlockIdFieldNumber;
const int TripLeg_TransitRouteInfo::kTripIdFieldNumber;
const int TripLeg_TransitRouteInfo::kShortNameFieldNumber;
const int TripLeg_TransitRouteInfo::kLongNameFieldNumber;
const int TripLeg_TransitRouteInfo::kHeadsignFieldNumber;
const int TripLeg_TransitRouteInfo::kColorFieldNumber;
const int TripLeg_TransitRouteInfo::kTextColorFieldNumber;
const int TripLeg_TransitRouteInfo::kDescriptionFieldNumber;
const int TripLeg_TransitRouteInfo::kOperatorOnestopIdFieldNumber;
const int TripLeg_TransitRouteInfo::kOperatorNameFieldNumber;
const int TripLeg_TransitRouteInfo::kOperatorUrlFieldNumber;
#endif  // !_MSC_VER

TripLeg_TransitRouteInfo::TripLeg_TransitRouteInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_TransitRouteInfo::InitAsDefaultInstance() {
}

TripLeg_TransitRouteInfo::TripLeg_TransitRouteInfo(const TripLeg_TransitRouteInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_TransitRouteInfo::SharedCtor() {
  _cached_size_ = 0;
  onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  block_id_ = 0u;
  trip_id_ = 0u;
  short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  color_ = 0u;
  text_color_ = 0u;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_TransitRouteInfo::~TripLeg_TransitRouteInfo() {
  SharedDtor();
}

void TripLeg_TransitRouteInfo::SharedDtor() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    delete short_name_;
  }
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    delete long_name_;
  }
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    delete headsign_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_onestop_id_;
  }
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_name_;
  }
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_url_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_TransitRouteInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_TransitRouteInfo& TripLeg_TransitRouteInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_TransitRouteInfo* TripLeg_TransitRouteInfo::default_instance_ = NULL;

TripLeg_TransitRouteInfo* TripLeg_TransitRouteInfo::New() const {
  return new TripLeg_TransitRouteInfo;
}

void TripLeg_TransitRouteInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_onestop_id()) {
      if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
        onestop_id_->clear();
      }
    }
    block_id_ = 0u;
    trip_id_ = 0u;
    if (has_short_name()) {
      if (short_name_ != &::google::protobuf::internal::kEmptyString) {
        short_name_->clear();
      }
    }
    if (has_long_name()) {
      if (long_name_ != &::google::protobuf::internal::kEmptyString) {
        long_name_->clear();
      }
    }
    if (has_headsign()) {
      if (headsign_ != &::google::protobuf::internal::kEmptyString) {
        headsign_->clear();
      }
    }
    color_ = 0u;
    text_color_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_operator_onestop_id()) {
      if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
        operator_onestop_id_->clear();
      }
    }
    if (has_operator_name()) {
      if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
        operator_name_->clear();
      }
    }
    if (has_operator_url()) {
      if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
        operator_url_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_TransitRouteInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string onestop_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_onestop_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_block_id;
        break;
      }

      // optional uint32 block_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_block_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &block_id_)));
          set_has_block_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_trip_id;
        break;
      }

      // optional uint32 trip_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trip_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trip_id_)));
          set_has_trip_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_short_name;
        break;
      }

      // optional string short_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_short_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_short_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_long_name;
        break;
      }

      // optional string long_name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_long_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_long_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_headsign;
        break;
      }

      // optional string headsign = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_headsign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_headsign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_color;
        break;
      }

      // optional uint32 color = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_text_color;
        break;
      }

      // optional uint32 text_color = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &text_color_)));
          set_has_text_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_description;
        break;
      }

      // optional string description = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_operator_onestop_id;
        break;
      }

      // optional string operator_onestop_id = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operator_onestop_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_onestop_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_operator_name;
        break;
      }

      // optional string operator_name = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operator_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_operator_url;
        break;
      }

      // optional string operator_url = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operator_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_url()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_TransitRouteInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string onestop_id = 1;
  if (has_onestop_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->onestop_id(), output);
  }

  // optional uint32 block_id = 2;
  if (has_block_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->block_id(), output);
  }

  // optional uint32 trip_id = 3;
  if (has_trip_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->trip_id(), output);
  }

  // optional string short_name = 4;
  if (has_short_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->short_name(), output);
  }

  // optional string long_name = 5;
  if (has_long_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->long_name(), output);
  }

  // optional string headsign = 6;
  if (has_headsign()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->headsign(), output);
  }

  // optional uint32 color = 7;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->color(), output);
  }

  // optional uint32 text_color = 8;
  if (has_text_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->text_color(), output);
  }

  // optional string description = 9;
  if (has_description()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->description(), output);
  }

  // optional string operator_onestop_id = 10;
  if (has_operator_onestop_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->operator_onestop_id(), output);
  }

  // optional string operator_name = 11;
  if (has_operator_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      11, this->operator_name(), output);
  }

  // optional string operator_url = 12;
  if (has_operator_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->operator_url(), output);
  }

}

int TripLeg_TransitRouteInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string onestop_id = 1;
    if (has_onestop_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->onestop_id());
    }

    // optional uint32 block_id = 2;
    if (has_block_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->block_id());
    }

    // optional uint32 trip_id = 3;
    if (has_trip_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trip_id());
    }

    // optional string short_name = 4;
    if (has_short_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->short_name());
    }

    // optional string long_name = 5;
    if (has_long_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->long_name());
    }

    // optional string headsign = 6;
    if (has_headsign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->headsign());
    }

    // optional uint32 color = 7;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->color());
    }

    // optional uint32 text_color = 8;
    if (has_text_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->text_color());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string description = 9;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional string operator_onestop_id = 10;
    if (has_operator_onestop_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_onestop_id());
    }

    // optional string operator_name = 11;
    if (has_operator_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_name());
    }

    // optional string operator_url = 12;
    if (has_operator_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_url());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_TransitRouteInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_TransitRouteInfo*>(&from));
}

void TripLeg_TransitRouteInfo::MergeFrom(const TripLeg_TransitRouteInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_onestop_id()) {
      set_onestop_id(from.onestop_id());
    }
    if (from.has_block_id()) {
      set_block_id(from.block_id());
    }
    if (from.has_trip_id()) {
      set_trip_id(from.trip_id());
    }
    if (from.has_short_name()) {
      set_short_name(from.short_name());
    }
    if (from.has_long_name()) {
      set_long_name(from.long_name());
    }
    if (from.has_headsign()) {
      set_headsign(from.headsign());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_text_color()) {
      set_text_color(from.text_color());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_operator_onestop_id()) {
      set_operator_onestop_id(from.operator_onestop_id());
    }
    if (from.has_operator_name()) {
      set_operator_name(from.operator_name());
    }
    if (from.has_operator_url()) {
      set_operator_url(from.operator_url());
    }
  }
}

void TripLeg_TransitRouteInfo::CopyFrom(const TripLeg_TransitRouteInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TransitRouteInfo::IsInitialized() const {

  return true;
}

void TripLeg_TransitRouteInfo::Swap(TripLeg_TransitRouteInfo* other) {
  if (other != this) {
    std::swap(onestop_id_, other->onestop_id_);
    std::swap(block_id_, other->block_id_);
    std::swap(trip_id_, other->trip_id_);
    std::swap(short_name_, other->short_name_);
    std::swap(long_name_, other->long_name_);
    std::swap(headsign_, other->headsign_);
    std::swap(color_, other->color_);
    std::swap(text_color_, other->text_color_);
    std::swap(description_, other->description_);
    std::swap(operator_onestop_id_, other->operator_onestop_id_);
    std::swap(operator_name_, other->operator_name_);
    std::swap(operator_url_, other->operator_url_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_TransitRouteInfo::GetTypeName() const {
  return "valhalla.TripLeg.TransitRouteInfo";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_LaneConnectivity::kFromWayIdFieldNumber;
const int TripLeg_LaneConnectivity::kFromLanesFieldNumber;
const int TripLeg_LaneConnectivity::kToLanesFieldNumber;
#endif  // !_MSC_VER

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_LaneConnectivity::InitAsDefaultInstance() {
}

TripLeg_LaneConnectivity::TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_LaneConnectivity::SharedCtor() {
  _cached_size_ = 0;
  from_way_id_ = GOOGLE_ULONGLONG(0);
  from_lanes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  to_lanes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_LaneConnectivity::~TripLeg_LaneConnectivity() {
  SharedDtor();
}

void TripLeg_LaneConnectivity::SharedDtor() {
  if (from_lanes_ != &::google::protobuf::internal::kEmptyString) {
    delete from_lanes_;
  }
  if (to_lanes_ != &::google::protobuf::internal::kEmptyString) {
    delete to_lanes_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_LaneConnectivity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_LaneConnectivity& TripLeg_LaneConnectivity::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_LaneConnectivity* TripLeg_LaneConnectivity::default_instance_ = NULL;

TripLeg_LaneConnectivity* TripLeg_LaneConnectivity::New() const {
  return new TripLeg_LaneConnectivity;
}

void TripLeg_LaneConnectivity::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    from_way_id_ = GOOGLE_ULONGLONG(0);
    if (has_from_lanes()) {
      if (from_lanes_ != &::google::protobuf::internal::kEmptyString) {
        from_lanes_->clear();
      }
    }
    if (has_to_lanes()) {
      if (to_lanes_ != &::google::protobuf::internal::kEmptyString) {
        to_lanes_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_LaneConnectivity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 from_way_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &from_way_id_)));
          set_has_from_way_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_from_lanes;
        break;
      }

      // optional string from_lanes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_from_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_from_lanes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_to_lanes;
        break;
      }

      // optional string to_lanes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_to_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_to_lanes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_LaneConnectivity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 from_way_id = 1;
  if (has_from_way_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->from_way_id(), output);
  }

  // optional string from_lanes = 2;
  if (has_from_lanes()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->from_lanes(), output);
  }

  // optional string to_lanes = 3;
  if (has_to_lanes()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->to_lanes(), output);
  }

}

int TripLeg_LaneConnectivity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 from_way_id = 1;
    if (has_from_way_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->from_way_id());
    }

    // optional string from_lanes = 2;
    if (has_from_lanes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->from_lanes());
    }

    // optional string to_lanes = 3;
    if (has_to_lanes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->to_lanes());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_LaneConnectivity::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_LaneConnectivity*>(&from));
}

void TripLeg_LaneConnectivity::MergeFrom(const TripLeg_LaneConnectivity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_way_id()) {
      set_from_way_id(from.from_way_id());
    }
    if (from.has_from_lanes()) {
      set_from_lanes(from.from_lanes());
    }
    if (from.has_to_lanes()) {
      set_to_lanes(from.to_lanes());
    }
  }
}

void TripLeg_LaneConnectivity::CopyFrom(const TripLeg_LaneConnectivity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_LaneConnectivity::IsInitialized() const {

  return true;
}

void TripLeg_LaneConnectivity::Swap(TripLeg_LaneConnectivity* other) {
  if (other != this) {
    std::swap(from_way_id_, other->from_way_id_);
    std::swap(from_lanes_, other->from_lanes_);
    std::swap(to_lanes_, other->to_lanes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_LaneConnectivity::GetTypeName() const {
  return "valhalla.TripLeg.LaneConnectivity";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_TrafficSegment::kSegmentIdFieldNumber;
const int TripLeg_TrafficSegment::kBeginPercentFieldNumber;
const int TripLeg_TrafficSegment::kEndPercentFieldNumber;
const int TripLeg_TrafficSegment::kStartsSegmentFieldNumber;
const int TripLeg_TrafficSegment::kEndsSegmentFieldNumber;
#endif  // !_MSC_VER

TripLeg_TrafficSegment::TripLeg_TrafficSegment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_TrafficSegment::InitAsDefaultInstance() {
}

TripLeg_TrafficSegment::TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_TrafficSegment::SharedCtor() {
  _cached_size_ = 0;
  segment_id_ = GOOGLE_ULONGLONG(0);
  begin_percent_ = 0;
  end_percent_ = 0;
  starts_segment_ = false;
  ends_segment_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_TrafficSegment::~TripLeg_TrafficSegment() {
  SharedDtor();
}

void TripLeg_TrafficSegment::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_TrafficSegment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_TrafficSegment& TripLeg_TrafficSegment::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_TrafficSegment* TripLeg_TrafficSegment::default_instance_ = NULL;

TripLeg_TrafficSegment* TripLeg_TrafficSegment::New() const {
  return new TripLeg_TrafficSegment;
}

void TripLeg_TrafficSegment::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    segment_id_ = GOOGLE_ULONGLONG(0);
    begin_percent_ = 0;
    end_percent_ = 0;
    starts_segment_ = false;
    ends_segment_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_TrafficSegment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 segment_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &segment_id_)));
          set_has_segment_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_begin_percent;
        break;
      }

      // optional float begin_percent = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_begin_percent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &begin_percent_)));
          set_has_begin_percent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_end_percent;
        break;
      }

      // optional float end_percent = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_end_percent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &end_percent_)));
          set_has_end_percent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_starts_segment;
        break;
      }

      // optional bool starts_segment = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_starts_segment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &starts_segment_)));
          set_has_starts_segment();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ends_segment;
        break;
      }

      // optional bool ends_segment = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ends_segment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ends_segment_)));
          set_has_ends_segment();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_TrafficSegment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 segment_id = 1;
  if (has_segment_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->segment_id(), output);
  }

  // optional float begin_percent = 2;
  if (has_begin_percent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->begin_percent(), output);
  }

  // optional float end_percent = 3;
  if (has_end_percent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->end_percent(), output);
  }

  // optional bool starts_segment = 4;
  if (has_starts_segment()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->starts_segment(), output);
  }

  // optional bool ends_segment = 5;
  if (has_ends_segment()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->ends_segment(), output);
  }

}

int TripLeg_TrafficSegment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 segment_id = 1;
    if (has_segment_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->segment_id());
    }

    // optional float begin_percent = 2;
    if (has_begin_percent()) {
      total_size += 1 + 4;
    }

    // optional float end_percent = 3;
    if (has_end_percent()) {
      total_size += 1 + 4;
    }

    // optional bool starts_segment = 4;
    if (has_starts_segment()) {
      total_size += 1 + 1;
    }

    // optional bool ends_segment = 5;
    if (has_ends_segment()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_TrafficSegment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_TrafficSegment*>(&from));
}

void TripLeg_TrafficSegment::MergeFrom(const TripLeg_TrafficSegment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_segment_id()) {
      set_segment_id(from.segment_id());
    }
    if (from.has_begin_percent()) {
      set_begin_percent(from.begin_percent());
    }
    if (from.has_end_percent()) {
      set_end_percent(from.end_percent());
    }
    if (from.has_starts_segment()) {
      set_starts_segment(from.starts_segment());
    }
    if (from.has_ends_segment()) {
      set_ends_segment(from.ends_segment());
    }
  }
}

void TripLeg_TrafficSegment::CopyFrom(const TripLeg_TrafficSegment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_TrafficSegment::IsInitialized() const {

  return true;
}

void TripLeg_TrafficSegment::Swap(TripLeg_TrafficSegment* other) {
  if (other != this) {
    std::swap(segment_id_, other->segment_id_);
    std::swap(begin_percent_, other->begin_percent_);
    std::swap(end_percent_, other->end_percent_);
    std::swap(starts_segment_, other->starts_segment_);
    std::swap(ends_segment_, other->ends_segment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_TrafficSegment::GetTypeName() const {
  return "valhalla.TripLeg.TrafficSegment";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_Edge::kNameFieldNumber;
const int TripLeg_Edge::kLengthFieldNumber;
const int TripLeg_Edge::kSpeedFieldNumber;
const int TripLeg_Edge::kRoadClassFieldNumber;
const int TripLeg_Edge::kBeginHeadingFieldNumber;
const int TripLeg_Edge::kEndHeadingFieldNumber;
const int TripLeg_Edge::kBeginShapeIndexFieldNumber;
const int TripLeg_Edge::kEndShapeIndexFieldNumber;
const int TripLeg_Edge::kTraversabilityFieldNumber;
const int TripLeg_Edge::kUseFieldNumber;
const int TripLeg_Edge::kTollFieldNumber;
const int TripLeg_Edge::kUnpavedFieldNumber;
const int TripLeg_Edge::kTunnelFieldNumber;
const int TripLeg_Edge::kBridgeFieldNumber;
const int TripLeg_Edge::kRoundaboutFieldNumber;
const int TripLeg_Edge::kInternalIntersectionFieldNumber;
const int TripLeg_Edge::kDriveOnRightFieldNumber;
const int TripLeg_Edge::kSurfaceFieldNumber;
const int TripLeg_Edge::kSignFieldNumber;
const int TripLeg_Edge::kTravelModeFieldNumber;
const int TripLeg_Edge::kVehicleTypeFieldNumber;
const int TripLeg_Edge::kPedestrianTypeFieldNumber;
const int TripLeg_Edge::kBicycleTypeFieldNumber;
const int TripLeg_Edge::kTransitTypeFieldNumber;
const int TripLeg_Edge::kTransitRouteInfoFieldNumber;
const int TripLeg_Edge::kIdFieldNumber;
const int TripLeg_Edge::kWayIdFieldNumber;
const int TripLeg_Edge::kWeightedGradeFieldNumber;
const int TripLeg_Edge::kMaxUpwardGradeFieldNumber;
const int TripLeg_Edge::kMaxDownwardGradeFieldNumber;
const int TripLeg_Edge::kLaneCountFieldNumber;
const int TripLeg_Edge::kCycleLaneFieldNumber;
const int TripLeg_Edge::kBicycleNetworkFieldNumber;
const int TripLeg_Edge::kSidewalkFieldNumber;
const int TripLeg_Edge::kDensityFieldNumber;
const int TripLeg_Edge::kSpeedLimitFieldNumber;
const int TripLeg_Edge::kTruckSpeedFieldNumber;
const int TripLeg_Edge::kTruckRouteFieldNumber;
const int TripLeg_Edge::kLaneConnectivityFieldNumber;
const int TripLeg_Edge::kMeanElevationFieldNumber;
const int TripLeg_Edge::kTrafficSegmentFieldNumber;
const int TripLeg_Edge::kTurnLanesFieldNumber;
const int TripLeg_Edge::kHasTimeRestrictionsFieldNumber;
#endif  // !_MSC_VER

TripLeg_Edge::TripLeg_Edge()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_Edge::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_ = const_cast< ::valhalla::TripLeg_Sign*>(
      ::valhalla::TripLeg_Sign::internal_default_instance());
#else
  sign_ = const_cast< ::valhalla::TripLeg_Sign*>(&::valhalla::TripLeg_Sign::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_route_info_ = const_cast< ::valhalla::TripLeg_TransitRouteInfo*>(
      ::valhalla::TripLeg_TransitRouteInfo::internal_default_instance());
#else
  transit_route_info_ = const_cast< ::valhalla::TripLeg_TransitRouteInfo*>(&::valhalla::TripLeg_TransitRouteInfo::default_instance());
#endif
}

TripLeg_Edge::TripLeg_Edge(const TripLeg_Edge& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_Edge::SharedCtor() {
  _cached_size_ = 0;
  length_ = 0;
  speed_ = 0;
  road_class_ = 0;
  begin_heading_ = 0u;
  end_heading_ = 0u;
  begin_shape_index_ = 0u;
  end_shape_index_ = 0u;
  traversability_ = 0;
  use_ = 0;
  toll_ = false;
  unpaved_ = false;
  tunnel_ = false;
  bridge_ = false;
  roundabout_ = false;
  internal_intersection_ = false;
  drive_on_right_ = true;
  surface_ = 0;
  sign_ = NULL;
  travel_mode_ = 0;
  vehicle_type_ = 0;
  pedestrian_type_ = 0;
  bicycle_type_ = 0;
  transit_type_ = 0;
  transit_route_info_ = NULL;
  id_ = GOOGLE_ULONGLONG(0);
  way_id_ = GOOGLE_ULONGLONG(0);
  weighted_grade_ = 0;
  max_upward_grade_ = 0;
  max_downward_grade_ = 0;
  lane_count_ = 0u;
  cycle_lane_ = 0;
  bicycle_network_ = 0u;
  sidewalk_ = 0;
  density_ = 0u;
  speed_limit_ = 0u;
  truck_speed_ = 0;
  truck_route_ = false;
  mean_elevation_ = 0;
  has_time_restrictions_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_Edge::~TripLeg_Edge() {
  SharedDtor();
}

void TripLeg_Edge::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_;
    delete transit_route_info_;
  }
}

void TripLeg_Edge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Edge& TripLeg_Edge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Edge* TripLeg_Edge::default_instance_ = NULL;

TripLeg_Edge* TripLeg_Edge::New() const {
  return new TripLeg_Edge;
}

void TripLeg_Edge::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    length_ = 0;
    speed_ = 0;
    road_class_ = 0;
    begin_heading_ = 0u;
    end_heading_ = 0u;
    begin_shape_index_ = 0u;
    end_shape_index_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    traversability_ = 0;
    use_ = 0;
    toll_ = false;
    unpaved_ = false;
    tunnel_ = false;
    bridge_ = false;
    roundabout_ = false;
    internal_intersection_ = false;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    drive_on_right_ = true;
    surface_ = 0;
    if (has_sign()) {
      if (sign_ != NULL) sign_->::valhalla::TripLeg_Sign::Clear();
    }
    travel_mode_ = 0;
    vehicle_type_ = 0;
    pedestrian_type_ = 0;
    bicycle_type_ = 0;
    transit_type_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (has_transit_route_info()) {
      if (transit_route_info_ != NULL) transit_route_info_->::valhalla::TripLeg_TransitRouteInfo::Clear();
    }
    id_ = GOOGLE_ULONGLONG(0);
    way_id_ = GOOGLE_ULONGLONG(0);
    weighted_grade_ = 0;
    max_upward_grade_ = 0;
    max_downward_grade_ = 0;
    lane_count_ = 0u;
    cycle_lane_ = 0;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    bicycle_network_ = 0u;
    sidewalk_ = 0;
    density_ = 0u;
    speed_limit_ = 0u;
    truck_speed_ = 0;
    truck_route_ = false;
    mean_elevation_ = 0;
  }
  if (_has_bits_[42 / 32] & (0xffu << (42 % 32))) {
    has_time_restrictions_ = false;
  }
  name_.Clear();
  lane_connectivity_.Clear();
  traffic_segment_.Clear();
  turn_lanes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_Edge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.StreetName name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_name;
        if (input->ExpectTag(21)) goto parse_length;
        break;
      }

      // optional float length = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_speed;
        break;
      }

      // optional float speed = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_road_class;
        break;
      }

      // optional .valhalla.TripLeg.RoadClass road_class = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_road_class:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_RoadClass_IsValid(value)) {
            set_road_class(static_cast< ::valhalla::TripLeg_RoadClass >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_begin_heading;
        break;
      }

      // optional uint32 begin_heading = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_heading_)));
          set_has_begin_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_end_heading;
        break;
      }

      // optional uint32 end_heading = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_heading_)));
          set_has_end_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_begin_shape_index;
        break;
      }

      // optional uint32 begin_shape_index = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_shape_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_shape_index_)));
          set_has_begin_shape_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_end_shape_index;
        break;
      }

      // optional uint32 end_shape_index = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_shape_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_shape_index_)));
          set_has_end_shape_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_traversability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability traversability = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_traversability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Traversability_IsValid(value)) {
            set_traversability(static_cast< ::valhalla::TripLeg_Traversability >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_use;
        break;
      }

      // optional .valhalla.TripLeg.Use use = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Use_IsValid(value)) {
            set_use(static_cast< ::valhalla::TripLeg_Use >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_toll;
        break;
      }

      // optional bool toll = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_toll:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &toll_)));
          set_has_toll();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_unpaved;
        break;
      }

      // optional bool unpaved = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unpaved:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unpaved_)));
          set_has_unpaved();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_tunnel;
        break;
      }

      // optional bool tunnel = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tunnel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &tunnel_)));
          set_has_tunnel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_bridge;
        break;
      }

      // optional bool bridge = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bridge:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bridge_)));
          set_has_bridge();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_roundabout;
        break;
      }

      // optional bool roundabout = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roundabout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &roundabout_)));
          set_has_roundabout();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_internal_intersection;
        break;
      }

      // optional bool internal_intersection = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_internal_intersection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &internal_intersection_)));
          set_has_internal_intersection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_drive_on_right;
        break;
      }

      // optional bool drive_on_right = 17 [default = true];
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_drive_on_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &drive_on_right_)));
          set_has_drive_on_right();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_surface;
        break;
      }

      // optional .valhalla.TripLeg.Surface surface = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_surface:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Surface_IsValid(value)) {
            set_surface(static_cast< ::valhalla::TripLeg_Surface >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_sign;
        break;
      }

      // optional .valhalla.TripLeg.Sign sign = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_travel_mode;
        break;
      }

      // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_travel_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_TravelMode_IsValid(value)) {
            set_travel_mode(static_cast< ::valhalla::TripLeg_TravelMode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(168)) goto parse_vehicle_type;
        break;
      }

      // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vehicle_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_VehicleType_IsValid(value)) {
            set_vehicle_type(static_cast< ::valhalla::TripLeg_VehicleType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_pedestrian_type;
        break;
      }

      // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pedestrian_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_PedestrianType_IsValid(value)) {
            set_pedestrian_type(static_cast< ::valhalla::TripLeg_PedestrianType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_bicycle_type;
        break;
      }

      // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bicycle_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_BicycleType_IsValid(value)) {
            set_bicycle_type(static_cast< ::valhalla::TripLeg_BicycleType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_transit_type;
        break;
      }

      // optional .valhalla.TripLeg.TransitType transit_type = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transit_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_TransitType_IsValid(value)) {
            set_transit_type(static_cast< ::valhalla::TripLeg_TransitType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(202)) goto parse_transit_route_info;
        break;
      }

      // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transit_route_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_route_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_id;
        break;
      }

      // optional uint64 id = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(216)) goto parse_way_id;
        break;
      }

      // optional uint64 way_id = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_way_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &way_id_)));
          set_has_way_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(229)) goto parse_weighted_grade;
        break;
      }

      // optional float weighted_grade = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_weighted_grade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weighted_grade_)));
          set_has_weighted_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(232)) goto parse_max_upward_grade;
        break;
      }

      // optional int32 max_upward_grade = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_upward_grade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_upward_grade_)));
          set_has_max_upward_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(240)) goto parse_max_downward_grade;
        break;
      }

      // optional int32 max_downward_grade = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_downward_grade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_downward_grade_)));
          set_has_max_downward_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(248)) goto parse_lane_count;
        break;
      }

      // optional uint32 lane_count = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lane_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lane_count_)));
          set_has_lane_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(256)) goto parse_cycle_lane;
        break;
      }

      // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cycle_lane:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_CycleLane_IsValid(value)) {
            set_cycle_lane(static_cast< ::valhalla::TripLeg_CycleLane >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(264)) goto parse_bicycle_network;
        break;
      }

      // optional uint32 bicycle_network = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bicycle_network:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bicycle_network_)));
          set_has_bicycle_network();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(272)) goto parse_sidewalk;
        break;
      }

      // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sidewalk:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Sidewalk_IsValid(value)) {
            set_sidewalk(static_cast< ::valhalla::TripLeg_Sidewalk >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(280)) goto parse_density;
        break;
      }

      // optional uint32 density = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_density:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &density_)));
          set_has_density();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(288)) goto parse_speed_limit;
        break;
      }

      // optional uint32 speed_limit = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &speed_limit_)));
          set_has_speed_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(301)) goto parse_truck_speed;
        break;
      }

      // optional float truck_speed = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_truck_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &truck_speed_)));
          set_has_truck_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(304)) goto parse_truck_route;
        break;
      }

      // optional bool truck_route = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_truck_route:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &truck_route_)));
          set_has_truck_route();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(314)) goto parse_lane_connectivity;
        break;
      }

      // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lane_connectivity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lane_connectivity()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(314)) goto parse_lane_connectivity;
        if (input->ExpectTag(320)) goto parse_mean_elevation;
        break;
      }

      // optional int32 mean_elevation = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mean_elevation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mean_elevation_)));
          set_has_mean_elevation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(330)) goto parse_traffic_segment;
        break;
      }

      // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_traffic_segment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_traffic_segment()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(330)) goto parse_traffic_segment;
        if (input->ExpectTag(338)) goto parse_turn_lanes;
        break;
      }

      // repeated .valhalla.TurnLane turn_lanes = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_turn_lanes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_turn_lanes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(338)) goto parse_turn_lanes;
        if (input->ExpectTag(344)) goto parse_has_time_restrictions;
        break;
      }

      // optional bool has_time_restrictions = 43;
      case 43: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_time_restrictions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_time_restrictions_)));
          set_has_has_time_restrictions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_Edge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.StreetName name = 1;
  for (int i = 0; i < this->name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->name(i), output);
  }

  // optional float length = 2;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->length(), output);
  }

  // optional float speed = 3;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->speed(), output);
  }

  // optional .valhalla.TripLeg.RoadClass road_class = 4;
  if (has_road_class()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->road_class(), output);
  }

  // optional uint32 begin_heading = 5;
  if (has_begin_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->begin_heading(), output);
  }

  // optional uint32 end_heading = 6;
  if (has_end_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->end_heading(), output);
  }

  // optional uint32 begin_shape_index = 7;
  if (has_begin_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->begin_shape_index(), output);
  }

  // optional uint32 end_shape_index = 8;
  if (has_end_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->end_shape_index(), output);
  }

  // optional .valhalla.TripLeg.Traversability traversability = 9;
  if (has_traversability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->traversability(), output);
  }

  // optional .valhalla.TripLeg.Use use = 10;
  if (has_use()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->use(), output);
  }

  // optional bool toll = 11;
  if (has_toll()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->toll(), output);
  }

  // optional bool unpaved = 12;
  if (has_unpaved()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->unpaved(), output);
  }

  // optional bool tunnel = 13;
  if (has_tunnel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->tunnel(), output);
  }

  // optional bool bridge = 14;
  if (has_bridge()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->bridge(), output);
  }

  // optional bool roundabout = 15;
  if (has_roundabout()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->roundabout(), output);
  }

  // optional bool internal_intersection = 16;
  if (has_internal_intersection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->internal_intersection(), output);
  }

  // optional bool drive_on_right = 17 [default = true];
  if (has_drive_on_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->drive_on_right(), output);
  }

  // optional .valhalla.TripLeg.Surface surface = 18;
  if (has_surface()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      18, this->surface(), output);
  }

  // optional .valhalla.TripLeg.Sign sign = 19;
  if (has_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      19, this->sign(), output);
  }

  // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
  if (has_travel_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      20, this->travel_mode(), output);
  }

  // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      21, this->vehicle_type(), output);
  }

  // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
  if (has_pedestrian_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      22, this->pedestrian_type(), output);
  }

  // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
  if (has_bicycle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      23, this->bicycle_type(), output);
  }

  // optional .valhalla.TripLeg.TransitType transit_type = 24;
  if (has_transit_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      24, this->transit_type(), output);
  }

  // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
  if (has_transit_route_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      25, this->transit_route_info(), output);
  }

  // optional uint64 id = 26;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->id(), output);
  }

  // optional uint64 way_id = 27;
  if (has_way_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(27, this->way_id(), output);
  }

  // optional float weighted_grade = 28;
  if (has_weighted_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(28, this->weighted_grade(), output);
  }

  // optional int32 max_upward_grade = 29;
  if (has_max_upward_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(29, this->max_upward_grade(), output);
  }

  // optional int32 max_downward_grade = 30;
  if (has_max_downward_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(30, this->max_downward_grade(), output);
  }

  // optional uint32 lane_count = 31;
  if (has_lane_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->lane_count(), output);
  }

  // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
  if (has_cycle_lane()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      32, this->cycle_lane(), output);
  }

  // optional uint32 bicycle_network = 33;
  if (has_bicycle_network()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(33, this->bicycle_network(), output);
  }

  // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
  if (has_sidewalk()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      34, this->sidewalk(), output);
  }

  // optional uint32 density = 35;
  if (has_density()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(35, this->density(), output);
  }

  // optional uint32 speed_limit = 36;
  if (has_speed_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(36, this->speed_limit(), output);
  }

  // optional float truck_speed = 37;
  if (has_truck_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(37, this->truck_speed(), output);
  }

  // optional bool truck_route = 38;
  if (has_truck_route()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(38, this->truck_route(), output);
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  for (int i = 0; i < this->lane_connectivity_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      39, this->lane_connectivity(i), output);
  }

  // optional int32 mean_elevation = 40;
  if (has_mean_elevation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(40, this->mean_elevation(), output);
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  for (int i = 0; i < this->traffic_segment_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      41, this->traffic_segment(i), output);
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  for (int i = 0; i < this->turn_lanes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      42, this->turn_lanes(i), output);
  }

  // optional bool has_time_restrictions = 43;
  if (has_has_time_restrictions()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(43, this->has_time_restrictions(), output);
  }

}

int TripLeg_Edge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional float length = 2;
    if (has_length()) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (has_speed()) {
      total_size += 1 + 4;
    }

    // optional .valhalla.TripLeg.RoadClass road_class = 4;
    if (has_road_class()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->road_class());
    }

    // optional uint32 begin_heading = 5;
    if (has_begin_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_heading());
    }

    // optional uint32 end_heading = 6;
    if (has_end_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_heading());
    }

    // optional uint32 begin_shape_index = 7;
    if (has_begin_shape_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_shape_index());
    }

    // optional uint32 end_shape_index = 8;
    if (has_end_shape_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_shape_index());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .valhalla.TripLeg.Traversability traversability = 9;
    if (has_traversability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->traversability());
    }

    // optional .valhalla.TripLeg.Use use = 10;
    if (has_use()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->use());
    }

    // optional bool toll = 11;
    if (has_toll()) {
      total_size += 1 + 1;
    }

    // optional bool unpaved = 12;
    if (has_unpaved()) {
      total_size += 1 + 1;
    }

    // optional bool tunnel = 13;
    if (has_tunnel()) {
      total_size += 1 + 1;
    }

    // optional bool bridge = 14;
    if (has_bridge()) {
      total_size += 1 + 1;
    }

    // optional bool roundabout = 15;
    if (has_roundabout()) {
      total_size += 1 + 1;
    }

    // optional bool internal_intersection = 16;
    if (has_internal_intersection()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bool drive_on_right = 17 [default = true];
    if (has_drive_on_right()) {
      total_size += 2 + 1;
    }

    // optional .valhalla.TripLeg.Surface surface = 18;
    if (has_surface()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->surface());
    }

    // optional .valhalla.TripLeg.Sign sign = 19;
    if (has_sign()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign());
    }

    // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
    if (has_travel_mode()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->travel_mode());
    }

    // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
    if (has_vehicle_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->vehicle_type());
    }

    // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
    if (has_pedestrian_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pedestrian_type());
    }

    // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
    if (has_bicycle_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->bicycle_type());
    }

    // optional .valhalla.TripLeg.TransitType transit_type = 24;
    if (has_transit_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transit_type());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
    if (has_transit_route_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transit_route_info());
    }

    // optional uint64 id = 26;
    if (has_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional uint64 way_id = 27;
    if (has_way_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->way_id());
    }

    // optional float weighted_grade = 28;
    if (has_weighted_grade()) {
      total_size += 2 + 4;
    }

    // optional int32 max_upward_grade = 29;
    if (has_max_upward_grade()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_upward_grade());
    }

    // optional int32 max_downward_grade = 30;
    if (has_max_downward_grade()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_downward_grade());
    }

    // optional uint32 lane_count = 31;
    if (has_lane_count()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lane_count());
    }

    // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
    if (has_cycle_lane()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cycle_lane());
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional uint32 bicycle_network = 33;
    if (has_bicycle_network()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bicycle_network());
    }

    // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
    if (has_sidewalk()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sidewalk());
    }

    // optional uint32 density = 35;
    if (has_density()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->density());
    }

    // optional uint32 speed_limit = 36;
    if (has_speed_limit()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->speed_limit());
    }

    // optional float truck_speed = 37;
    if (has_truck_speed()) {
      total_size += 2 + 4;
    }

    // optional bool truck_route = 38;
    if (has_truck_route()) {
      total_size += 2 + 1;
    }

    // optional int32 mean_elevation = 40;
    if (has_mean_elevation()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mean_elevation());
    }

  }
  if (_has_bits_[42 / 32] & (0xffu << (42 % 32))) {
    // optional bool has_time_restrictions = 43;
    if (has_has_time_restrictions()) {
      total_size += 2 + 1;
    }

  }
  // repeated .valhalla.StreetName name = 1;
  total_size += 1 * this->name_size();
  for (int i = 0; i < this->name_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->name(i));
  }

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  total_size += 2 * this->lane_connectivity_size();
  for (int i = 0; i < this->lane_connectivity_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lane_connectivity(i));
  }

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  total_size += 2 * this->traffic_segment_size();
  for (int i = 0; i < this->traffic_segment_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->traffic_segment(i));
  }

  // repeated .valhalla.TurnLane turn_lanes = 42;
  total_size += 2 * this->turn_lanes_size();
  for (int i = 0; i < this->turn_lanes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->turn_lanes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Edge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Edge*>(&from));
}

void TripLeg_Edge::MergeFrom(const TripLeg_Edge& from) {
  GOOGLE_CHECK_NE(&from, this);
  name_.MergeFrom(from.name_);
  lane_connectivity_.MergeFrom(from.lane_connectivity_);
  traffic_segment_.MergeFrom(from.traffic_segment_);
  turn_lanes_.MergeFrom(from.turn_lanes_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_road_class()) {
      set_road_class(from.road_class());
    }
    if (from.has_begin_heading()) {
      set_begin_heading(from.begin_heading());
    }
    if (from.has_end_heading()) {
      set_end_heading(from.end_heading());
    }
    if (from.has_begin_shape_index()) {
      set_begin_shape_index(from.begin_shape_index());
    }
    if (from.has_end_shape_index()) {
      set_end_shape_index(from.end_shape_index());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_traversability()) {
      set_traversability(from.traversability());
    }
    if (from.has_use()) {
      set_use(from.use());
    }
    if (from.has_toll()) {
      set_toll(from.toll());
    }
    if (from.has_unpaved()) {
      set_unpaved(from.unpaved());
    }
    if (from.has_tunnel()) {
      set_tunnel(from.tunnel());
    }
    if (from.has_bridge()) {
      set_bridge(from.bridge());
    }
    if (from.has_roundabout()) {
      set_roundabout(from.roundabout());
    }
    if (from.has_internal_intersection()) {
      set_internal_intersection(from.internal_intersection());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_drive_on_right()) {
      set_drive_on_right(from.drive_on_right());
    }
    if (from.has_surface()) {
      set_surface(from.surface());
    }
    if (from.has_sign()) {
      mutable_sign()->::valhalla::TripLeg_Sign::MergeFrom(from.sign());
    }
    if (from.has_travel_mode()) {
      set_travel_mode(from.travel_mode());
    }
    if (from.has_vehicle_type()) {
      set_vehicle_type(from.vehicle_type());
    }
    if (from.has_pedestrian_type()) {
      set_pedestrian_type(from.pedestrian_type());
    }
    if (from.has_bicycle_type()) {
      set_bicycle_type(from.bicycle_type());
    }
    if (from.has_transit_type()) {
      set_transit_type(from.transit_type());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_transit_route_info()) {
      mutable_transit_route_info()->::valhalla::TripLeg_TransitRouteInfo::MergeFrom(from.transit_route_info());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_way_id()) {
      set_way_id(from.way_id());
    }
    if (from.has_weighted_grade()) {
      set_weighted_grade(from.weighted_grade());
    }
    if (from.has_max_upward_grade()) {
      set_max_upward_grade(from.max_upward_grade());
    }
    if (from.has_max_downward_grade()) {
      set_max_downward_grade(from.max_downward_grade());
    }
    if (from.has_lane_count()) {
      set_lane_count(from.lane_count());
    }
    if (from.has_cycle_lane()) {
      set_cycle_lane(from.cycle_lane());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_bicycle_network()) {
      set_bicycle_network(from.bicycle_network());
    }
    if (from.has_sidewalk()) {
      set_sidewalk(from.sidewalk());
    }
    if (from.has_density()) {
      set_density(from.density());
    }
    if (from.has_speed_limit()) {
      set_speed_limit(from.speed_limit());
    }
    if (from.has_truck_speed()) {
      set_truck_speed(from.truck_speed());
    }
    if (from.has_truck_route()) {
      set_truck_route(from.truck_route());
    }
    if (from.has_mean_elevation()) {
      set_mean_elevation(from.mean_elevation());
    }
  }
  if (from._has_bits_[42 / 32] & (0xffu << (42 % 32))) {
    if (from.has_has_time_restrictions()) {
      set_has_time_restrictions(from.has_time_restrictions());
    }
  }
}

void TripLeg_Edge::CopyFrom(const TripLeg_Edge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Edge::IsInitialized() const {

  return true;
}

void TripLeg_Edge::Swap(TripLeg_Edge* other) {
  if (other != this) {
    name_.Swap(&other->name_);
    std::swap(length_, other->length_);
    std::swap(speed_, other->speed_);
    std::swap(road_class_, other->road_class_);
    std::swap(begin_heading_, other->begin_heading_);
    std::swap(end_heading_, other->end_heading_);
    std::swap(begin_shape_index_, other->begin_shape_index_);
    std::swap(end_shape_index_, other->end_shape_index_);
    std::swap(traversability_, other->traversability_);
    std::swap(use_, other->use_);
    std::swap(toll_, other->toll_);
    std::swap(unpaved_, other->unpaved_);
    std::swap(tunnel_, other->tunnel_);
    std::swap(bridge_, other->bridge_);
    std::swap(roundabout_, other->roundabout_);
    std::swap(internal_intersection_, other->internal_intersection_);
    std::swap(drive_on_right_, other->drive_on_right_);
    std::swap(surface_, other->surface_);
    std::swap(sign_, other->sign_);
    std::swap(travel_mode_, other->travel_mode_);
    std::swap(vehicle_type_, other->vehicle_type_);
    std::swap(pedestrian_type_, other->pedestrian_type_);
    std::swap(bicycle_type_, other->bicycle_type_);
    std::swap(transit_type_, other->transit_type_);
    std::swap(transit_route_info_, other->transit_route_info_);
    std::swap(id_, other->id_);
    std::swap(way_id_, other->way_id_);
    std::swap(weighted_grade_, other->weighted_grade_);
    std::swap(max_upward_grade_, other->max_upward_grade_);
    std::swap(max_downward_grade_, other->max_downward_grade_);
    std::swap(lane_count_, other->lane_count_);
    std::swap(cycle_lane_, other->cycle_lane_);
    std::swap(bicycle_network_, other->bicycle_network_);
    std::swap(sidewalk_, other->sidewalk_);
    std::swap(density_, other->density_);
    std::swap(speed_limit_, other->speed_limit_);
    std::swap(truck_speed_, other->truck_speed_);
    std::swap(truck_route_, other->truck_route_);
    lane_connectivity_.Swap(&other->lane_connectivity_);
    std::swap(mean_elevation_, other->mean_elevation_);
    traffic_segment_.Swap(&other->traffic_segment_);
    turn_lanes_.Swap(&other->turn_lanes_);
    std::swap(has_time_restrictions_, other->has_time_restrictions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_Edge::GetTypeName() const {
  return "valhalla.TripLeg.Edge";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_IntersectingEdge::kBeginHeadingFieldNumber;
const int TripLeg_IntersectingEdge::kPrevNameConsistencyFieldNumber;
const int TripLeg_IntersectingEdge::kCurrNameConsistencyFieldNumber;
const int TripLeg_IntersectingEdge::kDriveabilityFieldNumber;
const int TripLeg_IntersectingEdge::kCyclabilityFieldNumber;
const int TripLeg_IntersectingEdge::kWalkabilityFieldNumber;
const int TripLeg_IntersectingEdge::kUseFieldNumber;
const int TripLeg_IntersectingEdge::kRoadClassFieldNumber;
#endif  // !_MSC_VER

TripLeg_IntersectingEdge::TripLeg_IntersectingEdge()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_IntersectingEdge::InitAsDefaultInstance() {
}

TripLeg_IntersectingEdge::TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_IntersectingEdge::SharedCtor() {
  _cached_size_ = 0;
  begin_heading_ = 0u;
  prev_name_consistency_ = false;
  curr_name_consistency_ = false;
  driveability_ = 0;
  cyclability_ = 0;
  walkability_ = 0;
  use_ = 0;
  road_class_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_IntersectingEdge::~TripLeg_IntersectingEdge() {
  SharedDtor();
}

void TripLeg_IntersectingEdge::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_IntersectingEdge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_IntersectingEdge& TripLeg_IntersectingEdge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_IntersectingEdge* TripLeg_IntersectingEdge::default_instance_ = NULL;

TripLeg_IntersectingEdge* TripLeg_IntersectingEdge::New() const {
  return new TripLeg_IntersectingEdge;
}

void TripLeg_IntersectingEdge::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    begin_heading_ = 0u;
    prev_name_consistency_ = false;
    curr_name_consistency_ = false;
    driveability_ = 0;
    cyclability_ = 0;
    walkability_ = 0;
    use_ = 0;
    road_class_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_IntersectingEdge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 begin_heading = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_heading_)));
          set_has_begin_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_prev_name_consistency;
        break;
      }

      // optional bool prev_name_consistency = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_prev_name_consistency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &prev_name_consistency_)));
          set_has_prev_name_consistency();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_curr_name_consistency;
        break;
      }

      // optional bool curr_name_consistency = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curr_name_consistency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &curr_name_consistency_)));
          set_has_curr_name_consistency();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_driveability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability driveability = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_driveability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Traversability_IsValid(value)) {
            set_driveability(static_cast< ::valhalla::TripLeg_Traversability >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_cyclability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability cyclability = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cyclability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Traversability_IsValid(value)) {
            set_cyclability(static_cast< ::valhalla::TripLeg_Traversability >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_walkability;
        break;
      }

      // optional .valhalla.TripLeg.Traversability walkability = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_walkability:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Traversability_IsValid(value)) {
            set_walkability(static_cast< ::valhalla::TripLeg_Traversability >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_use;
        break;
      }

      // optional .valhalla.TripLeg.Use use = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Use_IsValid(value)) {
            set_use(static_cast< ::valhalla::TripLeg_Use >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_road_class;
        break;
      }

      // optional .valhalla.TripLeg.RoadClass road_class = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_road_class:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_RoadClass_IsValid(value)) {
            set_road_class(static_cast< ::valhalla::TripLeg_RoadClass >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_IntersectingEdge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 begin_heading = 1;
  if (has_begin_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->begin_heading(), output);
  }

  // optional bool prev_name_consistency = 2;
  if (has_prev_name_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->prev_name_consistency(), output);
  }

  // optional bool curr_name_consistency = 3;
  if (has_curr_name_consistency()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->curr_name_consistency(), output);
  }

  // optional .valhalla.TripLeg.Traversability driveability = 4;
  if (has_driveability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->driveability(), output);
  }

  // optional .valhalla.TripLeg.Traversability cyclability = 5;
  if (has_cyclability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->cyclability(), output);
  }

  // optional .valhalla.TripLeg.Traversability walkability = 6;
  if (has_walkability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->walkability(), output);
  }

  // optional .valhalla.TripLeg.Use use = 7;
  if (has_use()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->use(), output);
  }

  // optional .valhalla.TripLeg.RoadClass road_class = 8;
  if (has_road_class()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->road_class(), output);
  }

}

int TripLeg_IntersectingEdge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 begin_heading = 1;
    if (has_begin_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_heading());
    }

    // optional bool prev_name_consistency = 2;
    if (has_prev_name_consistency()) {
      total_size += 1 + 1;
    }

    // optional bool curr_name_consistency = 3;
    if (has_curr_name_consistency()) {
      total_size += 1 + 1;
    }

    // optional .valhalla.TripLeg.Traversability driveability = 4;
    if (has_driveability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->driveability());
    }

    // optional .valhalla.TripLeg.Traversability cyclability = 5;
    if (has_cyclability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cyclability());
    }

    // optional .valhalla.TripLeg.Traversability walkability = 6;
    if (has_walkability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->walkability());
    }

    // optional .valhalla.TripLeg.Use use = 7;
    if (has_use()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->use());
    }

    // optional .valhalla.TripLeg.RoadClass road_class = 8;
    if (has_road_class()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->road_class());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_IntersectingEdge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_IntersectingEdge*>(&from));
}

void TripLeg_IntersectingEdge::MergeFrom(const TripLeg_IntersectingEdge& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin_heading()) {
      set_begin_heading(from.begin_heading());
    }
    if (from.has_prev_name_consistency()) {
      set_prev_name_consistency(from.prev_name_consistency());
    }
    if (from.has_curr_name_consistency()) {
      set_curr_name_consistency(from.curr_name_consistency());
    }
    if (from.has_driveability()) {
      set_driveability(from.driveability());
    }
    if (from.has_cyclability()) {
      set_cyclability(from.cyclability());
    }
    if (from.has_walkability()) {
      set_walkability(from.walkability());
    }
    if (from.has_use()) {
      set_use(from.use());
    }
    if (from.has_road_class()) {
      set_road_class(from.road_class());
    }
  }
}

void TripLeg_IntersectingEdge::CopyFrom(const TripLeg_IntersectingEdge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_IntersectingEdge::IsInitialized() const {

  return true;
}

void TripLeg_IntersectingEdge::Swap(TripLeg_IntersectingEdge* other) {
  if (other != this) {
    std::swap(begin_heading_, other->begin_heading_);
    std::swap(prev_name_consistency_, other->prev_name_consistency_);
    std::swap(curr_name_consistency_, other->curr_name_consistency_);
    std::swap(driveability_, other->driveability_);
    std::swap(cyclability_, other->cyclability_);
    std::swap(walkability_, other->walkability_);
    std::swap(use_, other->use_);
    std::swap(road_class_, other->road_class_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_IntersectingEdge::GetTypeName() const {
  return "valhalla.TripLeg.IntersectingEdge";
}


// -------------------------------------------------------------------

bool TripLeg_Node_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const TripLeg_Node_Type TripLeg_Node::kStreetIntersection;
const TripLeg_Node_Type TripLeg_Node::kGate;
const TripLeg_Node_Type TripLeg_Node::kBollard;
const TripLeg_Node_Type TripLeg_Node::kTollBooth;
const TripLeg_Node_Type TripLeg_Node::kTransitEgress;
const TripLeg_Node_Type TripLeg_Node::kTransitStation;
const TripLeg_Node_Type TripLeg_Node::kTransitPlatform;
const TripLeg_Node_Type TripLeg_Node::kBikeShare;
const TripLeg_Node_Type TripLeg_Node::kParking;
const TripLeg_Node_Type TripLeg_Node::kMotorwayJunction;
const TripLeg_Node_Type TripLeg_Node::kBorderControl;
const TripLeg_Node_Type TripLeg_Node::Type_MIN;
const TripLeg_Node_Type TripLeg_Node::Type_MAX;
const int TripLeg_Node::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int TripLeg_Node::kEdgeFieldNumber;
const int TripLeg_Node::kIntersectingEdgeFieldNumber;
const int TripLeg_Node::kElapsedTimeFieldNumber;
const int TripLeg_Node::kAdminIndexFieldNumber;
const int TripLeg_Node::kTypeFieldNumber;
const int TripLeg_Node::kForkFieldNumber;
const int TripLeg_Node::kTransitPlatformInfoFieldNumber;
const int TripLeg_Node::kTransitStationInfoFieldNumber;
const int TripLeg_Node::kTransitEgressInfoFieldNumber;
const int TripLeg_Node::kTimeZoneFieldNumber;
#endif  // !_MSC_VER

TripLeg_Node::TripLeg_Node()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_Node::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  edge_ = const_cast< ::valhalla::TripLeg_Edge*>(
      ::valhalla::TripLeg_Edge::internal_default_instance());
#else
  edge_ = const_cast< ::valhalla::TripLeg_Edge*>(&::valhalla::TripLeg_Edge::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_platform_info_ = const_cast< ::valhalla::TransitPlatformInfo*>(
      ::valhalla::TransitPlatformInfo::internal_default_instance());
#else
  transit_platform_info_ = const_cast< ::valhalla::TransitPlatformInfo*>(&::valhalla::TransitPlatformInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_station_info_ = const_cast< ::valhalla::TransitStationInfo*>(
      ::valhalla::TransitStationInfo::internal_default_instance());
#else
  transit_station_info_ = const_cast< ::valhalla::TransitStationInfo*>(&::valhalla::TransitStationInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_egress_info_ = const_cast< ::valhalla::TransitEgressInfo*>(
      ::valhalla::TransitEgressInfo::internal_default_instance());
#else
  transit_egress_info_ = const_cast< ::valhalla::TransitEgressInfo*>(&::valhalla::TransitEgressInfo::default_instance());
#endif
}

TripLeg_Node::TripLeg_Node(const TripLeg_Node& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_Node::SharedCtor() {
  _cached_size_ = 0;
  edge_ = NULL;
  elapsed_time_ = 0;
  admin_index_ = 0u;
  type_ = 0;
  fork_ = false;
  transit_platform_info_ = NULL;
  transit_station_info_ = NULL;
  transit_egress_info_ = NULL;
  time_zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_Node::~TripLeg_Node() {
  SharedDtor();
}

void TripLeg_Node::SharedDtor() {
  if (time_zone_ != &::google::protobuf::internal::kEmptyString) {
    delete time_zone_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete edge_;
    delete transit_platform_info_;
    delete transit_station_info_;
    delete transit_egress_info_;
  }
}

void TripLeg_Node::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Node& TripLeg_Node::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Node* TripLeg_Node::default_instance_ = NULL;

TripLeg_Node* TripLeg_Node::New() const {
  return new TripLeg_Node;
}

void TripLeg_Node::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_edge()) {
      if (edge_ != NULL) edge_->::valhalla::TripLeg_Edge::Clear();
    }
    elapsed_time_ = 0;
    admin_index_ = 0u;
    type_ = 0;
    fork_ = false;
    if (has_transit_platform_info()) {
      if (transit_platform_info_ != NULL) transit_platform_info_->::valhalla::TransitPlatformInfo::Clear();
    }
    if (has_transit_station_info()) {
      if (transit_station_info_ != NULL) transit_station_info_->::valhalla::TransitStationInfo::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_transit_egress_info()) {
      if (transit_egress_info_ != NULL) transit_egress_info_->::valhalla::TransitEgressInfo::Clear();
    }
    if (has_time_zone()) {
      if (time_zone_ != &::google::protobuf::internal::kEmptyString) {
        time_zone_->clear();
      }
    }
  }
  intersecting_edge_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_Node::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .valhalla.TripLeg.Edge edge = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_edge()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_intersecting_edge;
        break;
      }

      // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_intersecting_edge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_intersecting_edge()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_intersecting_edge;
        if (input->ExpectTag(25)) goto parse_elapsed_time;
        break;
      }

      // optional double elapsed_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_elapsed_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &elapsed_time_)));
          set_has_elapsed_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_admin_index;
        break;
      }

      // optional uint32 admin_index = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_admin_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &admin_index_)));
          set_has_admin_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional .valhalla.TripLeg.Node.Type type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::TripLeg_Node_Type_IsValid(value)) {
            set_type(static_cast< ::valhalla::TripLeg_Node_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_fork;
        break;
      }

      // optional bool fork = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fork:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &fork_)));
          set_has_fork();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_transit_platform_info;
        break;
      }

      // optional .valhalla.TransitPlatformInfo transit_platform_info = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transit_platform_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_platform_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_transit_station_info;
        break;
      }

      // optional .valhalla.TransitStationInfo transit_station_info = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transit_station_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_station_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_transit_egress_info;
        break;
      }

      // optional .valhalla.TransitEgressInfo transit_egress_info = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transit_egress_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_egress_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_time_zone;
        break;
      }

      // optional string time_zone = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_time_zone:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_time_zone()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_Node::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .valhalla.TripLeg.Edge edge = 1;
  if (has_edge()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->edge(), output);
  }

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  for (int i = 0; i < this->intersecting_edge_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->intersecting_edge(i), output);
  }

  // optional double elapsed_time = 3;
  if (has_elapsed_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->elapsed_time(), output);
  }

  // optional uint32 admin_index = 4;
  if (has_admin_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->admin_index(), output);
  }

  // optional .valhalla.TripLeg.Node.Type type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->type(), output);
  }

  // optional bool fork = 6;
  if (has_fork()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->fork(), output);
  }

  // optional .valhalla.TransitPlatformInfo transit_platform_info = 7;
  if (has_transit_platform_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->transit_platform_info(), output);
  }

  // optional .valhalla.TransitStationInfo transit_station_info = 8;
  if (has_transit_station_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->transit_station_info(), output);
  }

  // optional .valhalla.TransitEgressInfo transit_egress_info = 9;
  if (has_transit_egress_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->transit_egress_info(), output);
  }

  // optional string time_zone = 10;
  if (has_time_zone()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->time_zone(), output);
  }

}

int TripLeg_Node::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .valhalla.TripLeg.Edge edge = 1;
    if (has_edge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->edge());
    }

    // optional double elapsed_time = 3;
    if (has_elapsed_time()) {
      total_size += 1 + 8;
    }

    // optional uint32 admin_index = 4;
    if (has_admin_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->admin_index());
    }

    // optional .valhalla.TripLeg.Node.Type type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bool fork = 6;
    if (has_fork()) {
      total_size += 1 + 1;
    }

    // optional .valhalla.TransitPlatformInfo transit_platform_info = 7;
    if (has_transit_platform_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transit_platform_info());
    }

    // optional .valhalla.TransitStationInfo transit_station_info = 8;
    if (has_transit_station_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transit_station_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .valhalla.TransitEgressInfo transit_egress_info = 9;
    if (has_transit_egress_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transit_egress_info());
    }

    // optional string time_zone = 10;
    if (has_time_zone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->time_zone());
    }

  }
  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  total_size += 1 * this->intersecting_edge_size();
  for (int i = 0; i < this->intersecting_edge_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->intersecting_edge(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Node::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Node*>(&from));
}

void TripLeg_Node::MergeFrom(const TripLeg_Node& from) {
  GOOGLE_CHECK_NE(&from, this);
  intersecting_edge_.MergeFrom(from.intersecting_edge_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_edge()) {
      mutable_edge()->::valhalla::TripLeg_Edge::MergeFrom(from.edge());
    }
    if (from.has_elapsed_time()) {
      set_elapsed_time(from.elapsed_time());
    }
    if (from.has_admin_index()) {
      set_admin_index(from.admin_index());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_fork()) {
      set_fork(from.fork());
    }
    if (from.has_transit_platform_info()) {
      mutable_transit_platform_info()->::valhalla::TransitPlatformInfo::MergeFrom(from.transit_platform_info());
    }
    if (from.has_transit_station_info()) {
      mutable_transit_station_info()->::valhalla::TransitStationInfo::MergeFrom(from.transit_station_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_transit_egress_info()) {
      mutable_transit_egress_info()->::valhalla::TransitEgressInfo::MergeFrom(from.transit_egress_info());
    }
    if (from.has_time_zone()) {
      set_time_zone(from.time_zone());
    }
  }
}

void TripLeg_Node::CopyFrom(const TripLeg_Node& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Node::IsInitialized() const {

  return true;
}

void TripLeg_Node::Swap(TripLeg_Node* other) {
  if (other != this) {
    std::swap(edge_, other->edge_);
    intersecting_edge_.Swap(&other->intersecting_edge_);
    std::swap(elapsed_time_, other->elapsed_time_);
    std::swap(admin_index_, other->admin_index_);
    std::swap(type_, other->type_);
    std::swap(fork_, other->fork_);
    std::swap(transit_platform_info_, other->transit_platform_info_);
    std::swap(transit_station_info_, other->transit_station_info_);
    std::swap(transit_egress_info_, other->transit_egress_info_);
    std::swap(time_zone_, other->time_zone_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_Node::GetTypeName() const {
  return "valhalla.TripLeg.Node";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_Admin::kCountryCodeFieldNumber;
const int TripLeg_Admin::kCountryTextFieldNumber;
const int TripLeg_Admin::kStateCodeFieldNumber;
const int TripLeg_Admin::kStateTextFieldNumber;
#endif  // !_MSC_VER

TripLeg_Admin::TripLeg_Admin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_Admin::InitAsDefaultInstance() {
}

TripLeg_Admin::TripLeg_Admin(const TripLeg_Admin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_Admin::SharedCtor() {
  _cached_size_ = 0;
  country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  country_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  state_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_Admin::~TripLeg_Admin() {
  SharedDtor();
}

void TripLeg_Admin::SharedDtor() {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete country_code_;
  }
  if (country_text_ != &::google::protobuf::internal::kEmptyString) {
    delete country_text_;
  }
  if (state_code_ != &::google::protobuf::internal::kEmptyString) {
    delete state_code_;
  }
  if (state_text_ != &::google::protobuf::internal::kEmptyString) {
    delete state_text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_Admin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_Admin& TripLeg_Admin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_Admin* TripLeg_Admin::default_instance_ = NULL;

TripLeg_Admin* TripLeg_Admin::New() const {
  return new TripLeg_Admin;
}

void TripLeg_Admin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_country_code()) {
      if (country_code_ != &::google::protobuf::internal::kEmptyString) {
        country_code_->clear();
      }
    }
    if (has_country_text()) {
      if (country_text_ != &::google::protobuf::internal::kEmptyString) {
        country_text_->clear();
      }
    }
    if (has_state_code()) {
      if (state_code_ != &::google::protobuf::internal::kEmptyString) {
        state_code_->clear();
      }
    }
    if (has_state_text()) {
      if (state_text_ != &::google::protobuf::internal::kEmptyString) {
        state_text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_Admin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string country_code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_country_text;
        break;
      }

      // optional string country_text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_country_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_country_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_state_code;
        break;
      }

      // optional string state_code = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_state_text;
        break;
      }

      // optional string state_text = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_Admin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string country_code = 1;
  if (has_country_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->country_code(), output);
  }

  // optional string country_text = 2;
  if (has_country_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->country_text(), output);
  }

  // optional string state_code = 3;
  if (has_state_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->state_code(), output);
  }

  // optional string state_text = 4;
  if (has_state_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->state_text(), output);
  }

}

int TripLeg_Admin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string country_code = 1;
    if (has_country_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->country_code());
    }

    // optional string country_text = 2;
    if (has_country_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->country_text());
    }

    // optional string state_code = 3;
    if (has_state_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state_code());
    }

    // optional string state_text = 4;
    if (has_state_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state_text());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_Admin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_Admin*>(&from));
}

void TripLeg_Admin::MergeFrom(const TripLeg_Admin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_country_code()) {
      set_country_code(from.country_code());
    }
    if (from.has_country_text()) {
      set_country_text(from.country_text());
    }
    if (from.has_state_code()) {
      set_state_code(from.state_code());
    }
    if (from.has_state_text()) {
      set_state_text(from.state_text());
    }
  }
}

void TripLeg_Admin::CopyFrom(const TripLeg_Admin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_Admin::IsInitialized() const {

  return true;
}

void TripLeg_Admin::Swap(TripLeg_Admin* other) {
  if (other != this) {
    std::swap(country_code_, other->country_code_);
    std::swap(country_text_, other->country_text_);
    std::swap(state_code_, other->state_code_);
    std::swap(state_text_, other->state_text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_Admin::GetTypeName() const {
  return "valhalla.TripLeg.Admin";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg_ShapeAttributes::kTimeFieldNumber;
const int TripLeg_ShapeAttributes::kLengthFieldNumber;
const int TripLeg_ShapeAttributes::kSpeedFieldNumber;
#endif  // !_MSC_VER

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg_ShapeAttributes::InitAsDefaultInstance() {
}

TripLeg_ShapeAttributes::TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg_ShapeAttributes::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg_ShapeAttributes::~TripLeg_ShapeAttributes() {
  SharedDtor();
}

void TripLeg_ShapeAttributes::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripLeg_ShapeAttributes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg_ShapeAttributes& TripLeg_ShapeAttributes::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg_ShapeAttributes* TripLeg_ShapeAttributes::default_instance_ = NULL;

TripLeg_ShapeAttributes* TripLeg_ShapeAttributes::New() const {
  return new TripLeg_ShapeAttributes;
}

void TripLeg_ShapeAttributes::Clear() {
  time_.Clear();
  length_.Clear();
  speed_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg_ShapeAttributes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 time = 1 [packed = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_time())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 10, input, this->mutable_time())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_length;
        break;
      }

      // repeated uint32 length = 2 [packed = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_length())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 18, input, this->mutable_length())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_speed;
        break;
      }

      // repeated uint32 speed = 3 [packed = true];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_speed())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 26, input, this->mutable_speed())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg_ShapeAttributes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 time = 1 [packed = true];
  if (this->time_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(1, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_time_cached_byte_size_);
  }
  for (int i = 0; i < this->time_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->time(i), output);
  }

  // repeated uint32 length = 2 [packed = true];
  if (this->length_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_length_cached_byte_size_);
  }
  for (int i = 0; i < this->length_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->length(i), output);
  }

  // repeated uint32 speed = 3 [packed = true];
  if (this->speed_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_speed_cached_byte_size_);
  }
  for (int i = 0; i < this->speed_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32NoTag(
      this->speed(i), output);
  }

}

int TripLeg_ShapeAttributes::ByteSize() const {
  int total_size = 0;

  // repeated uint32 time = 1 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->time_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->time(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _time_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint32 length = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->length_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->length(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _length_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated uint32 speed = 3 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->speed_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->speed(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _speed_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg_ShapeAttributes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg_ShapeAttributes*>(&from));
}

void TripLeg_ShapeAttributes::MergeFrom(const TripLeg_ShapeAttributes& from) {
  GOOGLE_CHECK_NE(&from, this);
  time_.MergeFrom(from.time_);
  length_.MergeFrom(from.length_);
  speed_.MergeFrom(from.speed_);
}

void TripLeg_ShapeAttributes::CopyFrom(const TripLeg_ShapeAttributes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg_ShapeAttributes::IsInitialized() const {

  return true;
}

void TripLeg_ShapeAttributes::Swap(TripLeg_ShapeAttributes* other) {
  if (other != this) {
    time_.Swap(&other->time_);
    length_.Swap(&other->length_);
    speed_.Swap(&other->speed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg_ShapeAttributes::GetTypeName() const {
  return "valhalla.TripLeg.ShapeAttributes";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TripLeg::kOsmChangesetFieldNumber;
const int TripLeg::kTripIdFieldNumber;
const int TripLeg::kLegIdFieldNumber;
const int TripLeg::kLegCountFieldNumber;
const int TripLeg::kLocationFieldNumber;
const int TripLeg::kNodeFieldNumber;
const int TripLeg::kAdminFieldNumber;
const int TripLeg::kShapeFieldNumber;
const int TripLeg::kBboxFieldNumber;
const int TripLeg::kShapeAttributesFieldNumber;
#endif  // !_MSC_VER

TripLeg::TripLeg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripLeg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bbox_ = const_cast< ::valhalla::BoundingBox*>(
      ::valhalla::BoundingBox::internal_default_instance());
#else
  bbox_ = const_cast< ::valhalla::BoundingBox*>(&::valhalla::BoundingBox::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  shape_attributes_ = const_cast< ::valhalla::TripLeg_ShapeAttributes*>(
      ::valhalla::TripLeg_ShapeAttributes::internal_default_instance());
#else
  shape_attributes_ = const_cast< ::valhalla::TripLeg_ShapeAttributes*>(&::valhalla::TripLeg_ShapeAttributes::default_instance());
#endif
}

TripLeg::TripLeg(const TripLeg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripLeg::SharedCtor() {
  _cached_size_ = 0;
  osm_changeset_ = GOOGLE_ULONGLONG(0);
  trip_id_ = GOOGLE_ULONGLONG(0);
  leg_id_ = 0u;
  leg_count_ = 0u;
  shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bbox_ = NULL;
  shape_attributes_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripLeg::~TripLeg() {
  SharedDtor();
}

void TripLeg::SharedDtor() {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    delete shape_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete bbox_;
    delete shape_attributes_;
  }
}

void TripLeg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripLeg& TripLeg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripLeg* TripLeg::default_instance_ = NULL;

TripLeg* TripLeg::New() const {
  return new TripLeg;
}

void TripLeg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    osm_changeset_ = GOOGLE_ULONGLONG(0);
    trip_id_ = GOOGLE_ULONGLONG(0);
    leg_id_ = 0u;
    leg_count_ = 0u;
    if (has_shape()) {
      if (shape_ != &::google::protobuf::internal::kEmptyString) {
        shape_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_bbox()) {
      if (bbox_ != NULL) bbox_->::valhalla::BoundingBox::Clear();
    }
    if (has_shape_attributes()) {
      if (shape_attributes_ != NULL) shape_attributes_->::valhalla::TripLeg_ShapeAttributes::Clear();
    }
  }
  location_.Clear();
  node_.Clear();
  admin_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripLeg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 osm_changeset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &osm_changeset_)));
          set_has_osm_changeset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_trip_id;
        break;
      }

      // optional uint64 trip_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trip_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &trip_id_)));
          set_has_trip_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_leg_id;
        break;
      }

      // optional uint32 leg_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leg_id_)));
          set_has_leg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_leg_count;
        break;
      }

      // optional uint32 leg_count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leg_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leg_count_)));
          set_has_leg_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_location;
        break;
      }

      // repeated .valhalla.Location location = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_location()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_location;
        if (input->ExpectTag(50)) goto parse_node;
        break;
      }

      // repeated .valhalla.TripLeg.Node node = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_node;
        if (input->ExpectTag(58)) goto parse_admin;
        break;
      }

      // repeated .valhalla.TripLeg.Admin admin = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_admin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_admin()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_admin;
        if (input->ExpectTag(66)) goto parse_shape;
        break;
      }

      // optional string shape = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_shape()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_bbox;
        break;
      }

      // optional .valhalla.BoundingBox bbox = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bbox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bbox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_shape_attributes;
        break;
      }

      // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shape_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shape_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripLeg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 osm_changeset = 1;
  if (has_osm_changeset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->osm_changeset(), output);
  }

  // optional uint64 trip_id = 2;
  if (has_trip_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->trip_id(), output);
  }

  // optional uint32 leg_id = 3;
  if (has_leg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->leg_id(), output);
  }

  // optional uint32 leg_count = 4;
  if (has_leg_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->leg_count(), output);
  }

  // repeated .valhalla.Location location = 5;
  for (int i = 0; i < this->location_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->location(i), output);
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  for (int i = 0; i < this->node_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->node(i), output);
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  for (int i = 0; i < this->admin_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->admin(i), output);
  }

  // optional string shape = 8;
  if (has_shape()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->shape(), output);
  }

  // optional .valhalla.BoundingBox bbox = 9;
  if (has_bbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->bbox(), output);
  }

  // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  if (has_shape_attributes()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->shape_attributes(), output);
  }

}

int TripLeg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 osm_changeset = 1;
    if (has_osm_changeset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->osm_changeset());
    }

    // optional uint64 trip_id = 2;
    if (has_trip_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->trip_id());
    }

    // optional uint32 leg_id = 3;
    if (has_leg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leg_id());
    }

    // optional uint32 leg_count = 4;
    if (has_leg_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leg_count());
    }

    // optional string shape = 8;
    if (has_shape()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->shape());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .valhalla.BoundingBox bbox = 9;
    if (has_bbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bbox());
    }

    // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
    if (has_shape_attributes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shape_attributes());
    }

  }
  // repeated .valhalla.Location location = 5;
  total_size += 1 * this->location_size();
  for (int i = 0; i < this->location_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->location(i));
  }

  // repeated .valhalla.TripLeg.Node node = 6;
  total_size += 1 * this->node_size();
  for (int i = 0; i < this->node_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->node(i));
  }

  // repeated .valhalla.TripLeg.Admin admin = 7;
  total_size += 1 * this->admin_size();
  for (int i = 0; i < this->admin_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->admin(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripLeg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripLeg*>(&from));
}

void TripLeg::MergeFrom(const TripLeg& from) {
  GOOGLE_CHECK_NE(&from, this);
  location_.MergeFrom(from.location_);
  node_.MergeFrom(from.node_);
  admin_.MergeFrom(from.admin_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_osm_changeset()) {
      set_osm_changeset(from.osm_changeset());
    }
    if (from.has_trip_id()) {
      set_trip_id(from.trip_id());
    }
    if (from.has_leg_id()) {
      set_leg_id(from.leg_id());
    }
    if (from.has_leg_count()) {
      set_leg_count(from.leg_count());
    }
    if (from.has_shape()) {
      set_shape(from.shape());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_bbox()) {
      mutable_bbox()->::valhalla::BoundingBox::MergeFrom(from.bbox());
    }
    if (from.has_shape_attributes()) {
      mutable_shape_attributes()->::valhalla::TripLeg_ShapeAttributes::MergeFrom(from.shape_attributes());
    }
  }
}

void TripLeg::CopyFrom(const TripLeg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripLeg::IsInitialized() const {

  return true;
}

void TripLeg::Swap(TripLeg* other) {
  if (other != this) {
    std::swap(osm_changeset_, other->osm_changeset_);
    std::swap(trip_id_, other->trip_id_);
    std::swap(leg_id_, other->leg_id_);
    std::swap(leg_count_, other->leg_count_);
    location_.Swap(&other->location_);
    node_.Swap(&other->node_);
    admin_.Swap(&other->admin_);
    std::swap(shape_, other->shape_);
    std::swap(bbox_, other->bbox_);
    std::swap(shape_attributes_, other->shape_attributes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripLeg::GetTypeName() const {
  return "valhalla.TripLeg";
}


// ===================================================================

#ifndef _MSC_VER
const int TripRoute::kLegsFieldNumber;
#endif  // !_MSC_VER

TripRoute::TripRoute()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TripRoute::InitAsDefaultInstance() {
}

TripRoute::TripRoute(const TripRoute& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TripRoute::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TripRoute::~TripRoute() {
  SharedDtor();
}

void TripRoute::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TripRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TripRoute& TripRoute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

TripRoute* TripRoute::default_instance_ = NULL;

TripRoute* TripRoute::New() const {
  return new TripRoute;
}

void TripRoute::Clear() {
  legs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TripRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.TripLeg legs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_legs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_legs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_legs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TripRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.TripLeg legs = 1;
  for (int i = 0; i < this->legs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->legs(i), output);
  }

}

int TripRoute::ByteSize() const {
  int total_size = 0;

  // repeated .valhalla.TripLeg legs = 1;
  total_size += 1 * this->legs_size();
  for (int i = 0; i < this->legs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->legs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TripRoute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TripRoute*>(&from));
}

void TripRoute::MergeFrom(const TripRoute& from) {
  GOOGLE_CHECK_NE(&from, this);
  legs_.MergeFrom(from.legs_);
}

void TripRoute::CopyFrom(const TripRoute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripRoute::IsInitialized() const {

  return true;
}

void TripRoute::Swap(TripRoute* other) {
  if (other != this) {
    legs_.Swap(&other->legs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TripRoute::GetTypeName() const {
  return "valhalla.TripRoute";
}


// ===================================================================

#ifndef _MSC_VER
const int Trip::kRoutesFieldNumber;
#endif  // !_MSC_VER

Trip::Trip()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Trip::InitAsDefaultInstance() {
}

Trip::Trip(const Trip& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Trip::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Trip::~Trip() {
  SharedDtor();
}

void Trip::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Trip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Trip& Trip::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_trip_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_trip_2eproto();
#endif
  return *default_instance_;
}

Trip* Trip::default_instance_ = NULL;

Trip* Trip::New() const {
  return new Trip;
}

void Trip::Clear() {
  routes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Trip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.TripRoute routes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_routes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_routes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_routes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Trip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.TripRoute routes = 1;
  for (int i = 0; i < this->routes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->routes(i), output);
  }

}

int Trip::ByteSize() const {
  int total_size = 0;

  // repeated .valhalla.TripRoute routes = 1;
  total_size += 1 * this->routes_size();
  for (int i = 0; i < this->routes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->routes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Trip::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Trip*>(&from));
}

void Trip::MergeFrom(const Trip& from) {
  GOOGLE_CHECK_NE(&from, this);
  routes_.MergeFrom(from.routes_);
}

void Trip::CopyFrom(const Trip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trip::IsInitialized() const {

  return true;
}

void Trip::Swap(Trip* other) {
  if (other != this) {
    routes_.Swap(&other->routes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Trip::GetTypeName() const {
  return "valhalla.Trip";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)
