// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "directions.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

void protobuf_ShutdownFile_directions_2eproto() {
  delete DirectionsLeg::default_instance_;
  delete DirectionsLeg_Summary::default_instance_;
  delete DirectionsLeg_TransitInfo::default_instance_;
  delete DirectionsLeg_Maneuver::default_instance_;
  delete DirectionsLeg_Maneuver_SignElement::default_instance_;
  delete DirectionsLeg_Maneuver_Sign::default_instance_;
  delete DirectionsRoute::default_instance_;
  delete Directions::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_directions_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_directions_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::valhalla::protobuf_AddDesc_tripcommon_2eproto();
  DirectionsLeg::default_instance_ = new DirectionsLeg();
  DirectionsLeg_Summary::default_instance_ = new DirectionsLeg_Summary();
  DirectionsLeg_TransitInfo::default_instance_ = new DirectionsLeg_TransitInfo();
  DirectionsLeg_Maneuver::default_instance_ = new DirectionsLeg_Maneuver();
  DirectionsLeg_Maneuver_SignElement::default_instance_ = new DirectionsLeg_Maneuver_SignElement();
  DirectionsLeg_Maneuver_Sign::default_instance_ = new DirectionsLeg_Maneuver_Sign();
  DirectionsRoute::default_instance_ = new DirectionsRoute();
  Directions::default_instance_ = new Directions();
  DirectionsLeg::default_instance_->InitAsDefaultInstance();
  DirectionsLeg_Summary::default_instance_->InitAsDefaultInstance();
  DirectionsLeg_TransitInfo::default_instance_->InitAsDefaultInstance();
  DirectionsLeg_Maneuver::default_instance_->InitAsDefaultInstance();
  DirectionsLeg_Maneuver_SignElement::default_instance_->InitAsDefaultInstance();
  DirectionsLeg_Maneuver_Sign::default_instance_->InitAsDefaultInstance();
  DirectionsRoute::default_instance_->InitAsDefaultInstance();
  Directions::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_directions_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_directions_2eproto_once_);
void protobuf_AddDesc_directions_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_directions_2eproto_once_,
                 &protobuf_AddDesc_directions_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_directions_2eproto {
  StaticDescriptorInitializer_directions_2eproto() {
    protobuf_AddDesc_directions_2eproto();
  }
} static_descriptor_initializer_directions_2eproto_;
#endif

// ===================================================================

bool DirectionsLeg_TravelMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_TravelMode DirectionsLeg::kDrive;
const DirectionsLeg_TravelMode DirectionsLeg::kPedestrian;
const DirectionsLeg_TravelMode DirectionsLeg::kBicycle;
const DirectionsLeg_TravelMode DirectionsLeg::kTransit;
const DirectionsLeg_TravelMode DirectionsLeg::TravelMode_MIN;
const DirectionsLeg_TravelMode DirectionsLeg::TravelMode_MAX;
const int DirectionsLeg::TravelMode_ARRAYSIZE;
#endif  // _MSC_VER
bool DirectionsLeg_VehicleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_VehicleType DirectionsLeg::kCar;
const DirectionsLeg_VehicleType DirectionsLeg::kMotorcycle;
const DirectionsLeg_VehicleType DirectionsLeg::kAutoBus;
const DirectionsLeg_VehicleType DirectionsLeg::kTractorTrailer;
const DirectionsLeg_VehicleType DirectionsLeg::kMotorScooter;
const DirectionsLeg_VehicleType DirectionsLeg::VehicleType_MIN;
const DirectionsLeg_VehicleType DirectionsLeg::VehicleType_MAX;
const int DirectionsLeg::VehicleType_ARRAYSIZE;
#endif  // _MSC_VER
bool DirectionsLeg_PedestrianType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_PedestrianType DirectionsLeg::kFoot;
const DirectionsLeg_PedestrianType DirectionsLeg::kWheelchair;
const DirectionsLeg_PedestrianType DirectionsLeg::kSegway;
const DirectionsLeg_PedestrianType DirectionsLeg::PedestrianType_MIN;
const DirectionsLeg_PedestrianType DirectionsLeg::PedestrianType_MAX;
const int DirectionsLeg::PedestrianType_ARRAYSIZE;
#endif  // _MSC_VER
bool DirectionsLeg_BicycleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_BicycleType DirectionsLeg::kRoad;
const DirectionsLeg_BicycleType DirectionsLeg::kCross;
const DirectionsLeg_BicycleType DirectionsLeg::kHybrid;
const DirectionsLeg_BicycleType DirectionsLeg::kMountain;
const DirectionsLeg_BicycleType DirectionsLeg::BicycleType_MIN;
const DirectionsLeg_BicycleType DirectionsLeg::BicycleType_MAX;
const int DirectionsLeg::BicycleType_ARRAYSIZE;
#endif  // _MSC_VER
bool DirectionsLeg_TransitType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_TransitType DirectionsLeg::kTram;
const DirectionsLeg_TransitType DirectionsLeg::kMetro;
const DirectionsLeg_TransitType DirectionsLeg::kRail;
const DirectionsLeg_TransitType DirectionsLeg::kBus;
const DirectionsLeg_TransitType DirectionsLeg::kFerry;
const DirectionsLeg_TransitType DirectionsLeg::kCableCar;
const DirectionsLeg_TransitType DirectionsLeg::kGondola;
const DirectionsLeg_TransitType DirectionsLeg::kFunicular;
const DirectionsLeg_TransitType DirectionsLeg::TransitType_MIN;
const DirectionsLeg_TransitType DirectionsLeg::TransitType_MAX;
const int DirectionsLeg::TransitType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DirectionsLeg_Summary::kLengthFieldNumber;
const int DirectionsLeg_Summary::kTimeFieldNumber;
const int DirectionsLeg_Summary::kBboxFieldNumber;
const int DirectionsLeg_Summary::kHasTimeRestrictionsFieldNumber;
#endif  // !_MSC_VER

DirectionsLeg_Summary::DirectionsLeg_Summary()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsLeg_Summary::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bbox_ = const_cast< ::valhalla::BoundingBox*>(
      ::valhalla::BoundingBox::internal_default_instance());
#else
  bbox_ = const_cast< ::valhalla::BoundingBox*>(&::valhalla::BoundingBox::default_instance());
#endif
}

DirectionsLeg_Summary::DirectionsLeg_Summary(const DirectionsLeg_Summary& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsLeg_Summary::SharedCtor() {
  _cached_size_ = 0;
  length_ = 0;
  time_ = 0u;
  bbox_ = NULL;
  has_time_restrictions_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsLeg_Summary::~DirectionsLeg_Summary() {
  SharedDtor();
}

void DirectionsLeg_Summary::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete bbox_;
  }
}

void DirectionsLeg_Summary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsLeg_Summary& DirectionsLeg_Summary::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsLeg_Summary* DirectionsLeg_Summary::default_instance_ = NULL;

DirectionsLeg_Summary* DirectionsLeg_Summary::New() const {
  return new DirectionsLeg_Summary;
}

void DirectionsLeg_Summary::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    length_ = 0;
    time_ = 0u;
    if (has_bbox()) {
      if (bbox_ != NULL) bbox_->::valhalla::BoundingBox::Clear();
    }
    has_time_restrictions_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsLeg_Summary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float length = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // optional uint32 time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bbox;
        break;
      }

      // optional .valhalla.BoundingBox bbox = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bbox:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bbox()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_has_time_restrictions;
        break;
      }

      // optional bool has_time_restrictions = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_time_restrictions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_time_restrictions_)));
          set_has_has_time_restrictions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsLeg_Summary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float length = 1;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->length(), output);
  }

  // optional uint32 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  // optional .valhalla.BoundingBox bbox = 3;
  if (has_bbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->bbox(), output);
  }

  // optional bool has_time_restrictions = 4;
  if (has_has_time_restrictions()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->has_time_restrictions(), output);
  }

}

int DirectionsLeg_Summary::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float length = 1;
    if (has_length()) {
      total_size += 1 + 4;
    }

    // optional uint32 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // optional .valhalla.BoundingBox bbox = 3;
    if (has_bbox()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bbox());
    }

    // optional bool has_time_restrictions = 4;
    if (has_has_time_restrictions()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsLeg_Summary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsLeg_Summary*>(&from));
}

void DirectionsLeg_Summary::MergeFrom(const DirectionsLeg_Summary& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_bbox()) {
      mutable_bbox()->::valhalla::BoundingBox::MergeFrom(from.bbox());
    }
    if (from.has_has_time_restrictions()) {
      set_has_time_restrictions(from.has_time_restrictions());
    }
  }
}

void DirectionsLeg_Summary::CopyFrom(const DirectionsLeg_Summary& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsLeg_Summary::IsInitialized() const {

  return true;
}

void DirectionsLeg_Summary::Swap(DirectionsLeg_Summary* other) {
  if (other != this) {
    std::swap(length_, other->length_);
    std::swap(time_, other->time_);
    std::swap(bbox_, other->bbox_);
    std::swap(has_time_restrictions_, other->has_time_restrictions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsLeg_Summary::GetTypeName() const {
  return "valhalla.DirectionsLeg.Summary";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int DirectionsLeg_TransitInfo::kOnestopIdFieldNumber;
const int DirectionsLeg_TransitInfo::kShortNameFieldNumber;
const int DirectionsLeg_TransitInfo::kLongNameFieldNumber;
const int DirectionsLeg_TransitInfo::kHeadsignFieldNumber;
const int DirectionsLeg_TransitInfo::kColorFieldNumber;
const int DirectionsLeg_TransitInfo::kTextColorFieldNumber;
const int DirectionsLeg_TransitInfo::kDescriptionFieldNumber;
const int DirectionsLeg_TransitInfo::kOperatorOnestopIdFieldNumber;
const int DirectionsLeg_TransitInfo::kOperatorNameFieldNumber;
const int DirectionsLeg_TransitInfo::kOperatorUrlFieldNumber;
const int DirectionsLeg_TransitInfo::kTransitStopsFieldNumber;
#endif  // !_MSC_VER

DirectionsLeg_TransitInfo::DirectionsLeg_TransitInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsLeg_TransitInfo::InitAsDefaultInstance() {
}

DirectionsLeg_TransitInfo::DirectionsLeg_TransitInfo(const DirectionsLeg_TransitInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsLeg_TransitInfo::SharedCtor() {
  _cached_size_ = 0;
  onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  color_ = 0u;
  text_color_ = 0u;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsLeg_TransitInfo::~DirectionsLeg_TransitInfo() {
  SharedDtor();
}

void DirectionsLeg_TransitInfo::SharedDtor() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    delete short_name_;
  }
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    delete long_name_;
  }
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    delete headsign_;
  }
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_onestop_id_;
  }
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_name_;
  }
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_url_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DirectionsLeg_TransitInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsLeg_TransitInfo& DirectionsLeg_TransitInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsLeg_TransitInfo* DirectionsLeg_TransitInfo::default_instance_ = NULL;

DirectionsLeg_TransitInfo* DirectionsLeg_TransitInfo::New() const {
  return new DirectionsLeg_TransitInfo;
}

void DirectionsLeg_TransitInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_onestop_id()) {
      if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
        onestop_id_->clear();
      }
    }
    if (has_short_name()) {
      if (short_name_ != &::google::protobuf::internal::kEmptyString) {
        short_name_->clear();
      }
    }
    if (has_long_name()) {
      if (long_name_ != &::google::protobuf::internal::kEmptyString) {
        long_name_->clear();
      }
    }
    if (has_headsign()) {
      if (headsign_ != &::google::protobuf::internal::kEmptyString) {
        headsign_->clear();
      }
    }
    color_ = 0u;
    text_color_ = 0u;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::kEmptyString) {
        description_->clear();
      }
    }
    if (has_operator_onestop_id()) {
      if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
        operator_onestop_id_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_operator_name()) {
      if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
        operator_name_->clear();
      }
    }
    if (has_operator_url()) {
      if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
        operator_url_->clear();
      }
    }
  }
  transit_stops_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsLeg_TransitInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string onestop_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_onestop_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_short_name;
        break;
      }

      // optional string short_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_short_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_short_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_long_name;
        break;
      }

      // optional string long_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_long_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_long_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_headsign;
        break;
      }

      // optional string headsign = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_headsign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_headsign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_color;
        break;
      }

      // optional uint32 color = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_text_color;
        break;
      }

      // optional uint32 text_color = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_text_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &text_color_)));
          set_has_text_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_description;
        break;
      }

      // optional string description = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_operator_onestop_id;
        break;
      }

      // optional string operator_onestop_id = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operator_onestop_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_onestop_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_operator_name;
        break;
      }

      // optional string operator_name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operator_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_operator_url;
        break;
      }

      // optional string operator_url = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_operator_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_url()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_transit_stops;
        break;
      }

      // repeated .valhalla.TransitPlatformInfo transit_stops = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transit_stops:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transit_stops()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_transit_stops;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsLeg_TransitInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string onestop_id = 1;
  if (has_onestop_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->onestop_id(), output);
  }

  // optional string short_name = 2;
  if (has_short_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->short_name(), output);
  }

  // optional string long_name = 3;
  if (has_long_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->long_name(), output);
  }

  // optional string headsign = 4;
  if (has_headsign()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->headsign(), output);
  }

  // optional uint32 color = 5;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->color(), output);
  }

  // optional uint32 text_color = 6;
  if (has_text_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->text_color(), output);
  }

  // optional string description = 7;
  if (has_description()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->description(), output);
  }

  // optional string operator_onestop_id = 8;
  if (has_operator_onestop_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->operator_onestop_id(), output);
  }

  // optional string operator_name = 9;
  if (has_operator_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->operator_name(), output);
  }

  // optional string operator_url = 10;
  if (has_operator_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->operator_url(), output);
  }

  // repeated .valhalla.TransitPlatformInfo transit_stops = 11;
  for (int i = 0; i < this->transit_stops_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->transit_stops(i), output);
  }

}

int DirectionsLeg_TransitInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string onestop_id = 1;
    if (has_onestop_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->onestop_id());
    }

    // optional string short_name = 2;
    if (has_short_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->short_name());
    }

    // optional string long_name = 3;
    if (has_long_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->long_name());
    }

    // optional string headsign = 4;
    if (has_headsign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->headsign());
    }

    // optional uint32 color = 5;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->color());
    }

    // optional uint32 text_color = 6;
    if (has_text_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->text_color());
    }

    // optional string description = 7;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional string operator_onestop_id = 8;
    if (has_operator_onestop_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_onestop_id());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string operator_name = 9;
    if (has_operator_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_name());
    }

    // optional string operator_url = 10;
    if (has_operator_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_url());
    }

  }
  // repeated .valhalla.TransitPlatformInfo transit_stops = 11;
  total_size += 1 * this->transit_stops_size();
  for (int i = 0; i < this->transit_stops_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transit_stops(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsLeg_TransitInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsLeg_TransitInfo*>(&from));
}

void DirectionsLeg_TransitInfo::MergeFrom(const DirectionsLeg_TransitInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  transit_stops_.MergeFrom(from.transit_stops_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_onestop_id()) {
      set_onestop_id(from.onestop_id());
    }
    if (from.has_short_name()) {
      set_short_name(from.short_name());
    }
    if (from.has_long_name()) {
      set_long_name(from.long_name());
    }
    if (from.has_headsign()) {
      set_headsign(from.headsign());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_text_color()) {
      set_text_color(from.text_color());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
    if (from.has_operator_onestop_id()) {
      set_operator_onestop_id(from.operator_onestop_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_operator_name()) {
      set_operator_name(from.operator_name());
    }
    if (from.has_operator_url()) {
      set_operator_url(from.operator_url());
    }
  }
}

void DirectionsLeg_TransitInfo::CopyFrom(const DirectionsLeg_TransitInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsLeg_TransitInfo::IsInitialized() const {

  return true;
}

void DirectionsLeg_TransitInfo::Swap(DirectionsLeg_TransitInfo* other) {
  if (other != this) {
    std::swap(onestop_id_, other->onestop_id_);
    std::swap(short_name_, other->short_name_);
    std::swap(long_name_, other->long_name_);
    std::swap(headsign_, other->headsign_);
    std::swap(color_, other->color_);
    std::swap(text_color_, other->text_color_);
    std::swap(description_, other->description_);
    std::swap(operator_onestop_id_, other->operator_onestop_id_);
    std::swap(operator_name_, other->operator_name_);
    std::swap(operator_url_, other->operator_url_);
    transit_stops_.Swap(&other->transit_stops_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsLeg_TransitInfo::GetTypeName() const {
  return "valhalla.DirectionsLeg.TransitInfo";
}


// -------------------------------------------------------------------

bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kNorth;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kNorthEast;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kEast;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kSouthEast;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kSouth;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kSouthWest;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kWest;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::kNorthWest;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::CardinalDirection_MIN;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::CardinalDirection_MAX;
const int DirectionsLeg_Maneuver::CardinalDirection_ARRAYSIZE;
#endif  // _MSC_VER
bool DirectionsLeg_Maneuver_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kNone;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kStart;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kStartRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kStartLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kDestination;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kDestinationRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kDestinationLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kBecomes;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kContinue;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kSlightRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kSharpRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kUturnRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kUturnLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kSharpLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kSlightLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kRampStraight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kRampRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kRampLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kExitRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kExitLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kStayStraight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kStayRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kStayLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kMerge;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kRoundaboutEnter;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kRoundaboutExit;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kFerryEnter;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kFerryExit;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kTransit;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kTransitTransfer;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kTransitRemainOn;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kTransitConnectionStart;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kTransitConnectionTransfer;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kTransitConnectionDestination;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kPostTransitConnectionDestination;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kMergeRight;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::kMergeLeft;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::Type_MIN;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::Type_MAX;
const int DirectionsLeg_Maneuver::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DirectionsLeg_Maneuver_SignElement::kTextFieldNumber;
const int DirectionsLeg_Maneuver_SignElement::kIsRouteNumberFieldNumber;
const int DirectionsLeg_Maneuver_SignElement::kConsecutiveCountFieldNumber;
#endif  // !_MSC_VER

DirectionsLeg_Maneuver_SignElement::DirectionsLeg_Maneuver_SignElement()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsLeg_Maneuver_SignElement::InitAsDefaultInstance() {
}

DirectionsLeg_Maneuver_SignElement::DirectionsLeg_Maneuver_SignElement(const DirectionsLeg_Maneuver_SignElement& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsLeg_Maneuver_SignElement::SharedCtor() {
  _cached_size_ = 0;
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  is_route_number_ = false;
  consecutive_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsLeg_Maneuver_SignElement::~DirectionsLeg_Maneuver_SignElement() {
  SharedDtor();
}

void DirectionsLeg_Maneuver_SignElement::SharedDtor() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DirectionsLeg_Maneuver_SignElement::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_SignElement::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_SignElement::default_instance_ = NULL;

DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_SignElement::New() const {
  return new DirectionsLeg_Maneuver_SignElement;
}

void DirectionsLeg_Maneuver_SignElement::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
    is_route_number_ = false;
    consecutive_count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsLeg_Maneuver_SignElement::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_is_route_number;
        break;
      }

      // optional bool is_route_number = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_route_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_route_number_)));
          set_has_is_route_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_consecutive_count;
        break;
      }

      // optional uint32 consecutive_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_consecutive_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &consecutive_count_)));
          set_has_consecutive_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsLeg_Maneuver_SignElement::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string text = 1;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->text(), output);
  }

  // optional bool is_route_number = 2;
  if (has_is_route_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_route_number(), output);
  }

  // optional uint32 consecutive_count = 3;
  if (has_consecutive_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->consecutive_count(), output);
  }

}

int DirectionsLeg_Maneuver_SignElement::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string text = 1;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional bool is_route_number = 2;
    if (has_is_route_number()) {
      total_size += 1 + 1;
    }

    // optional uint32 consecutive_count = 3;
    if (has_consecutive_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->consecutive_count());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsLeg_Maneuver_SignElement::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsLeg_Maneuver_SignElement*>(&from));
}

void DirectionsLeg_Maneuver_SignElement::MergeFrom(const DirectionsLeg_Maneuver_SignElement& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_text()) {
      set_text(from.text());
    }
    if (from.has_is_route_number()) {
      set_is_route_number(from.is_route_number());
    }
    if (from.has_consecutive_count()) {
      set_consecutive_count(from.consecutive_count());
    }
  }
}

void DirectionsLeg_Maneuver_SignElement::CopyFrom(const DirectionsLeg_Maneuver_SignElement& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsLeg_Maneuver_SignElement::IsInitialized() const {

  return true;
}

void DirectionsLeg_Maneuver_SignElement::Swap(DirectionsLeg_Maneuver_SignElement* other) {
  if (other != this) {
    std::swap(text_, other->text_);
    std::swap(is_route_number_, other->is_route_number_);
    std::swap(consecutive_count_, other->consecutive_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsLeg_Maneuver_SignElement::GetTypeName() const {
  return "valhalla.DirectionsLeg.Maneuver.SignElement";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int DirectionsLeg_Maneuver_Sign::kExitNumbersFieldNumber;
const int DirectionsLeg_Maneuver_Sign::kExitOntoStreetsFieldNumber;
const int DirectionsLeg_Maneuver_Sign::kExitTowardLocationsFieldNumber;
const int DirectionsLeg_Maneuver_Sign::kExitNamesFieldNumber;
#endif  // !_MSC_VER

DirectionsLeg_Maneuver_Sign::DirectionsLeg_Maneuver_Sign()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsLeg_Maneuver_Sign::InitAsDefaultInstance() {
}

DirectionsLeg_Maneuver_Sign::DirectionsLeg_Maneuver_Sign(const DirectionsLeg_Maneuver_Sign& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsLeg_Maneuver_Sign::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsLeg_Maneuver_Sign::~DirectionsLeg_Maneuver_Sign() {
  SharedDtor();
}

void DirectionsLeg_Maneuver_Sign::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DirectionsLeg_Maneuver_Sign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsLeg_Maneuver_Sign& DirectionsLeg_Maneuver_Sign::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver_Sign::default_instance_ = NULL;

DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver_Sign::New() const {
  return new DirectionsLeg_Maneuver_Sign;
}

void DirectionsLeg_Maneuver_Sign::Clear() {
  exit_numbers_.Clear();
  exit_onto_streets_.Clear();
  exit_toward_locations_.Clear();
  exit_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsLeg_Maneuver_Sign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_numbers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_numbers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_exit_numbers;
        if (input->ExpectTag(18)) goto parse_exit_onto_streets;
        break;
      }

      // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_onto_streets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_onto_streets()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_exit_onto_streets;
        if (input->ExpectTag(26)) goto parse_exit_toward_locations;
        break;
      }

      // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_toward_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_toward_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_exit_toward_locations;
        if (input->ExpectTag(34)) goto parse_exit_names;
        break;
      }

      // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exit_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_exit_names()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_exit_names;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsLeg_Maneuver_Sign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
  for (int i = 0; i < this->exit_numbers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->exit_numbers(i), output);
  }

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
  for (int i = 0; i < this->exit_onto_streets_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->exit_onto_streets(i), output);
  }

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
  for (int i = 0; i < this->exit_toward_locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->exit_toward_locations(i), output);
  }

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
  for (int i = 0; i < this->exit_names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->exit_names(i), output);
  }

}

int DirectionsLeg_Maneuver_Sign::ByteSize() const {
  int total_size = 0;

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
  total_size += 1 * this->exit_numbers_size();
  for (int i = 0; i < this->exit_numbers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_numbers(i));
  }

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
  total_size += 1 * this->exit_onto_streets_size();
  for (int i = 0; i < this->exit_onto_streets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_onto_streets(i));
  }

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
  total_size += 1 * this->exit_toward_locations_size();
  for (int i = 0; i < this->exit_toward_locations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_toward_locations(i));
  }

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
  total_size += 1 * this->exit_names_size();
  for (int i = 0; i < this->exit_names_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->exit_names(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsLeg_Maneuver_Sign::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsLeg_Maneuver_Sign*>(&from));
}

void DirectionsLeg_Maneuver_Sign::MergeFrom(const DirectionsLeg_Maneuver_Sign& from) {
  GOOGLE_CHECK_NE(&from, this);
  exit_numbers_.MergeFrom(from.exit_numbers_);
  exit_onto_streets_.MergeFrom(from.exit_onto_streets_);
  exit_toward_locations_.MergeFrom(from.exit_toward_locations_);
  exit_names_.MergeFrom(from.exit_names_);
}

void DirectionsLeg_Maneuver_Sign::CopyFrom(const DirectionsLeg_Maneuver_Sign& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsLeg_Maneuver_Sign::IsInitialized() const {

  return true;
}

void DirectionsLeg_Maneuver_Sign::Swap(DirectionsLeg_Maneuver_Sign* other) {
  if (other != this) {
    exit_numbers_.Swap(&other->exit_numbers_);
    exit_onto_streets_.Swap(&other->exit_onto_streets_);
    exit_toward_locations_.Swap(&other->exit_toward_locations_);
    exit_names_.Swap(&other->exit_names_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsLeg_Maneuver_Sign::GetTypeName() const {
  return "valhalla.DirectionsLeg.Maneuver.Sign";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int DirectionsLeg_Maneuver::kTypeFieldNumber;
const int DirectionsLeg_Maneuver::kTextInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kStreetNameFieldNumber;
const int DirectionsLeg_Maneuver::kLengthFieldNumber;
const int DirectionsLeg_Maneuver::kTimeFieldNumber;
const int DirectionsLeg_Maneuver::kBeginCardinalDirectionFieldNumber;
const int DirectionsLeg_Maneuver::kBeginHeadingFieldNumber;
const int DirectionsLeg_Maneuver::kBeginShapeIndexFieldNumber;
const int DirectionsLeg_Maneuver::kEndShapeIndexFieldNumber;
const int DirectionsLeg_Maneuver::kPortionsTollFieldNumber;
const int DirectionsLeg_Maneuver::kPortionsUnpavedFieldNumber;
const int DirectionsLeg_Maneuver::kVerbalTransitionAlertInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kVerbalPreTransitionInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kVerbalPostTransitionInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kBeginStreetNameFieldNumber;
const int DirectionsLeg_Maneuver::kSignFieldNumber;
const int DirectionsLeg_Maneuver::kRoundaboutExitCountFieldNumber;
const int DirectionsLeg_Maneuver::kDepartInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kVerbalDepartInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kArriveInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kVerbalArriveInstructionFieldNumber;
const int DirectionsLeg_Maneuver::kTransitInfoFieldNumber;
const int DirectionsLeg_Maneuver::kVerbalMultiCueFieldNumber;
const int DirectionsLeg_Maneuver::kTravelModeFieldNumber;
const int DirectionsLeg_Maneuver::kVehicleTypeFieldNumber;
const int DirectionsLeg_Maneuver::kPedestrianTypeFieldNumber;
const int DirectionsLeg_Maneuver::kBicycleTypeFieldNumber;
const int DirectionsLeg_Maneuver::kTransitTypeFieldNumber;
const int DirectionsLeg_Maneuver::kBeginPathIndexFieldNumber;
const int DirectionsLeg_Maneuver::kEndPathIndexFieldNumber;
const int DirectionsLeg_Maneuver::kToStayOnFieldNumber;
const int DirectionsLeg_Maneuver::kRoundaboutExitStreetNamesFieldNumber;
const int DirectionsLeg_Maneuver::kTurnDegreeFieldNumber;
const int DirectionsLeg_Maneuver::kHasTimeRestrictionsFieldNumber;
#endif  // !_MSC_VER

DirectionsLeg_Maneuver::DirectionsLeg_Maneuver()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsLeg_Maneuver::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sign_ = const_cast< ::valhalla::DirectionsLeg_Maneuver_Sign*>(
      ::valhalla::DirectionsLeg_Maneuver_Sign::internal_default_instance());
#else
  sign_ = const_cast< ::valhalla::DirectionsLeg_Maneuver_Sign*>(&::valhalla::DirectionsLeg_Maneuver_Sign::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  transit_info_ = const_cast< ::valhalla::DirectionsLeg_TransitInfo*>(
      ::valhalla::DirectionsLeg_TransitInfo::internal_default_instance());
#else
  transit_info_ = const_cast< ::valhalla::DirectionsLeg_TransitInfo*>(&::valhalla::DirectionsLeg_TransitInfo::default_instance());
#endif
}

DirectionsLeg_Maneuver::DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsLeg_Maneuver::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  length_ = 0;
  time_ = 0u;
  begin_cardinal_direction_ = 0;
  begin_heading_ = 0u;
  begin_shape_index_ = 0u;
  end_shape_index_ = 0u;
  portions_toll_ = false;
  portions_unpaved_ = false;
  verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sign_ = NULL;
  roundabout_exit_count_ = 0u;
  depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  verbal_depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  verbal_arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transit_info_ = NULL;
  verbal_multi_cue_ = false;
  travel_mode_ = 0;
  vehicle_type_ = 0;
  pedestrian_type_ = 0;
  bicycle_type_ = 0;
  transit_type_ = 0;
  begin_path_index_ = 0u;
  end_path_index_ = 0u;
  to_stay_on_ = false;
  turn_degree_ = 0u;
  has_time_restrictions_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsLeg_Maneuver::~DirectionsLeg_Maneuver() {
  SharedDtor();
}

void DirectionsLeg_Maneuver::SharedDtor() {
  if (text_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete text_instruction_;
  }
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_transition_alert_instruction_;
  }
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_pre_transition_instruction_;
  }
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_post_transition_instruction_;
  }
  if (depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete depart_instruction_;
  }
  if (verbal_depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_depart_instruction_;
  }
  if (arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete arrive_instruction_;
  }
  if (verbal_arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_arrive_instruction_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete sign_;
    delete transit_info_;
  }
}

void DirectionsLeg_Maneuver::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsLeg_Maneuver& DirectionsLeg_Maneuver::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsLeg_Maneuver* DirectionsLeg_Maneuver::default_instance_ = NULL;

DirectionsLeg_Maneuver* DirectionsLeg_Maneuver::New() const {
  return new DirectionsLeg_Maneuver;
}

void DirectionsLeg_Maneuver::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_text_instruction()) {
      if (text_instruction_ != &::google::protobuf::internal::kEmptyString) {
        text_instruction_->clear();
      }
    }
    length_ = 0;
    time_ = 0u;
    begin_cardinal_direction_ = 0;
    begin_heading_ = 0u;
    begin_shape_index_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    end_shape_index_ = 0u;
    portions_toll_ = false;
    portions_unpaved_ = false;
    if (has_verbal_transition_alert_instruction()) {
      if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::kEmptyString) {
        verbal_transition_alert_instruction_->clear();
      }
    }
    if (has_verbal_pre_transition_instruction()) {
      if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
        verbal_pre_transition_instruction_->clear();
      }
    }
    if (has_verbal_post_transition_instruction()) {
      if (verbal_post_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
        verbal_post_transition_instruction_->clear();
      }
    }
    if (has_sign()) {
      if (sign_ != NULL) sign_->::valhalla::DirectionsLeg_Maneuver_Sign::Clear();
    }
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    roundabout_exit_count_ = 0u;
    if (has_depart_instruction()) {
      if (depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
        depart_instruction_->clear();
      }
    }
    if (has_verbal_depart_instruction()) {
      if (verbal_depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
        verbal_depart_instruction_->clear();
      }
    }
    if (has_arrive_instruction()) {
      if (arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
        arrive_instruction_->clear();
      }
    }
    if (has_verbal_arrive_instruction()) {
      if (verbal_arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
        verbal_arrive_instruction_->clear();
      }
    }
    if (has_transit_info()) {
      if (transit_info_ != NULL) transit_info_->::valhalla::DirectionsLeg_TransitInfo::Clear();
    }
    verbal_multi_cue_ = false;
    travel_mode_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    vehicle_type_ = 0;
    pedestrian_type_ = 0;
    bicycle_type_ = 0;
    transit_type_ = 0;
    begin_path_index_ = 0u;
    end_path_index_ = 0u;
    to_stay_on_ = false;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    turn_degree_ = 0u;
    has_time_restrictions_ = false;
  }
  street_name_.Clear();
  begin_street_name_.Clear();
  roundabout_exit_street_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsLeg_Maneuver::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_Maneuver_Type_IsValid(value)) {
            set_type(static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_text_instruction;
        break;
      }

      // optional string text_instruction = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_street_name;
        break;
      }

      // repeated .valhalla.StreetName street_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_street_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_street_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_street_name;
        if (input->ExpectTag(37)) goto parse_length;
        break;
      }

      // optional float length = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_time;
        break;
      }

      // optional uint32 time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_begin_cardinal_direction;
        break;
      }

      // optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_cardinal_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_Maneuver_CardinalDirection_IsValid(value)) {
            set_begin_cardinal_direction(static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_begin_heading;
        break;
      }

      // optional uint32 begin_heading = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_heading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_heading_)));
          set_has_begin_heading();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_begin_shape_index;
        break;
      }

      // optional uint32 begin_shape_index = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_shape_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_shape_index_)));
          set_has_begin_shape_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_end_shape_index;
        break;
      }

      // optional uint32 end_shape_index = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_shape_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_shape_index_)));
          set_has_end_shape_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_portions_toll;
        break;
      }

      // optional bool portions_toll = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_portions_toll:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &portions_toll_)));
          set_has_portions_toll();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_portions_unpaved;
        break;
      }

      // optional bool portions_unpaved = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_portions_unpaved:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &portions_unpaved_)));
          set_has_portions_unpaved();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_verbal_transition_alert_instruction;
        break;
      }

      // optional string verbal_transition_alert_instruction = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_verbal_transition_alert_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_verbal_transition_alert_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_verbal_pre_transition_instruction;
        break;
      }

      // optional string verbal_pre_transition_instruction = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_verbal_pre_transition_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_verbal_pre_transition_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_verbal_post_transition_instruction;
        break;
      }

      // optional string verbal_post_transition_instruction = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_verbal_post_transition_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_verbal_post_transition_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_begin_street_name;
        break;
      }

      // repeated .valhalla.StreetName begin_street_name = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_begin_street_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_begin_street_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_begin_street_name;
        if (input->ExpectTag(130)) goto parse_sign;
        break;
      }

      // optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sign()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(136)) goto parse_roundabout_exit_count;
        break;
      }

      // optional uint32 roundabout_exit_count = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roundabout_exit_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &roundabout_exit_count_)));
          set_has_roundabout_exit_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(146)) goto parse_depart_instruction;
        break;
      }

      // optional string depart_instruction = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_depart_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_depart_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_verbal_depart_instruction;
        break;
      }

      // optional string verbal_depart_instruction = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_verbal_depart_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_verbal_depart_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_arrive_instruction;
        break;
      }

      // optional string arrive_instruction = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_arrive_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_arrive_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(170)) goto parse_verbal_arrive_instruction;
        break;
      }

      // optional string verbal_arrive_instruction = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_verbal_arrive_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_verbal_arrive_instruction()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_transit_info;
        break;
      }

      // optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transit_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transit_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(184)) goto parse_verbal_multi_cue;
        break;
      }

      // optional bool verbal_multi_cue = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_verbal_multi_cue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &verbal_multi_cue_)));
          set_has_verbal_multi_cue();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(192)) goto parse_travel_mode;
        break;
      }

      // optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_travel_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_TravelMode_IsValid(value)) {
            set_travel_mode(static_cast< ::valhalla::DirectionsLeg_TravelMode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(200)) goto parse_vehicle_type;
        break;
      }

      // optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vehicle_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_VehicleType_IsValid(value)) {
            set_vehicle_type(static_cast< ::valhalla::DirectionsLeg_VehicleType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_pedestrian_type;
        break;
      }

      // optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pedestrian_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_PedestrianType_IsValid(value)) {
            set_pedestrian_type(static_cast< ::valhalla::DirectionsLeg_PedestrianType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(216)) goto parse_bicycle_type;
        break;
      }

      // optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bicycle_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_BicycleType_IsValid(value)) {
            set_bicycle_type(static_cast< ::valhalla::DirectionsLeg_BicycleType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(224)) goto parse_transit_type;
        break;
      }

      // optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transit_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsLeg_TransitType_IsValid(value)) {
            set_transit_type(static_cast< ::valhalla::DirectionsLeg_TransitType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(232)) goto parse_begin_path_index;
        break;
      }

      // optional uint32 begin_path_index = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_begin_path_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &begin_path_index_)));
          set_has_begin_path_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(240)) goto parse_end_path_index;
        break;
      }

      // optional uint32 end_path_index = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_path_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_path_index_)));
          set_has_end_path_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(248)) goto parse_to_stay_on;
        break;
      }

      // optional bool to_stay_on = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_to_stay_on:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &to_stay_on_)));
          set_has_to_stay_on();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(258)) goto parse_roundabout_exit_street_names;
        break;
      }

      // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roundabout_exit_street_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_roundabout_exit_street_names()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(258)) goto parse_roundabout_exit_street_names;
        if (input->ExpectTag(264)) goto parse_turn_degree;
        break;
      }

      // optional uint32 turn_degree = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_turn_degree:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &turn_degree_)));
          set_has_turn_degree();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(272)) goto parse_has_time_restrictions;
        break;
      }

      // optional bool has_time_restrictions = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_time_restrictions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_time_restrictions_)));
          set_has_has_time_restrictions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsLeg_Maneuver::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string text_instruction = 2;
  if (has_text_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->text_instruction(), output);
  }

  // repeated .valhalla.StreetName street_name = 3;
  for (int i = 0; i < this->street_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->street_name(i), output);
  }

  // optional float length = 4;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->length(), output);
  }

  // optional uint32 time = 5;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->time(), output);
  }

  // optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  if (has_begin_cardinal_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->begin_cardinal_direction(), output);
  }

  // optional uint32 begin_heading = 7;
  if (has_begin_heading()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->begin_heading(), output);
  }

  // optional uint32 begin_shape_index = 8;
  if (has_begin_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->begin_shape_index(), output);
  }

  // optional uint32 end_shape_index = 9;
  if (has_end_shape_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->end_shape_index(), output);
  }

  // optional bool portions_toll = 10;
  if (has_portions_toll()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->portions_toll(), output);
  }

  // optional bool portions_unpaved = 11;
  if (has_portions_unpaved()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->portions_unpaved(), output);
  }

  // optional string verbal_transition_alert_instruction = 12;
  if (has_verbal_transition_alert_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->verbal_transition_alert_instruction(), output);
  }

  // optional string verbal_pre_transition_instruction = 13;
  if (has_verbal_pre_transition_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->verbal_pre_transition_instruction(), output);
  }

  // optional string verbal_post_transition_instruction = 14;
  if (has_verbal_post_transition_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      14, this->verbal_post_transition_instruction(), output);
  }

  // repeated .valhalla.StreetName begin_street_name = 15;
  for (int i = 0; i < this->begin_street_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->begin_street_name(i), output);
  }

  // optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
  if (has_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      16, this->sign(), output);
  }

  // optional uint32 roundabout_exit_count = 17;
  if (has_roundabout_exit_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(17, this->roundabout_exit_count(), output);
  }

  // optional string depart_instruction = 18;
  if (has_depart_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->depart_instruction(), output);
  }

  // optional string verbal_depart_instruction = 19;
  if (has_verbal_depart_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->verbal_depart_instruction(), output);
  }

  // optional string arrive_instruction = 20;
  if (has_arrive_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->arrive_instruction(), output);
  }

  // optional string verbal_arrive_instruction = 21;
  if (has_verbal_arrive_instruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      21, this->verbal_arrive_instruction(), output);
  }

  // optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
  if (has_transit_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      22, this->transit_info(), output);
  }

  // optional bool verbal_multi_cue = 23;
  if (has_verbal_multi_cue()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->verbal_multi_cue(), output);
  }

  // optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
  if (has_travel_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      24, this->travel_mode(), output);
  }

  // optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      25, this->vehicle_type(), output);
  }

  // optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
  if (has_pedestrian_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      26, this->pedestrian_type(), output);
  }

  // optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
  if (has_bicycle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      27, this->bicycle_type(), output);
  }

  // optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
  if (has_transit_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      28, this->transit_type(), output);
  }

  // optional uint32 begin_path_index = 29;
  if (has_begin_path_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(29, this->begin_path_index(), output);
  }

  // optional uint32 end_path_index = 30;
  if (has_end_path_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(30, this->end_path_index(), output);
  }

  // optional bool to_stay_on = 31;
  if (has_to_stay_on()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(31, this->to_stay_on(), output);
  }

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  for (int i = 0; i < this->roundabout_exit_street_names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      32, this->roundabout_exit_street_names(i), output);
  }

  // optional uint32 turn_degree = 33;
  if (has_turn_degree()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(33, this->turn_degree(), output);
  }

  // optional bool has_time_restrictions = 34;
  if (has_has_time_restrictions()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(34, this->has_time_restrictions(), output);
  }

}

int DirectionsLeg_Maneuver::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string text_instruction = 2;
    if (has_text_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text_instruction());
    }

    // optional float length = 4;
    if (has_length()) {
      total_size += 1 + 4;
    }

    // optional uint32 time = 5;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
    if (has_begin_cardinal_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->begin_cardinal_direction());
    }

    // optional uint32 begin_heading = 7;
    if (has_begin_heading()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_heading());
    }

    // optional uint32 begin_shape_index = 8;
    if (has_begin_shape_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_shape_index());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 end_shape_index = 9;
    if (has_end_shape_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_shape_index());
    }

    // optional bool portions_toll = 10;
    if (has_portions_toll()) {
      total_size += 1 + 1;
    }

    // optional bool portions_unpaved = 11;
    if (has_portions_unpaved()) {
      total_size += 1 + 1;
    }

    // optional string verbal_transition_alert_instruction = 12;
    if (has_verbal_transition_alert_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->verbal_transition_alert_instruction());
    }

    // optional string verbal_pre_transition_instruction = 13;
    if (has_verbal_pre_transition_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->verbal_pre_transition_instruction());
    }

    // optional string verbal_post_transition_instruction = 14;
    if (has_verbal_post_transition_instruction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->verbal_post_transition_instruction());
    }

    // optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
    if (has_sign()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sign());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint32 roundabout_exit_count = 17;
    if (has_roundabout_exit_count()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->roundabout_exit_count());
    }

    // optional string depart_instruction = 18;
    if (has_depart_instruction()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->depart_instruction());
    }

    // optional string verbal_depart_instruction = 19;
    if (has_verbal_depart_instruction()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->verbal_depart_instruction());
    }

    // optional string arrive_instruction = 20;
    if (has_arrive_instruction()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->arrive_instruction());
    }

    // optional string verbal_arrive_instruction = 21;
    if (has_verbal_arrive_instruction()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->verbal_arrive_instruction());
    }

    // optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
    if (has_transit_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transit_info());
    }

    // optional bool verbal_multi_cue = 23;
    if (has_verbal_multi_cue()) {
      total_size += 2 + 1;
    }

    // optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
    if (has_travel_mode()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->travel_mode());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
    if (has_vehicle_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->vehicle_type());
    }

    // optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
    if (has_pedestrian_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->pedestrian_type());
    }

    // optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
    if (has_bicycle_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->bicycle_type());
    }

    // optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
    if (has_transit_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->transit_type());
    }

    // optional uint32 begin_path_index = 29;
    if (has_begin_path_index()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->begin_path_index());
    }

    // optional uint32 end_path_index = 30;
    if (has_end_path_index()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_path_index());
    }

    // optional bool to_stay_on = 31;
    if (has_to_stay_on()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional uint32 turn_degree = 33;
    if (has_turn_degree()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->turn_degree());
    }

    // optional bool has_time_restrictions = 34;
    if (has_has_time_restrictions()) {
      total_size += 2 + 1;
    }

  }
  // repeated .valhalla.StreetName street_name = 3;
  total_size += 1 * this->street_name_size();
  for (int i = 0; i < this->street_name_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->street_name(i));
  }

  // repeated .valhalla.StreetName begin_street_name = 15;
  total_size += 1 * this->begin_street_name_size();
  for (int i = 0; i < this->begin_street_name_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->begin_street_name(i));
  }

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  total_size += 2 * this->roundabout_exit_street_names_size();
  for (int i = 0; i < this->roundabout_exit_street_names_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->roundabout_exit_street_names(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsLeg_Maneuver::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsLeg_Maneuver*>(&from));
}

void DirectionsLeg_Maneuver::MergeFrom(const DirectionsLeg_Maneuver& from) {
  GOOGLE_CHECK_NE(&from, this);
  street_name_.MergeFrom(from.street_name_);
  begin_street_name_.MergeFrom(from.begin_street_name_);
  roundabout_exit_street_names_.MergeFrom(from.roundabout_exit_street_names_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_text_instruction()) {
      set_text_instruction(from.text_instruction());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_begin_cardinal_direction()) {
      set_begin_cardinal_direction(from.begin_cardinal_direction());
    }
    if (from.has_begin_heading()) {
      set_begin_heading(from.begin_heading());
    }
    if (from.has_begin_shape_index()) {
      set_begin_shape_index(from.begin_shape_index());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_end_shape_index()) {
      set_end_shape_index(from.end_shape_index());
    }
    if (from.has_portions_toll()) {
      set_portions_toll(from.portions_toll());
    }
    if (from.has_portions_unpaved()) {
      set_portions_unpaved(from.portions_unpaved());
    }
    if (from.has_verbal_transition_alert_instruction()) {
      set_verbal_transition_alert_instruction(from.verbal_transition_alert_instruction());
    }
    if (from.has_verbal_pre_transition_instruction()) {
      set_verbal_pre_transition_instruction(from.verbal_pre_transition_instruction());
    }
    if (from.has_verbal_post_transition_instruction()) {
      set_verbal_post_transition_instruction(from.verbal_post_transition_instruction());
    }
    if (from.has_sign()) {
      mutable_sign()->::valhalla::DirectionsLeg_Maneuver_Sign::MergeFrom(from.sign());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_roundabout_exit_count()) {
      set_roundabout_exit_count(from.roundabout_exit_count());
    }
    if (from.has_depart_instruction()) {
      set_depart_instruction(from.depart_instruction());
    }
    if (from.has_verbal_depart_instruction()) {
      set_verbal_depart_instruction(from.verbal_depart_instruction());
    }
    if (from.has_arrive_instruction()) {
      set_arrive_instruction(from.arrive_instruction());
    }
    if (from.has_verbal_arrive_instruction()) {
      set_verbal_arrive_instruction(from.verbal_arrive_instruction());
    }
    if (from.has_transit_info()) {
      mutable_transit_info()->::valhalla::DirectionsLeg_TransitInfo::MergeFrom(from.transit_info());
    }
    if (from.has_verbal_multi_cue()) {
      set_verbal_multi_cue(from.verbal_multi_cue());
    }
    if (from.has_travel_mode()) {
      set_travel_mode(from.travel_mode());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_vehicle_type()) {
      set_vehicle_type(from.vehicle_type());
    }
    if (from.has_pedestrian_type()) {
      set_pedestrian_type(from.pedestrian_type());
    }
    if (from.has_bicycle_type()) {
      set_bicycle_type(from.bicycle_type());
    }
    if (from.has_transit_type()) {
      set_transit_type(from.transit_type());
    }
    if (from.has_begin_path_index()) {
      set_begin_path_index(from.begin_path_index());
    }
    if (from.has_end_path_index()) {
      set_end_path_index(from.end_path_index());
    }
    if (from.has_to_stay_on()) {
      set_to_stay_on(from.to_stay_on());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_turn_degree()) {
      set_turn_degree(from.turn_degree());
    }
    if (from.has_has_time_restrictions()) {
      set_has_time_restrictions(from.has_time_restrictions());
    }
  }
}

void DirectionsLeg_Maneuver::CopyFrom(const DirectionsLeg_Maneuver& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsLeg_Maneuver::IsInitialized() const {

  return true;
}

void DirectionsLeg_Maneuver::Swap(DirectionsLeg_Maneuver* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(text_instruction_, other->text_instruction_);
    street_name_.Swap(&other->street_name_);
    std::swap(length_, other->length_);
    std::swap(time_, other->time_);
    std::swap(begin_cardinal_direction_, other->begin_cardinal_direction_);
    std::swap(begin_heading_, other->begin_heading_);
    std::swap(begin_shape_index_, other->begin_shape_index_);
    std::swap(end_shape_index_, other->end_shape_index_);
    std::swap(portions_toll_, other->portions_toll_);
    std::swap(portions_unpaved_, other->portions_unpaved_);
    std::swap(verbal_transition_alert_instruction_, other->verbal_transition_alert_instruction_);
    std::swap(verbal_pre_transition_instruction_, other->verbal_pre_transition_instruction_);
    std::swap(verbal_post_transition_instruction_, other->verbal_post_transition_instruction_);
    begin_street_name_.Swap(&other->begin_street_name_);
    std::swap(sign_, other->sign_);
    std::swap(roundabout_exit_count_, other->roundabout_exit_count_);
    std::swap(depart_instruction_, other->depart_instruction_);
    std::swap(verbal_depart_instruction_, other->verbal_depart_instruction_);
    std::swap(arrive_instruction_, other->arrive_instruction_);
    std::swap(verbal_arrive_instruction_, other->verbal_arrive_instruction_);
    std::swap(transit_info_, other->transit_info_);
    std::swap(verbal_multi_cue_, other->verbal_multi_cue_);
    std::swap(travel_mode_, other->travel_mode_);
    std::swap(vehicle_type_, other->vehicle_type_);
    std::swap(pedestrian_type_, other->pedestrian_type_);
    std::swap(bicycle_type_, other->bicycle_type_);
    std::swap(transit_type_, other->transit_type_);
    std::swap(begin_path_index_, other->begin_path_index_);
    std::swap(end_path_index_, other->end_path_index_);
    std::swap(to_stay_on_, other->to_stay_on_);
    roundabout_exit_street_names_.Swap(&other->roundabout_exit_street_names_);
    std::swap(turn_degree_, other->turn_degree_);
    std::swap(has_time_restrictions_, other->has_time_restrictions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsLeg_Maneuver::GetTypeName() const {
  return "valhalla.DirectionsLeg.Maneuver";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int DirectionsLeg::kTripIdFieldNumber;
const int DirectionsLeg::kLegIdFieldNumber;
const int DirectionsLeg::kLegCountFieldNumber;
const int DirectionsLeg::kLocationFieldNumber;
const int DirectionsLeg::kSummaryFieldNumber;
const int DirectionsLeg::kManeuverFieldNumber;
const int DirectionsLeg::kShapeFieldNumber;
#endif  // !_MSC_VER

DirectionsLeg::DirectionsLeg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsLeg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  summary_ = const_cast< ::valhalla::DirectionsLeg_Summary*>(
      ::valhalla::DirectionsLeg_Summary::internal_default_instance());
#else
  summary_ = const_cast< ::valhalla::DirectionsLeg_Summary*>(&::valhalla::DirectionsLeg_Summary::default_instance());
#endif
}

DirectionsLeg::DirectionsLeg(const DirectionsLeg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsLeg::SharedCtor() {
  _cached_size_ = 0;
  trip_id_ = GOOGLE_ULONGLONG(0);
  leg_id_ = 0u;
  leg_count_ = 0u;
  summary_ = NULL;
  shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsLeg::~DirectionsLeg() {
  SharedDtor();
}

void DirectionsLeg::SharedDtor() {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    delete shape_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete summary_;
  }
}

void DirectionsLeg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsLeg& DirectionsLeg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsLeg* DirectionsLeg::default_instance_ = NULL;

DirectionsLeg* DirectionsLeg::New() const {
  return new DirectionsLeg;
}

void DirectionsLeg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    trip_id_ = GOOGLE_ULONGLONG(0);
    leg_id_ = 0u;
    leg_count_ = 0u;
    if (has_summary()) {
      if (summary_ != NULL) summary_->::valhalla::DirectionsLeg_Summary::Clear();
    }
    if (has_shape()) {
      if (shape_ != &::google::protobuf::internal::kEmptyString) {
        shape_->clear();
      }
    }
  }
  location_.Clear();
  maneuver_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsLeg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 trip_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &trip_id_)));
          set_has_trip_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_leg_id;
        break;
      }

      // optional uint32 leg_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leg_id_)));
          set_has_leg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_leg_count;
        break;
      }

      // optional uint32 leg_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_leg_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &leg_count_)));
          set_has_leg_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // repeated .valhalla.Location location = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_location()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_location;
        if (input->ExpectTag(42)) goto parse_summary;
        break;
      }

      // optional .valhalla.DirectionsLeg.Summary summary = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_summary:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_summary()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_maneuver;
        break;
      }

      // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_maneuver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_maneuver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_maneuver;
        if (input->ExpectTag(58)) goto parse_shape;
        break;
      }

      // optional string shape = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_shape()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsLeg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 trip_id = 1;
  if (has_trip_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->trip_id(), output);
  }

  // optional uint32 leg_id = 2;
  if (has_leg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->leg_id(), output);
  }

  // optional uint32 leg_count = 3;
  if (has_leg_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->leg_count(), output);
  }

  // repeated .valhalla.Location location = 4;
  for (int i = 0; i < this->location_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->location(i), output);
  }

  // optional .valhalla.DirectionsLeg.Summary summary = 5;
  if (has_summary()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->summary(), output);
  }

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  for (int i = 0; i < this->maneuver_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->maneuver(i), output);
  }

  // optional string shape = 7;
  if (has_shape()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->shape(), output);
  }

}

int DirectionsLeg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 trip_id = 1;
    if (has_trip_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->trip_id());
    }

    // optional uint32 leg_id = 2;
    if (has_leg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leg_id());
    }

    // optional uint32 leg_count = 3;
    if (has_leg_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->leg_count());
    }

    // optional .valhalla.DirectionsLeg.Summary summary = 5;
    if (has_summary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->summary());
    }

    // optional string shape = 7;
    if (has_shape()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->shape());
    }

  }
  // repeated .valhalla.Location location = 4;
  total_size += 1 * this->location_size();
  for (int i = 0; i < this->location_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->location(i));
  }

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  total_size += 1 * this->maneuver_size();
  for (int i = 0; i < this->maneuver_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->maneuver(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsLeg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsLeg*>(&from));
}

void DirectionsLeg::MergeFrom(const DirectionsLeg& from) {
  GOOGLE_CHECK_NE(&from, this);
  location_.MergeFrom(from.location_);
  maneuver_.MergeFrom(from.maneuver_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trip_id()) {
      set_trip_id(from.trip_id());
    }
    if (from.has_leg_id()) {
      set_leg_id(from.leg_id());
    }
    if (from.has_leg_count()) {
      set_leg_count(from.leg_count());
    }
    if (from.has_summary()) {
      mutable_summary()->::valhalla::DirectionsLeg_Summary::MergeFrom(from.summary());
    }
    if (from.has_shape()) {
      set_shape(from.shape());
    }
  }
}

void DirectionsLeg::CopyFrom(const DirectionsLeg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsLeg::IsInitialized() const {

  return true;
}

void DirectionsLeg::Swap(DirectionsLeg* other) {
  if (other != this) {
    std::swap(trip_id_, other->trip_id_);
    std::swap(leg_id_, other->leg_id_);
    std::swap(leg_count_, other->leg_count_);
    location_.Swap(&other->location_);
    std::swap(summary_, other->summary_);
    maneuver_.Swap(&other->maneuver_);
    std::swap(shape_, other->shape_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsLeg::GetTypeName() const {
  return "valhalla.DirectionsLeg";
}


// ===================================================================

#ifndef _MSC_VER
const int DirectionsRoute::kLegsFieldNumber;
#endif  // !_MSC_VER

DirectionsRoute::DirectionsRoute()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DirectionsRoute::InitAsDefaultInstance() {
}

DirectionsRoute::DirectionsRoute(const DirectionsRoute& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DirectionsRoute::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectionsRoute::~DirectionsRoute() {
  SharedDtor();
}

void DirectionsRoute::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DirectionsRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DirectionsRoute& DirectionsRoute::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

DirectionsRoute* DirectionsRoute::default_instance_ = NULL;

DirectionsRoute* DirectionsRoute::New() const {
  return new DirectionsRoute;
}

void DirectionsRoute::Clear() {
  legs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DirectionsRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.DirectionsLeg legs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_legs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_legs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_legs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectionsRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.DirectionsLeg legs = 1;
  for (int i = 0; i < this->legs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->legs(i), output);
  }

}

int DirectionsRoute::ByteSize() const {
  int total_size = 0;

  // repeated .valhalla.DirectionsLeg legs = 1;
  total_size += 1 * this->legs_size();
  for (int i = 0; i < this->legs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->legs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectionsRoute::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DirectionsRoute*>(&from));
}

void DirectionsRoute::MergeFrom(const DirectionsRoute& from) {
  GOOGLE_CHECK_NE(&from, this);
  legs_.MergeFrom(from.legs_);
}

void DirectionsRoute::CopyFrom(const DirectionsRoute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectionsRoute::IsInitialized() const {

  return true;
}

void DirectionsRoute::Swap(DirectionsRoute* other) {
  if (other != this) {
    legs_.Swap(&other->legs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DirectionsRoute::GetTypeName() const {
  return "valhalla.DirectionsRoute";
}


// ===================================================================

#ifndef _MSC_VER
const int Directions::kRoutesFieldNumber;
#endif  // !_MSC_VER

Directions::Directions()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Directions::InitAsDefaultInstance() {
}

Directions::Directions(const Directions& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Directions::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Directions::~Directions() {
  SharedDtor();
}

void Directions::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Directions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Directions& Directions::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_directions_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_directions_2eproto();
#endif
  return *default_instance_;
}

Directions* Directions::default_instance_ = NULL;

Directions* Directions::New() const {
  return new Directions;
}

void Directions::Clear() {
  routes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Directions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .valhalla.DirectionsRoute routes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_routes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_routes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_routes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Directions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .valhalla.DirectionsRoute routes = 1;
  for (int i = 0; i < this->routes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->routes(i), output);
  }

}

int Directions::ByteSize() const {
  int total_size = 0;

  // repeated .valhalla.DirectionsRoute routes = 1;
  total_size += 1 * this->routes_size();
  for (int i = 0; i < this->routes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->routes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Directions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Directions*>(&from));
}

void Directions::MergeFrom(const Directions& from) {
  GOOGLE_CHECK_NE(&from, this);
  routes_.MergeFrom(from.routes_);
}

void Directions::CopyFrom(const Directions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Directions::IsInitialized() const {

  return true;
}

void Directions::Swap(Directions* other) {
  if (other != this) {
    routes_.Swap(&other->routes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Directions::GetTypeName() const {
  return "valhalla.Directions";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)
