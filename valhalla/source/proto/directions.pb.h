// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: directions.proto

#ifndef PROTOBUF_directions_2eproto__INCLUDED
#define PROTOBUF_directions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "tripcommon.pb.h"
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_directions_2eproto();
void protobuf_AssignDesc_directions_2eproto();
void protobuf_ShutdownFile_directions_2eproto();

class DirectionsLeg;
class DirectionsLeg_Summary;
class DirectionsLeg_TransitInfo;
class DirectionsLeg_Maneuver;
class DirectionsLeg_Maneuver_SignElement;
class DirectionsLeg_Maneuver_Sign;
class DirectionsRoute;
class Directions;

enum DirectionsLeg_Maneuver_CardinalDirection {
  DirectionsLeg_Maneuver_CardinalDirection_kNorth = 0,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthEast = 1,
  DirectionsLeg_Maneuver_CardinalDirection_kEast = 2,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthEast = 3,
  DirectionsLeg_Maneuver_CardinalDirection_kSouth = 4,
  DirectionsLeg_Maneuver_CardinalDirection_kSouthWest = 5,
  DirectionsLeg_Maneuver_CardinalDirection_kWest = 6,
  DirectionsLeg_Maneuver_CardinalDirection_kNorthWest = 7
};
bool DirectionsLeg_Maneuver_CardinalDirection_IsValid(int value);
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
const DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
const int DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX + 1;

enum DirectionsLeg_Maneuver_Type {
  DirectionsLeg_Maneuver_Type_kNone = 0,
  DirectionsLeg_Maneuver_Type_kStart = 1,
  DirectionsLeg_Maneuver_Type_kStartRight = 2,
  DirectionsLeg_Maneuver_Type_kStartLeft = 3,
  DirectionsLeg_Maneuver_Type_kDestination = 4,
  DirectionsLeg_Maneuver_Type_kDestinationRight = 5,
  DirectionsLeg_Maneuver_Type_kDestinationLeft = 6,
  DirectionsLeg_Maneuver_Type_kBecomes = 7,
  DirectionsLeg_Maneuver_Type_kContinue = 8,
  DirectionsLeg_Maneuver_Type_kSlightRight = 9,
  DirectionsLeg_Maneuver_Type_kRight = 10,
  DirectionsLeg_Maneuver_Type_kSharpRight = 11,
  DirectionsLeg_Maneuver_Type_kUturnRight = 12,
  DirectionsLeg_Maneuver_Type_kUturnLeft = 13,
  DirectionsLeg_Maneuver_Type_kSharpLeft = 14,
  DirectionsLeg_Maneuver_Type_kLeft = 15,
  DirectionsLeg_Maneuver_Type_kSlightLeft = 16,
  DirectionsLeg_Maneuver_Type_kRampStraight = 17,
  DirectionsLeg_Maneuver_Type_kRampRight = 18,
  DirectionsLeg_Maneuver_Type_kRampLeft = 19,
  DirectionsLeg_Maneuver_Type_kExitRight = 20,
  DirectionsLeg_Maneuver_Type_kExitLeft = 21,
  DirectionsLeg_Maneuver_Type_kStayStraight = 22,
  DirectionsLeg_Maneuver_Type_kStayRight = 23,
  DirectionsLeg_Maneuver_Type_kStayLeft = 24,
  DirectionsLeg_Maneuver_Type_kMerge = 25,
  DirectionsLeg_Maneuver_Type_kRoundaboutEnter = 26,
  DirectionsLeg_Maneuver_Type_kRoundaboutExit = 27,
  DirectionsLeg_Maneuver_Type_kFerryEnter = 28,
  DirectionsLeg_Maneuver_Type_kFerryExit = 29,
  DirectionsLeg_Maneuver_Type_kTransit = 30,
  DirectionsLeg_Maneuver_Type_kTransitTransfer = 31,
  DirectionsLeg_Maneuver_Type_kTransitRemainOn = 32,
  DirectionsLeg_Maneuver_Type_kTransitConnectionStart = 33,
  DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer = 34,
  DirectionsLeg_Maneuver_Type_kTransitConnectionDestination = 35,
  DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination = 36,
  DirectionsLeg_Maneuver_Type_kMergeRight = 37,
  DirectionsLeg_Maneuver_Type_kMergeLeft = 38
};
bool DirectionsLeg_Maneuver_Type_IsValid(int value);
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MIN = DirectionsLeg_Maneuver_Type_kNone;
const DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver_Type_Type_MAX = DirectionsLeg_Maneuver_Type_kMergeLeft;
const int DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE = DirectionsLeg_Maneuver_Type_Type_MAX + 1;

enum DirectionsLeg_TravelMode {
  DirectionsLeg_TravelMode_kDrive = 0,
  DirectionsLeg_TravelMode_kPedestrian = 1,
  DirectionsLeg_TravelMode_kBicycle = 2,
  DirectionsLeg_TravelMode_kTransit = 3
};
bool DirectionsLeg_TravelMode_IsValid(int value);
const DirectionsLeg_TravelMode DirectionsLeg_TravelMode_TravelMode_MIN = DirectionsLeg_TravelMode_kDrive;
const DirectionsLeg_TravelMode DirectionsLeg_TravelMode_TravelMode_MAX = DirectionsLeg_TravelMode_kTransit;
const int DirectionsLeg_TravelMode_TravelMode_ARRAYSIZE = DirectionsLeg_TravelMode_TravelMode_MAX + 1;

enum DirectionsLeg_VehicleType {
  DirectionsLeg_VehicleType_kCar = 0,
  DirectionsLeg_VehicleType_kMotorcycle = 1,
  DirectionsLeg_VehicleType_kAutoBus = 2,
  DirectionsLeg_VehicleType_kTractorTrailer = 3,
  DirectionsLeg_VehicleType_kMotorScooter = 4
};
bool DirectionsLeg_VehicleType_IsValid(int value);
const DirectionsLeg_VehicleType DirectionsLeg_VehicleType_VehicleType_MIN = DirectionsLeg_VehicleType_kCar;
const DirectionsLeg_VehicleType DirectionsLeg_VehicleType_VehicleType_MAX = DirectionsLeg_VehicleType_kMotorScooter;
const int DirectionsLeg_VehicleType_VehicleType_ARRAYSIZE = DirectionsLeg_VehicleType_VehicleType_MAX + 1;

enum DirectionsLeg_PedestrianType {
  DirectionsLeg_PedestrianType_kFoot = 0,
  DirectionsLeg_PedestrianType_kWheelchair = 1,
  DirectionsLeg_PedestrianType_kSegway = 2
};
bool DirectionsLeg_PedestrianType_IsValid(int value);
const DirectionsLeg_PedestrianType DirectionsLeg_PedestrianType_PedestrianType_MIN = DirectionsLeg_PedestrianType_kFoot;
const DirectionsLeg_PedestrianType DirectionsLeg_PedestrianType_PedestrianType_MAX = DirectionsLeg_PedestrianType_kSegway;
const int DirectionsLeg_PedestrianType_PedestrianType_ARRAYSIZE = DirectionsLeg_PedestrianType_PedestrianType_MAX + 1;

enum DirectionsLeg_BicycleType {
  DirectionsLeg_BicycleType_kRoad = 0,
  DirectionsLeg_BicycleType_kCross = 1,
  DirectionsLeg_BicycleType_kHybrid = 2,
  DirectionsLeg_BicycleType_kMountain = 3
};
bool DirectionsLeg_BicycleType_IsValid(int value);
const DirectionsLeg_BicycleType DirectionsLeg_BicycleType_BicycleType_MIN = DirectionsLeg_BicycleType_kRoad;
const DirectionsLeg_BicycleType DirectionsLeg_BicycleType_BicycleType_MAX = DirectionsLeg_BicycleType_kMountain;
const int DirectionsLeg_BicycleType_BicycleType_ARRAYSIZE = DirectionsLeg_BicycleType_BicycleType_MAX + 1;

enum DirectionsLeg_TransitType {
  DirectionsLeg_TransitType_kTram = 0,
  DirectionsLeg_TransitType_kMetro = 1,
  DirectionsLeg_TransitType_kRail = 2,
  DirectionsLeg_TransitType_kBus = 3,
  DirectionsLeg_TransitType_kFerry = 4,
  DirectionsLeg_TransitType_kCableCar = 5,
  DirectionsLeg_TransitType_kGondola = 6,
  DirectionsLeg_TransitType_kFunicular = 7
};
bool DirectionsLeg_TransitType_IsValid(int value);
const DirectionsLeg_TransitType DirectionsLeg_TransitType_TransitType_MIN = DirectionsLeg_TransitType_kTram;
const DirectionsLeg_TransitType DirectionsLeg_TransitType_TransitType_MAX = DirectionsLeg_TransitType_kFunicular;
const int DirectionsLeg_TransitType_TransitType_ARRAYSIZE = DirectionsLeg_TransitType_TransitType_MAX + 1;

// ===================================================================

class DirectionsLeg_Summary : public ::google::protobuf::MessageLite {
 public:
  DirectionsLeg_Summary();
  virtual ~DirectionsLeg_Summary();

  DirectionsLeg_Summary(const DirectionsLeg_Summary& from);

  inline DirectionsLeg_Summary& operator=(const DirectionsLeg_Summary& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_Summary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_Summary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_Summary* other);

  // implements Message ----------------------------------------------

  DirectionsLeg_Summary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_Summary& from);
  void MergeFrom(const DirectionsLeg_Summary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline float length() const;
  inline void set_length(float value);

  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .valhalla.BoundingBox bbox = 3;
  inline bool has_bbox() const;
  inline void clear_bbox();
  static const int kBboxFieldNumber = 3;
  inline const ::valhalla::BoundingBox& bbox() const;
  inline ::valhalla::BoundingBox* mutable_bbox();
  inline ::valhalla::BoundingBox* release_bbox();
  inline void set_allocated_bbox(::valhalla::BoundingBox* bbox);

  // optional bool has_time_restrictions = 4;
  inline bool has_has_time_restrictions() const;
  inline void clear_has_time_restrictions();
  static const int kHasTimeRestrictionsFieldNumber = 4;
  inline bool has_time_restrictions() const;
  inline void set_has_time_restrictions(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Summary)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bbox();
  inline void clear_has_bbox();
  inline void set_has_has_time_restrictions();
  inline void clear_has_has_time_restrictions();

  float length_;
  ::google::protobuf::uint32 time_;
  ::valhalla::BoundingBox* bbox_;
  bool has_time_restrictions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_Summary* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg_TransitInfo : public ::google::protobuf::MessageLite {
 public:
  DirectionsLeg_TransitInfo();
  virtual ~DirectionsLeg_TransitInfo();

  DirectionsLeg_TransitInfo(const DirectionsLeg_TransitInfo& from);

  inline DirectionsLeg_TransitInfo& operator=(const DirectionsLeg_TransitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_TransitInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_TransitInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_TransitInfo* other);

  // implements Message ----------------------------------------------

  DirectionsLeg_TransitInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_TransitInfo& from);
  void MergeFrom(const DirectionsLeg_TransitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string onestop_id = 1;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 1;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string short_name = 2;
  inline bool has_short_name() const;
  inline void clear_short_name();
  static const int kShortNameFieldNumber = 2;
  inline const ::std::string& short_name() const;
  inline void set_short_name(const ::std::string& value);
  inline void set_short_name(const char* value);
  inline void set_short_name(const char* value, size_t size);
  inline ::std::string* mutable_short_name();
  inline ::std::string* release_short_name();
  inline void set_allocated_short_name(::std::string* short_name);

  // optional string long_name = 3;
  inline bool has_long_name() const;
  inline void clear_long_name();
  static const int kLongNameFieldNumber = 3;
  inline const ::std::string& long_name() const;
  inline void set_long_name(const ::std::string& value);
  inline void set_long_name(const char* value);
  inline void set_long_name(const char* value, size_t size);
  inline ::std::string* mutable_long_name();
  inline ::std::string* release_long_name();
  inline void set_allocated_long_name(::std::string* long_name);

  // optional string headsign = 4;
  inline bool has_headsign() const;
  inline void clear_headsign();
  static const int kHeadsignFieldNumber = 4;
  inline const ::std::string& headsign() const;
  inline void set_headsign(const ::std::string& value);
  inline void set_headsign(const char* value);
  inline void set_headsign(const char* value, size_t size);
  inline ::std::string* mutable_headsign();
  inline ::std::string* release_headsign();
  inline void set_allocated_headsign(::std::string* headsign);

  // optional uint32 color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 text_color = 6;
  inline bool has_text_color() const;
  inline void clear_text_color();
  static const int kTextColorFieldNumber = 6;
  inline ::google::protobuf::uint32 text_color() const;
  inline void set_text_color(::google::protobuf::uint32 value);

  // optional string description = 7;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 7;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string operator_onestop_id = 8;
  inline bool has_operator_onestop_id() const;
  inline void clear_operator_onestop_id();
  static const int kOperatorOnestopIdFieldNumber = 8;
  inline const ::std::string& operator_onestop_id() const;
  inline void set_operator_onestop_id(const ::std::string& value);
  inline void set_operator_onestop_id(const char* value);
  inline void set_operator_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_operator_onestop_id();
  inline ::std::string* release_operator_onestop_id();
  inline void set_allocated_operator_onestop_id(::std::string* operator_onestop_id);

  // optional string operator_name = 9;
  inline bool has_operator_name() const;
  inline void clear_operator_name();
  static const int kOperatorNameFieldNumber = 9;
  inline const ::std::string& operator_name() const;
  inline void set_operator_name(const ::std::string& value);
  inline void set_operator_name(const char* value);
  inline void set_operator_name(const char* value, size_t size);
  inline ::std::string* mutable_operator_name();
  inline ::std::string* release_operator_name();
  inline void set_allocated_operator_name(::std::string* operator_name);

  // optional string operator_url = 10;
  inline bool has_operator_url() const;
  inline void clear_operator_url();
  static const int kOperatorUrlFieldNumber = 10;
  inline const ::std::string& operator_url() const;
  inline void set_operator_url(const ::std::string& value);
  inline void set_operator_url(const char* value);
  inline void set_operator_url(const char* value, size_t size);
  inline ::std::string* mutable_operator_url();
  inline ::std::string* release_operator_url();
  inline void set_allocated_operator_url(::std::string* operator_url);

  // repeated .valhalla.TransitPlatformInfo transit_stops = 11;
  inline int transit_stops_size() const;
  inline void clear_transit_stops();
  static const int kTransitStopsFieldNumber = 11;
  inline const ::valhalla::TransitPlatformInfo& transit_stops(int index) const;
  inline ::valhalla::TransitPlatformInfo* mutable_transit_stops(int index);
  inline ::valhalla::TransitPlatformInfo* add_transit_stops();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo >&
      transit_stops() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo >*
      mutable_transit_stops();

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.TransitInfo)
 private:
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_short_name();
  inline void clear_has_short_name();
  inline void set_has_long_name();
  inline void clear_has_long_name();
  inline void set_has_headsign();
  inline void clear_has_headsign();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_text_color();
  inline void clear_has_text_color();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_operator_onestop_id();
  inline void clear_has_operator_onestop_id();
  inline void set_has_operator_name();
  inline void clear_has_operator_name();
  inline void set_has_operator_url();
  inline void clear_has_operator_url();

  ::std::string* onestop_id_;
  ::std::string* short_name_;
  ::std::string* long_name_;
  ::std::string* headsign_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 text_color_;
  ::std::string* description_;
  ::std::string* operator_onestop_id_;
  ::std::string* operator_name_;
  ::std::string* operator_url_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo > transit_stops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_TransitInfo* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver_SignElement : public ::google::protobuf::MessageLite {
 public:
  DirectionsLeg_Maneuver_SignElement();
  virtual ~DirectionsLeg_Maneuver_SignElement();

  DirectionsLeg_Maneuver_SignElement(const DirectionsLeg_Maneuver_SignElement& from);

  inline DirectionsLeg_Maneuver_SignElement& operator=(const DirectionsLeg_Maneuver_SignElement& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_Maneuver_SignElement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_Maneuver_SignElement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_Maneuver_SignElement* other);

  // implements Message ----------------------------------------------

  DirectionsLeg_Maneuver_SignElement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_Maneuver_SignElement& from);
  void MergeFrom(const DirectionsLeg_Maneuver_SignElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool is_route_number = 2;
  inline bool has_is_route_number() const;
  inline void clear_is_route_number();
  static const int kIsRouteNumberFieldNumber = 2;
  inline bool is_route_number() const;
  inline void set_is_route_number(bool value);

  // optional uint32 consecutive_count = 3;
  inline bool has_consecutive_count() const;
  inline void clear_consecutive_count();
  static const int kConsecutiveCountFieldNumber = 3;
  inline ::google::protobuf::uint32 consecutive_count() const;
  inline void set_consecutive_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver.SignElement)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_is_route_number();
  inline void clear_has_is_route_number();
  inline void set_has_consecutive_count();
  inline void clear_has_consecutive_count();

  ::std::string* text_;
  bool is_route_number_;
  ::google::protobuf::uint32 consecutive_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_Maneuver_SignElement* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver_Sign : public ::google::protobuf::MessageLite {
 public:
  DirectionsLeg_Maneuver_Sign();
  virtual ~DirectionsLeg_Maneuver_Sign();

  DirectionsLeg_Maneuver_Sign(const DirectionsLeg_Maneuver_Sign& from);

  inline DirectionsLeg_Maneuver_Sign& operator=(const DirectionsLeg_Maneuver_Sign& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_Maneuver_Sign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_Maneuver_Sign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_Maneuver_Sign* other);

  // implements Message ----------------------------------------------

  DirectionsLeg_Maneuver_Sign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_Maneuver_Sign& from);
  void MergeFrom(const DirectionsLeg_Maneuver_Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
  inline int exit_numbers_size() const;
  inline void clear_exit_numbers();
  static const int kExitNumbersFieldNumber = 1;
  inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_numbers(int index) const;
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_numbers(int index);
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_numbers();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_numbers() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_numbers();

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
  inline int exit_onto_streets_size() const;
  inline void clear_exit_onto_streets();
  static const int kExitOntoStreetsFieldNumber = 2;
  inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_onto_streets(int index) const;
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_onto_streets(int index);
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_onto_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_onto_streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_onto_streets();

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
  inline int exit_toward_locations_size() const;
  inline void clear_exit_toward_locations();
  static const int kExitTowardLocationsFieldNumber = 3;
  inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_toward_locations(int index) const;
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_toward_locations(int index);
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_toward_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_toward_locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_toward_locations();

  // repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
  inline int exit_names_size() const;
  inline void clear_exit_names();
  static const int kExitNamesFieldNumber = 4;
  inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& exit_names(int index) const;
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* mutable_exit_names(int index);
  inline ::valhalla::DirectionsLeg_Maneuver_SignElement* add_exit_names();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
      exit_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
      mutable_exit_names();

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver.Sign)
 private:

  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_numbers_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_onto_streets_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_toward_locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement > exit_names_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_Maneuver_Sign* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg_Maneuver : public ::google::protobuf::MessageLite {
 public:
  DirectionsLeg_Maneuver();
  virtual ~DirectionsLeg_Maneuver();

  DirectionsLeg_Maneuver(const DirectionsLeg_Maneuver& from);

  inline DirectionsLeg_Maneuver& operator=(const DirectionsLeg_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg_Maneuver& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg_Maneuver* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg_Maneuver* other);

  // implements Message ----------------------------------------------

  DirectionsLeg_Maneuver* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg_Maneuver& from);
  void MergeFrom(const DirectionsLeg_Maneuver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Maneuver_SignElement SignElement;
  typedef DirectionsLeg_Maneuver_Sign Sign;

  typedef DirectionsLeg_Maneuver_CardinalDirection CardinalDirection;
  static const CardinalDirection kNorth = DirectionsLeg_Maneuver_CardinalDirection_kNorth;
  static const CardinalDirection kNorthEast = DirectionsLeg_Maneuver_CardinalDirection_kNorthEast;
  static const CardinalDirection kEast = DirectionsLeg_Maneuver_CardinalDirection_kEast;
  static const CardinalDirection kSouthEast = DirectionsLeg_Maneuver_CardinalDirection_kSouthEast;
  static const CardinalDirection kSouth = DirectionsLeg_Maneuver_CardinalDirection_kSouth;
  static const CardinalDirection kSouthWest = DirectionsLeg_Maneuver_CardinalDirection_kSouthWest;
  static const CardinalDirection kWest = DirectionsLeg_Maneuver_CardinalDirection_kWest;
  static const CardinalDirection kNorthWest = DirectionsLeg_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return DirectionsLeg_Maneuver_CardinalDirection_IsValid(value);
  }
  static const CardinalDirection CardinalDirection_MIN =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static const CardinalDirection CardinalDirection_MAX =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static const int CardinalDirection_ARRAYSIZE =
    DirectionsLeg_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;

  typedef DirectionsLeg_Maneuver_Type Type;
  static const Type kNone = DirectionsLeg_Maneuver_Type_kNone;
  static const Type kStart = DirectionsLeg_Maneuver_Type_kStart;
  static const Type kStartRight = DirectionsLeg_Maneuver_Type_kStartRight;
  static const Type kStartLeft = DirectionsLeg_Maneuver_Type_kStartLeft;
  static const Type kDestination = DirectionsLeg_Maneuver_Type_kDestination;
  static const Type kDestinationRight = DirectionsLeg_Maneuver_Type_kDestinationRight;
  static const Type kDestinationLeft = DirectionsLeg_Maneuver_Type_kDestinationLeft;
  static const Type kBecomes = DirectionsLeg_Maneuver_Type_kBecomes;
  static const Type kContinue = DirectionsLeg_Maneuver_Type_kContinue;
  static const Type kSlightRight = DirectionsLeg_Maneuver_Type_kSlightRight;
  static const Type kRight = DirectionsLeg_Maneuver_Type_kRight;
  static const Type kSharpRight = DirectionsLeg_Maneuver_Type_kSharpRight;
  static const Type kUturnRight = DirectionsLeg_Maneuver_Type_kUturnRight;
  static const Type kUturnLeft = DirectionsLeg_Maneuver_Type_kUturnLeft;
  static const Type kSharpLeft = DirectionsLeg_Maneuver_Type_kSharpLeft;
  static const Type kLeft = DirectionsLeg_Maneuver_Type_kLeft;
  static const Type kSlightLeft = DirectionsLeg_Maneuver_Type_kSlightLeft;
  static const Type kRampStraight = DirectionsLeg_Maneuver_Type_kRampStraight;
  static const Type kRampRight = DirectionsLeg_Maneuver_Type_kRampRight;
  static const Type kRampLeft = DirectionsLeg_Maneuver_Type_kRampLeft;
  static const Type kExitRight = DirectionsLeg_Maneuver_Type_kExitRight;
  static const Type kExitLeft = DirectionsLeg_Maneuver_Type_kExitLeft;
  static const Type kStayStraight = DirectionsLeg_Maneuver_Type_kStayStraight;
  static const Type kStayRight = DirectionsLeg_Maneuver_Type_kStayRight;
  static const Type kStayLeft = DirectionsLeg_Maneuver_Type_kStayLeft;
  static const Type kMerge = DirectionsLeg_Maneuver_Type_kMerge;
  static const Type kRoundaboutEnter = DirectionsLeg_Maneuver_Type_kRoundaboutEnter;
  static const Type kRoundaboutExit = DirectionsLeg_Maneuver_Type_kRoundaboutExit;
  static const Type kFerryEnter = DirectionsLeg_Maneuver_Type_kFerryEnter;
  static const Type kFerryExit = DirectionsLeg_Maneuver_Type_kFerryExit;
  static const Type kTransit = DirectionsLeg_Maneuver_Type_kTransit;
  static const Type kTransitTransfer = DirectionsLeg_Maneuver_Type_kTransitTransfer;
  static const Type kTransitRemainOn = DirectionsLeg_Maneuver_Type_kTransitRemainOn;
  static const Type kTransitConnectionStart = DirectionsLeg_Maneuver_Type_kTransitConnectionStart;
  static const Type kTransitConnectionTransfer = DirectionsLeg_Maneuver_Type_kTransitConnectionTransfer;
  static const Type kTransitConnectionDestination = DirectionsLeg_Maneuver_Type_kTransitConnectionDestination;
  static const Type kPostTransitConnectionDestination = DirectionsLeg_Maneuver_Type_kPostTransitConnectionDestination;
  static const Type kMergeRight = DirectionsLeg_Maneuver_Type_kMergeRight;
  static const Type kMergeLeft = DirectionsLeg_Maneuver_Type_kMergeLeft;
  static inline bool Type_IsValid(int value) {
    return DirectionsLeg_Maneuver_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DirectionsLeg_Maneuver_Type_Type_MIN;
  static const Type Type_MAX =
    DirectionsLeg_Maneuver_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DirectionsLeg_Maneuver_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::valhalla::DirectionsLeg_Maneuver_Type type() const;
  inline void set_type(::valhalla::DirectionsLeg_Maneuver_Type value);

  // optional string text_instruction = 2;
  inline bool has_text_instruction() const;
  inline void clear_text_instruction();
  static const int kTextInstructionFieldNumber = 2;
  inline const ::std::string& text_instruction() const;
  inline void set_text_instruction(const ::std::string& value);
  inline void set_text_instruction(const char* value);
  inline void set_text_instruction(const char* value, size_t size);
  inline ::std::string* mutable_text_instruction();
  inline ::std::string* release_text_instruction();
  inline void set_allocated_text_instruction(::std::string* text_instruction);

  // repeated .valhalla.StreetName street_name = 3;
  inline int street_name_size() const;
  inline void clear_street_name();
  static const int kStreetNameFieldNumber = 3;
  inline const ::valhalla::StreetName& street_name(int index) const;
  inline ::valhalla::StreetName* mutable_street_name(int index);
  inline ::valhalla::StreetName* add_street_name();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      street_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_street_name();

  // optional float length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline float length() const;
  inline void set_length(float value);

  // optional uint32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  inline bool has_begin_cardinal_direction() const;
  inline void clear_begin_cardinal_direction();
  static const int kBeginCardinalDirectionFieldNumber = 6;
  inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection begin_cardinal_direction() const;
  inline void set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value);

  // optional uint32 begin_heading = 7;
  inline bool has_begin_heading() const;
  inline void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 7;
  inline ::google::protobuf::uint32 begin_heading() const;
  inline void set_begin_heading(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 8;
  inline bool has_begin_shape_index() const;
  inline void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 begin_shape_index() const;
  inline void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 9;
  inline bool has_end_shape_index() const;
  inline void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 9;
  inline ::google::protobuf::uint32 end_shape_index() const;
  inline void set_end_shape_index(::google::protobuf::uint32 value);

  // optional bool portions_toll = 10;
  inline bool has_portions_toll() const;
  inline void clear_portions_toll();
  static const int kPortionsTollFieldNumber = 10;
  inline bool portions_toll() const;
  inline void set_portions_toll(bool value);

  // optional bool portions_unpaved = 11;
  inline bool has_portions_unpaved() const;
  inline void clear_portions_unpaved();
  static const int kPortionsUnpavedFieldNumber = 11;
  inline bool portions_unpaved() const;
  inline void set_portions_unpaved(bool value);

  // optional string verbal_transition_alert_instruction = 12;
  inline bool has_verbal_transition_alert_instruction() const;
  inline void clear_verbal_transition_alert_instruction();
  static const int kVerbalTransitionAlertInstructionFieldNumber = 12;
  inline const ::std::string& verbal_transition_alert_instruction() const;
  inline void set_verbal_transition_alert_instruction(const ::std::string& value);
  inline void set_verbal_transition_alert_instruction(const char* value);
  inline void set_verbal_transition_alert_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_transition_alert_instruction();
  inline ::std::string* release_verbal_transition_alert_instruction();
  inline void set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction);

  // optional string verbal_pre_transition_instruction = 13;
  inline bool has_verbal_pre_transition_instruction() const;
  inline void clear_verbal_pre_transition_instruction();
  static const int kVerbalPreTransitionInstructionFieldNumber = 13;
  inline const ::std::string& verbal_pre_transition_instruction() const;
  inline void set_verbal_pre_transition_instruction(const ::std::string& value);
  inline void set_verbal_pre_transition_instruction(const char* value);
  inline void set_verbal_pre_transition_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_pre_transition_instruction();
  inline ::std::string* release_verbal_pre_transition_instruction();
  inline void set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction);

  // optional string verbal_post_transition_instruction = 14;
  inline bool has_verbal_post_transition_instruction() const;
  inline void clear_verbal_post_transition_instruction();
  static const int kVerbalPostTransitionInstructionFieldNumber = 14;
  inline const ::std::string& verbal_post_transition_instruction() const;
  inline void set_verbal_post_transition_instruction(const ::std::string& value);
  inline void set_verbal_post_transition_instruction(const char* value);
  inline void set_verbal_post_transition_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_post_transition_instruction();
  inline ::std::string* release_verbal_post_transition_instruction();
  inline void set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction);

  // repeated .valhalla.StreetName begin_street_name = 15;
  inline int begin_street_name_size() const;
  inline void clear_begin_street_name();
  static const int kBeginStreetNameFieldNumber = 15;
  inline const ::valhalla::StreetName& begin_street_name(int index) const;
  inline ::valhalla::StreetName* mutable_begin_street_name(int index);
  inline ::valhalla::StreetName* add_begin_street_name();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      begin_street_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_begin_street_name();

  // optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 16;
  inline const ::valhalla::DirectionsLeg_Maneuver_Sign& sign() const;
  inline ::valhalla::DirectionsLeg_Maneuver_Sign* mutable_sign();
  inline ::valhalla::DirectionsLeg_Maneuver_Sign* release_sign();
  inline void set_allocated_sign(::valhalla::DirectionsLeg_Maneuver_Sign* sign);

  // optional uint32 roundabout_exit_count = 17;
  inline bool has_roundabout_exit_count() const;
  inline void clear_roundabout_exit_count();
  static const int kRoundaboutExitCountFieldNumber = 17;
  inline ::google::protobuf::uint32 roundabout_exit_count() const;
  inline void set_roundabout_exit_count(::google::protobuf::uint32 value);

  // optional string depart_instruction = 18;
  inline bool has_depart_instruction() const;
  inline void clear_depart_instruction();
  static const int kDepartInstructionFieldNumber = 18;
  inline const ::std::string& depart_instruction() const;
  inline void set_depart_instruction(const ::std::string& value);
  inline void set_depart_instruction(const char* value);
  inline void set_depart_instruction(const char* value, size_t size);
  inline ::std::string* mutable_depart_instruction();
  inline ::std::string* release_depart_instruction();
  inline void set_allocated_depart_instruction(::std::string* depart_instruction);

  // optional string verbal_depart_instruction = 19;
  inline bool has_verbal_depart_instruction() const;
  inline void clear_verbal_depart_instruction();
  static const int kVerbalDepartInstructionFieldNumber = 19;
  inline const ::std::string& verbal_depart_instruction() const;
  inline void set_verbal_depart_instruction(const ::std::string& value);
  inline void set_verbal_depart_instruction(const char* value);
  inline void set_verbal_depart_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_depart_instruction();
  inline ::std::string* release_verbal_depart_instruction();
  inline void set_allocated_verbal_depart_instruction(::std::string* verbal_depart_instruction);

  // optional string arrive_instruction = 20;
  inline bool has_arrive_instruction() const;
  inline void clear_arrive_instruction();
  static const int kArriveInstructionFieldNumber = 20;
  inline const ::std::string& arrive_instruction() const;
  inline void set_arrive_instruction(const ::std::string& value);
  inline void set_arrive_instruction(const char* value);
  inline void set_arrive_instruction(const char* value, size_t size);
  inline ::std::string* mutable_arrive_instruction();
  inline ::std::string* release_arrive_instruction();
  inline void set_allocated_arrive_instruction(::std::string* arrive_instruction);

  // optional string verbal_arrive_instruction = 21;
  inline bool has_verbal_arrive_instruction() const;
  inline void clear_verbal_arrive_instruction();
  static const int kVerbalArriveInstructionFieldNumber = 21;
  inline const ::std::string& verbal_arrive_instruction() const;
  inline void set_verbal_arrive_instruction(const ::std::string& value);
  inline void set_verbal_arrive_instruction(const char* value);
  inline void set_verbal_arrive_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_arrive_instruction();
  inline ::std::string* release_verbal_arrive_instruction();
  inline void set_allocated_verbal_arrive_instruction(::std::string* verbal_arrive_instruction);

  // optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
  inline bool has_transit_info() const;
  inline void clear_transit_info();
  static const int kTransitInfoFieldNumber = 22;
  inline const ::valhalla::DirectionsLeg_TransitInfo& transit_info() const;
  inline ::valhalla::DirectionsLeg_TransitInfo* mutable_transit_info();
  inline ::valhalla::DirectionsLeg_TransitInfo* release_transit_info();
  inline void set_allocated_transit_info(::valhalla::DirectionsLeg_TransitInfo* transit_info);

  // optional bool verbal_multi_cue = 23;
  inline bool has_verbal_multi_cue() const;
  inline void clear_verbal_multi_cue();
  static const int kVerbalMultiCueFieldNumber = 23;
  inline bool verbal_multi_cue() const;
  inline void set_verbal_multi_cue(bool value);

  // optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
  inline bool has_travel_mode() const;
  inline void clear_travel_mode();
  static const int kTravelModeFieldNumber = 24;
  inline ::valhalla::DirectionsLeg_TravelMode travel_mode() const;
  inline void set_travel_mode(::valhalla::DirectionsLeg_TravelMode value);

  // optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
  inline bool has_vehicle_type() const;
  inline void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 25;
  inline ::valhalla::DirectionsLeg_VehicleType vehicle_type() const;
  inline void set_vehicle_type(::valhalla::DirectionsLeg_VehicleType value);

  // optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
  inline bool has_pedestrian_type() const;
  inline void clear_pedestrian_type();
  static const int kPedestrianTypeFieldNumber = 26;
  inline ::valhalla::DirectionsLeg_PedestrianType pedestrian_type() const;
  inline void set_pedestrian_type(::valhalla::DirectionsLeg_PedestrianType value);

  // optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
  inline bool has_bicycle_type() const;
  inline void clear_bicycle_type();
  static const int kBicycleTypeFieldNumber = 27;
  inline ::valhalla::DirectionsLeg_BicycleType bicycle_type() const;
  inline void set_bicycle_type(::valhalla::DirectionsLeg_BicycleType value);

  // optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
  inline bool has_transit_type() const;
  inline void clear_transit_type();
  static const int kTransitTypeFieldNumber = 28;
  inline ::valhalla::DirectionsLeg_TransitType transit_type() const;
  inline void set_transit_type(::valhalla::DirectionsLeg_TransitType value);

  // optional uint32 begin_path_index = 29;
  inline bool has_begin_path_index() const;
  inline void clear_begin_path_index();
  static const int kBeginPathIndexFieldNumber = 29;
  inline ::google::protobuf::uint32 begin_path_index() const;
  inline void set_begin_path_index(::google::protobuf::uint32 value);

  // optional uint32 end_path_index = 30;
  inline bool has_end_path_index() const;
  inline void clear_end_path_index();
  static const int kEndPathIndexFieldNumber = 30;
  inline ::google::protobuf::uint32 end_path_index() const;
  inline void set_end_path_index(::google::protobuf::uint32 value);

  // optional bool to_stay_on = 31;
  inline bool has_to_stay_on() const;
  inline void clear_to_stay_on();
  static const int kToStayOnFieldNumber = 31;
  inline bool to_stay_on() const;
  inline void set_to_stay_on(bool value);

  // repeated .valhalla.StreetName roundabout_exit_street_names = 32;
  inline int roundabout_exit_street_names_size() const;
  inline void clear_roundabout_exit_street_names();
  static const int kRoundaboutExitStreetNamesFieldNumber = 32;
  inline const ::valhalla::StreetName& roundabout_exit_street_names(int index) const;
  inline ::valhalla::StreetName* mutable_roundabout_exit_street_names(int index);
  inline ::valhalla::StreetName* add_roundabout_exit_street_names();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      roundabout_exit_street_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_roundabout_exit_street_names();

  // optional uint32 turn_degree = 33;
  inline bool has_turn_degree() const;
  inline void clear_turn_degree();
  static const int kTurnDegreeFieldNumber = 33;
  inline ::google::protobuf::uint32 turn_degree() const;
  inline void set_turn_degree(::google::protobuf::uint32 value);

  // optional bool has_time_restrictions = 34;
  inline bool has_has_time_restrictions() const;
  inline void clear_has_time_restrictions();
  static const int kHasTimeRestrictionsFieldNumber = 34;
  inline bool has_time_restrictions() const;
  inline void set_has_time_restrictions(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg.Maneuver)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text_instruction();
  inline void clear_has_text_instruction();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_begin_cardinal_direction();
  inline void clear_has_begin_cardinal_direction();
  inline void set_has_begin_heading();
  inline void clear_has_begin_heading();
  inline void set_has_begin_shape_index();
  inline void clear_has_begin_shape_index();
  inline void set_has_end_shape_index();
  inline void clear_has_end_shape_index();
  inline void set_has_portions_toll();
  inline void clear_has_portions_toll();
  inline void set_has_portions_unpaved();
  inline void clear_has_portions_unpaved();
  inline void set_has_verbal_transition_alert_instruction();
  inline void clear_has_verbal_transition_alert_instruction();
  inline void set_has_verbal_pre_transition_instruction();
  inline void clear_has_verbal_pre_transition_instruction();
  inline void set_has_verbal_post_transition_instruction();
  inline void clear_has_verbal_post_transition_instruction();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_roundabout_exit_count();
  inline void clear_has_roundabout_exit_count();
  inline void set_has_depart_instruction();
  inline void clear_has_depart_instruction();
  inline void set_has_verbal_depart_instruction();
  inline void clear_has_verbal_depart_instruction();
  inline void set_has_arrive_instruction();
  inline void clear_has_arrive_instruction();
  inline void set_has_verbal_arrive_instruction();
  inline void clear_has_verbal_arrive_instruction();
  inline void set_has_transit_info();
  inline void clear_has_transit_info();
  inline void set_has_verbal_multi_cue();
  inline void clear_has_verbal_multi_cue();
  inline void set_has_travel_mode();
  inline void clear_has_travel_mode();
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();
  inline void set_has_pedestrian_type();
  inline void clear_has_pedestrian_type();
  inline void set_has_bicycle_type();
  inline void clear_has_bicycle_type();
  inline void set_has_transit_type();
  inline void clear_has_transit_type();
  inline void set_has_begin_path_index();
  inline void clear_has_begin_path_index();
  inline void set_has_end_path_index();
  inline void clear_has_end_path_index();
  inline void set_has_to_stay_on();
  inline void clear_has_to_stay_on();
  inline void set_has_turn_degree();
  inline void clear_has_turn_degree();
  inline void set_has_has_time_restrictions();
  inline void clear_has_has_time_restrictions();

  ::std::string* text_instruction_;
  int type_;
  float length_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > street_name_;
  ::google::protobuf::uint32 time_;
  int begin_cardinal_direction_;
  ::google::protobuf::uint32 begin_heading_;
  ::google::protobuf::uint32 begin_shape_index_;
  ::std::string* verbal_transition_alert_instruction_;
  ::std::string* verbal_pre_transition_instruction_;
  ::google::protobuf::uint32 end_shape_index_;
  ::google::protobuf::uint32 roundabout_exit_count_;
  ::std::string* verbal_post_transition_instruction_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > begin_street_name_;
  ::valhalla::DirectionsLeg_Maneuver_Sign* sign_;
  ::std::string* depart_instruction_;
  ::std::string* verbal_depart_instruction_;
  bool portions_toll_;
  bool portions_unpaved_;
  bool verbal_multi_cue_;
  bool to_stay_on_;
  int travel_mode_;
  ::std::string* arrive_instruction_;
  ::std::string* verbal_arrive_instruction_;
  ::valhalla::DirectionsLeg_TransitInfo* transit_info_;
  int vehicle_type_;
  int pedestrian_type_;
  int bicycle_type_;
  int transit_type_;
  ::google::protobuf::uint32 begin_path_index_;
  ::google::protobuf::uint32 end_path_index_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > roundabout_exit_street_names_;
  ::google::protobuf::uint32 turn_degree_;
  bool has_time_restrictions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(34 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg_Maneuver* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsLeg : public ::google::protobuf::MessageLite {
 public:
  DirectionsLeg();
  virtual ~DirectionsLeg();

  DirectionsLeg(const DirectionsLeg& from);

  inline DirectionsLeg& operator=(const DirectionsLeg& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsLeg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsLeg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsLeg* other);

  // implements Message ----------------------------------------------

  DirectionsLeg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsLeg& from);
  void MergeFrom(const DirectionsLeg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DirectionsLeg_Summary Summary;
  typedef DirectionsLeg_TransitInfo TransitInfo;
  typedef DirectionsLeg_Maneuver Maneuver;

  typedef DirectionsLeg_TravelMode TravelMode;
  static const TravelMode kDrive = DirectionsLeg_TravelMode_kDrive;
  static const TravelMode kPedestrian = DirectionsLeg_TravelMode_kPedestrian;
  static const TravelMode kBicycle = DirectionsLeg_TravelMode_kBicycle;
  static const TravelMode kTransit = DirectionsLeg_TravelMode_kTransit;
  static inline bool TravelMode_IsValid(int value) {
    return DirectionsLeg_TravelMode_IsValid(value);
  }
  static const TravelMode TravelMode_MIN =
    DirectionsLeg_TravelMode_TravelMode_MIN;
  static const TravelMode TravelMode_MAX =
    DirectionsLeg_TravelMode_TravelMode_MAX;
  static const int TravelMode_ARRAYSIZE =
    DirectionsLeg_TravelMode_TravelMode_ARRAYSIZE;

  typedef DirectionsLeg_VehicleType VehicleType;
  static const VehicleType kCar = DirectionsLeg_VehicleType_kCar;
  static const VehicleType kMotorcycle = DirectionsLeg_VehicleType_kMotorcycle;
  static const VehicleType kAutoBus = DirectionsLeg_VehicleType_kAutoBus;
  static const VehicleType kTractorTrailer = DirectionsLeg_VehicleType_kTractorTrailer;
  static const VehicleType kMotorScooter = DirectionsLeg_VehicleType_kMotorScooter;
  static inline bool VehicleType_IsValid(int value) {
    return DirectionsLeg_VehicleType_IsValid(value);
  }
  static const VehicleType VehicleType_MIN =
    DirectionsLeg_VehicleType_VehicleType_MIN;
  static const VehicleType VehicleType_MAX =
    DirectionsLeg_VehicleType_VehicleType_MAX;
  static const int VehicleType_ARRAYSIZE =
    DirectionsLeg_VehicleType_VehicleType_ARRAYSIZE;

  typedef DirectionsLeg_PedestrianType PedestrianType;
  static const PedestrianType kFoot = DirectionsLeg_PedestrianType_kFoot;
  static const PedestrianType kWheelchair = DirectionsLeg_PedestrianType_kWheelchair;
  static const PedestrianType kSegway = DirectionsLeg_PedestrianType_kSegway;
  static inline bool PedestrianType_IsValid(int value) {
    return DirectionsLeg_PedestrianType_IsValid(value);
  }
  static const PedestrianType PedestrianType_MIN =
    DirectionsLeg_PedestrianType_PedestrianType_MIN;
  static const PedestrianType PedestrianType_MAX =
    DirectionsLeg_PedestrianType_PedestrianType_MAX;
  static const int PedestrianType_ARRAYSIZE =
    DirectionsLeg_PedestrianType_PedestrianType_ARRAYSIZE;

  typedef DirectionsLeg_BicycleType BicycleType;
  static const BicycleType kRoad = DirectionsLeg_BicycleType_kRoad;
  static const BicycleType kCross = DirectionsLeg_BicycleType_kCross;
  static const BicycleType kHybrid = DirectionsLeg_BicycleType_kHybrid;
  static const BicycleType kMountain = DirectionsLeg_BicycleType_kMountain;
  static inline bool BicycleType_IsValid(int value) {
    return DirectionsLeg_BicycleType_IsValid(value);
  }
  static const BicycleType BicycleType_MIN =
    DirectionsLeg_BicycleType_BicycleType_MIN;
  static const BicycleType BicycleType_MAX =
    DirectionsLeg_BicycleType_BicycleType_MAX;
  static const int BicycleType_ARRAYSIZE =
    DirectionsLeg_BicycleType_BicycleType_ARRAYSIZE;

  typedef DirectionsLeg_TransitType TransitType;
  static const TransitType kTram = DirectionsLeg_TransitType_kTram;
  static const TransitType kMetro = DirectionsLeg_TransitType_kMetro;
  static const TransitType kRail = DirectionsLeg_TransitType_kRail;
  static const TransitType kBus = DirectionsLeg_TransitType_kBus;
  static const TransitType kFerry = DirectionsLeg_TransitType_kFerry;
  static const TransitType kCableCar = DirectionsLeg_TransitType_kCableCar;
  static const TransitType kGondola = DirectionsLeg_TransitType_kGondola;
  static const TransitType kFunicular = DirectionsLeg_TransitType_kFunicular;
  static inline bool TransitType_IsValid(int value) {
    return DirectionsLeg_TransitType_IsValid(value);
  }
  static const TransitType TransitType_MIN =
    DirectionsLeg_TransitType_TransitType_MIN;
  static const TransitType TransitType_MAX =
    DirectionsLeg_TransitType_TransitType_MAX;
  static const int TransitType_ARRAYSIZE =
    DirectionsLeg_TransitType_TransitType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint64 trip_id = 1;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  inline ::google::protobuf::uint64 trip_id() const;
  inline void set_trip_id(::google::protobuf::uint64 value);

  // optional uint32 leg_id = 2;
  inline bool has_leg_id() const;
  inline void clear_leg_id();
  static const int kLegIdFieldNumber = 2;
  inline ::google::protobuf::uint32 leg_id() const;
  inline void set_leg_id(::google::protobuf::uint32 value);

  // optional uint32 leg_count = 3;
  inline bool has_leg_count() const;
  inline void clear_leg_count();
  static const int kLegCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leg_count() const;
  inline void set_leg_count(::google::protobuf::uint32 value);

  // repeated .valhalla.Location location = 4;
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::valhalla::Location& location(int index) const;
  inline ::valhalla::Location* mutable_location(int index);
  inline ::valhalla::Location* add_location();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      location() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();

  // optional .valhalla.DirectionsLeg.Summary summary = 5;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 5;
  inline const ::valhalla::DirectionsLeg_Summary& summary() const;
  inline ::valhalla::DirectionsLeg_Summary* mutable_summary();
  inline ::valhalla::DirectionsLeg_Summary* release_summary();
  inline void set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary);

  // repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
  inline int maneuver_size() const;
  inline void clear_maneuver();
  static const int kManeuverFieldNumber = 6;
  inline const ::valhalla::DirectionsLeg_Maneuver& maneuver(int index) const;
  inline ::valhalla::DirectionsLeg_Maneuver* mutable_maneuver(int index);
  inline ::valhalla::DirectionsLeg_Maneuver* add_maneuver();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
      maneuver() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
      mutable_maneuver();

  // optional string shape = 7;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 7;
  inline const ::std::string& shape() const;
  inline void set_shape(const ::std::string& value);
  inline void set_shape(const char* value);
  inline void set_shape(const char* value, size_t size);
  inline ::std::string* mutable_shape();
  inline ::std::string* release_shape();
  inline void set_allocated_shape(::std::string* shape);

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsLeg)
 private:
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_leg_id();
  inline void clear_has_leg_id();
  inline void set_has_leg_count();
  inline void clear_has_leg_count();
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_shape();
  inline void clear_has_shape();

  ::google::protobuf::uint64 trip_id_;
  ::google::protobuf::uint32 leg_id_;
  ::google::protobuf::uint32 leg_count_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > location_;
  ::valhalla::DirectionsLeg_Summary* summary_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver > maneuver_;
  ::std::string* shape_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsLeg* default_instance_;
};
// -------------------------------------------------------------------

class DirectionsRoute : public ::google::protobuf::MessageLite {
 public:
  DirectionsRoute();
  virtual ~DirectionsRoute();

  DirectionsRoute(const DirectionsRoute& from);

  inline DirectionsRoute& operator=(const DirectionsRoute& from) {
    CopyFrom(from);
    return *this;
  }

  static const DirectionsRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DirectionsRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DirectionsRoute* other);

  // implements Message ----------------------------------------------

  DirectionsRoute* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DirectionsRoute& from);
  void MergeFrom(const DirectionsRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.DirectionsLeg legs = 1;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 1;
  inline const ::valhalla::DirectionsLeg& legs(int index) const;
  inline ::valhalla::DirectionsLeg* mutable_legs(int index);
  inline ::valhalla::DirectionsLeg* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >*
      mutable_legs();

  // @@protoc_insertion_point(class_scope:valhalla.DirectionsRoute)
 private:

  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg > legs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static DirectionsRoute* default_instance_;
};
// -------------------------------------------------------------------

class Directions : public ::google::protobuf::MessageLite {
 public:
  Directions();
  virtual ~Directions();

  Directions(const Directions& from);

  inline Directions& operator=(const Directions& from) {
    CopyFrom(from);
    return *this;
  }

  static const Directions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Directions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Directions* other);

  // implements Message ----------------------------------------------

  Directions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Directions& from);
  void MergeFrom(const Directions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.DirectionsRoute routes = 1;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 1;
  inline const ::valhalla::DirectionsRoute& routes(int index) const;
  inline ::valhalla::DirectionsRoute* mutable_routes(int index);
  inline ::valhalla::DirectionsRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >*
      mutable_routes();

  // @@protoc_insertion_point(class_scope:valhalla.Directions)
 private:

  ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute > routes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_directions_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_directions_2eproto();
  #endif
  friend void protobuf_AssignDesc_directions_2eproto();
  friend void protobuf_ShutdownFile_directions_2eproto();

  void InitAsDefaultInstance();
  static Directions* default_instance_;
};
// ===================================================================


// ===================================================================

// DirectionsLeg_Summary

// optional float length = 1;
inline bool DirectionsLeg_Summary::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLeg_Summary::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLeg_Summary::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLeg_Summary::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float DirectionsLeg_Summary::length() const {
  return length_;
}
inline void DirectionsLeg_Summary::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional uint32 time = 2;
inline bool DirectionsLeg_Summary::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLeg_Summary::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLeg_Summary::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLeg_Summary::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 DirectionsLeg_Summary::time() const {
  return time_;
}
inline void DirectionsLeg_Summary::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .valhalla.BoundingBox bbox = 3;
inline bool DirectionsLeg_Summary::has_bbox() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsLeg_Summary::set_has_bbox() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsLeg_Summary::clear_has_bbox() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsLeg_Summary::clear_bbox() {
  if (bbox_ != NULL) bbox_->::valhalla::BoundingBox::Clear();
  clear_has_bbox();
}
inline const ::valhalla::BoundingBox& DirectionsLeg_Summary::bbox() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bbox_ != NULL ? *bbox_ : *default_instance().bbox_;
#else
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
#endif
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::mutable_bbox() {
  set_has_bbox();
  if (bbox_ == NULL) bbox_ = new ::valhalla::BoundingBox;
  return bbox_;
}
inline ::valhalla::BoundingBox* DirectionsLeg_Summary::release_bbox() {
  clear_has_bbox();
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void DirectionsLeg_Summary::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    set_has_bbox();
  } else {
    clear_has_bbox();
  }
}

// optional bool has_time_restrictions = 4;
inline bool DirectionsLeg_Summary::has_has_time_restrictions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsLeg_Summary::set_has_has_time_restrictions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsLeg_Summary::clear_has_has_time_restrictions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsLeg_Summary::clear_has_time_restrictions() {
  has_time_restrictions_ = false;
  clear_has_has_time_restrictions();
}
inline bool DirectionsLeg_Summary::has_time_restrictions() const {
  return has_time_restrictions_;
}
inline void DirectionsLeg_Summary::set_has_time_restrictions(bool value) {
  set_has_has_time_restrictions();
  has_time_restrictions_ = value;
}

// -------------------------------------------------------------------

// DirectionsLeg_TransitInfo

// optional string onestop_id = 1;
inline bool DirectionsLeg_TransitInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLeg_TransitInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLeg_TransitInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& DirectionsLeg_TransitInfo::onestop_id() const {
  return *onestop_id_;
}
inline void DirectionsLeg_TransitInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string short_name = 2;
inline bool DirectionsLeg_TransitInfo::has_short_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_short_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLeg_TransitInfo::clear_has_short_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLeg_TransitInfo::clear_short_name() {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    short_name_->clear();
  }
  clear_has_short_name();
}
inline const ::std::string& DirectionsLeg_TransitInfo::short_name() const {
  return *short_name_;
}
inline void DirectionsLeg_TransitInfo::set_short_name(const ::std::string& value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_short_name(const char* value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_short_name(const char* value, size_t size) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_short_name() {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  return short_name_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_short_name() {
  clear_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_name_;
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_short_name(::std::string* short_name) {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    delete short_name_;
  }
  if (short_name) {
    set_has_short_name();
    short_name_ = short_name;
  } else {
    clear_has_short_name();
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string long_name = 3;
inline bool DirectionsLeg_TransitInfo::has_long_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_long_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsLeg_TransitInfo::clear_has_long_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsLeg_TransitInfo::clear_long_name() {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    long_name_->clear();
  }
  clear_has_long_name();
}
inline const ::std::string& DirectionsLeg_TransitInfo::long_name() const {
  return *long_name_;
}
inline void DirectionsLeg_TransitInfo::set_long_name(const ::std::string& value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_long_name(const char* value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_long_name(const char* value, size_t size) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_long_name() {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  return long_name_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_long_name() {
  clear_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = long_name_;
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_long_name(::std::string* long_name) {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    delete long_name_;
  }
  if (long_name) {
    set_has_long_name();
    long_name_ = long_name;
  } else {
    clear_has_long_name();
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string headsign = 4;
inline bool DirectionsLeg_TransitInfo::has_headsign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_headsign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsLeg_TransitInfo::clear_has_headsign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsLeg_TransitInfo::clear_headsign() {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    headsign_->clear();
  }
  clear_has_headsign();
}
inline const ::std::string& DirectionsLeg_TransitInfo::headsign() const {
  return *headsign_;
}
inline void DirectionsLeg_TransitInfo::set_headsign(const ::std::string& value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_headsign(const char* value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_headsign(const char* value, size_t size) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_headsign() {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  return headsign_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_headsign() {
  clear_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headsign_;
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_headsign(::std::string* headsign) {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    delete headsign_;
  }
  if (headsign) {
    set_has_headsign();
    headsign_ = headsign;
  } else {
    clear_has_headsign();
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 color = 5;
inline bool DirectionsLeg_TransitInfo::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsLeg_TransitInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsLeg_TransitInfo::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 DirectionsLeg_TransitInfo::color() const {
  return color_;
}
inline void DirectionsLeg_TransitInfo::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// optional uint32 text_color = 6;
inline bool DirectionsLeg_TransitInfo::has_text_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_text_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectionsLeg_TransitInfo::clear_has_text_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectionsLeg_TransitInfo::clear_text_color() {
  text_color_ = 0u;
  clear_has_text_color();
}
inline ::google::protobuf::uint32 DirectionsLeg_TransitInfo::text_color() const {
  return text_color_;
}
inline void DirectionsLeg_TransitInfo::set_text_color(::google::protobuf::uint32 value) {
  set_has_text_color();
  text_color_ = value;
}

// optional string description = 7;
inline bool DirectionsLeg_TransitInfo::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectionsLeg_TransitInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectionsLeg_TransitInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& DirectionsLeg_TransitInfo::description() const {
  return *description_;
}
inline void DirectionsLeg_TransitInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_onestop_id = 8;
inline bool DirectionsLeg_TransitInfo::has_operator_onestop_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_operator_onestop_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectionsLeg_TransitInfo::clear_has_operator_onestop_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectionsLeg_TransitInfo::clear_operator_onestop_id() {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_->clear();
  }
  clear_has_operator_onestop_id();
}
inline const ::std::string& DirectionsLeg_TransitInfo::operator_onestop_id() const {
  return *operator_onestop_id_;
}
inline void DirectionsLeg_TransitInfo::set_operator_onestop_id(const ::std::string& value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_operator_onestop_id(const char* value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_operator_onestop_id(const char* value, size_t size) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_operator_onestop_id() {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  return operator_onestop_id_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_operator_onestop_id() {
  clear_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_onestop_id_;
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_operator_onestop_id(::std::string* operator_onestop_id) {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_onestop_id_;
  }
  if (operator_onestop_id) {
    set_has_operator_onestop_id();
    operator_onestop_id_ = operator_onestop_id;
  } else {
    clear_has_operator_onestop_id();
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_name = 9;
inline bool DirectionsLeg_TransitInfo::has_operator_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_operator_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectionsLeg_TransitInfo::clear_has_operator_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectionsLeg_TransitInfo::clear_operator_name() {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    operator_name_->clear();
  }
  clear_has_operator_name();
}
inline const ::std::string& DirectionsLeg_TransitInfo::operator_name() const {
  return *operator_name_;
}
inline void DirectionsLeg_TransitInfo::set_operator_name(const ::std::string& value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_operator_name(const char* value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_operator_name(const char* value, size_t size) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_operator_name() {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  return operator_name_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_operator_name() {
  clear_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_name_;
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_operator_name(::std::string* operator_name) {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_name_;
  }
  if (operator_name) {
    set_has_operator_name();
    operator_name_ = operator_name;
  } else {
    clear_has_operator_name();
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_url = 10;
inline bool DirectionsLeg_TransitInfo::has_operator_url() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectionsLeg_TransitInfo::set_has_operator_url() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectionsLeg_TransitInfo::clear_has_operator_url() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectionsLeg_TransitInfo::clear_operator_url() {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    operator_url_->clear();
  }
  clear_has_operator_url();
}
inline const ::std::string& DirectionsLeg_TransitInfo::operator_url() const {
  return *operator_url_;
}
inline void DirectionsLeg_TransitInfo::set_operator_url(const ::std::string& value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_operator_url(const char* value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void DirectionsLeg_TransitInfo::set_operator_url(const char* value, size_t size) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_TransitInfo::mutable_operator_url() {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  return operator_url_;
}
inline ::std::string* DirectionsLeg_TransitInfo::release_operator_url() {
  clear_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_url_;
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_TransitInfo::set_allocated_operator_url(::std::string* operator_url) {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_url_;
  }
  if (operator_url) {
    set_has_operator_url();
    operator_url_ = operator_url;
  } else {
    clear_has_operator_url();
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .valhalla.TransitPlatformInfo transit_stops = 11;
inline int DirectionsLeg_TransitInfo::transit_stops_size() const {
  return transit_stops_.size();
}
inline void DirectionsLeg_TransitInfo::clear_transit_stops() {
  transit_stops_.Clear();
}
inline const ::valhalla::TransitPlatformInfo& DirectionsLeg_TransitInfo::transit_stops(int index) const {
  return transit_stops_.Get(index);
}
inline ::valhalla::TransitPlatformInfo* DirectionsLeg_TransitInfo::mutable_transit_stops(int index) {
  return transit_stops_.Mutable(index);
}
inline ::valhalla::TransitPlatformInfo* DirectionsLeg_TransitInfo::add_transit_stops() {
  return transit_stops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo >&
DirectionsLeg_TransitInfo::transit_stops() const {
  return transit_stops_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TransitPlatformInfo >*
DirectionsLeg_TransitInfo::mutable_transit_stops() {
  return &transit_stops_;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver_SignElement

// optional string text = 1;
inline bool DirectionsLeg_Maneuver_SignElement::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLeg_Maneuver_SignElement::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLeg_Maneuver_SignElement::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLeg_Maneuver_SignElement::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& DirectionsLeg_Maneuver_SignElement::text() const {
  return *text_;
}
inline void DirectionsLeg_Maneuver_SignElement::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DirectionsLeg_Maneuver_SignElement::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DirectionsLeg_Maneuver_SignElement::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver_SignElement::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* DirectionsLeg_Maneuver_SignElement::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver_SignElement::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_route_number = 2;
inline bool DirectionsLeg_Maneuver_SignElement::has_is_route_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLeg_Maneuver_SignElement::set_has_is_route_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLeg_Maneuver_SignElement::clear_has_is_route_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLeg_Maneuver_SignElement::clear_is_route_number() {
  is_route_number_ = false;
  clear_has_is_route_number();
}
inline bool DirectionsLeg_Maneuver_SignElement::is_route_number() const {
  return is_route_number_;
}
inline void DirectionsLeg_Maneuver_SignElement::set_is_route_number(bool value) {
  set_has_is_route_number();
  is_route_number_ = value;
}

// optional uint32 consecutive_count = 3;
inline bool DirectionsLeg_Maneuver_SignElement::has_consecutive_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsLeg_Maneuver_SignElement::set_has_consecutive_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsLeg_Maneuver_SignElement::clear_has_consecutive_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsLeg_Maneuver_SignElement::clear_consecutive_count() {
  consecutive_count_ = 0u;
  clear_has_consecutive_count();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver_SignElement::consecutive_count() const {
  return consecutive_count_;
}
inline void DirectionsLeg_Maneuver_SignElement::set_consecutive_count(::google::protobuf::uint32 value) {
  set_has_consecutive_count();
  consecutive_count_ = value;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver_Sign

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_numbers = 1;
inline int DirectionsLeg_Maneuver_Sign::exit_numbers_size() const {
  return exit_numbers_.size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_numbers() {
  exit_numbers_.Clear();
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_numbers(int index) const {
  return exit_numbers_.Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_numbers(int index) {
  return exit_numbers_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_numbers() {
  return exit_numbers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_numbers() const {
  return exit_numbers_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_numbers() {
  return &exit_numbers_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_onto_streets = 2;
inline int DirectionsLeg_Maneuver_Sign::exit_onto_streets_size() const {
  return exit_onto_streets_.size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_onto_streets() {
  exit_onto_streets_.Clear();
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_onto_streets(int index) const {
  return exit_onto_streets_.Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_onto_streets(int index) {
  return exit_onto_streets_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_onto_streets() {
  return exit_onto_streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_onto_streets() const {
  return exit_onto_streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_onto_streets() {
  return &exit_onto_streets_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_toward_locations = 3;
inline int DirectionsLeg_Maneuver_Sign::exit_toward_locations_size() const {
  return exit_toward_locations_.size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_toward_locations() {
  exit_toward_locations_.Clear();
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_toward_locations(int index) const {
  return exit_toward_locations_.Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_toward_locations(int index) {
  return exit_toward_locations_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_toward_locations() {
  return exit_toward_locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_toward_locations() const {
  return exit_toward_locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_toward_locations() {
  return &exit_toward_locations_;
}

// repeated .valhalla.DirectionsLeg.Maneuver.SignElement exit_names = 4;
inline int DirectionsLeg_Maneuver_Sign::exit_names_size() const {
  return exit_names_.size();
}
inline void DirectionsLeg_Maneuver_Sign::clear_exit_names() {
  exit_names_.Clear();
}
inline const ::valhalla::DirectionsLeg_Maneuver_SignElement& DirectionsLeg_Maneuver_Sign::exit_names(int index) const {
  return exit_names_.Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::mutable_exit_names(int index) {
  return exit_names_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_Maneuver_SignElement* DirectionsLeg_Maneuver_Sign::add_exit_names() {
  return exit_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >&
DirectionsLeg_Maneuver_Sign::exit_names() const {
  return exit_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver_SignElement >*
DirectionsLeg_Maneuver_Sign::mutable_exit_names() {
  return &exit_names_;
}

// -------------------------------------------------------------------

// DirectionsLeg_Maneuver

// optional .valhalla.DirectionsLeg.Maneuver.Type type = 1;
inline bool DirectionsLeg_Maneuver::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLeg_Maneuver::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLeg_Maneuver::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::DirectionsLeg_Maneuver_Type DirectionsLeg_Maneuver::type() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_Type >(type_);
}
inline void DirectionsLeg_Maneuver::set_type(::valhalla::DirectionsLeg_Maneuver_Type value) {
  assert(::valhalla::DirectionsLeg_Maneuver_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string text_instruction = 2;
inline bool DirectionsLeg_Maneuver::has_text_instruction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_text_instruction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLeg_Maneuver::clear_has_text_instruction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLeg_Maneuver::clear_text_instruction() {
  if (text_instruction_ != &::google::protobuf::internal::kEmptyString) {
    text_instruction_->clear();
  }
  clear_has_text_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::text_instruction() const {
  return *text_instruction_;
}
inline void DirectionsLeg_Maneuver::set_text_instruction(const ::std::string& value) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_text_instruction(const char* value) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_text_instruction(const char* value, size_t size) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_text_instruction() {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  return text_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_text_instruction() {
  clear_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_instruction_;
    text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_text_instruction(::std::string* text_instruction) {
  if (text_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete text_instruction_;
  }
  if (text_instruction) {
    set_has_text_instruction();
    text_instruction_ = text_instruction;
  } else {
    clear_has_text_instruction();
    text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .valhalla.StreetName street_name = 3;
inline int DirectionsLeg_Maneuver::street_name_size() const {
  return street_name_.size();
}
inline void DirectionsLeg_Maneuver::clear_street_name() {
  street_name_.Clear();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::street_name(int index) const {
  return street_name_.Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_street_name(int index) {
  return street_name_.Mutable(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_street_name() {
  return street_name_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::street_name() const {
  return street_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_street_name() {
  return &street_name_;
}

// optional float length = 4;
inline bool DirectionsLeg_Maneuver::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DirectionsLeg_Maneuver::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DirectionsLeg_Maneuver::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float DirectionsLeg_Maneuver::length() const {
  return length_;
}
inline void DirectionsLeg_Maneuver::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional uint32 time = 5;
inline bool DirectionsLeg_Maneuver::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsLeg_Maneuver::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsLeg_Maneuver::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::time() const {
  return time_;
}
inline void DirectionsLeg_Maneuver::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .valhalla.DirectionsLeg.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline bool DirectionsLeg_Maneuver::has_begin_cardinal_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_begin_cardinal_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DirectionsLeg_Maneuver::clear_has_begin_cardinal_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DirectionsLeg_Maneuver::clear_begin_cardinal_direction() {
  begin_cardinal_direction_ = 0;
  clear_has_begin_cardinal_direction();
}
inline ::valhalla::DirectionsLeg_Maneuver_CardinalDirection DirectionsLeg_Maneuver::begin_cardinal_direction() const {
  return static_cast< ::valhalla::DirectionsLeg_Maneuver_CardinalDirection >(begin_cardinal_direction_);
}
inline void DirectionsLeg_Maneuver::set_begin_cardinal_direction(::valhalla::DirectionsLeg_Maneuver_CardinalDirection value) {
  assert(::valhalla::DirectionsLeg_Maneuver_CardinalDirection_IsValid(value));
  set_has_begin_cardinal_direction();
  begin_cardinal_direction_ = value;
}

// optional uint32 begin_heading = 7;
inline bool DirectionsLeg_Maneuver::has_begin_heading() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_begin_heading() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectionsLeg_Maneuver::clear_has_begin_heading() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectionsLeg_Maneuver::clear_begin_heading() {
  begin_heading_ = 0u;
  clear_has_begin_heading();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::begin_heading() const {
  return begin_heading_;
}
inline void DirectionsLeg_Maneuver::set_begin_heading(::google::protobuf::uint32 value) {
  set_has_begin_heading();
  begin_heading_ = value;
}

// optional uint32 begin_shape_index = 8;
inline bool DirectionsLeg_Maneuver::has_begin_shape_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_begin_shape_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DirectionsLeg_Maneuver::clear_has_begin_shape_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DirectionsLeg_Maneuver::clear_begin_shape_index() {
  begin_shape_index_ = 0u;
  clear_has_begin_shape_index();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::begin_shape_index() const {
  return begin_shape_index_;
}
inline void DirectionsLeg_Maneuver::set_begin_shape_index(::google::protobuf::uint32 value) {
  set_has_begin_shape_index();
  begin_shape_index_ = value;
}

// optional uint32 end_shape_index = 9;
inline bool DirectionsLeg_Maneuver::has_end_shape_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_end_shape_index() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DirectionsLeg_Maneuver::clear_has_end_shape_index() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DirectionsLeg_Maneuver::clear_end_shape_index() {
  end_shape_index_ = 0u;
  clear_has_end_shape_index();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::end_shape_index() const {
  return end_shape_index_;
}
inline void DirectionsLeg_Maneuver::set_end_shape_index(::google::protobuf::uint32 value) {
  set_has_end_shape_index();
  end_shape_index_ = value;
}

// optional bool portions_toll = 10;
inline bool DirectionsLeg_Maneuver::has_portions_toll() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_portions_toll() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DirectionsLeg_Maneuver::clear_has_portions_toll() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DirectionsLeg_Maneuver::clear_portions_toll() {
  portions_toll_ = false;
  clear_has_portions_toll();
}
inline bool DirectionsLeg_Maneuver::portions_toll() const {
  return portions_toll_;
}
inline void DirectionsLeg_Maneuver::set_portions_toll(bool value) {
  set_has_portions_toll();
  portions_toll_ = value;
}

// optional bool portions_unpaved = 11;
inline bool DirectionsLeg_Maneuver::has_portions_unpaved() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_portions_unpaved() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DirectionsLeg_Maneuver::clear_has_portions_unpaved() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DirectionsLeg_Maneuver::clear_portions_unpaved() {
  portions_unpaved_ = false;
  clear_has_portions_unpaved();
}
inline bool DirectionsLeg_Maneuver::portions_unpaved() const {
  return portions_unpaved_;
}
inline void DirectionsLeg_Maneuver::set_portions_unpaved(bool value) {
  set_has_portions_unpaved();
  portions_unpaved_ = value;
}

// optional string verbal_transition_alert_instruction = 12;
inline bool DirectionsLeg_Maneuver::has_verbal_transition_alert_instruction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_transition_alert_instruction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DirectionsLeg_Maneuver::clear_has_verbal_transition_alert_instruction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DirectionsLeg_Maneuver::clear_verbal_transition_alert_instruction() {
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_->clear();
  }
  clear_has_verbal_transition_alert_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_transition_alert_instruction() const {
  return *verbal_transition_alert_instruction_;
}
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(const ::std::string& value) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(const char* value) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_transition_alert_instruction(const char* value, size_t size) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_transition_alert_instruction() {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  return verbal_transition_alert_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_transition_alert_instruction() {
  clear_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_transition_alert_instruction_;
    verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction) {
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_transition_alert_instruction_;
  }
  if (verbal_transition_alert_instruction) {
    set_has_verbal_transition_alert_instruction();
    verbal_transition_alert_instruction_ = verbal_transition_alert_instruction;
  } else {
    clear_has_verbal_transition_alert_instruction();
    verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_pre_transition_instruction = 13;
inline bool DirectionsLeg_Maneuver::has_verbal_pre_transition_instruction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_pre_transition_instruction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DirectionsLeg_Maneuver::clear_has_verbal_pre_transition_instruction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DirectionsLeg_Maneuver::clear_verbal_pre_transition_instruction() {
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_->clear();
  }
  clear_has_verbal_pre_transition_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_pre_transition_instruction() const {
  return *verbal_pre_transition_instruction_;
}
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(const ::std::string& value) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(const char* value) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_pre_transition_instruction(const char* value, size_t size) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_pre_transition_instruction() {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  return verbal_pre_transition_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_pre_transition_instruction() {
  clear_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_pre_transition_instruction_;
    verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction) {
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_pre_transition_instruction_;
  }
  if (verbal_pre_transition_instruction) {
    set_has_verbal_pre_transition_instruction();
    verbal_pre_transition_instruction_ = verbal_pre_transition_instruction;
  } else {
    clear_has_verbal_pre_transition_instruction();
    verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_post_transition_instruction = 14;
inline bool DirectionsLeg_Maneuver::has_verbal_post_transition_instruction() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_post_transition_instruction() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DirectionsLeg_Maneuver::clear_has_verbal_post_transition_instruction() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DirectionsLeg_Maneuver::clear_verbal_post_transition_instruction() {
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_->clear();
  }
  clear_has_verbal_post_transition_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_post_transition_instruction() const {
  return *verbal_post_transition_instruction_;
}
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(const ::std::string& value) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(const char* value) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_post_transition_instruction(const char* value, size_t size) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_post_transition_instruction() {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  return verbal_post_transition_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_post_transition_instruction() {
  clear_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_post_transition_instruction_;
    verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction) {
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_post_transition_instruction_;
  }
  if (verbal_post_transition_instruction) {
    set_has_verbal_post_transition_instruction();
    verbal_post_transition_instruction_ = verbal_post_transition_instruction;
  } else {
    clear_has_verbal_post_transition_instruction();
    verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .valhalla.StreetName begin_street_name = 15;
inline int DirectionsLeg_Maneuver::begin_street_name_size() const {
  return begin_street_name_.size();
}
inline void DirectionsLeg_Maneuver::clear_begin_street_name() {
  begin_street_name_.Clear();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::begin_street_name(int index) const {
  return begin_street_name_.Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_begin_street_name(int index) {
  return begin_street_name_.Mutable(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_begin_street_name() {
  return begin_street_name_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::begin_street_name() const {
  return begin_street_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_begin_street_name() {
  return &begin_street_name_;
}

// optional .valhalla.DirectionsLeg.Maneuver.Sign sign = 16;
inline bool DirectionsLeg_Maneuver::has_sign() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_sign() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DirectionsLeg_Maneuver::clear_has_sign() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DirectionsLeg_Maneuver::clear_sign() {
  if (sign_ != NULL) sign_->::valhalla::DirectionsLeg_Maneuver_Sign::Clear();
  clear_has_sign();
}
inline const ::valhalla::DirectionsLeg_Maneuver_Sign& DirectionsLeg_Maneuver::sign() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
inline ::valhalla::DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::valhalla::DirectionsLeg_Maneuver_Sign;
  return sign_;
}
inline ::valhalla::DirectionsLeg_Maneuver_Sign* DirectionsLeg_Maneuver::release_sign() {
  clear_has_sign();
  ::valhalla::DirectionsLeg_Maneuver_Sign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void DirectionsLeg_Maneuver::set_allocated_sign(::valhalla::DirectionsLeg_Maneuver_Sign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
}

// optional uint32 roundabout_exit_count = 17;
inline bool DirectionsLeg_Maneuver::has_roundabout_exit_count() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_roundabout_exit_count() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DirectionsLeg_Maneuver::clear_has_roundabout_exit_count() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_count() {
  roundabout_exit_count_ = 0u;
  clear_has_roundabout_exit_count();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::roundabout_exit_count() const {
  return roundabout_exit_count_;
}
inline void DirectionsLeg_Maneuver::set_roundabout_exit_count(::google::protobuf::uint32 value) {
  set_has_roundabout_exit_count();
  roundabout_exit_count_ = value;
}

// optional string depart_instruction = 18;
inline bool DirectionsLeg_Maneuver::has_depart_instruction() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_depart_instruction() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DirectionsLeg_Maneuver::clear_has_depart_instruction() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DirectionsLeg_Maneuver::clear_depart_instruction() {
  if (depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    depart_instruction_->clear();
  }
  clear_has_depart_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::depart_instruction() const {
  return *depart_instruction_;
}
inline void DirectionsLeg_Maneuver::set_depart_instruction(const ::std::string& value) {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  depart_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_depart_instruction(const char* value) {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  depart_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_depart_instruction(const char* value, size_t size) {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  depart_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_depart_instruction() {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  return depart_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_depart_instruction() {
  clear_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = depart_instruction_;
    depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_depart_instruction(::std::string* depart_instruction) {
  if (depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete depart_instruction_;
  }
  if (depart_instruction) {
    set_has_depart_instruction();
    depart_instruction_ = depart_instruction;
  } else {
    clear_has_depart_instruction();
    depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_depart_instruction = 19;
inline bool DirectionsLeg_Maneuver::has_verbal_depart_instruction() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_depart_instruction() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DirectionsLeg_Maneuver::clear_has_verbal_depart_instruction() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DirectionsLeg_Maneuver::clear_verbal_depart_instruction() {
  if (verbal_depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_->clear();
  }
  clear_has_verbal_depart_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_depart_instruction() const {
  return *verbal_depart_instruction_;
}
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(const ::std::string& value) {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  verbal_depart_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(const char* value) {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  verbal_depart_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_depart_instruction(const char* value, size_t size) {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  verbal_depart_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_depart_instruction() {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  return verbal_depart_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_depart_instruction() {
  clear_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_depart_instruction_;
    verbal_depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_depart_instruction(::std::string* verbal_depart_instruction) {
  if (verbal_depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_depart_instruction_;
  }
  if (verbal_depart_instruction) {
    set_has_verbal_depart_instruction();
    verbal_depart_instruction_ = verbal_depart_instruction;
  } else {
    clear_has_verbal_depart_instruction();
    verbal_depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrive_instruction = 20;
inline bool DirectionsLeg_Maneuver::has_arrive_instruction() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_arrive_instruction() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DirectionsLeg_Maneuver::clear_has_arrive_instruction() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DirectionsLeg_Maneuver::clear_arrive_instruction() {
  if (arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_->clear();
  }
  clear_has_arrive_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::arrive_instruction() const {
  return *arrive_instruction_;
}
inline void DirectionsLeg_Maneuver::set_arrive_instruction(const ::std::string& value) {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  arrive_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_arrive_instruction(const char* value) {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  arrive_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_arrive_instruction(const char* value, size_t size) {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  arrive_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_arrive_instruction() {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  return arrive_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_arrive_instruction() {
  clear_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrive_instruction_;
    arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_arrive_instruction(::std::string* arrive_instruction) {
  if (arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete arrive_instruction_;
  }
  if (arrive_instruction) {
    set_has_arrive_instruction();
    arrive_instruction_ = arrive_instruction;
  } else {
    clear_has_arrive_instruction();
    arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_arrive_instruction = 21;
inline bool DirectionsLeg_Maneuver::has_verbal_arrive_instruction() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_arrive_instruction() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DirectionsLeg_Maneuver::clear_has_verbal_arrive_instruction() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DirectionsLeg_Maneuver::clear_verbal_arrive_instruction() {
  if (verbal_arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_->clear();
  }
  clear_has_verbal_arrive_instruction();
}
inline const ::std::string& DirectionsLeg_Maneuver::verbal_arrive_instruction() const {
  return *verbal_arrive_instruction_;
}
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(const ::std::string& value) {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  verbal_arrive_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(const char* value) {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  verbal_arrive_instruction_->assign(value);
}
inline void DirectionsLeg_Maneuver::set_verbal_arrive_instruction(const char* value, size_t size) {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  verbal_arrive_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg_Maneuver::mutable_verbal_arrive_instruction() {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  return verbal_arrive_instruction_;
}
inline ::std::string* DirectionsLeg_Maneuver::release_verbal_arrive_instruction() {
  clear_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_arrive_instruction_;
    verbal_arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg_Maneuver::set_allocated_verbal_arrive_instruction(::std::string* verbal_arrive_instruction) {
  if (verbal_arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_arrive_instruction_;
  }
  if (verbal_arrive_instruction) {
    set_has_verbal_arrive_instruction();
    verbal_arrive_instruction_ = verbal_arrive_instruction;
  } else {
    clear_has_verbal_arrive_instruction();
    verbal_arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.DirectionsLeg.TransitInfo transit_info = 22;
inline bool DirectionsLeg_Maneuver::has_transit_info() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_transit_info() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DirectionsLeg_Maneuver::clear_has_transit_info() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DirectionsLeg_Maneuver::clear_transit_info() {
  if (transit_info_ != NULL) transit_info_->::valhalla::DirectionsLeg_TransitInfo::Clear();
  clear_has_transit_info();
}
inline const ::valhalla::DirectionsLeg_TransitInfo& DirectionsLeg_Maneuver::transit_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_info_ != NULL ? *transit_info_ : *default_instance().transit_info_;
#else
  return transit_info_ != NULL ? *transit_info_ : *default_instance_->transit_info_;
#endif
}
inline ::valhalla::DirectionsLeg_TransitInfo* DirectionsLeg_Maneuver::mutable_transit_info() {
  set_has_transit_info();
  if (transit_info_ == NULL) transit_info_ = new ::valhalla::DirectionsLeg_TransitInfo;
  return transit_info_;
}
inline ::valhalla::DirectionsLeg_TransitInfo* DirectionsLeg_Maneuver::release_transit_info() {
  clear_has_transit_info();
  ::valhalla::DirectionsLeg_TransitInfo* temp = transit_info_;
  transit_info_ = NULL;
  return temp;
}
inline void DirectionsLeg_Maneuver::set_allocated_transit_info(::valhalla::DirectionsLeg_TransitInfo* transit_info) {
  delete transit_info_;
  transit_info_ = transit_info;
  if (transit_info) {
    set_has_transit_info();
  } else {
    clear_has_transit_info();
  }
}

// optional bool verbal_multi_cue = 23;
inline bool DirectionsLeg_Maneuver::has_verbal_multi_cue() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_verbal_multi_cue() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DirectionsLeg_Maneuver::clear_has_verbal_multi_cue() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DirectionsLeg_Maneuver::clear_verbal_multi_cue() {
  verbal_multi_cue_ = false;
  clear_has_verbal_multi_cue();
}
inline bool DirectionsLeg_Maneuver::verbal_multi_cue() const {
  return verbal_multi_cue_;
}
inline void DirectionsLeg_Maneuver::set_verbal_multi_cue(bool value) {
  set_has_verbal_multi_cue();
  verbal_multi_cue_ = value;
}

// optional .valhalla.DirectionsLeg.TravelMode travel_mode = 24;
inline bool DirectionsLeg_Maneuver::has_travel_mode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_travel_mode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void DirectionsLeg_Maneuver::clear_has_travel_mode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void DirectionsLeg_Maneuver::clear_travel_mode() {
  travel_mode_ = 0;
  clear_has_travel_mode();
}
inline ::valhalla::DirectionsLeg_TravelMode DirectionsLeg_Maneuver::travel_mode() const {
  return static_cast< ::valhalla::DirectionsLeg_TravelMode >(travel_mode_);
}
inline void DirectionsLeg_Maneuver::set_travel_mode(::valhalla::DirectionsLeg_TravelMode value) {
  assert(::valhalla::DirectionsLeg_TravelMode_IsValid(value));
  set_has_travel_mode();
  travel_mode_ = value;
}

// optional .valhalla.DirectionsLeg.VehicleType vehicle_type = 25;
inline bool DirectionsLeg_Maneuver::has_vehicle_type() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_vehicle_type() {
  _has_bits_[0] |= 0x01000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void DirectionsLeg_Maneuver::clear_vehicle_type() {
  vehicle_type_ = 0;
  clear_has_vehicle_type();
}
inline ::valhalla::DirectionsLeg_VehicleType DirectionsLeg_Maneuver::vehicle_type() const {
  return static_cast< ::valhalla::DirectionsLeg_VehicleType >(vehicle_type_);
}
inline void DirectionsLeg_Maneuver::set_vehicle_type(::valhalla::DirectionsLeg_VehicleType value) {
  assert(::valhalla::DirectionsLeg_VehicleType_IsValid(value));
  set_has_vehicle_type();
  vehicle_type_ = value;
}

// optional .valhalla.DirectionsLeg.PedestrianType pedestrian_type = 26;
inline bool DirectionsLeg_Maneuver::has_pedestrian_type() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_pedestrian_type() {
  _has_bits_[0] |= 0x02000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_pedestrian_type() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void DirectionsLeg_Maneuver::clear_pedestrian_type() {
  pedestrian_type_ = 0;
  clear_has_pedestrian_type();
}
inline ::valhalla::DirectionsLeg_PedestrianType DirectionsLeg_Maneuver::pedestrian_type() const {
  return static_cast< ::valhalla::DirectionsLeg_PedestrianType >(pedestrian_type_);
}
inline void DirectionsLeg_Maneuver::set_pedestrian_type(::valhalla::DirectionsLeg_PedestrianType value) {
  assert(::valhalla::DirectionsLeg_PedestrianType_IsValid(value));
  set_has_pedestrian_type();
  pedestrian_type_ = value;
}

// optional .valhalla.DirectionsLeg.BicycleType bicycle_type = 27;
inline bool DirectionsLeg_Maneuver::has_bicycle_type() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_bicycle_type() {
  _has_bits_[0] |= 0x04000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_bicycle_type() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void DirectionsLeg_Maneuver::clear_bicycle_type() {
  bicycle_type_ = 0;
  clear_has_bicycle_type();
}
inline ::valhalla::DirectionsLeg_BicycleType DirectionsLeg_Maneuver::bicycle_type() const {
  return static_cast< ::valhalla::DirectionsLeg_BicycleType >(bicycle_type_);
}
inline void DirectionsLeg_Maneuver::set_bicycle_type(::valhalla::DirectionsLeg_BicycleType value) {
  assert(::valhalla::DirectionsLeg_BicycleType_IsValid(value));
  set_has_bicycle_type();
  bicycle_type_ = value;
}

// optional .valhalla.DirectionsLeg.TransitType transit_type = 28;
inline bool DirectionsLeg_Maneuver::has_transit_type() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_transit_type() {
  _has_bits_[0] |= 0x08000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_transit_type() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void DirectionsLeg_Maneuver::clear_transit_type() {
  transit_type_ = 0;
  clear_has_transit_type();
}
inline ::valhalla::DirectionsLeg_TransitType DirectionsLeg_Maneuver::transit_type() const {
  return static_cast< ::valhalla::DirectionsLeg_TransitType >(transit_type_);
}
inline void DirectionsLeg_Maneuver::set_transit_type(::valhalla::DirectionsLeg_TransitType value) {
  assert(::valhalla::DirectionsLeg_TransitType_IsValid(value));
  set_has_transit_type();
  transit_type_ = value;
}

// optional uint32 begin_path_index = 29;
inline bool DirectionsLeg_Maneuver::has_begin_path_index() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_begin_path_index() {
  _has_bits_[0] |= 0x10000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_begin_path_index() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void DirectionsLeg_Maneuver::clear_begin_path_index() {
  begin_path_index_ = 0u;
  clear_has_begin_path_index();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::begin_path_index() const {
  return begin_path_index_;
}
inline void DirectionsLeg_Maneuver::set_begin_path_index(::google::protobuf::uint32 value) {
  set_has_begin_path_index();
  begin_path_index_ = value;
}

// optional uint32 end_path_index = 30;
inline bool DirectionsLeg_Maneuver::has_end_path_index() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_end_path_index() {
  _has_bits_[0] |= 0x20000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_end_path_index() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void DirectionsLeg_Maneuver::clear_end_path_index() {
  end_path_index_ = 0u;
  clear_has_end_path_index();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::end_path_index() const {
  return end_path_index_;
}
inline void DirectionsLeg_Maneuver::set_end_path_index(::google::protobuf::uint32 value) {
  set_has_end_path_index();
  end_path_index_ = value;
}

// optional bool to_stay_on = 31;
inline bool DirectionsLeg_Maneuver::has_to_stay_on() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_to_stay_on() {
  _has_bits_[0] |= 0x40000000u;
}
inline void DirectionsLeg_Maneuver::clear_has_to_stay_on() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void DirectionsLeg_Maneuver::clear_to_stay_on() {
  to_stay_on_ = false;
  clear_has_to_stay_on();
}
inline bool DirectionsLeg_Maneuver::to_stay_on() const {
  return to_stay_on_;
}
inline void DirectionsLeg_Maneuver::set_to_stay_on(bool value) {
  set_has_to_stay_on();
  to_stay_on_ = value;
}

// repeated .valhalla.StreetName roundabout_exit_street_names = 32;
inline int DirectionsLeg_Maneuver::roundabout_exit_street_names_size() const {
  return roundabout_exit_street_names_.size();
}
inline void DirectionsLeg_Maneuver::clear_roundabout_exit_street_names() {
  roundabout_exit_street_names_.Clear();
}
inline const ::valhalla::StreetName& DirectionsLeg_Maneuver::roundabout_exit_street_names(int index) const {
  return roundabout_exit_street_names_.Get(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names(int index) {
  return roundabout_exit_street_names_.Mutable(index);
}
inline ::valhalla::StreetName* DirectionsLeg_Maneuver::add_roundabout_exit_street_names() {
  return roundabout_exit_street_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
DirectionsLeg_Maneuver::roundabout_exit_street_names() const {
  return roundabout_exit_street_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
DirectionsLeg_Maneuver::mutable_roundabout_exit_street_names() {
  return &roundabout_exit_street_names_;
}

// optional uint32 turn_degree = 33;
inline bool DirectionsLeg_Maneuver::has_turn_degree() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_turn_degree() {
  _has_bits_[1] |= 0x00000001u;
}
inline void DirectionsLeg_Maneuver::clear_has_turn_degree() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void DirectionsLeg_Maneuver::clear_turn_degree() {
  turn_degree_ = 0u;
  clear_has_turn_degree();
}
inline ::google::protobuf::uint32 DirectionsLeg_Maneuver::turn_degree() const {
  return turn_degree_;
}
inline void DirectionsLeg_Maneuver::set_turn_degree(::google::protobuf::uint32 value) {
  set_has_turn_degree();
  turn_degree_ = value;
}

// optional bool has_time_restrictions = 34;
inline bool DirectionsLeg_Maneuver::has_has_time_restrictions() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void DirectionsLeg_Maneuver::set_has_has_time_restrictions() {
  _has_bits_[1] |= 0x00000002u;
}
inline void DirectionsLeg_Maneuver::clear_has_has_time_restrictions() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void DirectionsLeg_Maneuver::clear_has_time_restrictions() {
  has_time_restrictions_ = false;
  clear_has_has_time_restrictions();
}
inline bool DirectionsLeg_Maneuver::has_time_restrictions() const {
  return has_time_restrictions_;
}
inline void DirectionsLeg_Maneuver::set_has_time_restrictions(bool value) {
  set_has_has_time_restrictions();
  has_time_restrictions_ = value;
}

// -------------------------------------------------------------------

// DirectionsLeg

// optional uint64 trip_id = 1;
inline bool DirectionsLeg::has_trip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectionsLeg::set_has_trip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectionsLeg::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectionsLeg::clear_trip_id() {
  trip_id_ = GOOGLE_ULONGLONG(0);
  clear_has_trip_id();
}
inline ::google::protobuf::uint64 DirectionsLeg::trip_id() const {
  return trip_id_;
}
inline void DirectionsLeg::set_trip_id(::google::protobuf::uint64 value) {
  set_has_trip_id();
  trip_id_ = value;
}

// optional uint32 leg_id = 2;
inline bool DirectionsLeg::has_leg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectionsLeg::set_has_leg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectionsLeg::clear_has_leg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectionsLeg::clear_leg_id() {
  leg_id_ = 0u;
  clear_has_leg_id();
}
inline ::google::protobuf::uint32 DirectionsLeg::leg_id() const {
  return leg_id_;
}
inline void DirectionsLeg::set_leg_id(::google::protobuf::uint32 value) {
  set_has_leg_id();
  leg_id_ = value;
}

// optional uint32 leg_count = 3;
inline bool DirectionsLeg::has_leg_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectionsLeg::set_has_leg_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectionsLeg::clear_has_leg_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectionsLeg::clear_leg_count() {
  leg_count_ = 0u;
  clear_has_leg_count();
}
inline ::google::protobuf::uint32 DirectionsLeg::leg_count() const {
  return leg_count_;
}
inline void DirectionsLeg::set_leg_count(::google::protobuf::uint32 value) {
  set_has_leg_count();
  leg_count_ = value;
}

// repeated .valhalla.Location location = 4;
inline int DirectionsLeg::location_size() const {
  return location_.size();
}
inline void DirectionsLeg::clear_location() {
  location_.Clear();
}
inline const ::valhalla::Location& DirectionsLeg::location(int index) const {
  return location_.Get(index);
}
inline ::valhalla::Location* DirectionsLeg::mutable_location(int index) {
  return location_.Mutable(index);
}
inline ::valhalla::Location* DirectionsLeg::add_location() {
  return location_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
DirectionsLeg::location() const {
  return location_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
DirectionsLeg::mutable_location() {
  return &location_;
}

// optional .valhalla.DirectionsLeg.Summary summary = 5;
inline bool DirectionsLeg::has_summary() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DirectionsLeg::set_has_summary() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DirectionsLeg::clear_has_summary() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DirectionsLeg::clear_summary() {
  if (summary_ != NULL) summary_->::valhalla::DirectionsLeg_Summary::Clear();
  clear_has_summary();
}
inline const ::valhalla::DirectionsLeg_Summary& DirectionsLeg::summary() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return summary_ != NULL ? *summary_ : *default_instance().summary_;
#else
  return summary_ != NULL ? *summary_ : *default_instance_->summary_;
#endif
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::mutable_summary() {
  set_has_summary();
  if (summary_ == NULL) summary_ = new ::valhalla::DirectionsLeg_Summary;
  return summary_;
}
inline ::valhalla::DirectionsLeg_Summary* DirectionsLeg::release_summary() {
  clear_has_summary();
  ::valhalla::DirectionsLeg_Summary* temp = summary_;
  summary_ = NULL;
  return temp;
}
inline void DirectionsLeg::set_allocated_summary(::valhalla::DirectionsLeg_Summary* summary) {
  delete summary_;
  summary_ = summary;
  if (summary) {
    set_has_summary();
  } else {
    clear_has_summary();
  }
}

// repeated .valhalla.DirectionsLeg.Maneuver maneuver = 6;
inline int DirectionsLeg::maneuver_size() const {
  return maneuver_.size();
}
inline void DirectionsLeg::clear_maneuver() {
  maneuver_.Clear();
}
inline const ::valhalla::DirectionsLeg_Maneuver& DirectionsLeg::maneuver(int index) const {
  return maneuver_.Get(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::mutable_maneuver(int index) {
  return maneuver_.Mutable(index);
}
inline ::valhalla::DirectionsLeg_Maneuver* DirectionsLeg::add_maneuver() {
  return maneuver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >&
DirectionsLeg::maneuver() const {
  return maneuver_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg_Maneuver >*
DirectionsLeg::mutable_maneuver() {
  return &maneuver_;
}

// optional string shape = 7;
inline bool DirectionsLeg::has_shape() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DirectionsLeg::set_has_shape() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DirectionsLeg::clear_has_shape() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DirectionsLeg::clear_shape() {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    shape_->clear();
  }
  clear_has_shape();
}
inline const ::std::string& DirectionsLeg::shape() const {
  return *shape_;
}
inline void DirectionsLeg::set_shape(const ::std::string& value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void DirectionsLeg::set_shape(const char* value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void DirectionsLeg::set_shape(const char* value, size_t size) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectionsLeg::mutable_shape() {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  return shape_;
}
inline ::std::string* DirectionsLeg::release_shape() {
  clear_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shape_;
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectionsLeg::set_allocated_shape(::std::string* shape) {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    delete shape_;
  }
  if (shape) {
    set_has_shape();
    shape_ = shape;
  } else {
    clear_has_shape();
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DirectionsRoute

// repeated .valhalla.DirectionsLeg legs = 1;
inline int DirectionsRoute::legs_size() const {
  return legs_.size();
}
inline void DirectionsRoute::clear_legs() {
  legs_.Clear();
}
inline const ::valhalla::DirectionsLeg& DirectionsRoute::legs(int index) const {
  return legs_.Get(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::mutable_legs(int index) {
  return legs_.Mutable(index);
}
inline ::valhalla::DirectionsLeg* DirectionsRoute::add_legs() {
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >&
DirectionsRoute::legs() const {
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsLeg >*
DirectionsRoute::mutable_legs() {
  return &legs_;
}

// -------------------------------------------------------------------

// Directions

// repeated .valhalla.DirectionsRoute routes = 1;
inline int Directions::routes_size() const {
  return routes_.size();
}
inline void Directions::clear_routes() {
  routes_.Clear();
}
inline const ::valhalla::DirectionsRoute& Directions::routes(int index) const {
  return routes_.Get(index);
}
inline ::valhalla::DirectionsRoute* Directions::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::valhalla::DirectionsRoute* Directions::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >&
Directions::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::DirectionsRoute >*
Directions::mutable_routes() {
  return &routes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_directions_2eproto__INCLUDED
