// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tripcommon.proto

#ifndef PROTOBUF_tripcommon_2eproto__INCLUDED
#define PROTOBUF_tripcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tripcommon_2eproto();
void protobuf_AssignDesc_tripcommon_2eproto();
void protobuf_ShutdownFile_tripcommon_2eproto();

class LatLng;
class BoundingBox;
class Location;
class Location_PathEdge;
class TransitEgressInfo;
class TransitStationInfo;
class TransitPlatformInfo;
class StreetName;
class TurnLane;

enum Location_Type {
  Location_Type_kBreak = 0,
  Location_Type_kThrough = 1,
  Location_Type_kVia = 2,
  Location_Type_kBreakThrough = 3
};
bool Location_Type_IsValid(int value);
const Location_Type Location_Type_Type_MIN = Location_Type_kBreak;
const Location_Type Location_Type_Type_MAX = Location_Type_kBreakThrough;
const int Location_Type_Type_ARRAYSIZE = Location_Type_Type_MAX + 1;

enum Location_SideOfStreet {
  Location_SideOfStreet_kNone = 0,
  Location_SideOfStreet_kLeft = 1,
  Location_SideOfStreet_kRight = 2
};
bool Location_SideOfStreet_IsValid(int value);
const Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MIN = Location_SideOfStreet_kNone;
const Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MAX = Location_SideOfStreet_kRight;
const int Location_SideOfStreet_SideOfStreet_ARRAYSIZE = Location_SideOfStreet_SideOfStreet_MAX + 1;

enum Location_PreferredSide {
  Location_PreferredSide_either = 0,
  Location_PreferredSide_same = 1,
  Location_PreferredSide_opposite = 2
};
bool Location_PreferredSide_IsValid(int value);
const Location_PreferredSide Location_PreferredSide_PreferredSide_MIN = Location_PreferredSide_either;
const Location_PreferredSide Location_PreferredSide_PreferredSide_MAX = Location_PreferredSide_opposite;
const int Location_PreferredSide_PreferredSide_ARRAYSIZE = Location_PreferredSide_PreferredSide_MAX + 1;

enum TransitPlatformInfo_Type {
  TransitPlatformInfo_Type_kStop = 0,
  TransitPlatformInfo_Type_kStation = 1
};
bool TransitPlatformInfo_Type_IsValid(int value);
const TransitPlatformInfo_Type TransitPlatformInfo_Type_Type_MIN = TransitPlatformInfo_Type_kStop;
const TransitPlatformInfo_Type TransitPlatformInfo_Type_Type_MAX = TransitPlatformInfo_Type_kStation;
const int TransitPlatformInfo_Type_Type_ARRAYSIZE = TransitPlatformInfo_Type_Type_MAX + 1;

// ===================================================================

class LatLng : public ::google::protobuf::MessageLite {
 public:
  LatLng();
  virtual ~LatLng();

  LatLng(const LatLng& from);

  inline LatLng& operator=(const LatLng& from) {
    CopyFrom(from);
    return *this;
  }

  static const LatLng& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LatLng* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LatLng* other);

  // implements Message ----------------------------------------------

  LatLng* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LatLng& from);
  void MergeFrom(const LatLng& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lng = 2;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 2;
  inline float lng() const;
  inline void set_lng(float value);

  // @@protoc_insertion_point(class_scope:valhalla.LatLng)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lng();
  inline void clear_has_lng();

  float lat_;
  float lng_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static LatLng* default_instance_;
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::MessageLite {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  static const BoundingBox& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BoundingBox* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BoundingBox* other);

  // implements Message ----------------------------------------------

  BoundingBox* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.LatLng min_ll = 1;
  inline bool has_min_ll() const;
  inline void clear_min_ll();
  static const int kMinLlFieldNumber = 1;
  inline const ::valhalla::LatLng& min_ll() const;
  inline ::valhalla::LatLng* mutable_min_ll();
  inline ::valhalla::LatLng* release_min_ll();
  inline void set_allocated_min_ll(::valhalla::LatLng* min_ll);

  // optional .valhalla.LatLng max_ll = 2;
  inline bool has_max_ll() const;
  inline void clear_max_ll();
  static const int kMaxLlFieldNumber = 2;
  inline const ::valhalla::LatLng& max_ll() const;
  inline ::valhalla::LatLng* mutable_max_ll();
  inline ::valhalla::LatLng* release_max_ll();
  inline void set_allocated_max_ll(::valhalla::LatLng* max_ll);

  // @@protoc_insertion_point(class_scope:valhalla.BoundingBox)
 private:
  inline void set_has_min_ll();
  inline void clear_has_min_ll();
  inline void set_has_max_ll();
  inline void clear_has_max_ll();

  ::valhalla::LatLng* min_ll_;
  ::valhalla::LatLng* max_ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class Location_PathEdge : public ::google::protobuf::MessageLite {
 public:
  Location_PathEdge();
  virtual ~Location_PathEdge();

  Location_PathEdge(const Location_PathEdge& from);

  inline Location_PathEdge& operator=(const Location_PathEdge& from) {
    CopyFrom(from);
    return *this;
  }

  static const Location_PathEdge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Location_PathEdge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Location_PathEdge* other);

  // implements Message ----------------------------------------------

  Location_PathEdge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location_PathEdge& from);
  void MergeFrom(const Location_PathEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 graph_id = 1;
  inline bool has_graph_id() const;
  inline void clear_graph_id();
  static const int kGraphIdFieldNumber = 1;
  inline ::google::protobuf::uint64 graph_id() const;
  inline void set_graph_id(::google::protobuf::uint64 value);

  // optional float percent_along = 2;
  inline bool has_percent_along() const;
  inline void clear_percent_along();
  static const int kPercentAlongFieldNumber = 2;
  inline float percent_along() const;
  inline void set_percent_along(float value);

  // optional .valhalla.LatLng ll = 3;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 3;
  inline const ::valhalla::LatLng& ll() const;
  inline ::valhalla::LatLng* mutable_ll();
  inline ::valhalla::LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::LatLng* ll);

  // optional .valhalla.Location.SideOfStreet side_of_street = 4;
  inline bool has_side_of_street() const;
  inline void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 4;
  inline ::valhalla::Location_SideOfStreet side_of_street() const;
  inline void set_side_of_street(::valhalla::Location_SideOfStreet value);

  // optional float distance = 5;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 5;
  inline float distance() const;
  inline void set_distance(float value);

  // optional int32 minimum_reachability = 6;
  inline bool has_minimum_reachability() const;
  inline void clear_minimum_reachability();
  static const int kMinimumReachabilityFieldNumber = 6;
  inline ::google::protobuf::int32 minimum_reachability() const;
  inline void set_minimum_reachability(::google::protobuf::int32 value);

  // optional bool begin_node = 7;
  inline bool has_begin_node() const;
  inline void clear_begin_node();
  static const int kBeginNodeFieldNumber = 7;
  inline bool begin_node() const;
  inline void set_begin_node(bool value);

  // optional bool end_node = 8;
  inline bool has_end_node() const;
  inline void clear_end_node();
  static const int kEndNodeFieldNumber = 8;
  inline bool end_node() const;
  inline void set_end_node(bool value);

  // repeated string names = 10;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 10;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // optional int32 outbound_reach = 11;
  inline bool has_outbound_reach() const;
  inline void clear_outbound_reach();
  static const int kOutboundReachFieldNumber = 11;
  inline ::google::protobuf::int32 outbound_reach() const;
  inline void set_outbound_reach(::google::protobuf::int32 value);

  // optional int32 inbound_reach = 12;
  inline bool has_inbound_reach() const;
  inline void clear_inbound_reach();
  static const int kInboundReachFieldNumber = 12;
  inline ::google::protobuf::int32 inbound_reach() const;
  inline void set_inbound_reach(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:valhalla.Location.PathEdge)
 private:
  inline void set_has_graph_id();
  inline void clear_has_graph_id();
  inline void set_has_percent_along();
  inline void clear_has_percent_along();
  inline void set_has_ll();
  inline void clear_has_ll();
  inline void set_has_side_of_street();
  inline void clear_has_side_of_street();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_minimum_reachability();
  inline void clear_has_minimum_reachability();
  inline void set_has_begin_node();
  inline void clear_has_begin_node();
  inline void set_has_end_node();
  inline void clear_has_end_node();
  inline void set_has_outbound_reach();
  inline void clear_has_outbound_reach();
  inline void set_has_inbound_reach();
  inline void clear_has_inbound_reach();

  ::google::protobuf::uint64 graph_id_;
  ::valhalla::LatLng* ll_;
  float percent_along_;
  int side_of_street_;
  float distance_;
  ::google::protobuf::int32 minimum_reachability_;
  bool begin_node_;
  bool end_node_;
  ::google::protobuf::int32 outbound_reach_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::google::protobuf::int32 inbound_reach_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static Location_PathEdge* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::MessageLite {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  static const Location& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Location* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Location_PathEdge PathEdge;

  typedef Location_Type Type;
  static const Type kBreak = Location_Type_kBreak;
  static const Type kThrough = Location_Type_kThrough;
  static const Type kVia = Location_Type_kVia;
  static const Type kBreakThrough = Location_Type_kBreakThrough;
  static inline bool Type_IsValid(int value) {
    return Location_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Location_Type_Type_MIN;
  static const Type Type_MAX =
    Location_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Location_Type_Type_ARRAYSIZE;

  typedef Location_SideOfStreet SideOfStreet;
  static const SideOfStreet kNone = Location_SideOfStreet_kNone;
  static const SideOfStreet kLeft = Location_SideOfStreet_kLeft;
  static const SideOfStreet kRight = Location_SideOfStreet_kRight;
  static inline bool SideOfStreet_IsValid(int value) {
    return Location_SideOfStreet_IsValid(value);
  }
  static const SideOfStreet SideOfStreet_MIN =
    Location_SideOfStreet_SideOfStreet_MIN;
  static const SideOfStreet SideOfStreet_MAX =
    Location_SideOfStreet_SideOfStreet_MAX;
  static const int SideOfStreet_ARRAYSIZE =
    Location_SideOfStreet_SideOfStreet_ARRAYSIZE;

  typedef Location_PreferredSide PreferredSide;
  static const PreferredSide either = Location_PreferredSide_either;
  static const PreferredSide same = Location_PreferredSide_same;
  static const PreferredSide opposite = Location_PreferredSide_opposite;
  static inline bool PreferredSide_IsValid(int value) {
    return Location_PreferredSide_IsValid(value);
  }
  static const PreferredSide PreferredSide_MIN =
    Location_PreferredSide_PreferredSide_MIN;
  static const PreferredSide PreferredSide_MAX =
    Location_PreferredSide_PreferredSide_MAX;
  static const int PreferredSide_ARRAYSIZE =
    Location_PreferredSide_PreferredSide_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.LatLng ll = 1;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 1;
  inline const ::valhalla::LatLng& ll() const;
  inline ::valhalla::LatLng* mutable_ll();
  inline ::valhalla::LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::LatLng* ll);

  // optional .valhalla.Location.Type type = 2 [default = kBreak];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::valhalla::Location_Type type() const;
  inline void set_type(::valhalla::Location_Type value);

  // optional uint32 heading = 3;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 3;
  inline ::google::protobuf::uint32 heading() const;
  inline void set_heading(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string street = 5;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 5;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string postal_code = 8;
  inline bool has_postal_code() const;
  inline void clear_postal_code();
  static const int kPostalCodeFieldNumber = 8;
  inline const ::std::string& postal_code() const;
  inline void set_postal_code(const ::std::string& value);
  inline void set_postal_code(const char* value);
  inline void set_postal_code(const char* value, size_t size);
  inline ::std::string* mutable_postal_code();
  inline ::std::string* release_postal_code();
  inline void set_allocated_postal_code(::std::string* postal_code);

  // optional string country = 9;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 9;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string phone = 10;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 10;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string url = 11;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 11;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string date_time = 12;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 12;
  inline const ::std::string& date_time() const;
  inline void set_date_time(const ::std::string& value);
  inline void set_date_time(const char* value);
  inline void set_date_time(const char* value, size_t size);
  inline ::std::string* mutable_date_time();
  inline ::std::string* release_date_time();
  inline void set_allocated_date_time(::std::string* date_time);

  // optional .valhalla.Location.SideOfStreet side_of_street = 13;
  inline bool has_side_of_street() const;
  inline void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 13;
  inline ::valhalla::Location_SideOfStreet side_of_street() const;
  inline void set_side_of_street(::valhalla::Location_SideOfStreet value);

  // optional uint32 heading_tolerance = 14;
  inline bool has_heading_tolerance() const;
  inline void clear_heading_tolerance();
  static const int kHeadingToleranceFieldNumber = 14;
  inline ::google::protobuf::uint32 heading_tolerance() const;
  inline void set_heading_tolerance(::google::protobuf::uint32 value);

  // optional uint32 node_snap_tolerance = 15;
  inline bool has_node_snap_tolerance() const;
  inline void clear_node_snap_tolerance();
  static const int kNodeSnapToleranceFieldNumber = 15;
  inline ::google::protobuf::uint32 node_snap_tolerance() const;
  inline void set_node_snap_tolerance(::google::protobuf::uint32 value);

  // optional uint64 way_id = 16;
  inline bool has_way_id() const;
  inline void clear_way_id();
  static const int kWayIdFieldNumber = 16;
  inline ::google::protobuf::uint64 way_id() const;
  inline void set_way_id(::google::protobuf::uint64 value);

  // optional uint32 minimum_reachability = 17;
  inline bool has_minimum_reachability() const;
  inline void clear_minimum_reachability();
  static const int kMinimumReachabilityFieldNumber = 17;
  inline ::google::protobuf::uint32 minimum_reachability() const;
  inline void set_minimum_reachability(::google::protobuf::uint32 value);

  // optional uint32 radius = 18;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 18;
  inline ::google::protobuf::uint32 radius() const;
  inline void set_radius(::google::protobuf::uint32 value);

  // optional uint32 accuracy = 19;
  inline bool has_accuracy() const;
  inline void clear_accuracy();
  static const int kAccuracyFieldNumber = 19;
  inline ::google::protobuf::uint32 accuracy() const;
  inline void set_accuracy(::google::protobuf::uint32 value);

  // optional double time = 20 [default = -1];
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 20;
  inline double time() const;
  inline void set_time(double value);

  // optional bool rank_candidates = 21 [default = true];
  inline bool has_rank_candidates() const;
  inline void clear_rank_candidates();
  static const int kRankCandidatesFieldNumber = 21;
  inline bool rank_candidates() const;
  inline void set_rank_candidates(bool value);

  // repeated .valhalla.Location.PathEdge path_edges = 22;
  inline int path_edges_size() const;
  inline void clear_path_edges();
  static const int kPathEdgesFieldNumber = 22;
  inline const ::valhalla::Location_PathEdge& path_edges(int index) const;
  inline ::valhalla::Location_PathEdge* mutable_path_edges(int index);
  inline ::valhalla::Location_PathEdge* add_path_edges();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >&
      path_edges() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >*
      mutable_path_edges();

  // repeated .valhalla.Location.PathEdge filtered_edges = 23;
  inline int filtered_edges_size() const;
  inline void clear_filtered_edges();
  static const int kFilteredEdgesFieldNumber = 23;
  inline const ::valhalla::Location_PathEdge& filtered_edges(int index) const;
  inline ::valhalla::Location_PathEdge* mutable_filtered_edges(int index);
  inline ::valhalla::Location_PathEdge* add_filtered_edges();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >&
      filtered_edges() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >*
      mutable_filtered_edges();

  // optional uint32 original_index = 24;
  inline bool has_original_index() const;
  inline void clear_original_index();
  static const int kOriginalIndexFieldNumber = 24;
  inline ::google::protobuf::uint32 original_index() const;
  inline void set_original_index(::google::protobuf::uint32 value);

  // optional .valhalla.LatLng projected_ll = 25;
  inline bool has_projected_ll() const;
  inline void clear_projected_ll();
  static const int kProjectedLlFieldNumber = 25;
  inline const ::valhalla::LatLng& projected_ll() const;
  inline ::valhalla::LatLng* mutable_projected_ll();
  inline ::valhalla::LatLng* release_projected_ll();
  inline void set_allocated_projected_ll(::valhalla::LatLng* projected_ll);

  // optional .valhalla.Location.PreferredSide preferred_side = 26 [default = either];
  inline bool has_preferred_side() const;
  inline void clear_preferred_side();
  static const int kPreferredSideFieldNumber = 26;
  inline ::valhalla::Location_PreferredSide preferred_side() const;
  inline void set_preferred_side(::valhalla::Location_PreferredSide value);

  // optional uint32 search_cutoff = 28;
  inline bool has_search_cutoff() const;
  inline void clear_search_cutoff();
  static const int kSearchCutoffFieldNumber = 28;
  inline ::google::protobuf::uint32 search_cutoff() const;
  inline void set_search_cutoff(::google::protobuf::uint32 value);

  // optional uint32 street_side_tolerance = 29;
  inline bool has_street_side_tolerance() const;
  inline void clear_street_side_tolerance();
  static const int kStreetSideToleranceFieldNumber = 29;
  inline ::google::protobuf::uint32 street_side_tolerance() const;
  inline void set_street_side_tolerance(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.Location)
 private:
  inline void set_has_ll();
  inline void clear_has_ll();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_postal_code();
  inline void clear_has_postal_code();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_date_time();
  inline void clear_has_date_time();
  inline void set_has_side_of_street();
  inline void clear_has_side_of_street();
  inline void set_has_heading_tolerance();
  inline void clear_has_heading_tolerance();
  inline void set_has_node_snap_tolerance();
  inline void clear_has_node_snap_tolerance();
  inline void set_has_way_id();
  inline void clear_has_way_id();
  inline void set_has_minimum_reachability();
  inline void clear_has_minimum_reachability();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_accuracy();
  inline void clear_has_accuracy();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_rank_candidates();
  inline void clear_has_rank_candidates();
  inline void set_has_original_index();
  inline void clear_has_original_index();
  inline void set_has_projected_ll();
  inline void clear_has_projected_ll();
  inline void set_has_preferred_side();
  inline void clear_has_preferred_side();
  inline void set_has_search_cutoff();
  inline void clear_has_search_cutoff();
  inline void set_has_street_side_tolerance();
  inline void clear_has_street_side_tolerance();

  ::valhalla::LatLng* ll_;
  int type_;
  ::google::protobuf::uint32 heading_;
  ::std::string* name_;
  ::std::string* street_;
  ::std::string* city_;
  ::std::string* state_;
  ::std::string* postal_code_;
  ::std::string* country_;
  ::std::string* phone_;
  ::std::string* url_;
  ::std::string* date_time_;
  int side_of_street_;
  ::google::protobuf::uint32 heading_tolerance_;
  ::google::protobuf::uint64 way_id_;
  ::google::protobuf::uint32 node_snap_tolerance_;
  ::google::protobuf::uint32 minimum_reachability_;
  ::google::protobuf::uint32 radius_;
  ::google::protobuf::uint32 accuracy_;
  double time_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge > path_edges_;
  bool rank_candidates_;
  ::google::protobuf::uint32 original_index_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge > filtered_edges_;
  ::valhalla::LatLng* projected_ll_;
  int preferred_side_;
  ::google::protobuf::uint32 search_cutoff_;
  ::google::protobuf::uint32 street_side_tolerance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class TransitEgressInfo : public ::google::protobuf::MessageLite {
 public:
  TransitEgressInfo();
  virtual ~TransitEgressInfo();

  TransitEgressInfo(const TransitEgressInfo& from);

  inline TransitEgressInfo& operator=(const TransitEgressInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransitEgressInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransitEgressInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransitEgressInfo* other);

  // implements Message ----------------------------------------------

  TransitEgressInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransitEgressInfo& from);
  void MergeFrom(const TransitEgressInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string onestop_id = 1;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 1;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .valhalla.LatLng ll = 3;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 3;
  inline const ::valhalla::LatLng& ll() const;
  inline ::valhalla::LatLng* mutable_ll();
  inline ::valhalla::LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::LatLng* ll);

  // @@protoc_insertion_point(class_scope:valhalla.TransitEgressInfo)
 private:
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ll();
  inline void clear_has_ll();

  ::std::string* onestop_id_;
  ::std::string* name_;
  ::valhalla::LatLng* ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static TransitEgressInfo* default_instance_;
};
// -------------------------------------------------------------------

class TransitStationInfo : public ::google::protobuf::MessageLite {
 public:
  TransitStationInfo();
  virtual ~TransitStationInfo();

  TransitStationInfo(const TransitStationInfo& from);

  inline TransitStationInfo& operator=(const TransitStationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransitStationInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransitStationInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransitStationInfo* other);

  // implements Message ----------------------------------------------

  TransitStationInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransitStationInfo& from);
  void MergeFrom(const TransitStationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string onestop_id = 1;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 1;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .valhalla.LatLng ll = 3;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 3;
  inline const ::valhalla::LatLng& ll() const;
  inline ::valhalla::LatLng* mutable_ll();
  inline ::valhalla::LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::LatLng* ll);

  // @@protoc_insertion_point(class_scope:valhalla.TransitStationInfo)
 private:
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ll();
  inline void clear_has_ll();

  ::std::string* onestop_id_;
  ::std::string* name_;
  ::valhalla::LatLng* ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static TransitStationInfo* default_instance_;
};
// -------------------------------------------------------------------

class TransitPlatformInfo : public ::google::protobuf::MessageLite {
 public:
  TransitPlatformInfo();
  virtual ~TransitPlatformInfo();

  TransitPlatformInfo(const TransitPlatformInfo& from);

  inline TransitPlatformInfo& operator=(const TransitPlatformInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransitPlatformInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransitPlatformInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransitPlatformInfo* other);

  // implements Message ----------------------------------------------

  TransitPlatformInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransitPlatformInfo& from);
  void MergeFrom(const TransitPlatformInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TransitPlatformInfo_Type Type;
  static const Type kStop = TransitPlatformInfo_Type_kStop;
  static const Type kStation = TransitPlatformInfo_Type_kStation;
  static inline bool Type_IsValid(int value) {
    return TransitPlatformInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TransitPlatformInfo_Type_Type_MIN;
  static const Type Type_MAX =
    TransitPlatformInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TransitPlatformInfo_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.TransitPlatformInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::valhalla::TransitPlatformInfo_Type type() const;
  inline void set_type(::valhalla::TransitPlatformInfo_Type value);

  // optional string onestop_id = 2;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 2;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string arrival_date_time = 4;
  inline bool has_arrival_date_time() const;
  inline void clear_arrival_date_time();
  static const int kArrivalDateTimeFieldNumber = 4;
  inline const ::std::string& arrival_date_time() const;
  inline void set_arrival_date_time(const ::std::string& value);
  inline void set_arrival_date_time(const char* value);
  inline void set_arrival_date_time(const char* value, size_t size);
  inline ::std::string* mutable_arrival_date_time();
  inline ::std::string* release_arrival_date_time();
  inline void set_allocated_arrival_date_time(::std::string* arrival_date_time);

  // optional string departure_date_time = 5;
  inline bool has_departure_date_time() const;
  inline void clear_departure_date_time();
  static const int kDepartureDateTimeFieldNumber = 5;
  inline const ::std::string& departure_date_time() const;
  inline void set_departure_date_time(const ::std::string& value);
  inline void set_departure_date_time(const char* value);
  inline void set_departure_date_time(const char* value, size_t size);
  inline ::std::string* mutable_departure_date_time();
  inline ::std::string* release_departure_date_time();
  inline void set_allocated_departure_date_time(::std::string* departure_date_time);

  // optional bool assumed_schedule = 6;
  inline bool has_assumed_schedule() const;
  inline void clear_assumed_schedule();
  static const int kAssumedScheduleFieldNumber = 6;
  inline bool assumed_schedule() const;
  inline void set_assumed_schedule(bool value);

  // optional .valhalla.LatLng ll = 7;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 7;
  inline const ::valhalla::LatLng& ll() const;
  inline ::valhalla::LatLng* mutable_ll();
  inline ::valhalla::LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::LatLng* ll);

  // optional string station_onestop_id = 8;
  inline bool has_station_onestop_id() const;
  inline void clear_station_onestop_id();
  static const int kStationOnestopIdFieldNumber = 8;
  inline const ::std::string& station_onestop_id() const;
  inline void set_station_onestop_id(const ::std::string& value);
  inline void set_station_onestop_id(const char* value);
  inline void set_station_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_station_onestop_id();
  inline ::std::string* release_station_onestop_id();
  inline void set_allocated_station_onestop_id(::std::string* station_onestop_id);

  // optional string station_name = 9;
  inline bool has_station_name() const;
  inline void clear_station_name();
  static const int kStationNameFieldNumber = 9;
  inline const ::std::string& station_name() const;
  inline void set_station_name(const ::std::string& value);
  inline void set_station_name(const char* value);
  inline void set_station_name(const char* value, size_t size);
  inline ::std::string* mutable_station_name();
  inline ::std::string* release_station_name();
  inline void set_allocated_station_name(::std::string* station_name);

  // @@protoc_insertion_point(class_scope:valhalla.TransitPlatformInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_arrival_date_time();
  inline void clear_has_arrival_date_time();
  inline void set_has_departure_date_time();
  inline void clear_has_departure_date_time();
  inline void set_has_assumed_schedule();
  inline void clear_has_assumed_schedule();
  inline void set_has_ll();
  inline void clear_has_ll();
  inline void set_has_station_onestop_id();
  inline void clear_has_station_onestop_id();
  inline void set_has_station_name();
  inline void clear_has_station_name();

  ::std::string* onestop_id_;
  ::std::string* name_;
  int type_;
  bool assumed_schedule_;
  ::std::string* arrival_date_time_;
  ::std::string* departure_date_time_;
  ::valhalla::LatLng* ll_;
  ::std::string* station_onestop_id_;
  ::std::string* station_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static TransitPlatformInfo* default_instance_;
};
// -------------------------------------------------------------------

class StreetName : public ::google::protobuf::MessageLite {
 public:
  StreetName();
  virtual ~StreetName();

  StreetName(const StreetName& from);

  inline StreetName& operator=(const StreetName& from) {
    CopyFrom(from);
    return *this;
  }

  static const StreetName& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StreetName* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StreetName* other);

  // implements Message ----------------------------------------------

  StreetName* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StreetName& from);
  void MergeFrom(const StreetName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bool is_route_number = 2;
  inline bool has_is_route_number() const;
  inline void clear_is_route_number();
  static const int kIsRouteNumberFieldNumber = 2;
  inline bool is_route_number() const;
  inline void set_is_route_number(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.StreetName)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_is_route_number();
  inline void clear_has_is_route_number();

  ::std::string* value_;
  bool is_route_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static StreetName* default_instance_;
};
// -------------------------------------------------------------------

class TurnLane : public ::google::protobuf::MessageLite {
 public:
  TurnLane();
  virtual ~TurnLane();

  TurnLane(const TurnLane& from);

  inline TurnLane& operator=(const TurnLane& from) {
    CopyFrom(from);
    return *this;
  }

  static const TurnLane& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TurnLane* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TurnLane* other);

  // implements Message ----------------------------------------------

  TurnLane* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TurnLane& from);
  void MergeFrom(const TurnLane& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 directions_mask = 1;
  inline bool has_directions_mask() const;
  inline void clear_directions_mask();
  static const int kDirectionsMaskFieldNumber = 1;
  inline ::google::protobuf::uint32 directions_mask() const;
  inline void set_directions_mask(::google::protobuf::uint32 value);

  // optional bool is_active = 2;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 2;
  inline bool is_active() const;
  inline void set_is_active(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.TurnLane)
 private:
  inline void set_has_directions_mask();
  inline void clear_has_directions_mask();
  inline void set_has_is_active();
  inline void clear_has_is_active();

  ::google::protobuf::uint32 directions_mask_;
  bool is_active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_tripcommon_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_tripcommon_2eproto();
  #endif
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static TurnLane* default_instance_;
};
// ===================================================================


// ===================================================================

// LatLng

// optional float lat = 1;
inline bool LatLng::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatLng::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatLng::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatLng::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float LatLng::lat() const {
  return lat_;
}
inline void LatLng::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lng = 2;
inline bool LatLng::has_lng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatLng::set_has_lng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatLng::clear_has_lng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatLng::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline float LatLng::lng() const {
  return lng_;
}
inline void LatLng::set_lng(float value) {
  set_has_lng();
  lng_ = value;
}

// -------------------------------------------------------------------

// BoundingBox

// optional .valhalla.LatLng min_ll = 1;
inline bool BoundingBox::has_min_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundingBox::set_has_min_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundingBox::clear_has_min_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundingBox::clear_min_ll() {
  if (min_ll_ != NULL) min_ll_->::valhalla::LatLng::Clear();
  clear_has_min_ll();
}
inline const ::valhalla::LatLng& BoundingBox::min_ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return min_ll_ != NULL ? *min_ll_ : *default_instance().min_ll_;
#else
  return min_ll_ != NULL ? *min_ll_ : *default_instance_->min_ll_;
#endif
}
inline ::valhalla::LatLng* BoundingBox::mutable_min_ll() {
  set_has_min_ll();
  if (min_ll_ == NULL) min_ll_ = new ::valhalla::LatLng;
  return min_ll_;
}
inline ::valhalla::LatLng* BoundingBox::release_min_ll() {
  clear_has_min_ll();
  ::valhalla::LatLng* temp = min_ll_;
  min_ll_ = NULL;
  return temp;
}
inline void BoundingBox::set_allocated_min_ll(::valhalla::LatLng* min_ll) {
  delete min_ll_;
  min_ll_ = min_ll;
  if (min_ll) {
    set_has_min_ll();
  } else {
    clear_has_min_ll();
  }
}

// optional .valhalla.LatLng max_ll = 2;
inline bool BoundingBox::has_max_ll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundingBox::set_has_max_ll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundingBox::clear_has_max_ll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundingBox::clear_max_ll() {
  if (max_ll_ != NULL) max_ll_->::valhalla::LatLng::Clear();
  clear_has_max_ll();
}
inline const ::valhalla::LatLng& BoundingBox::max_ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return max_ll_ != NULL ? *max_ll_ : *default_instance().max_ll_;
#else
  return max_ll_ != NULL ? *max_ll_ : *default_instance_->max_ll_;
#endif
}
inline ::valhalla::LatLng* BoundingBox::mutable_max_ll() {
  set_has_max_ll();
  if (max_ll_ == NULL) max_ll_ = new ::valhalla::LatLng;
  return max_ll_;
}
inline ::valhalla::LatLng* BoundingBox::release_max_ll() {
  clear_has_max_ll();
  ::valhalla::LatLng* temp = max_ll_;
  max_ll_ = NULL;
  return temp;
}
inline void BoundingBox::set_allocated_max_ll(::valhalla::LatLng* max_ll) {
  delete max_ll_;
  max_ll_ = max_ll;
  if (max_ll) {
    set_has_max_ll();
  } else {
    clear_has_max_ll();
  }
}

// -------------------------------------------------------------------

// Location_PathEdge

// optional uint64 graph_id = 1;
inline bool Location_PathEdge::has_graph_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location_PathEdge::set_has_graph_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location_PathEdge::clear_has_graph_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location_PathEdge::clear_graph_id() {
  graph_id_ = GOOGLE_ULONGLONG(0);
  clear_has_graph_id();
}
inline ::google::protobuf::uint64 Location_PathEdge::graph_id() const {
  return graph_id_;
}
inline void Location_PathEdge::set_graph_id(::google::protobuf::uint64 value) {
  set_has_graph_id();
  graph_id_ = value;
}

// optional float percent_along = 2;
inline bool Location_PathEdge::has_percent_along() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location_PathEdge::set_has_percent_along() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location_PathEdge::clear_has_percent_along() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location_PathEdge::clear_percent_along() {
  percent_along_ = 0;
  clear_has_percent_along();
}
inline float Location_PathEdge::percent_along() const {
  return percent_along_;
}
inline void Location_PathEdge::set_percent_along(float value) {
  set_has_percent_along();
  percent_along_ = value;
}

// optional .valhalla.LatLng ll = 3;
inline bool Location_PathEdge::has_ll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location_PathEdge::set_has_ll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location_PathEdge::clear_has_ll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location_PathEdge::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::LatLng& Location_PathEdge::ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ll_ != NULL ? *ll_ : *default_instance().ll_;
#else
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
#endif
}
inline ::valhalla::LatLng* Location_PathEdge::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::LatLng;
  return ll_;
}
inline ::valhalla::LatLng* Location_PathEdge::release_ll() {
  clear_has_ll();
  ::valhalla::LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void Location_PathEdge::set_allocated_ll(::valhalla::LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// optional .valhalla.Location.SideOfStreet side_of_street = 4;
inline bool Location_PathEdge::has_side_of_street() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location_PathEdge::set_has_side_of_street() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location_PathEdge::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location_PathEdge::clear_side_of_street() {
  side_of_street_ = 0;
  clear_has_side_of_street();
}
inline ::valhalla::Location_SideOfStreet Location_PathEdge::side_of_street() const {
  return static_cast< ::valhalla::Location_SideOfStreet >(side_of_street_);
}
inline void Location_PathEdge::set_side_of_street(::valhalla::Location_SideOfStreet value) {
  assert(::valhalla::Location_SideOfStreet_IsValid(value));
  set_has_side_of_street();
  side_of_street_ = value;
}

// optional float distance = 5;
inline bool Location_PathEdge::has_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location_PathEdge::set_has_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location_PathEdge::clear_has_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location_PathEdge::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline float Location_PathEdge::distance() const {
  return distance_;
}
inline void Location_PathEdge::set_distance(float value) {
  set_has_distance();
  distance_ = value;
}

// optional int32 minimum_reachability = 6;
inline bool Location_PathEdge::has_minimum_reachability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Location_PathEdge::set_has_minimum_reachability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Location_PathEdge::clear_has_minimum_reachability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Location_PathEdge::clear_minimum_reachability() {
  minimum_reachability_ = 0;
  clear_has_minimum_reachability();
}
inline ::google::protobuf::int32 Location_PathEdge::minimum_reachability() const {
  return minimum_reachability_;
}
inline void Location_PathEdge::set_minimum_reachability(::google::protobuf::int32 value) {
  set_has_minimum_reachability();
  minimum_reachability_ = value;
}

// optional bool begin_node = 7;
inline bool Location_PathEdge::has_begin_node() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Location_PathEdge::set_has_begin_node() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Location_PathEdge::clear_has_begin_node() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Location_PathEdge::clear_begin_node() {
  begin_node_ = false;
  clear_has_begin_node();
}
inline bool Location_PathEdge::begin_node() const {
  return begin_node_;
}
inline void Location_PathEdge::set_begin_node(bool value) {
  set_has_begin_node();
  begin_node_ = value;
}

// optional bool end_node = 8;
inline bool Location_PathEdge::has_end_node() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Location_PathEdge::set_has_end_node() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Location_PathEdge::clear_has_end_node() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Location_PathEdge::clear_end_node() {
  end_node_ = false;
  clear_has_end_node();
}
inline bool Location_PathEdge::end_node() const {
  return end_node_;
}
inline void Location_PathEdge::set_end_node(bool value) {
  set_has_end_node();
  end_node_ = value;
}

// repeated string names = 10;
inline int Location_PathEdge::names_size() const {
  return names_.size();
}
inline void Location_PathEdge::clear_names() {
  names_.Clear();
}
inline const ::std::string& Location_PathEdge::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* Location_PathEdge::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void Location_PathEdge::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void Location_PathEdge::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void Location_PathEdge::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location_PathEdge::add_names() {
  return names_.Add();
}
inline void Location_PathEdge::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void Location_PathEdge::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void Location_PathEdge::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Location_PathEdge::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Location_PathEdge::mutable_names() {
  return &names_;
}

// optional int32 outbound_reach = 11;
inline bool Location_PathEdge::has_outbound_reach() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Location_PathEdge::set_has_outbound_reach() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Location_PathEdge::clear_has_outbound_reach() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Location_PathEdge::clear_outbound_reach() {
  outbound_reach_ = 0;
  clear_has_outbound_reach();
}
inline ::google::protobuf::int32 Location_PathEdge::outbound_reach() const {
  return outbound_reach_;
}
inline void Location_PathEdge::set_outbound_reach(::google::protobuf::int32 value) {
  set_has_outbound_reach();
  outbound_reach_ = value;
}

// optional int32 inbound_reach = 12;
inline bool Location_PathEdge::has_inbound_reach() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Location_PathEdge::set_has_inbound_reach() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Location_PathEdge::clear_has_inbound_reach() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Location_PathEdge::clear_inbound_reach() {
  inbound_reach_ = 0;
  clear_has_inbound_reach();
}
inline ::google::protobuf::int32 Location_PathEdge::inbound_reach() const {
  return inbound_reach_;
}
inline void Location_PathEdge::set_inbound_reach(::google::protobuf::int32 value) {
  set_has_inbound_reach();
  inbound_reach_ = value;
}

// -------------------------------------------------------------------

// Location

// optional .valhalla.LatLng ll = 1;
inline bool Location::has_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::LatLng& Location::ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ll_ != NULL ? *ll_ : *default_instance().ll_;
#else
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
#endif
}
inline ::valhalla::LatLng* Location::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::LatLng;
  return ll_;
}
inline ::valhalla::LatLng* Location::release_ll() {
  clear_has_ll();
  ::valhalla::LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void Location::set_allocated_ll(::valhalla::LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// optional .valhalla.Location.Type type = 2 [default = kBreak];
inline bool Location::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::Location_Type Location::type() const {
  return static_cast< ::valhalla::Location_Type >(type_);
}
inline void Location::set_type(::valhalla::Location_Type value) {
  assert(::valhalla::Location_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 heading = 3;
inline bool Location::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location::clear_heading() {
  heading_ = 0u;
  clear_has_heading();
}
inline ::google::protobuf::uint32 Location::heading() const {
  return heading_;
}
inline void Location::set_heading(::google::protobuf::uint32 value) {
  set_has_heading();
  heading_ = value;
}

// optional string name = 4;
inline bool Location::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Location::name() const {
  return *name_;
}
inline void Location::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Location::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Location::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Location::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string street = 5;
inline bool Location::has_street() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location::set_has_street() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location::clear_has_street() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& Location::street() const {
  return *street_;
}
inline void Location::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void Location::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void Location::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* Location::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 6;
inline bool Location::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Location::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Location::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Location::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Location::city() const {
  return *city_;
}
inline void Location::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Location::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Location::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* Location::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 7;
inline bool Location::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Location::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Location::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Location::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Location::state() const {
  return *state_;
}
inline void Location::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Location::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Location::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* Location::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string postal_code = 8;
inline bool Location::has_postal_code() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Location::set_has_postal_code() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Location::clear_has_postal_code() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Location::clear_postal_code() {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    postal_code_->clear();
  }
  clear_has_postal_code();
}
inline const ::std::string& Location::postal_code() const {
  return *postal_code_;
}
inline void Location::set_postal_code(const ::std::string& value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void Location::set_postal_code(const char* value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void Location::set_postal_code(const char* value, size_t size) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_postal_code() {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  return postal_code_;
}
inline ::std::string* Location::release_postal_code() {
  clear_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postal_code_;
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_postal_code(::std::string* postal_code) {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    delete postal_code_;
  }
  if (postal_code) {
    set_has_postal_code();
    postal_code_ = postal_code;
  } else {
    clear_has_postal_code();
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country = 9;
inline bool Location::has_country() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Location::set_has_country() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Location::clear_has_country() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Location::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& Location::country() const {
  return *country_;
}
inline void Location::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void Location::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void Location::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* Location::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 10;
inline bool Location::has_phone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Location::set_has_phone() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Location::clear_has_phone() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Location::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& Location::phone() const {
  return *phone_;
}
inline void Location::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void Location::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void Location::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* Location::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 11;
inline bool Location::has_url() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Location::set_has_url() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Location::clear_has_url() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Location::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Location::url() const {
  return *url_;
}
inline void Location::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Location::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Location::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Location::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date_time = 12;
inline bool Location::has_date_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Location::set_has_date_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Location::clear_has_date_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Location::clear_date_time() {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    date_time_->clear();
  }
  clear_has_date_time();
}
inline const ::std::string& Location::date_time() const {
  return *date_time_;
}
inline void Location::set_date_time(const ::std::string& value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void Location::set_date_time(const char* value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void Location::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_date_time() {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  return date_time_;
}
inline ::std::string* Location::release_date_time() {
  clear_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_;
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_date_time(::std::string* date_time) {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_;
  }
  if (date_time) {
    set_has_date_time();
    date_time_ = date_time;
  } else {
    clear_has_date_time();
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.Location.SideOfStreet side_of_street = 13;
inline bool Location::has_side_of_street() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Location::set_has_side_of_street() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Location::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Location::clear_side_of_street() {
  side_of_street_ = 0;
  clear_has_side_of_street();
}
inline ::valhalla::Location_SideOfStreet Location::side_of_street() const {
  return static_cast< ::valhalla::Location_SideOfStreet >(side_of_street_);
}
inline void Location::set_side_of_street(::valhalla::Location_SideOfStreet value) {
  assert(::valhalla::Location_SideOfStreet_IsValid(value));
  set_has_side_of_street();
  side_of_street_ = value;
}

// optional uint32 heading_tolerance = 14;
inline bool Location::has_heading_tolerance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Location::set_has_heading_tolerance() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Location::clear_has_heading_tolerance() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Location::clear_heading_tolerance() {
  heading_tolerance_ = 0u;
  clear_has_heading_tolerance();
}
inline ::google::protobuf::uint32 Location::heading_tolerance() const {
  return heading_tolerance_;
}
inline void Location::set_heading_tolerance(::google::protobuf::uint32 value) {
  set_has_heading_tolerance();
  heading_tolerance_ = value;
}

// optional uint32 node_snap_tolerance = 15;
inline bool Location::has_node_snap_tolerance() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Location::set_has_node_snap_tolerance() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Location::clear_has_node_snap_tolerance() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Location::clear_node_snap_tolerance() {
  node_snap_tolerance_ = 0u;
  clear_has_node_snap_tolerance();
}
inline ::google::protobuf::uint32 Location::node_snap_tolerance() const {
  return node_snap_tolerance_;
}
inline void Location::set_node_snap_tolerance(::google::protobuf::uint32 value) {
  set_has_node_snap_tolerance();
  node_snap_tolerance_ = value;
}

// optional uint64 way_id = 16;
inline bool Location::has_way_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Location::set_has_way_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Location::clear_has_way_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Location::clear_way_id() {
  way_id_ = GOOGLE_ULONGLONG(0);
  clear_has_way_id();
}
inline ::google::protobuf::uint64 Location::way_id() const {
  return way_id_;
}
inline void Location::set_way_id(::google::protobuf::uint64 value) {
  set_has_way_id();
  way_id_ = value;
}

// optional uint32 minimum_reachability = 17;
inline bool Location::has_minimum_reachability() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Location::set_has_minimum_reachability() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Location::clear_has_minimum_reachability() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Location::clear_minimum_reachability() {
  minimum_reachability_ = 0u;
  clear_has_minimum_reachability();
}
inline ::google::protobuf::uint32 Location::minimum_reachability() const {
  return minimum_reachability_;
}
inline void Location::set_minimum_reachability(::google::protobuf::uint32 value) {
  set_has_minimum_reachability();
  minimum_reachability_ = value;
}

// optional uint32 radius = 18;
inline bool Location::has_radius() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Location::set_has_radius() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Location::clear_has_radius() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Location::clear_radius() {
  radius_ = 0u;
  clear_has_radius();
}
inline ::google::protobuf::uint32 Location::radius() const {
  return radius_;
}
inline void Location::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
}

// optional uint32 accuracy = 19;
inline bool Location::has_accuracy() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Location::set_has_accuracy() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Location::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Location::clear_accuracy() {
  accuracy_ = 0u;
  clear_has_accuracy();
}
inline ::google::protobuf::uint32 Location::accuracy() const {
  return accuracy_;
}
inline void Location::set_accuracy(::google::protobuf::uint32 value) {
  set_has_accuracy();
  accuracy_ = value;
}

// optional double time = 20 [default = -1];
inline bool Location::has_time() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Location::set_has_time() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Location::clear_has_time() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Location::clear_time() {
  time_ = -1;
  clear_has_time();
}
inline double Location::time() const {
  return time_;
}
inline void Location::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional bool rank_candidates = 21 [default = true];
inline bool Location::has_rank_candidates() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Location::set_has_rank_candidates() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Location::clear_has_rank_candidates() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Location::clear_rank_candidates() {
  rank_candidates_ = true;
  clear_has_rank_candidates();
}
inline bool Location::rank_candidates() const {
  return rank_candidates_;
}
inline void Location::set_rank_candidates(bool value) {
  set_has_rank_candidates();
  rank_candidates_ = value;
}

// repeated .valhalla.Location.PathEdge path_edges = 22;
inline int Location::path_edges_size() const {
  return path_edges_.size();
}
inline void Location::clear_path_edges() {
  path_edges_.Clear();
}
inline const ::valhalla::Location_PathEdge& Location::path_edges(int index) const {
  return path_edges_.Get(index);
}
inline ::valhalla::Location_PathEdge* Location::mutable_path_edges(int index) {
  return path_edges_.Mutable(index);
}
inline ::valhalla::Location_PathEdge* Location::add_path_edges() {
  return path_edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >&
Location::path_edges() const {
  return path_edges_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >*
Location::mutable_path_edges() {
  return &path_edges_;
}

// repeated .valhalla.Location.PathEdge filtered_edges = 23;
inline int Location::filtered_edges_size() const {
  return filtered_edges_.size();
}
inline void Location::clear_filtered_edges() {
  filtered_edges_.Clear();
}
inline const ::valhalla::Location_PathEdge& Location::filtered_edges(int index) const {
  return filtered_edges_.Get(index);
}
inline ::valhalla::Location_PathEdge* Location::mutable_filtered_edges(int index) {
  return filtered_edges_.Mutable(index);
}
inline ::valhalla::Location_PathEdge* Location::add_filtered_edges() {
  return filtered_edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >&
Location::filtered_edges() const {
  return filtered_edges_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location_PathEdge >*
Location::mutable_filtered_edges() {
  return &filtered_edges_;
}

// optional uint32 original_index = 24;
inline bool Location::has_original_index() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Location::set_has_original_index() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Location::clear_has_original_index() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Location::clear_original_index() {
  original_index_ = 0u;
  clear_has_original_index();
}
inline ::google::protobuf::uint32 Location::original_index() const {
  return original_index_;
}
inline void Location::set_original_index(::google::protobuf::uint32 value) {
  set_has_original_index();
  original_index_ = value;
}

// optional .valhalla.LatLng projected_ll = 25;
inline bool Location::has_projected_ll() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Location::set_has_projected_ll() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Location::clear_has_projected_ll() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Location::clear_projected_ll() {
  if (projected_ll_ != NULL) projected_ll_->::valhalla::LatLng::Clear();
  clear_has_projected_ll();
}
inline const ::valhalla::LatLng& Location::projected_ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return projected_ll_ != NULL ? *projected_ll_ : *default_instance().projected_ll_;
#else
  return projected_ll_ != NULL ? *projected_ll_ : *default_instance_->projected_ll_;
#endif
}
inline ::valhalla::LatLng* Location::mutable_projected_ll() {
  set_has_projected_ll();
  if (projected_ll_ == NULL) projected_ll_ = new ::valhalla::LatLng;
  return projected_ll_;
}
inline ::valhalla::LatLng* Location::release_projected_ll() {
  clear_has_projected_ll();
  ::valhalla::LatLng* temp = projected_ll_;
  projected_ll_ = NULL;
  return temp;
}
inline void Location::set_allocated_projected_ll(::valhalla::LatLng* projected_ll) {
  delete projected_ll_;
  projected_ll_ = projected_ll;
  if (projected_ll) {
    set_has_projected_ll();
  } else {
    clear_has_projected_ll();
  }
}

// optional .valhalla.Location.PreferredSide preferred_side = 26 [default = either];
inline bool Location::has_preferred_side() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Location::set_has_preferred_side() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Location::clear_has_preferred_side() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Location::clear_preferred_side() {
  preferred_side_ = 0;
  clear_has_preferred_side();
}
inline ::valhalla::Location_PreferredSide Location::preferred_side() const {
  return static_cast< ::valhalla::Location_PreferredSide >(preferred_side_);
}
inline void Location::set_preferred_side(::valhalla::Location_PreferredSide value) {
  assert(::valhalla::Location_PreferredSide_IsValid(value));
  set_has_preferred_side();
  preferred_side_ = value;
}

// optional uint32 search_cutoff = 28;
inline bool Location::has_search_cutoff() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Location::set_has_search_cutoff() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Location::clear_has_search_cutoff() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Location::clear_search_cutoff() {
  search_cutoff_ = 0u;
  clear_has_search_cutoff();
}
inline ::google::protobuf::uint32 Location::search_cutoff() const {
  return search_cutoff_;
}
inline void Location::set_search_cutoff(::google::protobuf::uint32 value) {
  set_has_search_cutoff();
  search_cutoff_ = value;
}

// optional uint32 street_side_tolerance = 29;
inline bool Location::has_street_side_tolerance() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Location::set_has_street_side_tolerance() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Location::clear_has_street_side_tolerance() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Location::clear_street_side_tolerance() {
  street_side_tolerance_ = 0u;
  clear_has_street_side_tolerance();
}
inline ::google::protobuf::uint32 Location::street_side_tolerance() const {
  return street_side_tolerance_;
}
inline void Location::set_street_side_tolerance(::google::protobuf::uint32 value) {
  set_has_street_side_tolerance();
  street_side_tolerance_ = value;
}

// -------------------------------------------------------------------

// TransitEgressInfo

// optional string onestop_id = 1;
inline bool TransitEgressInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitEgressInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitEgressInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitEgressInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TransitEgressInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TransitEgressInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TransitEgressInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TransitEgressInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitEgressInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TransitEgressInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitEgressInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TransitEgressInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitEgressInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitEgressInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitEgressInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TransitEgressInfo::name() const {
  return *name_;
}
inline void TransitEgressInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransitEgressInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransitEgressInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitEgressInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TransitEgressInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitEgressInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.LatLng ll = 3;
inline bool TransitEgressInfo::has_ll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitEgressInfo::set_has_ll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitEgressInfo::clear_has_ll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitEgressInfo::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::LatLng& TransitEgressInfo::ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ll_ != NULL ? *ll_ : *default_instance().ll_;
#else
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
#endif
}
inline ::valhalla::LatLng* TransitEgressInfo::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::LatLng;
  return ll_;
}
inline ::valhalla::LatLng* TransitEgressInfo::release_ll() {
  clear_has_ll();
  ::valhalla::LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TransitEgressInfo::set_allocated_ll(::valhalla::LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// -------------------------------------------------------------------

// TransitStationInfo

// optional string onestop_id = 1;
inline bool TransitStationInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitStationInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitStationInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitStationInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TransitStationInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TransitStationInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TransitStationInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TransitStationInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitStationInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TransitStationInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitStationInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool TransitStationInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitStationInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitStationInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitStationInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TransitStationInfo::name() const {
  return *name_;
}
inline void TransitStationInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransitStationInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransitStationInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitStationInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TransitStationInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitStationInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.LatLng ll = 3;
inline bool TransitStationInfo::has_ll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitStationInfo::set_has_ll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitStationInfo::clear_has_ll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitStationInfo::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::LatLng& TransitStationInfo::ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ll_ != NULL ? *ll_ : *default_instance().ll_;
#else
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
#endif
}
inline ::valhalla::LatLng* TransitStationInfo::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::LatLng;
  return ll_;
}
inline ::valhalla::LatLng* TransitStationInfo::release_ll() {
  clear_has_ll();
  ::valhalla::LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TransitStationInfo::set_allocated_ll(::valhalla::LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// -------------------------------------------------------------------

// TransitPlatformInfo

// optional .valhalla.TransitPlatformInfo.Type type = 1;
inline bool TransitPlatformInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitPlatformInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitPlatformInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitPlatformInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::TransitPlatformInfo_Type TransitPlatformInfo::type() const {
  return static_cast< ::valhalla::TransitPlatformInfo_Type >(type_);
}
inline void TransitPlatformInfo::set_type(::valhalla::TransitPlatformInfo_Type value) {
  assert(::valhalla::TransitPlatformInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string onestop_id = 2;
inline bool TransitPlatformInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitPlatformInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitPlatformInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitPlatformInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TransitPlatformInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TransitPlatformInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TransitPlatformInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TransitPlatformInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitPlatformInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TransitPlatformInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitPlatformInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TransitPlatformInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitPlatformInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitPlatformInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitPlatformInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TransitPlatformInfo::name() const {
  return *name_;
}
inline void TransitPlatformInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransitPlatformInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TransitPlatformInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitPlatformInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TransitPlatformInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitPlatformInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrival_date_time = 4;
inline bool TransitPlatformInfo::has_arrival_date_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransitPlatformInfo::set_has_arrival_date_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransitPlatformInfo::clear_has_arrival_date_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransitPlatformInfo::clear_arrival_date_time() {
  if (arrival_date_time_ != &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_->clear();
  }
  clear_has_arrival_date_time();
}
inline const ::std::string& TransitPlatformInfo::arrival_date_time() const {
  return *arrival_date_time_;
}
inline void TransitPlatformInfo::set_arrival_date_time(const ::std::string& value) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(value);
}
inline void TransitPlatformInfo::set_arrival_date_time(const char* value) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(value);
}
inline void TransitPlatformInfo::set_arrival_date_time(const char* value, size_t size) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitPlatformInfo::mutable_arrival_date_time() {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  return arrival_date_time_;
}
inline ::std::string* TransitPlatformInfo::release_arrival_date_time() {
  clear_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrival_date_time_;
    arrival_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitPlatformInfo::set_allocated_arrival_date_time(::std::string* arrival_date_time) {
  if (arrival_date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete arrival_date_time_;
  }
  if (arrival_date_time) {
    set_has_arrival_date_time();
    arrival_date_time_ = arrival_date_time;
  } else {
    clear_has_arrival_date_time();
    arrival_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string departure_date_time = 5;
inline bool TransitPlatformInfo::has_departure_date_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransitPlatformInfo::set_has_departure_date_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransitPlatformInfo::clear_has_departure_date_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransitPlatformInfo::clear_departure_date_time() {
  if (departure_date_time_ != &::google::protobuf::internal::kEmptyString) {
    departure_date_time_->clear();
  }
  clear_has_departure_date_time();
}
inline const ::std::string& TransitPlatformInfo::departure_date_time() const {
  return *departure_date_time_;
}
inline void TransitPlatformInfo::set_departure_date_time(const ::std::string& value) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(value);
}
inline void TransitPlatformInfo::set_departure_date_time(const char* value) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(value);
}
inline void TransitPlatformInfo::set_departure_date_time(const char* value, size_t size) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitPlatformInfo::mutable_departure_date_time() {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  return departure_date_time_;
}
inline ::std::string* TransitPlatformInfo::release_departure_date_time() {
  clear_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departure_date_time_;
    departure_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitPlatformInfo::set_allocated_departure_date_time(::std::string* departure_date_time) {
  if (departure_date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete departure_date_time_;
  }
  if (departure_date_time) {
    set_has_departure_date_time();
    departure_date_time_ = departure_date_time;
  } else {
    clear_has_departure_date_time();
    departure_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool assumed_schedule = 6;
inline bool TransitPlatformInfo::has_assumed_schedule() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransitPlatformInfo::set_has_assumed_schedule() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransitPlatformInfo::clear_has_assumed_schedule() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransitPlatformInfo::clear_assumed_schedule() {
  assumed_schedule_ = false;
  clear_has_assumed_schedule();
}
inline bool TransitPlatformInfo::assumed_schedule() const {
  return assumed_schedule_;
}
inline void TransitPlatformInfo::set_assumed_schedule(bool value) {
  set_has_assumed_schedule();
  assumed_schedule_ = value;
}

// optional .valhalla.LatLng ll = 7;
inline bool TransitPlatformInfo::has_ll() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransitPlatformInfo::set_has_ll() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransitPlatformInfo::clear_has_ll() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransitPlatformInfo::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::LatLng& TransitPlatformInfo::ll() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ll_ != NULL ? *ll_ : *default_instance().ll_;
#else
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
#endif
}
inline ::valhalla::LatLng* TransitPlatformInfo::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::LatLng;
  return ll_;
}
inline ::valhalla::LatLng* TransitPlatformInfo::release_ll() {
  clear_has_ll();
  ::valhalla::LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TransitPlatformInfo::set_allocated_ll(::valhalla::LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// optional string station_onestop_id = 8;
inline bool TransitPlatformInfo::has_station_onestop_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransitPlatformInfo::set_has_station_onestop_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransitPlatformInfo::clear_has_station_onestop_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransitPlatformInfo::clear_station_onestop_id() {
  if (station_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    station_onestop_id_->clear();
  }
  clear_has_station_onestop_id();
}
inline const ::std::string& TransitPlatformInfo::station_onestop_id() const {
  return *station_onestop_id_;
}
inline void TransitPlatformInfo::set_station_onestop_id(const ::std::string& value) {
  set_has_station_onestop_id();
  if (station_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    station_onestop_id_ = new ::std::string;
  }
  station_onestop_id_->assign(value);
}
inline void TransitPlatformInfo::set_station_onestop_id(const char* value) {
  set_has_station_onestop_id();
  if (station_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    station_onestop_id_ = new ::std::string;
  }
  station_onestop_id_->assign(value);
}
inline void TransitPlatformInfo::set_station_onestop_id(const char* value, size_t size) {
  set_has_station_onestop_id();
  if (station_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    station_onestop_id_ = new ::std::string;
  }
  station_onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitPlatformInfo::mutable_station_onestop_id() {
  set_has_station_onestop_id();
  if (station_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    station_onestop_id_ = new ::std::string;
  }
  return station_onestop_id_;
}
inline ::std::string* TransitPlatformInfo::release_station_onestop_id() {
  clear_has_station_onestop_id();
  if (station_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = station_onestop_id_;
    station_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitPlatformInfo::set_allocated_station_onestop_id(::std::string* station_onestop_id) {
  if (station_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete station_onestop_id_;
  }
  if (station_onestop_id) {
    set_has_station_onestop_id();
    station_onestop_id_ = station_onestop_id;
  } else {
    clear_has_station_onestop_id();
    station_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string station_name = 9;
inline bool TransitPlatformInfo::has_station_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransitPlatformInfo::set_has_station_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransitPlatformInfo::clear_has_station_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransitPlatformInfo::clear_station_name() {
  if (station_name_ != &::google::protobuf::internal::kEmptyString) {
    station_name_->clear();
  }
  clear_has_station_name();
}
inline const ::std::string& TransitPlatformInfo::station_name() const {
  return *station_name_;
}
inline void TransitPlatformInfo::set_station_name(const ::std::string& value) {
  set_has_station_name();
  if (station_name_ == &::google::protobuf::internal::kEmptyString) {
    station_name_ = new ::std::string;
  }
  station_name_->assign(value);
}
inline void TransitPlatformInfo::set_station_name(const char* value) {
  set_has_station_name();
  if (station_name_ == &::google::protobuf::internal::kEmptyString) {
    station_name_ = new ::std::string;
  }
  station_name_->assign(value);
}
inline void TransitPlatformInfo::set_station_name(const char* value, size_t size) {
  set_has_station_name();
  if (station_name_ == &::google::protobuf::internal::kEmptyString) {
    station_name_ = new ::std::string;
  }
  station_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransitPlatformInfo::mutable_station_name() {
  set_has_station_name();
  if (station_name_ == &::google::protobuf::internal::kEmptyString) {
    station_name_ = new ::std::string;
  }
  return station_name_;
}
inline ::std::string* TransitPlatformInfo::release_station_name() {
  clear_has_station_name();
  if (station_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = station_name_;
    station_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitPlatformInfo::set_allocated_station_name(::std::string* station_name) {
  if (station_name_ != &::google::protobuf::internal::kEmptyString) {
    delete station_name_;
  }
  if (station_name) {
    set_has_station_name();
    station_name_ = station_name;
  } else {
    clear_has_station_name();
    station_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// StreetName

// optional string value = 1;
inline bool StreetName::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreetName::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreetName::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreetName::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StreetName::value() const {
  return *value_;
}
inline void StreetName::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StreetName::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void StreetName::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StreetName::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* StreetName::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StreetName::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_route_number = 2;
inline bool StreetName::has_is_route_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreetName::set_has_is_route_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreetName::clear_has_is_route_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreetName::clear_is_route_number() {
  is_route_number_ = false;
  clear_has_is_route_number();
}
inline bool StreetName::is_route_number() const {
  return is_route_number_;
}
inline void StreetName::set_is_route_number(bool value) {
  set_has_is_route_number();
  is_route_number_ = value;
}

// -------------------------------------------------------------------

// TurnLane

// optional uint32 directions_mask = 1;
inline bool TurnLane::has_directions_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TurnLane::set_has_directions_mask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TurnLane::clear_has_directions_mask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TurnLane::clear_directions_mask() {
  directions_mask_ = 0u;
  clear_has_directions_mask();
}
inline ::google::protobuf::uint32 TurnLane::directions_mask() const {
  return directions_mask_;
}
inline void TurnLane::set_directions_mask(::google::protobuf::uint32 value) {
  set_has_directions_mask();
  directions_mask_ = value;
}

// optional bool is_active = 2;
inline bool TurnLane::has_is_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TurnLane::set_has_is_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TurnLane::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TurnLane::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool TurnLane::is_active() const {
  return is_active_;
}
inline void TurnLane::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tripcommon_2eproto__INCLUDED
