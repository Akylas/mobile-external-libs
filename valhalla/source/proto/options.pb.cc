// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "options.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace valhalla {

void protobuf_ShutdownFile_options_2eproto() {
  delete Contour::default_instance_;
  delete CostingOptions::default_instance_;
  delete AvoidEdge::default_instance_;
  delete Options::default_instance_;
  delete Options::_default_language_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_options_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_options_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::valhalla::protobuf_AddDesc_tripcommon_2eproto();
  Contour::default_instance_ = new Contour();
  CostingOptions::default_instance_ = new CostingOptions();
  AvoidEdge::default_instance_ = new AvoidEdge();
  Options::_default_language_ =
      new ::std::string("en-US", 5);
  Options::default_instance_ = new Options();
  Contour::default_instance_->InitAsDefaultInstance();
  CostingOptions::default_instance_->InitAsDefaultInstance();
  AvoidEdge::default_instance_->InitAsDefaultInstance();
  Options::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_options_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_options_2eproto_once_);
void protobuf_AddDesc_options_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_options_2eproto_once_,
                 &protobuf_AddDesc_options_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_options_2eproto {
  StaticDescriptorInitializer_options_2eproto() {
    protobuf_AddDesc_options_2eproto();
  }
} static_descriptor_initializer_options_2eproto_;
#endif
bool ShapeMatch_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool FilterAction_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool DirectionsType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ShapeFormat_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool Costing_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Contour::kTimeFieldNumber;
const int Contour::kColorFieldNumber;
#endif  // !_MSC_VER

Contour::Contour()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Contour::InitAsDefaultInstance() {
}

Contour::Contour(const Contour& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Contour::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Contour::~Contour() {
  SharedDtor();
}

void Contour::SharedDtor() {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    delete color_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Contour::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Contour& Contour::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_options_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_options_2eproto();
#endif
  return *default_instance_;
}

Contour* Contour::default_instance_ = NULL;

Contour* Contour::New() const {
  return new Contour;
}

void Contour::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_color()) {
      if (color_ != &::google::protobuf::internal::kEmptyString) {
        color_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Contour::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_color;
        break;
      }

      // optional string color = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_color:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_color()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Contour::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->time(), output);
  }

  // optional string color = 2;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->color(), output);
  }

}

int Contour::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float time = 1;
    if (has_time()) {
      total_size += 1 + 4;
    }

    // optional string color = 2;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->color());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Contour::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Contour*>(&from));
}

void Contour::MergeFrom(const Contour& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
  }
}

void Contour::CopyFrom(const Contour& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Contour::IsInitialized() const {

  return true;
}

void Contour::Swap(Contour* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(color_, other->color_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Contour::GetTypeName() const {
  return "valhalla.Contour";
}


// ===================================================================

#ifndef _MSC_VER
const int CostingOptions::kManeuverPenaltyFieldNumber;
const int CostingOptions::kDestinationOnlyPenaltyFieldNumber;
const int CostingOptions::kGateCostFieldNumber;
const int CostingOptions::kGatePenaltyFieldNumber;
const int CostingOptions::kTollBoothCostFieldNumber;
const int CostingOptions::kTollBoothPenaltyFieldNumber;
const int CostingOptions::kAlleyPenaltyFieldNumber;
const int CostingOptions::kCountryCrossingCostFieldNumber;
const int CostingOptions::kCountryCrossingPenaltyFieldNumber;
const int CostingOptions::kFerryCostFieldNumber;
const int CostingOptions::kAvoidBadSurfacesFieldNumber;
const int CostingOptions::kUseFerryFieldNumber;
const int CostingOptions::kUseHighwaysFieldNumber;
const int CostingOptions::kUseTollsFieldNumber;
const int CostingOptions::kUseRoadsFieldNumber;
const int CostingOptions::kMaxDistanceFieldNumber;
const int CostingOptions::kWalkingSpeedFieldNumber;
const int CostingOptions::kStepPenaltyFieldNumber;
const int CostingOptions::kMaxGradeFieldNumber;
const int CostingOptions::kMaxHikingDifficultyFieldNumber;
const int CostingOptions::kModeFactorFieldNumber;
const int CostingOptions::kWalkwayFactorFieldNumber;
const int CostingOptions::kSidewalkFactorFieldNumber;
const int CostingOptions::kAlleyFactorFieldNumber;
const int CostingOptions::kDrivewayFactorFieldNumber;
const int CostingOptions::kDrivewayPenaltyFieldNumber;
const int CostingOptions::kTransitStartEndMaxDistanceFieldNumber;
const int CostingOptions::kTransitTransferMaxDistanceFieldNumber;
const int CostingOptions::kTransportTypeFieldNumber;
const int CostingOptions::kTopSpeedFieldNumber;
const int CostingOptions::kUseHillsFieldNumber;
const int CostingOptions::kUsePrimaryFieldNumber;
const int CostingOptions::kUseTrailsFieldNumber;
const int CostingOptions::kLowClassPenaltyFieldNumber;
const int CostingOptions::kHazmatFieldNumber;
const int CostingOptions::kWeightFieldNumber;
const int CostingOptions::kAxleLoadFieldNumber;
const int CostingOptions::kHeightFieldNumber;
const int CostingOptions::kWidthFieldNumber;
const int CostingOptions::kLengthFieldNumber;
const int CostingOptions::kCyclingSpeedFieldNumber;
const int CostingOptions::kWheelchairFieldNumber;
const int CostingOptions::kBicycleFieldNumber;
const int CostingOptions::kUseBusFieldNumber;
const int CostingOptions::kUseRailFieldNumber;
const int CostingOptions::kUseTransfersFieldNumber;
const int CostingOptions::kTransferCostFieldNumber;
const int CostingOptions::kTransferPenaltyFieldNumber;
const int CostingOptions::kFilterStopActionFieldNumber;
const int CostingOptions::kFilterStopIdsFieldNumber;
const int CostingOptions::kFilterOperatorActionFieldNumber;
const int CostingOptions::kFilterOperatorIdsFieldNumber;
const int CostingOptions::kFilterRouteActionFieldNumber;
const int CostingOptions::kFilterRouteIdsFieldNumber;
const int CostingOptions::kFlowMaskFieldNumber;
#endif  // !_MSC_VER

CostingOptions::CostingOptions()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CostingOptions::InitAsDefaultInstance() {
}

CostingOptions::CostingOptions(const CostingOptions& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CostingOptions::SharedCtor() {
  _cached_size_ = 0;
  maneuver_penalty_ = 0;
  destination_only_penalty_ = 0;
  gate_cost_ = 0;
  gate_penalty_ = 0;
  toll_booth_cost_ = 0;
  toll_booth_penalty_ = 0;
  alley_penalty_ = 0;
  country_crossing_cost_ = 0;
  country_crossing_penalty_ = 0;
  ferry_cost_ = 0;
  avoid_bad_surfaces_ = 0;
  use_ferry_ = 0;
  use_highways_ = 0;
  use_tolls_ = 0;
  use_roads_ = 0;
  max_distance_ = 0u;
  walking_speed_ = 0;
  step_penalty_ = 0;
  max_grade_ = 0u;
  max_hiking_difficulty_ = 0u;
  mode_factor_ = 0;
  walkway_factor_ = 0;
  sidewalk_factor_ = 0;
  alley_factor_ = 0;
  driveway_factor_ = 0;
  driveway_penalty_ = 0;
  transit_start_end_max_distance_ = 0u;
  transit_transfer_max_distance_ = 0u;
  transport_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  top_speed_ = 0;
  use_hills_ = 0;
  use_primary_ = 0;
  use_trails_ = 0;
  low_class_penalty_ = 0;
  hazmat_ = false;
  weight_ = 0;
  axle_load_ = 0;
  height_ = 0;
  width_ = 0;
  length_ = 0;
  cycling_speed_ = 0;
  wheelchair_ = false;
  bicycle_ = false;
  use_bus_ = 0;
  use_rail_ = 0;
  use_transfers_ = 0;
  transfer_cost_ = 0;
  transfer_penalty_ = 0;
  filter_stop_action_ = 0;
  filter_operator_action_ = 0;
  filter_route_action_ = 0;
  flow_mask_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CostingOptions::~CostingOptions() {
  SharedDtor();
}

void CostingOptions::SharedDtor() {
  if (transport_type_ != &::google::protobuf::internal::kEmptyString) {
    delete transport_type_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CostingOptions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CostingOptions& CostingOptions::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_options_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_options_2eproto();
#endif
  return *default_instance_;
}

CostingOptions* CostingOptions::default_instance_ = NULL;

CostingOptions* CostingOptions::New() const {
  return new CostingOptions;
}

void CostingOptions::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    maneuver_penalty_ = 0;
    destination_only_penalty_ = 0;
    gate_cost_ = 0;
    gate_penalty_ = 0;
    toll_booth_cost_ = 0;
    toll_booth_penalty_ = 0;
    alley_penalty_ = 0;
    country_crossing_cost_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    country_crossing_penalty_ = 0;
    ferry_cost_ = 0;
    avoid_bad_surfaces_ = 0;
    use_ferry_ = 0;
    use_highways_ = 0;
    use_tolls_ = 0;
    use_roads_ = 0;
    max_distance_ = 0u;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    walking_speed_ = 0;
    step_penalty_ = 0;
    max_grade_ = 0u;
    max_hiking_difficulty_ = 0u;
    mode_factor_ = 0;
    walkway_factor_ = 0;
    sidewalk_factor_ = 0;
    alley_factor_ = 0;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    driveway_factor_ = 0;
    driveway_penalty_ = 0;
    transit_start_end_max_distance_ = 0u;
    transit_transfer_max_distance_ = 0u;
    if (has_transport_type()) {
      if (transport_type_ != &::google::protobuf::internal::kEmptyString) {
        transport_type_->clear();
      }
    }
    top_speed_ = 0;
    use_hills_ = 0;
    use_primary_ = 0;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    use_trails_ = 0;
    low_class_penalty_ = 0;
    hazmat_ = false;
    weight_ = 0;
    axle_load_ = 0;
    height_ = 0;
    width_ = 0;
    length_ = 0;
  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    cycling_speed_ = 0;
    wheelchair_ = false;
    bicycle_ = false;
    use_bus_ = 0;
    use_rail_ = 0;
    use_transfers_ = 0;
    transfer_cost_ = 0;
    transfer_penalty_ = 0;
  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    filter_stop_action_ = 0;
    filter_operator_action_ = 0;
    filter_route_action_ = 0;
    flow_mask_ = 0u;
  }
  filter_stop_ids_.Clear();
  filter_operator_ids_.Clear();
  filter_route_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CostingOptions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float maneuver_penalty = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maneuver_penalty_)));
          set_has_maneuver_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_destination_only_penalty;
        break;
      }

      // optional float destination_only_penalty = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_destination_only_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &destination_only_penalty_)));
          set_has_destination_only_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_gate_cost;
        break;
      }

      // optional float gate_cost = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_gate_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gate_cost_)));
          set_has_gate_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_gate_penalty;
        break;
      }

      // optional float gate_penalty = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_gate_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gate_penalty_)));
          set_has_gate_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_toll_booth_cost;
        break;
      }

      // optional float toll_booth_cost = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_toll_booth_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &toll_booth_cost_)));
          set_has_toll_booth_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_toll_booth_penalty;
        break;
      }

      // optional float toll_booth_penalty = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_toll_booth_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &toll_booth_penalty_)));
          set_has_toll_booth_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_alley_penalty;
        break;
      }

      // optional float alley_penalty = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_alley_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alley_penalty_)));
          set_has_alley_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_country_crossing_cost;
        break;
      }

      // optional float country_crossing_cost = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_country_crossing_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &country_crossing_cost_)));
          set_has_country_crossing_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_country_crossing_penalty;
        break;
      }

      // optional float country_crossing_penalty = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_country_crossing_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &country_crossing_penalty_)));
          set_has_country_crossing_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_ferry_cost;
        break;
      }

      // optional float ferry_cost = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ferry_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ferry_cost_)));
          set_has_ferry_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_avoid_bad_surfaces;
        break;
      }

      // optional float avoid_bad_surfaces = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_avoid_bad_surfaces:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &avoid_bad_surfaces_)));
          set_has_avoid_bad_surfaces();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_use_ferry;
        break;
      }

      // optional float use_ferry = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_ferry:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_ferry_)));
          set_has_use_ferry();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_use_highways;
        break;
      }

      // optional float use_highways = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_highways:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_highways_)));
          set_has_use_highways();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_use_tolls;
        break;
      }

      // optional float use_tolls = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_tolls:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_tolls_)));
          set_has_use_tolls();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_use_roads;
        break;
      }

      // optional float use_roads = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_roads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_roads_)));
          set_has_use_roads();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_max_distance;
        break;
      }

      // optional uint32 max_distance = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_distance_)));
          set_has_max_distance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(141)) goto parse_walking_speed;
        break;
      }

      // optional float walking_speed = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_walking_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &walking_speed_)));
          set_has_walking_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(149)) goto parse_step_penalty;
        break;
      }

      // optional float step_penalty = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_step_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &step_penalty_)));
          set_has_step_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_max_grade;
        break;
      }

      // optional uint32 max_grade = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_grade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_grade_)));
          set_has_max_grade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_max_hiking_difficulty;
        break;
      }

      // optional uint32 max_hiking_difficulty = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_hiking_difficulty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_hiking_difficulty_)));
          set_has_max_hiking_difficulty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(173)) goto parse_mode_factor;
        break;
      }

      // optional float mode_factor = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_mode_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mode_factor_)));
          set_has_mode_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(181)) goto parse_walkway_factor;
        break;
      }

      // optional float walkway_factor = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_walkway_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &walkway_factor_)));
          set_has_walkway_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(189)) goto parse_sidewalk_factor;
        break;
      }

      // optional float sidewalk_factor = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_sidewalk_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sidewalk_factor_)));
          set_has_sidewalk_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(197)) goto parse_alley_factor;
        break;
      }

      // optional float alley_factor = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_alley_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alley_factor_)));
          set_has_alley_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(205)) goto parse_driveway_factor;
        break;
      }

      // optional float driveway_factor = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_driveway_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &driveway_factor_)));
          set_has_driveway_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(213)) goto parse_driveway_penalty;
        break;
      }

      // optional float driveway_penalty = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_driveway_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &driveway_penalty_)));
          set_has_driveway_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(216)) goto parse_transit_start_end_max_distance;
        break;
      }

      // optional uint32 transit_start_end_max_distance = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transit_start_end_max_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &transit_start_end_max_distance_)));
          set_has_transit_start_end_max_distance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(224)) goto parse_transit_transfer_max_distance;
        break;
      }

      // optional uint32 transit_transfer_max_distance = 28;
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transit_transfer_max_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &transit_transfer_max_distance_)));
          set_has_transit_transfer_max_distance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(234)) goto parse_transport_type;
        break;
      }

      // optional string transport_type = 29;
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transport_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_transport_type()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(245)) goto parse_top_speed;
        break;
      }

      // optional float top_speed = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_top_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_speed_)));
          set_has_top_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(253)) goto parse_use_hills;
        break;
      }

      // optional float use_hills = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_hills:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_hills_)));
          set_has_use_hills();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(261)) goto parse_use_primary;
        break;
      }

      // optional float use_primary = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_primary:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_primary_)));
          set_has_use_primary();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(269)) goto parse_use_trails;
        break;
      }

      // optional float use_trails = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_trails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_trails_)));
          set_has_use_trails();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(277)) goto parse_low_class_penalty;
        break;
      }

      // optional float low_class_penalty = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_low_class_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &low_class_penalty_)));
          set_has_low_class_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(280)) goto parse_hazmat;
        break;
      }

      // optional bool hazmat = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hazmat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hazmat_)));
          set_has_hazmat();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(293)) goto parse_weight;
        break;
      }

      // optional float weight = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_weight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_)));
          set_has_weight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(301)) goto parse_axle_load;
        break;
      }

      // optional float axle_load = 37;
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_axle_load:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &axle_load_)));
          set_has_axle_load();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(309)) goto parse_height;
        break;
      }

      // optional float height = 38;
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(317)) goto parse_width;
        break;
      }

      // optional float width = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(325)) goto parse_length;
        break;
      }

      // optional float length = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(333)) goto parse_cycling_speed;
        break;
      }

      // optional float cycling_speed = 41;
      case 41: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_cycling_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cycling_speed_)));
          set_has_cycling_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(336)) goto parse_wheelchair;
        break;
      }

      // optional bool wheelchair = 42;
      case 42: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_wheelchair:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &wheelchair_)));
          set_has_wheelchair();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(344)) goto parse_bicycle;
        break;
      }

      // optional bool bicycle = 43;
      case 43: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bicycle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bicycle_)));
          set_has_bicycle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(357)) goto parse_use_bus;
        break;
      }

      // optional float use_bus = 44;
      case 44: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_bus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_bus_)));
          set_has_use_bus();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(365)) goto parse_use_rail;
        break;
      }

      // optional float use_rail = 45;
      case 45: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_rail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_rail_)));
          set_has_use_rail();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(373)) goto parse_use_transfers;
        break;
      }

      // optional float use_transfers = 46;
      case 46: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_use_transfers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &use_transfers_)));
          set_has_use_transfers();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(381)) goto parse_transfer_cost;
        break;
      }

      // optional float transfer_cost = 47;
      case 47: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_transfer_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &transfer_cost_)));
          set_has_transfer_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(389)) goto parse_transfer_penalty;
        break;
      }

      // optional float transfer_penalty = 48;
      case 48: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_transfer_penalty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &transfer_penalty_)));
          set_has_transfer_penalty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(392)) goto parse_filter_stop_action;
        break;
      }

      // optional .valhalla.FilterAction filter_stop_action = 49;
      case 49: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_stop_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::FilterAction_IsValid(value)) {
            set_filter_stop_action(static_cast< ::valhalla::FilterAction >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_filter_stop_ids;
        break;
      }

      // repeated string filter_stop_ids = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_stop_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_stop_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(402)) goto parse_filter_stop_ids;
        if (input->ExpectTag(408)) goto parse_filter_operator_action;
        break;
      }

      // optional .valhalla.FilterAction filter_operator_action = 51;
      case 51: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_operator_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::FilterAction_IsValid(value)) {
            set_filter_operator_action(static_cast< ::valhalla::FilterAction >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(418)) goto parse_filter_operator_ids;
        break;
      }

      // repeated string filter_operator_ids = 52;
      case 52: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_operator_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_operator_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(418)) goto parse_filter_operator_ids;
        if (input->ExpectTag(424)) goto parse_filter_route_action;
        break;
      }

      // optional .valhalla.FilterAction filter_route_action = 53;
      case 53: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_route_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::FilterAction_IsValid(value)) {
            set_filter_route_action(static_cast< ::valhalla::FilterAction >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(434)) goto parse_filter_route_ids;
        break;
      }

      // repeated string filter_route_ids = 54;
      case 54: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_route_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_route_ids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(434)) goto parse_filter_route_ids;
        if (input->ExpectTag(440)) goto parse_flow_mask;
        break;
      }

      // optional uint32 flow_mask = 55;
      case 55: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flow_mask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flow_mask_)));
          set_has_flow_mask();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CostingOptions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float maneuver_penalty = 1;
  if (has_maneuver_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->maneuver_penalty(), output);
  }

  // optional float destination_only_penalty = 2;
  if (has_destination_only_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->destination_only_penalty(), output);
  }

  // optional float gate_cost = 3;
  if (has_gate_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->gate_cost(), output);
  }

  // optional float gate_penalty = 4;
  if (has_gate_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->gate_penalty(), output);
  }

  // optional float toll_booth_cost = 5;
  if (has_toll_booth_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->toll_booth_cost(), output);
  }

  // optional float toll_booth_penalty = 6;
  if (has_toll_booth_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->toll_booth_penalty(), output);
  }

  // optional float alley_penalty = 7;
  if (has_alley_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->alley_penalty(), output);
  }

  // optional float country_crossing_cost = 8;
  if (has_country_crossing_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->country_crossing_cost(), output);
  }

  // optional float country_crossing_penalty = 9;
  if (has_country_crossing_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->country_crossing_penalty(), output);
  }

  // optional float ferry_cost = 10;
  if (has_ferry_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->ferry_cost(), output);
  }

  // optional float avoid_bad_surfaces = 11;
  if (has_avoid_bad_surfaces()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->avoid_bad_surfaces(), output);
  }

  // optional float use_ferry = 12;
  if (has_use_ferry()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->use_ferry(), output);
  }

  // optional float use_highways = 13;
  if (has_use_highways()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->use_highways(), output);
  }

  // optional float use_tolls = 14;
  if (has_use_tolls()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->use_tolls(), output);
  }

  // optional float use_roads = 15;
  if (has_use_roads()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->use_roads(), output);
  }

  // optional uint32 max_distance = 16;
  if (has_max_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->max_distance(), output);
  }

  // optional float walking_speed = 17;
  if (has_walking_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->walking_speed(), output);
  }

  // optional float step_penalty = 18;
  if (has_step_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(18, this->step_penalty(), output);
  }

  // optional uint32 max_grade = 19;
  if (has_max_grade()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(19, this->max_grade(), output);
  }

  // optional uint32 max_hiking_difficulty = 20;
  if (has_max_hiking_difficulty()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(20, this->max_hiking_difficulty(), output);
  }

  // optional float mode_factor = 21;
  if (has_mode_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->mode_factor(), output);
  }

  // optional float walkway_factor = 22;
  if (has_walkway_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(22, this->walkway_factor(), output);
  }

  // optional float sidewalk_factor = 23;
  if (has_sidewalk_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(23, this->sidewalk_factor(), output);
  }

  // optional float alley_factor = 24;
  if (has_alley_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(24, this->alley_factor(), output);
  }

  // optional float driveway_factor = 25;
  if (has_driveway_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(25, this->driveway_factor(), output);
  }

  // optional float driveway_penalty = 26;
  if (has_driveway_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(26, this->driveway_penalty(), output);
  }

  // optional uint32 transit_start_end_max_distance = 27;
  if (has_transit_start_end_max_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(27, this->transit_start_end_max_distance(), output);
  }

  // optional uint32 transit_transfer_max_distance = 28;
  if (has_transit_transfer_max_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(28, this->transit_transfer_max_distance(), output);
  }

  // optional string transport_type = 29;
  if (has_transport_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      29, this->transport_type(), output);
  }

  // optional float top_speed = 30;
  if (has_top_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(30, this->top_speed(), output);
  }

  // optional float use_hills = 31;
  if (has_use_hills()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(31, this->use_hills(), output);
  }

  // optional float use_primary = 32;
  if (has_use_primary()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(32, this->use_primary(), output);
  }

  // optional float use_trails = 33;
  if (has_use_trails()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(33, this->use_trails(), output);
  }

  // optional float low_class_penalty = 34;
  if (has_low_class_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(34, this->low_class_penalty(), output);
  }

  // optional bool hazmat = 35;
  if (has_hazmat()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(35, this->hazmat(), output);
  }

  // optional float weight = 36;
  if (has_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(36, this->weight(), output);
  }

  // optional float axle_load = 37;
  if (has_axle_load()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(37, this->axle_load(), output);
  }

  // optional float height = 38;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(38, this->height(), output);
  }

  // optional float width = 39;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(39, this->width(), output);
  }

  // optional float length = 40;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(40, this->length(), output);
  }

  // optional float cycling_speed = 41;
  if (has_cycling_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(41, this->cycling_speed(), output);
  }

  // optional bool wheelchair = 42;
  if (has_wheelchair()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(42, this->wheelchair(), output);
  }

  // optional bool bicycle = 43;
  if (has_bicycle()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(43, this->bicycle(), output);
  }

  // optional float use_bus = 44;
  if (has_use_bus()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(44, this->use_bus(), output);
  }

  // optional float use_rail = 45;
  if (has_use_rail()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(45, this->use_rail(), output);
  }

  // optional float use_transfers = 46;
  if (has_use_transfers()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(46, this->use_transfers(), output);
  }

  // optional float transfer_cost = 47;
  if (has_transfer_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(47, this->transfer_cost(), output);
  }

  // optional float transfer_penalty = 48;
  if (has_transfer_penalty()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(48, this->transfer_penalty(), output);
  }

  // optional .valhalla.FilterAction filter_stop_action = 49;
  if (has_filter_stop_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      49, this->filter_stop_action(), output);
  }

  // repeated string filter_stop_ids = 50;
  for (int i = 0; i < this->filter_stop_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      50, this->filter_stop_ids(i), output);
  }

  // optional .valhalla.FilterAction filter_operator_action = 51;
  if (has_filter_operator_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      51, this->filter_operator_action(), output);
  }

  // repeated string filter_operator_ids = 52;
  for (int i = 0; i < this->filter_operator_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      52, this->filter_operator_ids(i), output);
  }

  // optional .valhalla.FilterAction filter_route_action = 53;
  if (has_filter_route_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      53, this->filter_route_action(), output);
  }

  // repeated string filter_route_ids = 54;
  for (int i = 0; i < this->filter_route_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      54, this->filter_route_ids(i), output);
  }

  // optional uint32 flow_mask = 55;
  if (has_flow_mask()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(55, this->flow_mask(), output);
  }

}

int CostingOptions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float maneuver_penalty = 1;
    if (has_maneuver_penalty()) {
      total_size += 1 + 4;
    }

    // optional float destination_only_penalty = 2;
    if (has_destination_only_penalty()) {
      total_size += 1 + 4;
    }

    // optional float gate_cost = 3;
    if (has_gate_cost()) {
      total_size += 1 + 4;
    }

    // optional float gate_penalty = 4;
    if (has_gate_penalty()) {
      total_size += 1 + 4;
    }

    // optional float toll_booth_cost = 5;
    if (has_toll_booth_cost()) {
      total_size += 1 + 4;
    }

    // optional float toll_booth_penalty = 6;
    if (has_toll_booth_penalty()) {
      total_size += 1 + 4;
    }

    // optional float alley_penalty = 7;
    if (has_alley_penalty()) {
      total_size += 1 + 4;
    }

    // optional float country_crossing_cost = 8;
    if (has_country_crossing_cost()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float country_crossing_penalty = 9;
    if (has_country_crossing_penalty()) {
      total_size += 1 + 4;
    }

    // optional float ferry_cost = 10;
    if (has_ferry_cost()) {
      total_size += 1 + 4;
    }

    // optional float avoid_bad_surfaces = 11;
    if (has_avoid_bad_surfaces()) {
      total_size += 1 + 4;
    }

    // optional float use_ferry = 12;
    if (has_use_ferry()) {
      total_size += 1 + 4;
    }

    // optional float use_highways = 13;
    if (has_use_highways()) {
      total_size += 1 + 4;
    }

    // optional float use_tolls = 14;
    if (has_use_tolls()) {
      total_size += 1 + 4;
    }

    // optional float use_roads = 15;
    if (has_use_roads()) {
      total_size += 1 + 4;
    }

    // optional uint32 max_distance = 16;
    if (has_max_distance()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_distance());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional float walking_speed = 17;
    if (has_walking_speed()) {
      total_size += 2 + 4;
    }

    // optional float step_penalty = 18;
    if (has_step_penalty()) {
      total_size += 2 + 4;
    }

    // optional uint32 max_grade = 19;
    if (has_max_grade()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_grade());
    }

    // optional uint32 max_hiking_difficulty = 20;
    if (has_max_hiking_difficulty()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_hiking_difficulty());
    }

    // optional float mode_factor = 21;
    if (has_mode_factor()) {
      total_size += 2 + 4;
    }

    // optional float walkway_factor = 22;
    if (has_walkway_factor()) {
      total_size += 2 + 4;
    }

    // optional float sidewalk_factor = 23;
    if (has_sidewalk_factor()) {
      total_size += 2 + 4;
    }

    // optional float alley_factor = 24;
    if (has_alley_factor()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional float driveway_factor = 25;
    if (has_driveway_factor()) {
      total_size += 2 + 4;
    }

    // optional float driveway_penalty = 26;
    if (has_driveway_penalty()) {
      total_size += 2 + 4;
    }

    // optional uint32 transit_start_end_max_distance = 27;
    if (has_transit_start_end_max_distance()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->transit_start_end_max_distance());
    }

    // optional uint32 transit_transfer_max_distance = 28;
    if (has_transit_transfer_max_distance()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->transit_transfer_max_distance());
    }

    // optional string transport_type = 29;
    if (has_transport_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->transport_type());
    }

    // optional float top_speed = 30;
    if (has_top_speed()) {
      total_size += 2 + 4;
    }

    // optional float use_hills = 31;
    if (has_use_hills()) {
      total_size += 2 + 4;
    }

    // optional float use_primary = 32;
    if (has_use_primary()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional float use_trails = 33;
    if (has_use_trails()) {
      total_size += 2 + 4;
    }

    // optional float low_class_penalty = 34;
    if (has_low_class_penalty()) {
      total_size += 2 + 4;
    }

    // optional bool hazmat = 35;
    if (has_hazmat()) {
      total_size += 2 + 1;
    }

    // optional float weight = 36;
    if (has_weight()) {
      total_size += 2 + 4;
    }

    // optional float axle_load = 37;
    if (has_axle_load()) {
      total_size += 2 + 4;
    }

    // optional float height = 38;
    if (has_height()) {
      total_size += 2 + 4;
    }

    // optional float width = 39;
    if (has_width()) {
      total_size += 2 + 4;
    }

    // optional float length = 40;
    if (has_length()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    // optional float cycling_speed = 41;
    if (has_cycling_speed()) {
      total_size += 2 + 4;
    }

    // optional bool wheelchair = 42;
    if (has_wheelchair()) {
      total_size += 2 + 1;
    }

    // optional bool bicycle = 43;
    if (has_bicycle()) {
      total_size += 2 + 1;
    }

    // optional float use_bus = 44;
    if (has_use_bus()) {
      total_size += 2 + 4;
    }

    // optional float use_rail = 45;
    if (has_use_rail()) {
      total_size += 2 + 4;
    }

    // optional float use_transfers = 46;
    if (has_use_transfers()) {
      total_size += 2 + 4;
    }

    // optional float transfer_cost = 47;
    if (has_transfer_cost()) {
      total_size += 2 + 4;
    }

    // optional float transfer_penalty = 48;
    if (has_transfer_penalty()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    // optional .valhalla.FilterAction filter_stop_action = 49;
    if (has_filter_stop_action()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_stop_action());
    }

    // optional .valhalla.FilterAction filter_operator_action = 51;
    if (has_filter_operator_action()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_operator_action());
    }

    // optional .valhalla.FilterAction filter_route_action = 53;
    if (has_filter_route_action()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_route_action());
    }

    // optional uint32 flow_mask = 55;
    if (has_flow_mask()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flow_mask());
    }

  }
  // repeated string filter_stop_ids = 50;
  total_size += 2 * this->filter_stop_ids_size();
  for (int i = 0; i < this->filter_stop_ids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_stop_ids(i));
  }

  // repeated string filter_operator_ids = 52;
  total_size += 2 * this->filter_operator_ids_size();
  for (int i = 0; i < this->filter_operator_ids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_operator_ids(i));
  }

  // repeated string filter_route_ids = 54;
  total_size += 2 * this->filter_route_ids_size();
  for (int i = 0; i < this->filter_route_ids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_route_ids(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CostingOptions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CostingOptions*>(&from));
}

void CostingOptions::MergeFrom(const CostingOptions& from) {
  GOOGLE_CHECK_NE(&from, this);
  filter_stop_ids_.MergeFrom(from.filter_stop_ids_);
  filter_operator_ids_.MergeFrom(from.filter_operator_ids_);
  filter_route_ids_.MergeFrom(from.filter_route_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_maneuver_penalty()) {
      set_maneuver_penalty(from.maneuver_penalty());
    }
    if (from.has_destination_only_penalty()) {
      set_destination_only_penalty(from.destination_only_penalty());
    }
    if (from.has_gate_cost()) {
      set_gate_cost(from.gate_cost());
    }
    if (from.has_gate_penalty()) {
      set_gate_penalty(from.gate_penalty());
    }
    if (from.has_toll_booth_cost()) {
      set_toll_booth_cost(from.toll_booth_cost());
    }
    if (from.has_toll_booth_penalty()) {
      set_toll_booth_penalty(from.toll_booth_penalty());
    }
    if (from.has_alley_penalty()) {
      set_alley_penalty(from.alley_penalty());
    }
    if (from.has_country_crossing_cost()) {
      set_country_crossing_cost(from.country_crossing_cost());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_country_crossing_penalty()) {
      set_country_crossing_penalty(from.country_crossing_penalty());
    }
    if (from.has_ferry_cost()) {
      set_ferry_cost(from.ferry_cost());
    }
    if (from.has_avoid_bad_surfaces()) {
      set_avoid_bad_surfaces(from.avoid_bad_surfaces());
    }
    if (from.has_use_ferry()) {
      set_use_ferry(from.use_ferry());
    }
    if (from.has_use_highways()) {
      set_use_highways(from.use_highways());
    }
    if (from.has_use_tolls()) {
      set_use_tolls(from.use_tolls());
    }
    if (from.has_use_roads()) {
      set_use_roads(from.use_roads());
    }
    if (from.has_max_distance()) {
      set_max_distance(from.max_distance());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_walking_speed()) {
      set_walking_speed(from.walking_speed());
    }
    if (from.has_step_penalty()) {
      set_step_penalty(from.step_penalty());
    }
    if (from.has_max_grade()) {
      set_max_grade(from.max_grade());
    }
    if (from.has_max_hiking_difficulty()) {
      set_max_hiking_difficulty(from.max_hiking_difficulty());
    }
    if (from.has_mode_factor()) {
      set_mode_factor(from.mode_factor());
    }
    if (from.has_walkway_factor()) {
      set_walkway_factor(from.walkway_factor());
    }
    if (from.has_sidewalk_factor()) {
      set_sidewalk_factor(from.sidewalk_factor());
    }
    if (from.has_alley_factor()) {
      set_alley_factor(from.alley_factor());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_driveway_factor()) {
      set_driveway_factor(from.driveway_factor());
    }
    if (from.has_driveway_penalty()) {
      set_driveway_penalty(from.driveway_penalty());
    }
    if (from.has_transit_start_end_max_distance()) {
      set_transit_start_end_max_distance(from.transit_start_end_max_distance());
    }
    if (from.has_transit_transfer_max_distance()) {
      set_transit_transfer_max_distance(from.transit_transfer_max_distance());
    }
    if (from.has_transport_type()) {
      set_transport_type(from.transport_type());
    }
    if (from.has_top_speed()) {
      set_top_speed(from.top_speed());
    }
    if (from.has_use_hills()) {
      set_use_hills(from.use_hills());
    }
    if (from.has_use_primary()) {
      set_use_primary(from.use_primary());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_use_trails()) {
      set_use_trails(from.use_trails());
    }
    if (from.has_low_class_penalty()) {
      set_low_class_penalty(from.low_class_penalty());
    }
    if (from.has_hazmat()) {
      set_hazmat(from.hazmat());
    }
    if (from.has_weight()) {
      set_weight(from.weight());
    }
    if (from.has_axle_load()) {
      set_axle_load(from.axle_load());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_cycling_speed()) {
      set_cycling_speed(from.cycling_speed());
    }
    if (from.has_wheelchair()) {
      set_wheelchair(from.wheelchair());
    }
    if (from.has_bicycle()) {
      set_bicycle(from.bicycle());
    }
    if (from.has_use_bus()) {
      set_use_bus(from.use_bus());
    }
    if (from.has_use_rail()) {
      set_use_rail(from.use_rail());
    }
    if (from.has_use_transfers()) {
      set_use_transfers(from.use_transfers());
    }
    if (from.has_transfer_cost()) {
      set_transfer_cost(from.transfer_cost());
    }
    if (from.has_transfer_penalty()) {
      set_transfer_penalty(from.transfer_penalty());
    }
  }
  if (from._has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    if (from.has_filter_stop_action()) {
      set_filter_stop_action(from.filter_stop_action());
    }
    if (from.has_filter_operator_action()) {
      set_filter_operator_action(from.filter_operator_action());
    }
    if (from.has_filter_route_action()) {
      set_filter_route_action(from.filter_route_action());
    }
    if (from.has_flow_mask()) {
      set_flow_mask(from.flow_mask());
    }
  }
}

void CostingOptions::CopyFrom(const CostingOptions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CostingOptions::IsInitialized() const {

  return true;
}

void CostingOptions::Swap(CostingOptions* other) {
  if (other != this) {
    std::swap(maneuver_penalty_, other->maneuver_penalty_);
    std::swap(destination_only_penalty_, other->destination_only_penalty_);
    std::swap(gate_cost_, other->gate_cost_);
    std::swap(gate_penalty_, other->gate_penalty_);
    std::swap(toll_booth_cost_, other->toll_booth_cost_);
    std::swap(toll_booth_penalty_, other->toll_booth_penalty_);
    std::swap(alley_penalty_, other->alley_penalty_);
    std::swap(country_crossing_cost_, other->country_crossing_cost_);
    std::swap(country_crossing_penalty_, other->country_crossing_penalty_);
    std::swap(ferry_cost_, other->ferry_cost_);
    std::swap(avoid_bad_surfaces_, other->avoid_bad_surfaces_);
    std::swap(use_ferry_, other->use_ferry_);
    std::swap(use_highways_, other->use_highways_);
    std::swap(use_tolls_, other->use_tolls_);
    std::swap(use_roads_, other->use_roads_);
    std::swap(max_distance_, other->max_distance_);
    std::swap(walking_speed_, other->walking_speed_);
    std::swap(step_penalty_, other->step_penalty_);
    std::swap(max_grade_, other->max_grade_);
    std::swap(max_hiking_difficulty_, other->max_hiking_difficulty_);
    std::swap(mode_factor_, other->mode_factor_);
    std::swap(walkway_factor_, other->walkway_factor_);
    std::swap(sidewalk_factor_, other->sidewalk_factor_);
    std::swap(alley_factor_, other->alley_factor_);
    std::swap(driveway_factor_, other->driveway_factor_);
    std::swap(driveway_penalty_, other->driveway_penalty_);
    std::swap(transit_start_end_max_distance_, other->transit_start_end_max_distance_);
    std::swap(transit_transfer_max_distance_, other->transit_transfer_max_distance_);
    std::swap(transport_type_, other->transport_type_);
    std::swap(top_speed_, other->top_speed_);
    std::swap(use_hills_, other->use_hills_);
    std::swap(use_primary_, other->use_primary_);
    std::swap(use_trails_, other->use_trails_);
    std::swap(low_class_penalty_, other->low_class_penalty_);
    std::swap(hazmat_, other->hazmat_);
    std::swap(weight_, other->weight_);
    std::swap(axle_load_, other->axle_load_);
    std::swap(height_, other->height_);
    std::swap(width_, other->width_);
    std::swap(length_, other->length_);
    std::swap(cycling_speed_, other->cycling_speed_);
    std::swap(wheelchair_, other->wheelchair_);
    std::swap(bicycle_, other->bicycle_);
    std::swap(use_bus_, other->use_bus_);
    std::swap(use_rail_, other->use_rail_);
    std::swap(use_transfers_, other->use_transfers_);
    std::swap(transfer_cost_, other->transfer_cost_);
    std::swap(transfer_penalty_, other->transfer_penalty_);
    std::swap(filter_stop_action_, other->filter_stop_action_);
    filter_stop_ids_.Swap(&other->filter_stop_ids_);
    std::swap(filter_operator_action_, other->filter_operator_action_);
    filter_operator_ids_.Swap(&other->filter_operator_ids_);
    std::swap(filter_route_action_, other->filter_route_action_);
    filter_route_ids_.Swap(&other->filter_route_ids_);
    std::swap(flow_mask_, other->flow_mask_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CostingOptions::GetTypeName() const {
  return "valhalla.CostingOptions";
}


// ===================================================================

#ifndef _MSC_VER
const int AvoidEdge::kIdFieldNumber;
const int AvoidEdge::kPercentAlongFieldNumber;
#endif  // !_MSC_VER

AvoidEdge::AvoidEdge()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AvoidEdge::InitAsDefaultInstance() {
}

AvoidEdge::AvoidEdge(const AvoidEdge& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AvoidEdge::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  percent_along_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AvoidEdge::~AvoidEdge() {
  SharedDtor();
}

void AvoidEdge::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AvoidEdge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AvoidEdge& AvoidEdge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_options_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_options_2eproto();
#endif
  return *default_instance_;
}

AvoidEdge* AvoidEdge::default_instance_ = NULL;

AvoidEdge* AvoidEdge::New() const {
  return new AvoidEdge;
}

void AvoidEdge::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    percent_along_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AvoidEdge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_percent_along;
        break;
      }

      // optional float percent_along = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_percent_along:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &percent_along_)));
          set_has_percent_along();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AvoidEdge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // optional float percent_along = 2;
  if (has_percent_along()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->percent_along(), output);
  }

}

int AvoidEdge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional float percent_along = 2;
    if (has_percent_along()) {
      total_size += 1 + 4;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AvoidEdge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AvoidEdge*>(&from));
}

void AvoidEdge::MergeFrom(const AvoidEdge& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_percent_along()) {
      set_percent_along(from.percent_along());
    }
  }
}

void AvoidEdge::CopyFrom(const AvoidEdge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvoidEdge::IsInitialized() const {

  return true;
}

void AvoidEdge::Swap(AvoidEdge* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(percent_along_, other->percent_along_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AvoidEdge::GetTypeName() const {
  return "valhalla.AvoidEdge";
}


// ===================================================================

bool Options_Units_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Options_Units Options::kilometers;
const Options_Units Options::miles;
const Options_Units Options::Units_MIN;
const Options_Units Options::Units_MAX;
const int Options::Units_ARRAYSIZE;
#endif  // _MSC_VER
bool Options_Format_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Options_Format Options::json;
const Options_Format Options::gpx;
const Options_Format Options::osrm;
const Options_Format Options::Format_MIN;
const Options_Format Options::Format_MAX;
const int Options::Format_ARRAYSIZE;
#endif  // _MSC_VER
bool Options_Action_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Options_Action Options::route;
const Options_Action Options::locate;
const Options_Action Options::sources_to_targets;
const Options_Action Options::optimized_route;
const Options_Action Options::isochrone;
const Options_Action Options::trace_route;
const Options_Action Options::trace_attributes;
const Options_Action Options::height;
const Options_Action Options::transit_available;
const Options_Action Options::expansion;
const Options_Action Options::Action_MIN;
const Options_Action Options::Action_MAX;
const int Options::Action_ARRAYSIZE;
#endif  // _MSC_VER
bool Options_DateTimeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Options_DateTimeType Options::current;
const Options_DateTimeType Options::depart_at;
const Options_DateTimeType Options::arrive_by;
const Options_DateTimeType Options::DateTimeType_MIN;
const Options_DateTimeType Options::DateTimeType_MAX;
const int Options::DateTimeType_ARRAYSIZE;
#endif  // _MSC_VER
::std::string* Options::_default_language_ = NULL;
#ifndef _MSC_VER
const int Options::kUnitsFieldNumber;
const int Options::kLanguageFieldNumber;
const int Options::kDirectionsTypeFieldNumber;
const int Options::kFormatFieldNumber;
const int Options::kIdFieldNumber;
const int Options::kJsonpFieldNumber;
const int Options::kEncodedPolylineFieldNumber;
const int Options::kActionFieldNumber;
const int Options::kDoNotTrackFieldNumber;
const int Options::kRangeFieldNumber;
const int Options::kVerboseFieldNumber;
const int Options::kCostingFieldNumber;
const int Options::kCostingOptionsFieldNumber;
const int Options::kLocationsFieldNumber;
const int Options::kAvoidLocationsFieldNumber;
const int Options::kSourcesFieldNumber;
const int Options::kTargetsFieldNumber;
const int Options::kDateTimeTypeFieldNumber;
const int Options::kDateTimeFieldNumber;
const int Options::kShapeFieldNumber;
const int Options::kResampleDistanceFieldNumber;
const int Options::kContoursFieldNumber;
const int Options::kPolygonsFieldNumber;
const int Options::kDenoiseFieldNumber;
const int Options::kGeneralizeFieldNumber;
const int Options::kShowLocationsFieldNumber;
const int Options::kTraceFieldNumber;
const int Options::kShapeMatchFieldNumber;
const int Options::kBestPathsFieldNumber;
const int Options::kGpsAccuracyFieldNumber;
const int Options::kSearchRadiusFieldNumber;
const int Options::kTurnPenaltyFactorFieldNumber;
const int Options::kFilterActionFieldNumber;
const int Options::kFilterAttributesFieldNumber;
const int Options::kAvoidEdgesFieldNumber;
const int Options::kBreakageDistanceFieldNumber;
const int Options::kUseTimestampsFieldNumber;
const int Options::kShapeFormatFieldNumber;
const int Options::kAlternatesFieldNumber;
const int Options::kInterpolationDistanceFieldNumber;
#endif  // !_MSC_VER

Options::Options()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Options::InitAsDefaultInstance() {
}

Options::Options(const Options& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Options::SharedCtor() {
  _cached_size_ = 0;
  units_ = 0;
  language_ = const_cast< ::std::string*>(_default_language_);
  directions_type_ = 2;
  format_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  jsonp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encoded_polyline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  action_ = 1;
  do_not_track_ = false;
  range_ = false;
  verbose_ = false;
  costing_ = 0;
  date_time_type_ = 0;
  date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  resample_distance_ = 0;
  polygons_ = false;
  denoise_ = 1;
  generalize_ = 0;
  show_locations_ = false;
  shape_match_ = 2;
  best_paths_ = 1u;
  gps_accuracy_ = 0;
  search_radius_ = 0;
  turn_penalty_factor_ = 0;
  filter_action_ = 0;
  breakage_distance_ = 0;
  use_timestamps_ = false;
  shape_format_ = 1;
  alternates_ = 0u;
  interpolation_distance_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Options::~Options() {
  SharedDtor();
}

void Options::SharedDtor() {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (jsonp_ != &::google::protobuf::internal::kEmptyString) {
    delete jsonp_;
  }
  if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_polyline_;
  }
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Options::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Options& Options::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_options_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_options_2eproto();
#endif
  return *default_instance_;
}

Options* Options::default_instance_ = NULL;

Options* Options::New() const {
  return new Options;
}

void Options::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    units_ = 0;
    if (has_language()) {
      if (language_ != _default_language_) {
        language_->assign(*_default_language_);
      }
    }
    directions_type_ = 2;
    format_ = 0;
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    if (has_jsonp()) {
      if (jsonp_ != &::google::protobuf::internal::kEmptyString) {
        jsonp_->clear();
      }
    }
    if (has_encoded_polyline()) {
      if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
        encoded_polyline_->clear();
      }
    }
    action_ = 1;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    do_not_track_ = false;
    range_ = false;
    verbose_ = false;
    costing_ = 0;
  }
  if (_has_bits_[17 / 32] & (0xffu << (17 % 32))) {
    date_time_type_ = 0;
    if (has_date_time()) {
      if (date_time_ != &::google::protobuf::internal::kEmptyString) {
        date_time_->clear();
      }
    }
    resample_distance_ = 0;
    polygons_ = false;
    denoise_ = 1;
  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    generalize_ = 0;
    show_locations_ = false;
    shape_match_ = 2;
    best_paths_ = 1u;
    gps_accuracy_ = 0;
    search_radius_ = 0;
    turn_penalty_factor_ = 0;
  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    filter_action_ = 0;
    breakage_distance_ = 0;
    use_timestamps_ = false;
    shape_format_ = 1;
    alternates_ = 0u;
    interpolation_distance_ = 0;
  }
  costing_options_.Clear();
  locations_.Clear();
  avoid_locations_.Clear();
  sources_.Clear();
  targets_.Clear();
  shape_.Clear();
  contours_.Clear();
  trace_.Clear();
  filter_attributes_.Clear();
  avoid_edges_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Options::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .valhalla.Options.Units units = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::Options_Units_IsValid(value)) {
            set_units(static_cast< ::valhalla::Options_Units >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_language;
        break;
      }

      // optional string language = 2 [default = "en-US"];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_directions_type;
        break;
      }

      // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_directions_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::DirectionsType_IsValid(value)) {
            set_directions_type(static_cast< ::valhalla::DirectionsType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_format;
        break;
      }

      // optional .valhalla.Options.Format format = 4 [default = json];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_format:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::Options_Format_IsValid(value)) {
            set_format(static_cast< ::valhalla::Options_Format >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_id;
        break;
      }

      // optional string id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_jsonp;
        break;
      }

      // optional string jsonp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_jsonp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_jsonp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_encoded_polyline;
        break;
      }

      // optional string encoded_polyline = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encoded_polyline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_encoded_polyline()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_action;
        break;
      }

      // optional .valhalla.Options.Action action = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::Options_Action_IsValid(value)) {
            set_action(static_cast< ::valhalla::Options_Action >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_do_not_track;
        break;
      }

      // optional bool do_not_track = 9 [default = false];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_do_not_track:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &do_not_track_)));
          set_has_do_not_track();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_range;
        break;
      }

      // optional bool range = 10 [default = false];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_range:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &range_)));
          set_has_range();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_verbose;
        break;
      }

      // optional bool verbose = 11 [default = false];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_verbose:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &verbose_)));
          set_has_verbose();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_costing;
        break;
      }

      // optional .valhalla.Costing costing = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_costing:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::Costing_IsValid(value)) {
            set_costing(static_cast< ::valhalla::Costing >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_costing_options;
        break;
      }

      // repeated .valhalla.CostingOptions costing_options = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_costing_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_costing_options()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_costing_options;
        if (input->ExpectTag(114)) goto parse_locations;
        break;
      }

      // repeated .valhalla.Location locations = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_locations;
        if (input->ExpectTag(122)) goto parse_avoid_locations;
        break;
      }

      // repeated .valhalla.Location avoid_locations = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avoid_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_avoid_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_avoid_locations;
        if (input->ExpectTag(130)) goto parse_sources;
        break;
      }

      // repeated .valhalla.Location sources = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sources()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_sources;
        if (input->ExpectTag(138)) goto parse_targets;
        break;
      }

      // repeated .valhalla.Location targets = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_targets:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_targets()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(138)) goto parse_targets;
        if (input->ExpectTag(144)) goto parse_date_time_type;
        break;
      }

      // optional .valhalla.Options.DateTimeType date_time_type = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_date_time_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::Options_DateTimeType_IsValid(value)) {
            set_date_time_type(static_cast< ::valhalla::Options_DateTimeType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(154)) goto parse_date_time;
        break;
      }

      // optional string date_time = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_date_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_date_time()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_shape;
        break;
      }

      // repeated .valhalla.Location shape = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shape:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shape()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_shape;
        if (input->ExpectTag(169)) goto parse_resample_distance;
        break;
      }

      // optional double resample_distance = 21;
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_resample_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &resample_distance_)));
          set_has_resample_distance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_contours;
        break;
      }

      // repeated .valhalla.Contour contours = 22;
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_contours:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_contours()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(178)) goto parse_contours;
        if (input->ExpectTag(184)) goto parse_polygons;
        break;
      }

      // optional bool polygons = 23;
      case 23: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_polygons:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &polygons_)));
          set_has_polygons();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(197)) goto parse_denoise;
        break;
      }

      // optional float denoise = 24 [default = 1];
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_denoise:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &denoise_)));
          set_has_denoise();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(205)) goto parse_generalize;
        break;
      }

      // optional float generalize = 25;
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_generalize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &generalize_)));
          set_has_generalize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_show_locations;
        break;
      }

      // optional bool show_locations = 26;
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_show_locations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_locations_)));
          set_has_show_locations();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_trace;
        break;
      }

      // repeated .valhalla.Location trace = 27;
      case 27: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_trace:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_trace()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(218)) goto parse_trace;
        if (input->ExpectTag(224)) goto parse_shape_match;
        break;
      }

      // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
      case 28: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shape_match:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::ShapeMatch_IsValid(value)) {
            set_shape_match(static_cast< ::valhalla::ShapeMatch >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(232)) goto parse_best_paths;
        break;
      }

      // optional uint32 best_paths = 29 [default = 1];
      case 29: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_best_paths:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &best_paths_)));
          set_has_best_paths();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(245)) goto parse_gps_accuracy;
        break;
      }

      // optional float gps_accuracy = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_gps_accuracy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gps_accuracy_)));
          set_has_gps_accuracy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(253)) goto parse_search_radius;
        break;
      }

      // optional float search_radius = 31;
      case 31: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_search_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &search_radius_)));
          set_has_search_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(261)) goto parse_turn_penalty_factor;
        break;
      }

      // optional float turn_penalty_factor = 32;
      case 32: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_turn_penalty_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &turn_penalty_factor_)));
          set_has_turn_penalty_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(264)) goto parse_filter_action;
        break;
      }

      // optional .valhalla.FilterAction filter_action = 33;
      case 33: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_action:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::FilterAction_IsValid(value)) {
            set_filter_action(static_cast< ::valhalla::FilterAction >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_filter_attributes;
        break;
      }

      // repeated string filter_attributes = 34;
      case 34: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_attributes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(274)) goto parse_filter_attributes;
        if (input->ExpectTag(282)) goto parse_avoid_edges;
        break;
      }

      // repeated .valhalla.AvoidEdge avoid_edges = 35;
      case 35: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_avoid_edges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_avoid_edges()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(282)) goto parse_avoid_edges;
        if (input->ExpectTag(293)) goto parse_breakage_distance;
        break;
      }

      // optional float breakage_distance = 36;
      case 36: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_breakage_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &breakage_distance_)));
          set_has_breakage_distance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(296)) goto parse_use_timestamps;
        break;
      }

      // optional bool use_timestamps = 37 [default = false];
      case 37: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_use_timestamps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_timestamps_)));
          set_has_use_timestamps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(304)) goto parse_shape_format;
        break;
      }

      // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
      case 38: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shape_format:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::valhalla::ShapeFormat_IsValid(value)) {
            set_shape_format(static_cast< ::valhalla::ShapeFormat >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(312)) goto parse_alternates;
        break;
      }

      // optional uint32 alternates = 39;
      case 39: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_alternates:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alternates_)));
          set_has_alternates();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(325)) goto parse_interpolation_distance;
        break;
      }

      // optional float interpolation_distance = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_interpolation_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &interpolation_distance_)));
          set_has_interpolation_distance();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Options::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .valhalla.Options.Units units = 1;
  if (has_units()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->units(), output);
  }

  // optional string language = 2 [default = "en-US"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->language(), output);
  }

  // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
  if (has_directions_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->directions_type(), output);
  }

  // optional .valhalla.Options.Format format = 4 [default = json];
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->format(), output);
  }

  // optional string id = 5;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->id(), output);
  }

  // optional string jsonp = 6;
  if (has_jsonp()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->jsonp(), output);
  }

  // optional string encoded_polyline = 7;
  if (has_encoded_polyline()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->encoded_polyline(), output);
  }

  // optional .valhalla.Options.Action action = 8;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->action(), output);
  }

  // optional bool do_not_track = 9 [default = false];
  if (has_do_not_track()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->do_not_track(), output);
  }

  // optional bool range = 10 [default = false];
  if (has_range()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->range(), output);
  }

  // optional bool verbose = 11 [default = false];
  if (has_verbose()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->verbose(), output);
  }

  // optional .valhalla.Costing costing = 12;
  if (has_costing()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->costing(), output);
  }

  // repeated .valhalla.CostingOptions costing_options = 13;
  for (int i = 0; i < this->costing_options_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, this->costing_options(i), output);
  }

  // repeated .valhalla.Location locations = 14;
  for (int i = 0; i < this->locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->locations(i), output);
  }

  // repeated .valhalla.Location avoid_locations = 15;
  for (int i = 0; i < this->avoid_locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->avoid_locations(i), output);
  }

  // repeated .valhalla.Location sources = 16;
  for (int i = 0; i < this->sources_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      16, this->sources(i), output);
  }

  // repeated .valhalla.Location targets = 17;
  for (int i = 0; i < this->targets_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      17, this->targets(i), output);
  }

  // optional .valhalla.Options.DateTimeType date_time_type = 18;
  if (has_date_time_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      18, this->date_time_type(), output);
  }

  // optional string date_time = 19;
  if (has_date_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      19, this->date_time(), output);
  }

  // repeated .valhalla.Location shape = 20;
  for (int i = 0; i < this->shape_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, this->shape(i), output);
  }

  // optional double resample_distance = 21;
  if (has_resample_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(21, this->resample_distance(), output);
  }

  // repeated .valhalla.Contour contours = 22;
  for (int i = 0; i < this->contours_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      22, this->contours(i), output);
  }

  // optional bool polygons = 23;
  if (has_polygons()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(23, this->polygons(), output);
  }

  // optional float denoise = 24 [default = 1];
  if (has_denoise()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(24, this->denoise(), output);
  }

  // optional float generalize = 25;
  if (has_generalize()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(25, this->generalize(), output);
  }

  // optional bool show_locations = 26;
  if (has_show_locations()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(26, this->show_locations(), output);
  }

  // repeated .valhalla.Location trace = 27;
  for (int i = 0; i < this->trace_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      27, this->trace(i), output);
  }

  // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
  if (has_shape_match()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      28, this->shape_match(), output);
  }

  // optional uint32 best_paths = 29 [default = 1];
  if (has_best_paths()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(29, this->best_paths(), output);
  }

  // optional float gps_accuracy = 30;
  if (has_gps_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(30, this->gps_accuracy(), output);
  }

  // optional float search_radius = 31;
  if (has_search_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(31, this->search_radius(), output);
  }

  // optional float turn_penalty_factor = 32;
  if (has_turn_penalty_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(32, this->turn_penalty_factor(), output);
  }

  // optional .valhalla.FilterAction filter_action = 33;
  if (has_filter_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      33, this->filter_action(), output);
  }

  // repeated string filter_attributes = 34;
  for (int i = 0; i < this->filter_attributes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      34, this->filter_attributes(i), output);
  }

  // repeated .valhalla.AvoidEdge avoid_edges = 35;
  for (int i = 0; i < this->avoid_edges_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      35, this->avoid_edges(i), output);
  }

  // optional float breakage_distance = 36;
  if (has_breakage_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(36, this->breakage_distance(), output);
  }

  // optional bool use_timestamps = 37 [default = false];
  if (has_use_timestamps()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(37, this->use_timestamps(), output);
  }

  // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
  if (has_shape_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      38, this->shape_format(), output);
  }

  // optional uint32 alternates = 39;
  if (has_alternates()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(39, this->alternates(), output);
  }

  // optional float interpolation_distance = 40;
  if (has_interpolation_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(40, this->interpolation_distance(), output);
  }

}

int Options::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .valhalla.Options.Units units = 1;
    if (has_units()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->units());
    }

    // optional string language = 2 [default = "en-US"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
    if (has_directions_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->directions_type());
    }

    // optional .valhalla.Options.Format format = 4 [default = json];
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->format());
    }

    // optional string id = 5;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional string jsonp = 6;
    if (has_jsonp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->jsonp());
    }

    // optional string encoded_polyline = 7;
    if (has_encoded_polyline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encoded_polyline());
    }

    // optional .valhalla.Options.Action action = 8;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool do_not_track = 9 [default = false];
    if (has_do_not_track()) {
      total_size += 1 + 1;
    }

    // optional bool range = 10 [default = false];
    if (has_range()) {
      total_size += 1 + 1;
    }

    // optional bool verbose = 11 [default = false];
    if (has_verbose()) {
      total_size += 1 + 1;
    }

    // optional .valhalla.Costing costing = 12;
    if (has_costing()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->costing());
    }

  }
  if (_has_bits_[17 / 32] & (0xffu << (17 % 32))) {
    // optional .valhalla.Options.DateTimeType date_time_type = 18;
    if (has_date_time_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->date_time_type());
    }

    // optional string date_time = 19;
    if (has_date_time()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->date_time());
    }

    // optional double resample_distance = 21;
    if (has_resample_distance()) {
      total_size += 2 + 8;
    }

    // optional bool polygons = 23;
    if (has_polygons()) {
      total_size += 2 + 1;
    }

    // optional float denoise = 24 [default = 1];
    if (has_denoise()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional float generalize = 25;
    if (has_generalize()) {
      total_size += 2 + 4;
    }

    // optional bool show_locations = 26;
    if (has_show_locations()) {
      total_size += 2 + 1;
    }

    // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
    if (has_shape_match()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->shape_match());
    }

    // optional uint32 best_paths = 29 [default = 1];
    if (has_best_paths()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->best_paths());
    }

    // optional float gps_accuracy = 30;
    if (has_gps_accuracy()) {
      total_size += 2 + 4;
    }

    // optional float search_radius = 31;
    if (has_search_radius()) {
      total_size += 2 + 4;
    }

    // optional float turn_penalty_factor = 32;
    if (has_turn_penalty_factor()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    // optional .valhalla.FilterAction filter_action = 33;
    if (has_filter_action()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filter_action());
    }

    // optional float breakage_distance = 36;
    if (has_breakage_distance()) {
      total_size += 2 + 4;
    }

    // optional bool use_timestamps = 37 [default = false];
    if (has_use_timestamps()) {
      total_size += 2 + 1;
    }

    // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
    if (has_shape_format()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->shape_format());
    }

    // optional uint32 alternates = 39;
    if (has_alternates()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->alternates());
    }

    // optional float interpolation_distance = 40;
    if (has_interpolation_distance()) {
      total_size += 2 + 4;
    }

  }
  // repeated .valhalla.CostingOptions costing_options = 13;
  total_size += 1 * this->costing_options_size();
  for (int i = 0; i < this->costing_options_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->costing_options(i));
  }

  // repeated .valhalla.Location locations = 14;
  total_size += 1 * this->locations_size();
  for (int i = 0; i < this->locations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->locations(i));
  }

  // repeated .valhalla.Location avoid_locations = 15;
  total_size += 1 * this->avoid_locations_size();
  for (int i = 0; i < this->avoid_locations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->avoid_locations(i));
  }

  // repeated .valhalla.Location sources = 16;
  total_size += 2 * this->sources_size();
  for (int i = 0; i < this->sources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sources(i));
  }

  // repeated .valhalla.Location targets = 17;
  total_size += 2 * this->targets_size();
  for (int i = 0; i < this->targets_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->targets(i));
  }

  // repeated .valhalla.Location shape = 20;
  total_size += 2 * this->shape_size();
  for (int i = 0; i < this->shape_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shape(i));
  }

  // repeated .valhalla.Contour contours = 22;
  total_size += 2 * this->contours_size();
  for (int i = 0; i < this->contours_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->contours(i));
  }

  // repeated .valhalla.Location trace = 27;
  total_size += 2 * this->trace_size();
  for (int i = 0; i < this->trace_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->trace(i));
  }

  // repeated string filter_attributes = 34;
  total_size += 2 * this->filter_attributes_size();
  for (int i = 0; i < this->filter_attributes_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_attributes(i));
  }

  // repeated .valhalla.AvoidEdge avoid_edges = 35;
  total_size += 2 * this->avoid_edges_size();
  for (int i = 0; i < this->avoid_edges_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->avoid_edges(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Options::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Options*>(&from));
}

void Options::MergeFrom(const Options& from) {
  GOOGLE_CHECK_NE(&from, this);
  costing_options_.MergeFrom(from.costing_options_);
  locations_.MergeFrom(from.locations_);
  avoid_locations_.MergeFrom(from.avoid_locations_);
  sources_.MergeFrom(from.sources_);
  targets_.MergeFrom(from.targets_);
  shape_.MergeFrom(from.shape_);
  contours_.MergeFrom(from.contours_);
  trace_.MergeFrom(from.trace_);
  filter_attributes_.MergeFrom(from.filter_attributes_);
  avoid_edges_.MergeFrom(from.avoid_edges_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_units()) {
      set_units(from.units());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_directions_type()) {
      set_directions_type(from.directions_type());
    }
    if (from.has_format()) {
      set_format(from.format());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_jsonp()) {
      set_jsonp(from.jsonp());
    }
    if (from.has_encoded_polyline()) {
      set_encoded_polyline(from.encoded_polyline());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_do_not_track()) {
      set_do_not_track(from.do_not_track());
    }
    if (from.has_range()) {
      set_range(from.range());
    }
    if (from.has_verbose()) {
      set_verbose(from.verbose());
    }
    if (from.has_costing()) {
      set_costing(from.costing());
    }
  }
  if (from._has_bits_[17 / 32] & (0xffu << (17 % 32))) {
    if (from.has_date_time_type()) {
      set_date_time_type(from.date_time_type());
    }
    if (from.has_date_time()) {
      set_date_time(from.date_time());
    }
    if (from.has_resample_distance()) {
      set_resample_distance(from.resample_distance());
    }
    if (from.has_polygons()) {
      set_polygons(from.polygons());
    }
    if (from.has_denoise()) {
      set_denoise(from.denoise());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_generalize()) {
      set_generalize(from.generalize());
    }
    if (from.has_show_locations()) {
      set_show_locations(from.show_locations());
    }
    if (from.has_shape_match()) {
      set_shape_match(from.shape_match());
    }
    if (from.has_best_paths()) {
      set_best_paths(from.best_paths());
    }
    if (from.has_gps_accuracy()) {
      set_gps_accuracy(from.gps_accuracy());
    }
    if (from.has_search_radius()) {
      set_search_radius(from.search_radius());
    }
    if (from.has_turn_penalty_factor()) {
      set_turn_penalty_factor(from.turn_penalty_factor());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_filter_action()) {
      set_filter_action(from.filter_action());
    }
    if (from.has_breakage_distance()) {
      set_breakage_distance(from.breakage_distance());
    }
    if (from.has_use_timestamps()) {
      set_use_timestamps(from.use_timestamps());
    }
    if (from.has_shape_format()) {
      set_shape_format(from.shape_format());
    }
    if (from.has_alternates()) {
      set_alternates(from.alternates());
    }
    if (from.has_interpolation_distance()) {
      set_interpolation_distance(from.interpolation_distance());
    }
  }
}

void Options::CopyFrom(const Options& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Options::IsInitialized() const {

  return true;
}

void Options::Swap(Options* other) {
  if (other != this) {
    std::swap(units_, other->units_);
    std::swap(language_, other->language_);
    std::swap(directions_type_, other->directions_type_);
    std::swap(format_, other->format_);
    std::swap(id_, other->id_);
    std::swap(jsonp_, other->jsonp_);
    std::swap(encoded_polyline_, other->encoded_polyline_);
    std::swap(action_, other->action_);
    std::swap(do_not_track_, other->do_not_track_);
    std::swap(range_, other->range_);
    std::swap(verbose_, other->verbose_);
    std::swap(costing_, other->costing_);
    costing_options_.Swap(&other->costing_options_);
    locations_.Swap(&other->locations_);
    avoid_locations_.Swap(&other->avoid_locations_);
    sources_.Swap(&other->sources_);
    targets_.Swap(&other->targets_);
    std::swap(date_time_type_, other->date_time_type_);
    std::swap(date_time_, other->date_time_);
    shape_.Swap(&other->shape_);
    std::swap(resample_distance_, other->resample_distance_);
    contours_.Swap(&other->contours_);
    std::swap(polygons_, other->polygons_);
    std::swap(denoise_, other->denoise_);
    std::swap(generalize_, other->generalize_);
    std::swap(show_locations_, other->show_locations_);
    trace_.Swap(&other->trace_);
    std::swap(shape_match_, other->shape_match_);
    std::swap(best_paths_, other->best_paths_);
    std::swap(gps_accuracy_, other->gps_accuracy_);
    std::swap(search_radius_, other->search_radius_);
    std::swap(turn_penalty_factor_, other->turn_penalty_factor_);
    std::swap(filter_action_, other->filter_action_);
    filter_attributes_.Swap(&other->filter_attributes_);
    avoid_edges_.Swap(&other->avoid_edges_);
    std::swap(breakage_distance_, other->breakage_distance_);
    std::swap(use_timestamps_, other->use_timestamps_);
    std::swap(shape_format_, other->shape_format_);
    std::swap(alternates_, other->alternates_);
    std::swap(interpolation_distance_, other->interpolation_distance_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_has_bits_[1], other->_has_bits_[1]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Options::GetTypeName() const {
  return "valhalla.Options";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)
