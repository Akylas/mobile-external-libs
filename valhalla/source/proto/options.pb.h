// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: options.proto

#ifndef PROTOBUF_options_2eproto__INCLUDED
#define PROTOBUF_options_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "tripcommon.pb.h"
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_options_2eproto();
void protobuf_AssignDesc_options_2eproto();
void protobuf_ShutdownFile_options_2eproto();

class Contour;
class CostingOptions;
class AvoidEdge;
class Options;

enum Options_Units {
  Options_Units_kilometers = 0,
  Options_Units_miles = 1
};
bool Options_Units_IsValid(int value);
const Options_Units Options_Units_Units_MIN = Options_Units_kilometers;
const Options_Units Options_Units_Units_MAX = Options_Units_miles;
const int Options_Units_Units_ARRAYSIZE = Options_Units_Units_MAX + 1;

enum Options_Format {
  Options_Format_json = 0,
  Options_Format_gpx = 1,
  Options_Format_osrm = 2
};
bool Options_Format_IsValid(int value);
const Options_Format Options_Format_Format_MIN = Options_Format_json;
const Options_Format Options_Format_Format_MAX = Options_Format_osrm;
const int Options_Format_Format_ARRAYSIZE = Options_Format_Format_MAX + 1;

enum Options_Action {
  Options_Action_route = 1,
  Options_Action_locate = 2,
  Options_Action_sources_to_targets = 6,
  Options_Action_optimized_route = 7,
  Options_Action_isochrone = 8,
  Options_Action_trace_route = 9,
  Options_Action_trace_attributes = 10,
  Options_Action_height = 11,
  Options_Action_transit_available = 12,
  Options_Action_expansion = 13
};
bool Options_Action_IsValid(int value);
const Options_Action Options_Action_Action_MIN = Options_Action_route;
const Options_Action Options_Action_Action_MAX = Options_Action_expansion;
const int Options_Action_Action_ARRAYSIZE = Options_Action_Action_MAX + 1;

enum Options_DateTimeType {
  Options_DateTimeType_current = 0,
  Options_DateTimeType_depart_at = 1,
  Options_DateTimeType_arrive_by = 2
};
bool Options_DateTimeType_IsValid(int value);
const Options_DateTimeType Options_DateTimeType_DateTimeType_MIN = Options_DateTimeType_current;
const Options_DateTimeType Options_DateTimeType_DateTimeType_MAX = Options_DateTimeType_arrive_by;
const int Options_DateTimeType_DateTimeType_ARRAYSIZE = Options_DateTimeType_DateTimeType_MAX + 1;

enum ShapeMatch {
  edge_walk = 0,
  map_snap = 1,
  walk_or_snap = 2
};
bool ShapeMatch_IsValid(int value);
const ShapeMatch ShapeMatch_MIN = edge_walk;
const ShapeMatch ShapeMatch_MAX = walk_or_snap;
const int ShapeMatch_ARRAYSIZE = ShapeMatch_MAX + 1;

enum FilterAction {
  exclude = 0,
  include = 1
};
bool FilterAction_IsValid(int value);
const FilterAction FilterAction_MIN = exclude;
const FilterAction FilterAction_MAX = include;
const int FilterAction_ARRAYSIZE = FilterAction_MAX + 1;

enum DirectionsType {
  none = 0,
  maneuvers = 1,
  instructions = 2
};
bool DirectionsType_IsValid(int value);
const DirectionsType DirectionsType_MIN = none;
const DirectionsType DirectionsType_MAX = instructions;
const int DirectionsType_ARRAYSIZE = DirectionsType_MAX + 1;

enum ShapeFormat {
  polyline5 = 0,
  polyline6 = 1,
  geojson = 2
};
bool ShapeFormat_IsValid(int value);
const ShapeFormat ShapeFormat_MIN = polyline5;
const ShapeFormat ShapeFormat_MAX = geojson;
const int ShapeFormat_ARRAYSIZE = ShapeFormat_MAX + 1;

enum Costing {
  auto_ = 0,
  auto_shorter = 1,
  bicycle = 2,
  bus = 3,
  hov = 4,
  motor_scooter = 5,
  multimodal = 6,
  pedestrian = 7,
  transit = 8,
  truck = 9,
  motorcycle = 10,
  auto_data_fix = 11,
  taxi = 12
};
bool Costing_IsValid(int value);
const Costing Costing_MIN = auto_;
const Costing Costing_MAX = taxi;
const int Costing_ARRAYSIZE = Costing_MAX + 1;

// ===================================================================

class Contour : public ::google::protobuf::MessageLite {
 public:
  Contour();
  virtual ~Contour();

  Contour(const Contour& from);

  inline Contour& operator=(const Contour& from) {
    CopyFrom(from);
    return *this;
  }

  static const Contour& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Contour* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Contour* other);

  // implements Message ----------------------------------------------

  Contour* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Contour& from);
  void MergeFrom(const Contour& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline float time() const;
  inline void set_time(float value);

  // optional string color = 2;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 2;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // @@protoc_insertion_point(class_scope:valhalla.Contour)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_color();
  inline void clear_has_color();

  ::std::string* color_;
  float time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static Contour* default_instance_;
};
// -------------------------------------------------------------------

class CostingOptions : public ::google::protobuf::MessageLite {
 public:
  CostingOptions();
  virtual ~CostingOptions();

  CostingOptions(const CostingOptions& from);

  inline CostingOptions& operator=(const CostingOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const CostingOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CostingOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CostingOptions* other);

  // implements Message ----------------------------------------------

  CostingOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CostingOptions& from);
  void MergeFrom(const CostingOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float maneuver_penalty = 1;
  inline bool has_maneuver_penalty() const;
  inline void clear_maneuver_penalty();
  static const int kManeuverPenaltyFieldNumber = 1;
  inline float maneuver_penalty() const;
  inline void set_maneuver_penalty(float value);

  // optional float destination_only_penalty = 2;
  inline bool has_destination_only_penalty() const;
  inline void clear_destination_only_penalty();
  static const int kDestinationOnlyPenaltyFieldNumber = 2;
  inline float destination_only_penalty() const;
  inline void set_destination_only_penalty(float value);

  // optional float gate_cost = 3;
  inline bool has_gate_cost() const;
  inline void clear_gate_cost();
  static const int kGateCostFieldNumber = 3;
  inline float gate_cost() const;
  inline void set_gate_cost(float value);

  // optional float gate_penalty = 4;
  inline bool has_gate_penalty() const;
  inline void clear_gate_penalty();
  static const int kGatePenaltyFieldNumber = 4;
  inline float gate_penalty() const;
  inline void set_gate_penalty(float value);

  // optional float toll_booth_cost = 5;
  inline bool has_toll_booth_cost() const;
  inline void clear_toll_booth_cost();
  static const int kTollBoothCostFieldNumber = 5;
  inline float toll_booth_cost() const;
  inline void set_toll_booth_cost(float value);

  // optional float toll_booth_penalty = 6;
  inline bool has_toll_booth_penalty() const;
  inline void clear_toll_booth_penalty();
  static const int kTollBoothPenaltyFieldNumber = 6;
  inline float toll_booth_penalty() const;
  inline void set_toll_booth_penalty(float value);

  // optional float alley_penalty = 7;
  inline bool has_alley_penalty() const;
  inline void clear_alley_penalty();
  static const int kAlleyPenaltyFieldNumber = 7;
  inline float alley_penalty() const;
  inline void set_alley_penalty(float value);

  // optional float country_crossing_cost = 8;
  inline bool has_country_crossing_cost() const;
  inline void clear_country_crossing_cost();
  static const int kCountryCrossingCostFieldNumber = 8;
  inline float country_crossing_cost() const;
  inline void set_country_crossing_cost(float value);

  // optional float country_crossing_penalty = 9;
  inline bool has_country_crossing_penalty() const;
  inline void clear_country_crossing_penalty();
  static const int kCountryCrossingPenaltyFieldNumber = 9;
  inline float country_crossing_penalty() const;
  inline void set_country_crossing_penalty(float value);

  // optional float ferry_cost = 10;
  inline bool has_ferry_cost() const;
  inline void clear_ferry_cost();
  static const int kFerryCostFieldNumber = 10;
  inline float ferry_cost() const;
  inline void set_ferry_cost(float value);

  // optional float avoid_bad_surfaces = 11;
  inline bool has_avoid_bad_surfaces() const;
  inline void clear_avoid_bad_surfaces();
  static const int kAvoidBadSurfacesFieldNumber = 11;
  inline float avoid_bad_surfaces() const;
  inline void set_avoid_bad_surfaces(float value);

  // optional float use_ferry = 12;
  inline bool has_use_ferry() const;
  inline void clear_use_ferry();
  static const int kUseFerryFieldNumber = 12;
  inline float use_ferry() const;
  inline void set_use_ferry(float value);

  // optional float use_highways = 13;
  inline bool has_use_highways() const;
  inline void clear_use_highways();
  static const int kUseHighwaysFieldNumber = 13;
  inline float use_highways() const;
  inline void set_use_highways(float value);

  // optional float use_tolls = 14;
  inline bool has_use_tolls() const;
  inline void clear_use_tolls();
  static const int kUseTollsFieldNumber = 14;
  inline float use_tolls() const;
  inline void set_use_tolls(float value);

  // optional float use_roads = 15;
  inline bool has_use_roads() const;
  inline void clear_use_roads();
  static const int kUseRoadsFieldNumber = 15;
  inline float use_roads() const;
  inline void set_use_roads(float value);

  // optional uint32 max_distance = 16;
  inline bool has_max_distance() const;
  inline void clear_max_distance();
  static const int kMaxDistanceFieldNumber = 16;
  inline ::google::protobuf::uint32 max_distance() const;
  inline void set_max_distance(::google::protobuf::uint32 value);

  // optional float walking_speed = 17;
  inline bool has_walking_speed() const;
  inline void clear_walking_speed();
  static const int kWalkingSpeedFieldNumber = 17;
  inline float walking_speed() const;
  inline void set_walking_speed(float value);

  // optional float step_penalty = 18;
  inline bool has_step_penalty() const;
  inline void clear_step_penalty();
  static const int kStepPenaltyFieldNumber = 18;
  inline float step_penalty() const;
  inline void set_step_penalty(float value);

  // optional uint32 max_grade = 19;
  inline bool has_max_grade() const;
  inline void clear_max_grade();
  static const int kMaxGradeFieldNumber = 19;
  inline ::google::protobuf::uint32 max_grade() const;
  inline void set_max_grade(::google::protobuf::uint32 value);

  // optional uint32 max_hiking_difficulty = 20;
  inline bool has_max_hiking_difficulty() const;
  inline void clear_max_hiking_difficulty();
  static const int kMaxHikingDifficultyFieldNumber = 20;
  inline ::google::protobuf::uint32 max_hiking_difficulty() const;
  inline void set_max_hiking_difficulty(::google::protobuf::uint32 value);

  // optional float mode_factor = 21;
  inline bool has_mode_factor() const;
  inline void clear_mode_factor();
  static const int kModeFactorFieldNumber = 21;
  inline float mode_factor() const;
  inline void set_mode_factor(float value);

  // optional float walkway_factor = 22;
  inline bool has_walkway_factor() const;
  inline void clear_walkway_factor();
  static const int kWalkwayFactorFieldNumber = 22;
  inline float walkway_factor() const;
  inline void set_walkway_factor(float value);

  // optional float sidewalk_factor = 23;
  inline bool has_sidewalk_factor() const;
  inline void clear_sidewalk_factor();
  static const int kSidewalkFactorFieldNumber = 23;
  inline float sidewalk_factor() const;
  inline void set_sidewalk_factor(float value);

  // optional float alley_factor = 24;
  inline bool has_alley_factor() const;
  inline void clear_alley_factor();
  static const int kAlleyFactorFieldNumber = 24;
  inline float alley_factor() const;
  inline void set_alley_factor(float value);

  // optional float driveway_factor = 25;
  inline bool has_driveway_factor() const;
  inline void clear_driveway_factor();
  static const int kDrivewayFactorFieldNumber = 25;
  inline float driveway_factor() const;
  inline void set_driveway_factor(float value);

  // optional float driveway_penalty = 26;
  inline bool has_driveway_penalty() const;
  inline void clear_driveway_penalty();
  static const int kDrivewayPenaltyFieldNumber = 26;
  inline float driveway_penalty() const;
  inline void set_driveway_penalty(float value);

  // optional uint32 transit_start_end_max_distance = 27;
  inline bool has_transit_start_end_max_distance() const;
  inline void clear_transit_start_end_max_distance();
  static const int kTransitStartEndMaxDistanceFieldNumber = 27;
  inline ::google::protobuf::uint32 transit_start_end_max_distance() const;
  inline void set_transit_start_end_max_distance(::google::protobuf::uint32 value);

  // optional uint32 transit_transfer_max_distance = 28;
  inline bool has_transit_transfer_max_distance() const;
  inline void clear_transit_transfer_max_distance();
  static const int kTransitTransferMaxDistanceFieldNumber = 28;
  inline ::google::protobuf::uint32 transit_transfer_max_distance() const;
  inline void set_transit_transfer_max_distance(::google::protobuf::uint32 value);

  // optional string transport_type = 29;
  inline bool has_transport_type() const;
  inline void clear_transport_type();
  static const int kTransportTypeFieldNumber = 29;
  inline const ::std::string& transport_type() const;
  inline void set_transport_type(const ::std::string& value);
  inline void set_transport_type(const char* value);
  inline void set_transport_type(const char* value, size_t size);
  inline ::std::string* mutable_transport_type();
  inline ::std::string* release_transport_type();
  inline void set_allocated_transport_type(::std::string* transport_type);

  // optional float top_speed = 30;
  inline bool has_top_speed() const;
  inline void clear_top_speed();
  static const int kTopSpeedFieldNumber = 30;
  inline float top_speed() const;
  inline void set_top_speed(float value);

  // optional float use_hills = 31;
  inline bool has_use_hills() const;
  inline void clear_use_hills();
  static const int kUseHillsFieldNumber = 31;
  inline float use_hills() const;
  inline void set_use_hills(float value);

  // optional float use_primary = 32;
  inline bool has_use_primary() const;
  inline void clear_use_primary();
  static const int kUsePrimaryFieldNumber = 32;
  inline float use_primary() const;
  inline void set_use_primary(float value);

  // optional float use_trails = 33;
  inline bool has_use_trails() const;
  inline void clear_use_trails();
  static const int kUseTrailsFieldNumber = 33;
  inline float use_trails() const;
  inline void set_use_trails(float value);

  // optional float low_class_penalty = 34;
  inline bool has_low_class_penalty() const;
  inline void clear_low_class_penalty();
  static const int kLowClassPenaltyFieldNumber = 34;
  inline float low_class_penalty() const;
  inline void set_low_class_penalty(float value);

  // optional bool hazmat = 35;
  inline bool has_hazmat() const;
  inline void clear_hazmat();
  static const int kHazmatFieldNumber = 35;
  inline bool hazmat() const;
  inline void set_hazmat(bool value);

  // optional float weight = 36;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 36;
  inline float weight() const;
  inline void set_weight(float value);

  // optional float axle_load = 37;
  inline bool has_axle_load() const;
  inline void clear_axle_load();
  static const int kAxleLoadFieldNumber = 37;
  inline float axle_load() const;
  inline void set_axle_load(float value);

  // optional float height = 38;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 38;
  inline float height() const;
  inline void set_height(float value);

  // optional float width = 39;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 39;
  inline float width() const;
  inline void set_width(float value);

  // optional float length = 40;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 40;
  inline float length() const;
  inline void set_length(float value);

  // optional float cycling_speed = 41;
  inline bool has_cycling_speed() const;
  inline void clear_cycling_speed();
  static const int kCyclingSpeedFieldNumber = 41;
  inline float cycling_speed() const;
  inline void set_cycling_speed(float value);

  // optional bool wheelchair = 42;
  inline bool has_wheelchair() const;
  inline void clear_wheelchair();
  static const int kWheelchairFieldNumber = 42;
  inline bool wheelchair() const;
  inline void set_wheelchair(bool value);

  // optional bool bicycle = 43;
  inline bool has_bicycle() const;
  inline void clear_bicycle();
  static const int kBicycleFieldNumber = 43;
  inline bool bicycle() const;
  inline void set_bicycle(bool value);

  // optional float use_bus = 44;
  inline bool has_use_bus() const;
  inline void clear_use_bus();
  static const int kUseBusFieldNumber = 44;
  inline float use_bus() const;
  inline void set_use_bus(float value);

  // optional float use_rail = 45;
  inline bool has_use_rail() const;
  inline void clear_use_rail();
  static const int kUseRailFieldNumber = 45;
  inline float use_rail() const;
  inline void set_use_rail(float value);

  // optional float use_transfers = 46;
  inline bool has_use_transfers() const;
  inline void clear_use_transfers();
  static const int kUseTransfersFieldNumber = 46;
  inline float use_transfers() const;
  inline void set_use_transfers(float value);

  // optional float transfer_cost = 47;
  inline bool has_transfer_cost() const;
  inline void clear_transfer_cost();
  static const int kTransferCostFieldNumber = 47;
  inline float transfer_cost() const;
  inline void set_transfer_cost(float value);

  // optional float transfer_penalty = 48;
  inline bool has_transfer_penalty() const;
  inline void clear_transfer_penalty();
  static const int kTransferPenaltyFieldNumber = 48;
  inline float transfer_penalty() const;
  inline void set_transfer_penalty(float value);

  // optional .valhalla.FilterAction filter_stop_action = 49;
  inline bool has_filter_stop_action() const;
  inline void clear_filter_stop_action();
  static const int kFilterStopActionFieldNumber = 49;
  inline ::valhalla::FilterAction filter_stop_action() const;
  inline void set_filter_stop_action(::valhalla::FilterAction value);

  // repeated string filter_stop_ids = 50;
  inline int filter_stop_ids_size() const;
  inline void clear_filter_stop_ids();
  static const int kFilterStopIdsFieldNumber = 50;
  inline const ::std::string& filter_stop_ids(int index) const;
  inline ::std::string* mutable_filter_stop_ids(int index);
  inline void set_filter_stop_ids(int index, const ::std::string& value);
  inline void set_filter_stop_ids(int index, const char* value);
  inline void set_filter_stop_ids(int index, const char* value, size_t size);
  inline ::std::string* add_filter_stop_ids();
  inline void add_filter_stop_ids(const ::std::string& value);
  inline void add_filter_stop_ids(const char* value);
  inline void add_filter_stop_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_stop_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_stop_ids();

  // optional .valhalla.FilterAction filter_operator_action = 51;
  inline bool has_filter_operator_action() const;
  inline void clear_filter_operator_action();
  static const int kFilterOperatorActionFieldNumber = 51;
  inline ::valhalla::FilterAction filter_operator_action() const;
  inline void set_filter_operator_action(::valhalla::FilterAction value);

  // repeated string filter_operator_ids = 52;
  inline int filter_operator_ids_size() const;
  inline void clear_filter_operator_ids();
  static const int kFilterOperatorIdsFieldNumber = 52;
  inline const ::std::string& filter_operator_ids(int index) const;
  inline ::std::string* mutable_filter_operator_ids(int index);
  inline void set_filter_operator_ids(int index, const ::std::string& value);
  inline void set_filter_operator_ids(int index, const char* value);
  inline void set_filter_operator_ids(int index, const char* value, size_t size);
  inline ::std::string* add_filter_operator_ids();
  inline void add_filter_operator_ids(const ::std::string& value);
  inline void add_filter_operator_ids(const char* value);
  inline void add_filter_operator_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_operator_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_operator_ids();

  // optional .valhalla.FilterAction filter_route_action = 53;
  inline bool has_filter_route_action() const;
  inline void clear_filter_route_action();
  static const int kFilterRouteActionFieldNumber = 53;
  inline ::valhalla::FilterAction filter_route_action() const;
  inline void set_filter_route_action(::valhalla::FilterAction value);

  // repeated string filter_route_ids = 54;
  inline int filter_route_ids_size() const;
  inline void clear_filter_route_ids();
  static const int kFilterRouteIdsFieldNumber = 54;
  inline const ::std::string& filter_route_ids(int index) const;
  inline ::std::string* mutable_filter_route_ids(int index);
  inline void set_filter_route_ids(int index, const ::std::string& value);
  inline void set_filter_route_ids(int index, const char* value);
  inline void set_filter_route_ids(int index, const char* value, size_t size);
  inline ::std::string* add_filter_route_ids();
  inline void add_filter_route_ids(const ::std::string& value);
  inline void add_filter_route_ids(const char* value);
  inline void add_filter_route_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_route_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_route_ids();

  // optional uint32 flow_mask = 55;
  inline bool has_flow_mask() const;
  inline void clear_flow_mask();
  static const int kFlowMaskFieldNumber = 55;
  inline ::google::protobuf::uint32 flow_mask() const;
  inline void set_flow_mask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.CostingOptions)
 private:
  inline void set_has_maneuver_penalty();
  inline void clear_has_maneuver_penalty();
  inline void set_has_destination_only_penalty();
  inline void clear_has_destination_only_penalty();
  inline void set_has_gate_cost();
  inline void clear_has_gate_cost();
  inline void set_has_gate_penalty();
  inline void clear_has_gate_penalty();
  inline void set_has_toll_booth_cost();
  inline void clear_has_toll_booth_cost();
  inline void set_has_toll_booth_penalty();
  inline void clear_has_toll_booth_penalty();
  inline void set_has_alley_penalty();
  inline void clear_has_alley_penalty();
  inline void set_has_country_crossing_cost();
  inline void clear_has_country_crossing_cost();
  inline void set_has_country_crossing_penalty();
  inline void clear_has_country_crossing_penalty();
  inline void set_has_ferry_cost();
  inline void clear_has_ferry_cost();
  inline void set_has_avoid_bad_surfaces();
  inline void clear_has_avoid_bad_surfaces();
  inline void set_has_use_ferry();
  inline void clear_has_use_ferry();
  inline void set_has_use_highways();
  inline void clear_has_use_highways();
  inline void set_has_use_tolls();
  inline void clear_has_use_tolls();
  inline void set_has_use_roads();
  inline void clear_has_use_roads();
  inline void set_has_max_distance();
  inline void clear_has_max_distance();
  inline void set_has_walking_speed();
  inline void clear_has_walking_speed();
  inline void set_has_step_penalty();
  inline void clear_has_step_penalty();
  inline void set_has_max_grade();
  inline void clear_has_max_grade();
  inline void set_has_max_hiking_difficulty();
  inline void clear_has_max_hiking_difficulty();
  inline void set_has_mode_factor();
  inline void clear_has_mode_factor();
  inline void set_has_walkway_factor();
  inline void clear_has_walkway_factor();
  inline void set_has_sidewalk_factor();
  inline void clear_has_sidewalk_factor();
  inline void set_has_alley_factor();
  inline void clear_has_alley_factor();
  inline void set_has_driveway_factor();
  inline void clear_has_driveway_factor();
  inline void set_has_driveway_penalty();
  inline void clear_has_driveway_penalty();
  inline void set_has_transit_start_end_max_distance();
  inline void clear_has_transit_start_end_max_distance();
  inline void set_has_transit_transfer_max_distance();
  inline void clear_has_transit_transfer_max_distance();
  inline void set_has_transport_type();
  inline void clear_has_transport_type();
  inline void set_has_top_speed();
  inline void clear_has_top_speed();
  inline void set_has_use_hills();
  inline void clear_has_use_hills();
  inline void set_has_use_primary();
  inline void clear_has_use_primary();
  inline void set_has_use_trails();
  inline void clear_has_use_trails();
  inline void set_has_low_class_penalty();
  inline void clear_has_low_class_penalty();
  inline void set_has_hazmat();
  inline void clear_has_hazmat();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_axle_load();
  inline void clear_has_axle_load();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_cycling_speed();
  inline void clear_has_cycling_speed();
  inline void set_has_wheelchair();
  inline void clear_has_wheelchair();
  inline void set_has_bicycle();
  inline void clear_has_bicycle();
  inline void set_has_use_bus();
  inline void clear_has_use_bus();
  inline void set_has_use_rail();
  inline void clear_has_use_rail();
  inline void set_has_use_transfers();
  inline void clear_has_use_transfers();
  inline void set_has_transfer_cost();
  inline void clear_has_transfer_cost();
  inline void set_has_transfer_penalty();
  inline void clear_has_transfer_penalty();
  inline void set_has_filter_stop_action();
  inline void clear_has_filter_stop_action();
  inline void set_has_filter_operator_action();
  inline void clear_has_filter_operator_action();
  inline void set_has_filter_route_action();
  inline void clear_has_filter_route_action();
  inline void set_has_flow_mask();
  inline void clear_has_flow_mask();

  float maneuver_penalty_;
  float destination_only_penalty_;
  float gate_cost_;
  float gate_penalty_;
  float toll_booth_cost_;
  float toll_booth_penalty_;
  float alley_penalty_;
  float country_crossing_cost_;
  float country_crossing_penalty_;
  float ferry_cost_;
  float avoid_bad_surfaces_;
  float use_ferry_;
  float use_highways_;
  float use_tolls_;
  float use_roads_;
  ::google::protobuf::uint32 max_distance_;
  float walking_speed_;
  float step_penalty_;
  ::google::protobuf::uint32 max_grade_;
  ::google::protobuf::uint32 max_hiking_difficulty_;
  float mode_factor_;
  float walkway_factor_;
  float sidewalk_factor_;
  float alley_factor_;
  float driveway_factor_;
  float driveway_penalty_;
  ::google::protobuf::uint32 transit_start_end_max_distance_;
  ::google::protobuf::uint32 transit_transfer_max_distance_;
  ::std::string* transport_type_;
  float top_speed_;
  float use_hills_;
  float use_primary_;
  float use_trails_;
  float low_class_penalty_;
  float weight_;
  float axle_load_;
  float height_;
  float width_;
  bool hazmat_;
  bool wheelchair_;
  bool bicycle_;
  float length_;
  float cycling_speed_;
  float use_bus_;
  float use_rail_;
  float use_transfers_;
  float transfer_cost_;
  float transfer_penalty_;
  int filter_stop_action_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_stop_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_operator_ids_;
  int filter_operator_action_;
  int filter_route_action_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_route_ids_;
  ::google::protobuf::uint32 flow_mask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(55 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static CostingOptions* default_instance_;
};
// -------------------------------------------------------------------

class AvoidEdge : public ::google::protobuf::MessageLite {
 public:
  AvoidEdge();
  virtual ~AvoidEdge();

  AvoidEdge(const AvoidEdge& from);

  inline AvoidEdge& operator=(const AvoidEdge& from) {
    CopyFrom(from);
    return *this;
  }

  static const AvoidEdge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvoidEdge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvoidEdge* other);

  // implements Message ----------------------------------------------

  AvoidEdge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvoidEdge& from);
  void MergeFrom(const AvoidEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional float percent_along = 2;
  inline bool has_percent_along() const;
  inline void clear_percent_along();
  static const int kPercentAlongFieldNumber = 2;
  inline float percent_along() const;
  inline void set_percent_along(float value);

  // @@protoc_insertion_point(class_scope:valhalla.AvoidEdge)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_percent_along();
  inline void clear_has_percent_along();

  ::google::protobuf::uint64 id_;
  float percent_along_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static AvoidEdge* default_instance_;
};
// -------------------------------------------------------------------

class Options : public ::google::protobuf::MessageLite {
 public:
  Options();
  virtual ~Options();

  Options(const Options& from);

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }

  static const Options& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Options* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Options* other);

  // implements Message ----------------------------------------------

  Options* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Options_Units Units;
  static const Units kilometers = Options_Units_kilometers;
  static const Units miles = Options_Units_miles;
  static inline bool Units_IsValid(int value) {
    return Options_Units_IsValid(value);
  }
  static const Units Units_MIN =
    Options_Units_Units_MIN;
  static const Units Units_MAX =
    Options_Units_Units_MAX;
  static const int Units_ARRAYSIZE =
    Options_Units_Units_ARRAYSIZE;

  typedef Options_Format Format;
  static const Format json = Options_Format_json;
  static const Format gpx = Options_Format_gpx;
  static const Format osrm = Options_Format_osrm;
  static inline bool Format_IsValid(int value) {
    return Options_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Options_Format_Format_MIN;
  static const Format Format_MAX =
    Options_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Options_Format_Format_ARRAYSIZE;

  typedef Options_Action Action;
  static const Action route = Options_Action_route;
  static const Action locate = Options_Action_locate;
  static const Action sources_to_targets = Options_Action_sources_to_targets;
  static const Action optimized_route = Options_Action_optimized_route;
  static const Action isochrone = Options_Action_isochrone;
  static const Action trace_route = Options_Action_trace_route;
  static const Action trace_attributes = Options_Action_trace_attributes;
  static const Action height = Options_Action_height;
  static const Action transit_available = Options_Action_transit_available;
  static const Action expansion = Options_Action_expansion;
  static inline bool Action_IsValid(int value) {
    return Options_Action_IsValid(value);
  }
  static const Action Action_MIN =
    Options_Action_Action_MIN;
  static const Action Action_MAX =
    Options_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    Options_Action_Action_ARRAYSIZE;

  typedef Options_DateTimeType DateTimeType;
  static const DateTimeType current = Options_DateTimeType_current;
  static const DateTimeType depart_at = Options_DateTimeType_depart_at;
  static const DateTimeType arrive_by = Options_DateTimeType_arrive_by;
  static inline bool DateTimeType_IsValid(int value) {
    return Options_DateTimeType_IsValid(value);
  }
  static const DateTimeType DateTimeType_MIN =
    Options_DateTimeType_DateTimeType_MIN;
  static const DateTimeType DateTimeType_MAX =
    Options_DateTimeType_DateTimeType_MAX;
  static const int DateTimeType_ARRAYSIZE =
    Options_DateTimeType_DateTimeType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.Options.Units units = 1;
  inline bool has_units() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline ::valhalla::Options_Units units() const;
  inline void set_units(::valhalla::Options_Units value);

  // optional string language = 2 [default = "en-US"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 2;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
  inline bool has_directions_type() const;
  inline void clear_directions_type();
  static const int kDirectionsTypeFieldNumber = 3;
  inline ::valhalla::DirectionsType directions_type() const;
  inline void set_directions_type(::valhalla::DirectionsType value);

  // optional .valhalla.Options.Format format = 4 [default = json];
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 4;
  inline ::valhalla::Options_Format format() const;
  inline void set_format(::valhalla::Options_Format value);

  // optional string id = 5;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string jsonp = 6;
  inline bool has_jsonp() const;
  inline void clear_jsonp();
  static const int kJsonpFieldNumber = 6;
  inline const ::std::string& jsonp() const;
  inline void set_jsonp(const ::std::string& value);
  inline void set_jsonp(const char* value);
  inline void set_jsonp(const char* value, size_t size);
  inline ::std::string* mutable_jsonp();
  inline ::std::string* release_jsonp();
  inline void set_allocated_jsonp(::std::string* jsonp);

  // optional string encoded_polyline = 7;
  inline bool has_encoded_polyline() const;
  inline void clear_encoded_polyline();
  static const int kEncodedPolylineFieldNumber = 7;
  inline const ::std::string& encoded_polyline() const;
  inline void set_encoded_polyline(const ::std::string& value);
  inline void set_encoded_polyline(const char* value);
  inline void set_encoded_polyline(const char* value, size_t size);
  inline ::std::string* mutable_encoded_polyline();
  inline ::std::string* release_encoded_polyline();
  inline void set_allocated_encoded_polyline(::std::string* encoded_polyline);

  // optional .valhalla.Options.Action action = 8;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 8;
  inline ::valhalla::Options_Action action() const;
  inline void set_action(::valhalla::Options_Action value);

  // optional bool do_not_track = 9 [default = false];
  inline bool has_do_not_track() const;
  inline void clear_do_not_track();
  static const int kDoNotTrackFieldNumber = 9;
  inline bool do_not_track() const;
  inline void set_do_not_track(bool value);

  // optional bool range = 10 [default = false];
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 10;
  inline bool range() const;
  inline void set_range(bool value);

  // optional bool verbose = 11 [default = false];
  inline bool has_verbose() const;
  inline void clear_verbose();
  static const int kVerboseFieldNumber = 11;
  inline bool verbose() const;
  inline void set_verbose(bool value);

  // optional .valhalla.Costing costing = 12;
  inline bool has_costing() const;
  inline void clear_costing();
  static const int kCostingFieldNumber = 12;
  inline ::valhalla::Costing costing() const;
  inline void set_costing(::valhalla::Costing value);

  // repeated .valhalla.CostingOptions costing_options = 13;
  inline int costing_options_size() const;
  inline void clear_costing_options();
  static const int kCostingOptionsFieldNumber = 13;
  inline const ::valhalla::CostingOptions& costing_options(int index) const;
  inline ::valhalla::CostingOptions* mutable_costing_options(int index);
  inline ::valhalla::CostingOptions* add_costing_options();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >&
      costing_options() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >*
      mutable_costing_options();

  // repeated .valhalla.Location locations = 14;
  inline int locations_size() const;
  inline void clear_locations();
  static const int kLocationsFieldNumber = 14;
  inline const ::valhalla::Location& locations(int index) const;
  inline ::valhalla::Location* mutable_locations(int index);
  inline ::valhalla::Location* add_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_locations();

  // repeated .valhalla.Location avoid_locations = 15;
  inline int avoid_locations_size() const;
  inline void clear_avoid_locations();
  static const int kAvoidLocationsFieldNumber = 15;
  inline const ::valhalla::Location& avoid_locations(int index) const;
  inline ::valhalla::Location* mutable_avoid_locations(int index);
  inline ::valhalla::Location* add_avoid_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      avoid_locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_avoid_locations();

  // repeated .valhalla.Location sources = 16;
  inline int sources_size() const;
  inline void clear_sources();
  static const int kSourcesFieldNumber = 16;
  inline const ::valhalla::Location& sources(int index) const;
  inline ::valhalla::Location* mutable_sources(int index);
  inline ::valhalla::Location* add_sources();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      sources() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_sources();

  // repeated .valhalla.Location targets = 17;
  inline int targets_size() const;
  inline void clear_targets();
  static const int kTargetsFieldNumber = 17;
  inline const ::valhalla::Location& targets(int index) const;
  inline ::valhalla::Location* mutable_targets(int index);
  inline ::valhalla::Location* add_targets();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      targets() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_targets();

  // optional .valhalla.Options.DateTimeType date_time_type = 18;
  inline bool has_date_time_type() const;
  inline void clear_date_time_type();
  static const int kDateTimeTypeFieldNumber = 18;
  inline ::valhalla::Options_DateTimeType date_time_type() const;
  inline void set_date_time_type(::valhalla::Options_DateTimeType value);

  // optional string date_time = 19;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 19;
  inline const ::std::string& date_time() const;
  inline void set_date_time(const ::std::string& value);
  inline void set_date_time(const char* value);
  inline void set_date_time(const char* value, size_t size);
  inline ::std::string* mutable_date_time();
  inline ::std::string* release_date_time();
  inline void set_allocated_date_time(::std::string* date_time);

  // repeated .valhalla.Location shape = 20;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 20;
  inline const ::valhalla::Location& shape(int index) const;
  inline ::valhalla::Location* mutable_shape(int index);
  inline ::valhalla::Location* add_shape();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      shape() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_shape();

  // optional double resample_distance = 21;
  inline bool has_resample_distance() const;
  inline void clear_resample_distance();
  static const int kResampleDistanceFieldNumber = 21;
  inline double resample_distance() const;
  inline void set_resample_distance(double value);

  // repeated .valhalla.Contour contours = 22;
  inline int contours_size() const;
  inline void clear_contours();
  static const int kContoursFieldNumber = 22;
  inline const ::valhalla::Contour& contours(int index) const;
  inline ::valhalla::Contour* mutable_contours(int index);
  inline ::valhalla::Contour* add_contours();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >&
      contours() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >*
      mutable_contours();

  // optional bool polygons = 23;
  inline bool has_polygons() const;
  inline void clear_polygons();
  static const int kPolygonsFieldNumber = 23;
  inline bool polygons() const;
  inline void set_polygons(bool value);

  // optional float denoise = 24 [default = 1];
  inline bool has_denoise() const;
  inline void clear_denoise();
  static const int kDenoiseFieldNumber = 24;
  inline float denoise() const;
  inline void set_denoise(float value);

  // optional float generalize = 25;
  inline bool has_generalize() const;
  inline void clear_generalize();
  static const int kGeneralizeFieldNumber = 25;
  inline float generalize() const;
  inline void set_generalize(float value);

  // optional bool show_locations = 26;
  inline bool has_show_locations() const;
  inline void clear_show_locations();
  static const int kShowLocationsFieldNumber = 26;
  inline bool show_locations() const;
  inline void set_show_locations(bool value);

  // repeated .valhalla.Location trace = 27;
  inline int trace_size() const;
  inline void clear_trace();
  static const int kTraceFieldNumber = 27;
  inline const ::valhalla::Location& trace(int index) const;
  inline ::valhalla::Location* mutable_trace(int index);
  inline ::valhalla::Location* add_trace();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      trace() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_trace();

  // optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
  inline bool has_shape_match() const;
  inline void clear_shape_match();
  static const int kShapeMatchFieldNumber = 28;
  inline ::valhalla::ShapeMatch shape_match() const;
  inline void set_shape_match(::valhalla::ShapeMatch value);

  // optional uint32 best_paths = 29 [default = 1];
  inline bool has_best_paths() const;
  inline void clear_best_paths();
  static const int kBestPathsFieldNumber = 29;
  inline ::google::protobuf::uint32 best_paths() const;
  inline void set_best_paths(::google::protobuf::uint32 value);

  // optional float gps_accuracy = 30;
  inline bool has_gps_accuracy() const;
  inline void clear_gps_accuracy();
  static const int kGpsAccuracyFieldNumber = 30;
  inline float gps_accuracy() const;
  inline void set_gps_accuracy(float value);

  // optional float search_radius = 31;
  inline bool has_search_radius() const;
  inline void clear_search_radius();
  static const int kSearchRadiusFieldNumber = 31;
  inline float search_radius() const;
  inline void set_search_radius(float value);

  // optional float turn_penalty_factor = 32;
  inline bool has_turn_penalty_factor() const;
  inline void clear_turn_penalty_factor();
  static const int kTurnPenaltyFactorFieldNumber = 32;
  inline float turn_penalty_factor() const;
  inline void set_turn_penalty_factor(float value);

  // optional .valhalla.FilterAction filter_action = 33;
  inline bool has_filter_action() const;
  inline void clear_filter_action();
  static const int kFilterActionFieldNumber = 33;
  inline ::valhalla::FilterAction filter_action() const;
  inline void set_filter_action(::valhalla::FilterAction value);

  // repeated string filter_attributes = 34;
  inline int filter_attributes_size() const;
  inline void clear_filter_attributes();
  static const int kFilterAttributesFieldNumber = 34;
  inline const ::std::string& filter_attributes(int index) const;
  inline ::std::string* mutable_filter_attributes(int index);
  inline void set_filter_attributes(int index, const ::std::string& value);
  inline void set_filter_attributes(int index, const char* value);
  inline void set_filter_attributes(int index, const char* value, size_t size);
  inline ::std::string* add_filter_attributes();
  inline void add_filter_attributes(const ::std::string& value);
  inline void add_filter_attributes(const char* value);
  inline void add_filter_attributes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_attributes();

  // repeated .valhalla.AvoidEdge avoid_edges = 35;
  inline int avoid_edges_size() const;
  inline void clear_avoid_edges();
  static const int kAvoidEdgesFieldNumber = 35;
  inline const ::valhalla::AvoidEdge& avoid_edges(int index) const;
  inline ::valhalla::AvoidEdge* mutable_avoid_edges(int index);
  inline ::valhalla::AvoidEdge* add_avoid_edges();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >&
      avoid_edges() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >*
      mutable_avoid_edges();

  // optional float breakage_distance = 36;
  inline bool has_breakage_distance() const;
  inline void clear_breakage_distance();
  static const int kBreakageDistanceFieldNumber = 36;
  inline float breakage_distance() const;
  inline void set_breakage_distance(float value);

  // optional bool use_timestamps = 37 [default = false];
  inline bool has_use_timestamps() const;
  inline void clear_use_timestamps();
  static const int kUseTimestampsFieldNumber = 37;
  inline bool use_timestamps() const;
  inline void set_use_timestamps(bool value);

  // optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
  inline bool has_shape_format() const;
  inline void clear_shape_format();
  static const int kShapeFormatFieldNumber = 38;
  inline ::valhalla::ShapeFormat shape_format() const;
  inline void set_shape_format(::valhalla::ShapeFormat value);

  // optional uint32 alternates = 39;
  inline bool has_alternates() const;
  inline void clear_alternates();
  static const int kAlternatesFieldNumber = 39;
  inline ::google::protobuf::uint32 alternates() const;
  inline void set_alternates(::google::protobuf::uint32 value);

  // optional float interpolation_distance = 40;
  inline bool has_interpolation_distance() const;
  inline void clear_interpolation_distance();
  static const int kInterpolationDistanceFieldNumber = 40;
  inline float interpolation_distance() const;
  inline void set_interpolation_distance(float value);

  // @@protoc_insertion_point(class_scope:valhalla.Options)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_directions_type();
  inline void clear_has_directions_type();
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_jsonp();
  inline void clear_has_jsonp();
  inline void set_has_encoded_polyline();
  inline void clear_has_encoded_polyline();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_do_not_track();
  inline void clear_has_do_not_track();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_verbose();
  inline void clear_has_verbose();
  inline void set_has_costing();
  inline void clear_has_costing();
  inline void set_has_date_time_type();
  inline void clear_has_date_time_type();
  inline void set_has_date_time();
  inline void clear_has_date_time();
  inline void set_has_resample_distance();
  inline void clear_has_resample_distance();
  inline void set_has_polygons();
  inline void clear_has_polygons();
  inline void set_has_denoise();
  inline void clear_has_denoise();
  inline void set_has_generalize();
  inline void clear_has_generalize();
  inline void set_has_show_locations();
  inline void clear_has_show_locations();
  inline void set_has_shape_match();
  inline void clear_has_shape_match();
  inline void set_has_best_paths();
  inline void clear_has_best_paths();
  inline void set_has_gps_accuracy();
  inline void clear_has_gps_accuracy();
  inline void set_has_search_radius();
  inline void clear_has_search_radius();
  inline void set_has_turn_penalty_factor();
  inline void clear_has_turn_penalty_factor();
  inline void set_has_filter_action();
  inline void clear_has_filter_action();
  inline void set_has_breakage_distance();
  inline void clear_has_breakage_distance();
  inline void set_has_use_timestamps();
  inline void clear_has_use_timestamps();
  inline void set_has_shape_format();
  inline void clear_has_shape_format();
  inline void set_has_alternates();
  inline void clear_has_alternates();
  inline void set_has_interpolation_distance();
  inline void clear_has_interpolation_distance();

  int units_;
  int directions_type_;
  ::std::string* language_;
  static ::std::string* _default_language_;
  ::std::string* id_;
  ::std::string* jsonp_;
  int format_;
  int action_;
  ::std::string* encoded_polyline_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions > costing_options_;
  int costing_;
  bool do_not_track_;
  bool range_;
  bool verbose_;
  bool polygons_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > avoid_locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > sources_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > targets_;
  ::std::string* date_time_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > shape_;
  int date_time_type_;
  float denoise_;
  double resample_distance_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Contour > contours_;
  float generalize_;
  int shape_match_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > trace_;
  ::google::protobuf::uint32 best_paths_;
  float gps_accuracy_;
  float search_radius_;
  bool show_locations_;
  bool use_timestamps_;
  float turn_penalty_factor_;
  int filter_action_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_attributes_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge > avoid_edges_;
  float breakage_distance_;
  int shape_format_;
  ::google::protobuf::uint32 alternates_;
  float interpolation_distance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(40 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_options_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_options_2eproto();
  #endif
  friend void protobuf_AssignDesc_options_2eproto();
  friend void protobuf_ShutdownFile_options_2eproto();

  void InitAsDefaultInstance();
  static Options* default_instance_;
};
// ===================================================================


// ===================================================================

// Contour

// optional float time = 1;
inline bool Contour::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contour::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contour::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contour::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline float Contour::time() const {
  return time_;
}
inline void Contour::set_time(float value) {
  set_has_time();
  time_ = value;
}

// optional string color = 2;
inline bool Contour::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contour::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contour::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contour::clear_color() {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& Contour::color() const {
  return *color_;
}
inline void Contour::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void Contour::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void Contour::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contour::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  return color_;
}
inline ::std::string* Contour::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Contour::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CostingOptions

// optional float maneuver_penalty = 1;
inline bool CostingOptions::has_maneuver_penalty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CostingOptions::set_has_maneuver_penalty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CostingOptions::clear_has_maneuver_penalty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CostingOptions::clear_maneuver_penalty() {
  maneuver_penalty_ = 0;
  clear_has_maneuver_penalty();
}
inline float CostingOptions::maneuver_penalty() const {
  return maneuver_penalty_;
}
inline void CostingOptions::set_maneuver_penalty(float value) {
  set_has_maneuver_penalty();
  maneuver_penalty_ = value;
}

// optional float destination_only_penalty = 2;
inline bool CostingOptions::has_destination_only_penalty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CostingOptions::set_has_destination_only_penalty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CostingOptions::clear_has_destination_only_penalty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CostingOptions::clear_destination_only_penalty() {
  destination_only_penalty_ = 0;
  clear_has_destination_only_penalty();
}
inline float CostingOptions::destination_only_penalty() const {
  return destination_only_penalty_;
}
inline void CostingOptions::set_destination_only_penalty(float value) {
  set_has_destination_only_penalty();
  destination_only_penalty_ = value;
}

// optional float gate_cost = 3;
inline bool CostingOptions::has_gate_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CostingOptions::set_has_gate_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CostingOptions::clear_has_gate_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CostingOptions::clear_gate_cost() {
  gate_cost_ = 0;
  clear_has_gate_cost();
}
inline float CostingOptions::gate_cost() const {
  return gate_cost_;
}
inline void CostingOptions::set_gate_cost(float value) {
  set_has_gate_cost();
  gate_cost_ = value;
}

// optional float gate_penalty = 4;
inline bool CostingOptions::has_gate_penalty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CostingOptions::set_has_gate_penalty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CostingOptions::clear_has_gate_penalty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CostingOptions::clear_gate_penalty() {
  gate_penalty_ = 0;
  clear_has_gate_penalty();
}
inline float CostingOptions::gate_penalty() const {
  return gate_penalty_;
}
inline void CostingOptions::set_gate_penalty(float value) {
  set_has_gate_penalty();
  gate_penalty_ = value;
}

// optional float toll_booth_cost = 5;
inline bool CostingOptions::has_toll_booth_cost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CostingOptions::set_has_toll_booth_cost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CostingOptions::clear_has_toll_booth_cost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CostingOptions::clear_toll_booth_cost() {
  toll_booth_cost_ = 0;
  clear_has_toll_booth_cost();
}
inline float CostingOptions::toll_booth_cost() const {
  return toll_booth_cost_;
}
inline void CostingOptions::set_toll_booth_cost(float value) {
  set_has_toll_booth_cost();
  toll_booth_cost_ = value;
}

// optional float toll_booth_penalty = 6;
inline bool CostingOptions::has_toll_booth_penalty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CostingOptions::set_has_toll_booth_penalty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CostingOptions::clear_has_toll_booth_penalty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CostingOptions::clear_toll_booth_penalty() {
  toll_booth_penalty_ = 0;
  clear_has_toll_booth_penalty();
}
inline float CostingOptions::toll_booth_penalty() const {
  return toll_booth_penalty_;
}
inline void CostingOptions::set_toll_booth_penalty(float value) {
  set_has_toll_booth_penalty();
  toll_booth_penalty_ = value;
}

// optional float alley_penalty = 7;
inline bool CostingOptions::has_alley_penalty() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CostingOptions::set_has_alley_penalty() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CostingOptions::clear_has_alley_penalty() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CostingOptions::clear_alley_penalty() {
  alley_penalty_ = 0;
  clear_has_alley_penalty();
}
inline float CostingOptions::alley_penalty() const {
  return alley_penalty_;
}
inline void CostingOptions::set_alley_penalty(float value) {
  set_has_alley_penalty();
  alley_penalty_ = value;
}

// optional float country_crossing_cost = 8;
inline bool CostingOptions::has_country_crossing_cost() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CostingOptions::set_has_country_crossing_cost() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CostingOptions::clear_has_country_crossing_cost() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CostingOptions::clear_country_crossing_cost() {
  country_crossing_cost_ = 0;
  clear_has_country_crossing_cost();
}
inline float CostingOptions::country_crossing_cost() const {
  return country_crossing_cost_;
}
inline void CostingOptions::set_country_crossing_cost(float value) {
  set_has_country_crossing_cost();
  country_crossing_cost_ = value;
}

// optional float country_crossing_penalty = 9;
inline bool CostingOptions::has_country_crossing_penalty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CostingOptions::set_has_country_crossing_penalty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CostingOptions::clear_has_country_crossing_penalty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CostingOptions::clear_country_crossing_penalty() {
  country_crossing_penalty_ = 0;
  clear_has_country_crossing_penalty();
}
inline float CostingOptions::country_crossing_penalty() const {
  return country_crossing_penalty_;
}
inline void CostingOptions::set_country_crossing_penalty(float value) {
  set_has_country_crossing_penalty();
  country_crossing_penalty_ = value;
}

// optional float ferry_cost = 10;
inline bool CostingOptions::has_ferry_cost() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CostingOptions::set_has_ferry_cost() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CostingOptions::clear_has_ferry_cost() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CostingOptions::clear_ferry_cost() {
  ferry_cost_ = 0;
  clear_has_ferry_cost();
}
inline float CostingOptions::ferry_cost() const {
  return ferry_cost_;
}
inline void CostingOptions::set_ferry_cost(float value) {
  set_has_ferry_cost();
  ferry_cost_ = value;
}

// optional float avoid_bad_surfaces = 11;
inline bool CostingOptions::has_avoid_bad_surfaces() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CostingOptions::set_has_avoid_bad_surfaces() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CostingOptions::clear_has_avoid_bad_surfaces() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CostingOptions::clear_avoid_bad_surfaces() {
  avoid_bad_surfaces_ = 0;
  clear_has_avoid_bad_surfaces();
}
inline float CostingOptions::avoid_bad_surfaces() const {
  return avoid_bad_surfaces_;
}
inline void CostingOptions::set_avoid_bad_surfaces(float value) {
  set_has_avoid_bad_surfaces();
  avoid_bad_surfaces_ = value;
}

// optional float use_ferry = 12;
inline bool CostingOptions::has_use_ferry() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CostingOptions::set_has_use_ferry() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CostingOptions::clear_has_use_ferry() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CostingOptions::clear_use_ferry() {
  use_ferry_ = 0;
  clear_has_use_ferry();
}
inline float CostingOptions::use_ferry() const {
  return use_ferry_;
}
inline void CostingOptions::set_use_ferry(float value) {
  set_has_use_ferry();
  use_ferry_ = value;
}

// optional float use_highways = 13;
inline bool CostingOptions::has_use_highways() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CostingOptions::set_has_use_highways() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CostingOptions::clear_has_use_highways() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CostingOptions::clear_use_highways() {
  use_highways_ = 0;
  clear_has_use_highways();
}
inline float CostingOptions::use_highways() const {
  return use_highways_;
}
inline void CostingOptions::set_use_highways(float value) {
  set_has_use_highways();
  use_highways_ = value;
}

// optional float use_tolls = 14;
inline bool CostingOptions::has_use_tolls() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CostingOptions::set_has_use_tolls() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CostingOptions::clear_has_use_tolls() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CostingOptions::clear_use_tolls() {
  use_tolls_ = 0;
  clear_has_use_tolls();
}
inline float CostingOptions::use_tolls() const {
  return use_tolls_;
}
inline void CostingOptions::set_use_tolls(float value) {
  set_has_use_tolls();
  use_tolls_ = value;
}

// optional float use_roads = 15;
inline bool CostingOptions::has_use_roads() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CostingOptions::set_has_use_roads() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CostingOptions::clear_has_use_roads() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CostingOptions::clear_use_roads() {
  use_roads_ = 0;
  clear_has_use_roads();
}
inline float CostingOptions::use_roads() const {
  return use_roads_;
}
inline void CostingOptions::set_use_roads(float value) {
  set_has_use_roads();
  use_roads_ = value;
}

// optional uint32 max_distance = 16;
inline bool CostingOptions::has_max_distance() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CostingOptions::set_has_max_distance() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CostingOptions::clear_has_max_distance() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CostingOptions::clear_max_distance() {
  max_distance_ = 0u;
  clear_has_max_distance();
}
inline ::google::protobuf::uint32 CostingOptions::max_distance() const {
  return max_distance_;
}
inline void CostingOptions::set_max_distance(::google::protobuf::uint32 value) {
  set_has_max_distance();
  max_distance_ = value;
}

// optional float walking_speed = 17;
inline bool CostingOptions::has_walking_speed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CostingOptions::set_has_walking_speed() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CostingOptions::clear_has_walking_speed() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CostingOptions::clear_walking_speed() {
  walking_speed_ = 0;
  clear_has_walking_speed();
}
inline float CostingOptions::walking_speed() const {
  return walking_speed_;
}
inline void CostingOptions::set_walking_speed(float value) {
  set_has_walking_speed();
  walking_speed_ = value;
}

// optional float step_penalty = 18;
inline bool CostingOptions::has_step_penalty() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CostingOptions::set_has_step_penalty() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CostingOptions::clear_has_step_penalty() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CostingOptions::clear_step_penalty() {
  step_penalty_ = 0;
  clear_has_step_penalty();
}
inline float CostingOptions::step_penalty() const {
  return step_penalty_;
}
inline void CostingOptions::set_step_penalty(float value) {
  set_has_step_penalty();
  step_penalty_ = value;
}

// optional uint32 max_grade = 19;
inline bool CostingOptions::has_max_grade() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CostingOptions::set_has_max_grade() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CostingOptions::clear_has_max_grade() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CostingOptions::clear_max_grade() {
  max_grade_ = 0u;
  clear_has_max_grade();
}
inline ::google::protobuf::uint32 CostingOptions::max_grade() const {
  return max_grade_;
}
inline void CostingOptions::set_max_grade(::google::protobuf::uint32 value) {
  set_has_max_grade();
  max_grade_ = value;
}

// optional uint32 max_hiking_difficulty = 20;
inline bool CostingOptions::has_max_hiking_difficulty() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CostingOptions::set_has_max_hiking_difficulty() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CostingOptions::clear_has_max_hiking_difficulty() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CostingOptions::clear_max_hiking_difficulty() {
  max_hiking_difficulty_ = 0u;
  clear_has_max_hiking_difficulty();
}
inline ::google::protobuf::uint32 CostingOptions::max_hiking_difficulty() const {
  return max_hiking_difficulty_;
}
inline void CostingOptions::set_max_hiking_difficulty(::google::protobuf::uint32 value) {
  set_has_max_hiking_difficulty();
  max_hiking_difficulty_ = value;
}

// optional float mode_factor = 21;
inline bool CostingOptions::has_mode_factor() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CostingOptions::set_has_mode_factor() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CostingOptions::clear_has_mode_factor() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CostingOptions::clear_mode_factor() {
  mode_factor_ = 0;
  clear_has_mode_factor();
}
inline float CostingOptions::mode_factor() const {
  return mode_factor_;
}
inline void CostingOptions::set_mode_factor(float value) {
  set_has_mode_factor();
  mode_factor_ = value;
}

// optional float walkway_factor = 22;
inline bool CostingOptions::has_walkway_factor() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CostingOptions::set_has_walkway_factor() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CostingOptions::clear_has_walkway_factor() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CostingOptions::clear_walkway_factor() {
  walkway_factor_ = 0;
  clear_has_walkway_factor();
}
inline float CostingOptions::walkway_factor() const {
  return walkway_factor_;
}
inline void CostingOptions::set_walkway_factor(float value) {
  set_has_walkway_factor();
  walkway_factor_ = value;
}

// optional float sidewalk_factor = 23;
inline bool CostingOptions::has_sidewalk_factor() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CostingOptions::set_has_sidewalk_factor() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CostingOptions::clear_has_sidewalk_factor() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CostingOptions::clear_sidewalk_factor() {
  sidewalk_factor_ = 0;
  clear_has_sidewalk_factor();
}
inline float CostingOptions::sidewalk_factor() const {
  return sidewalk_factor_;
}
inline void CostingOptions::set_sidewalk_factor(float value) {
  set_has_sidewalk_factor();
  sidewalk_factor_ = value;
}

// optional float alley_factor = 24;
inline bool CostingOptions::has_alley_factor() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CostingOptions::set_has_alley_factor() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CostingOptions::clear_has_alley_factor() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CostingOptions::clear_alley_factor() {
  alley_factor_ = 0;
  clear_has_alley_factor();
}
inline float CostingOptions::alley_factor() const {
  return alley_factor_;
}
inline void CostingOptions::set_alley_factor(float value) {
  set_has_alley_factor();
  alley_factor_ = value;
}

// optional float driveway_factor = 25;
inline bool CostingOptions::has_driveway_factor() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CostingOptions::set_has_driveway_factor() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CostingOptions::clear_has_driveway_factor() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CostingOptions::clear_driveway_factor() {
  driveway_factor_ = 0;
  clear_has_driveway_factor();
}
inline float CostingOptions::driveway_factor() const {
  return driveway_factor_;
}
inline void CostingOptions::set_driveway_factor(float value) {
  set_has_driveway_factor();
  driveway_factor_ = value;
}

// optional float driveway_penalty = 26;
inline bool CostingOptions::has_driveway_penalty() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CostingOptions::set_has_driveway_penalty() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CostingOptions::clear_has_driveway_penalty() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CostingOptions::clear_driveway_penalty() {
  driveway_penalty_ = 0;
  clear_has_driveway_penalty();
}
inline float CostingOptions::driveway_penalty() const {
  return driveway_penalty_;
}
inline void CostingOptions::set_driveway_penalty(float value) {
  set_has_driveway_penalty();
  driveway_penalty_ = value;
}

// optional uint32 transit_start_end_max_distance = 27;
inline bool CostingOptions::has_transit_start_end_max_distance() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CostingOptions::set_has_transit_start_end_max_distance() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CostingOptions::clear_has_transit_start_end_max_distance() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CostingOptions::clear_transit_start_end_max_distance() {
  transit_start_end_max_distance_ = 0u;
  clear_has_transit_start_end_max_distance();
}
inline ::google::protobuf::uint32 CostingOptions::transit_start_end_max_distance() const {
  return transit_start_end_max_distance_;
}
inline void CostingOptions::set_transit_start_end_max_distance(::google::protobuf::uint32 value) {
  set_has_transit_start_end_max_distance();
  transit_start_end_max_distance_ = value;
}

// optional uint32 transit_transfer_max_distance = 28;
inline bool CostingOptions::has_transit_transfer_max_distance() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CostingOptions::set_has_transit_transfer_max_distance() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CostingOptions::clear_has_transit_transfer_max_distance() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CostingOptions::clear_transit_transfer_max_distance() {
  transit_transfer_max_distance_ = 0u;
  clear_has_transit_transfer_max_distance();
}
inline ::google::protobuf::uint32 CostingOptions::transit_transfer_max_distance() const {
  return transit_transfer_max_distance_;
}
inline void CostingOptions::set_transit_transfer_max_distance(::google::protobuf::uint32 value) {
  set_has_transit_transfer_max_distance();
  transit_transfer_max_distance_ = value;
}

// optional string transport_type = 29;
inline bool CostingOptions::has_transport_type() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CostingOptions::set_has_transport_type() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CostingOptions::clear_has_transport_type() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CostingOptions::clear_transport_type() {
  if (transport_type_ != &::google::protobuf::internal::kEmptyString) {
    transport_type_->clear();
  }
  clear_has_transport_type();
}
inline const ::std::string& CostingOptions::transport_type() const {
  return *transport_type_;
}
inline void CostingOptions::set_transport_type(const ::std::string& value) {
  set_has_transport_type();
  if (transport_type_ == &::google::protobuf::internal::kEmptyString) {
    transport_type_ = new ::std::string;
  }
  transport_type_->assign(value);
}
inline void CostingOptions::set_transport_type(const char* value) {
  set_has_transport_type();
  if (transport_type_ == &::google::protobuf::internal::kEmptyString) {
    transport_type_ = new ::std::string;
  }
  transport_type_->assign(value);
}
inline void CostingOptions::set_transport_type(const char* value, size_t size) {
  set_has_transport_type();
  if (transport_type_ == &::google::protobuf::internal::kEmptyString) {
    transport_type_ = new ::std::string;
  }
  transport_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CostingOptions::mutable_transport_type() {
  set_has_transport_type();
  if (transport_type_ == &::google::protobuf::internal::kEmptyString) {
    transport_type_ = new ::std::string;
  }
  return transport_type_;
}
inline ::std::string* CostingOptions::release_transport_type() {
  clear_has_transport_type();
  if (transport_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transport_type_;
    transport_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CostingOptions::set_allocated_transport_type(::std::string* transport_type) {
  if (transport_type_ != &::google::protobuf::internal::kEmptyString) {
    delete transport_type_;
  }
  if (transport_type) {
    set_has_transport_type();
    transport_type_ = transport_type;
  } else {
    clear_has_transport_type();
    transport_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float top_speed = 30;
inline bool CostingOptions::has_top_speed() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CostingOptions::set_has_top_speed() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CostingOptions::clear_has_top_speed() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CostingOptions::clear_top_speed() {
  top_speed_ = 0;
  clear_has_top_speed();
}
inline float CostingOptions::top_speed() const {
  return top_speed_;
}
inline void CostingOptions::set_top_speed(float value) {
  set_has_top_speed();
  top_speed_ = value;
}

// optional float use_hills = 31;
inline bool CostingOptions::has_use_hills() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CostingOptions::set_has_use_hills() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CostingOptions::clear_has_use_hills() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CostingOptions::clear_use_hills() {
  use_hills_ = 0;
  clear_has_use_hills();
}
inline float CostingOptions::use_hills() const {
  return use_hills_;
}
inline void CostingOptions::set_use_hills(float value) {
  set_has_use_hills();
  use_hills_ = value;
}

// optional float use_primary = 32;
inline bool CostingOptions::has_use_primary() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CostingOptions::set_has_use_primary() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CostingOptions::clear_has_use_primary() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CostingOptions::clear_use_primary() {
  use_primary_ = 0;
  clear_has_use_primary();
}
inline float CostingOptions::use_primary() const {
  return use_primary_;
}
inline void CostingOptions::set_use_primary(float value) {
  set_has_use_primary();
  use_primary_ = value;
}

// optional float use_trails = 33;
inline bool CostingOptions::has_use_trails() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CostingOptions::set_has_use_trails() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CostingOptions::clear_has_use_trails() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CostingOptions::clear_use_trails() {
  use_trails_ = 0;
  clear_has_use_trails();
}
inline float CostingOptions::use_trails() const {
  return use_trails_;
}
inline void CostingOptions::set_use_trails(float value) {
  set_has_use_trails();
  use_trails_ = value;
}

// optional float low_class_penalty = 34;
inline bool CostingOptions::has_low_class_penalty() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CostingOptions::set_has_low_class_penalty() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CostingOptions::clear_has_low_class_penalty() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CostingOptions::clear_low_class_penalty() {
  low_class_penalty_ = 0;
  clear_has_low_class_penalty();
}
inline float CostingOptions::low_class_penalty() const {
  return low_class_penalty_;
}
inline void CostingOptions::set_low_class_penalty(float value) {
  set_has_low_class_penalty();
  low_class_penalty_ = value;
}

// optional bool hazmat = 35;
inline bool CostingOptions::has_hazmat() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CostingOptions::set_has_hazmat() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CostingOptions::clear_has_hazmat() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CostingOptions::clear_hazmat() {
  hazmat_ = false;
  clear_has_hazmat();
}
inline bool CostingOptions::hazmat() const {
  return hazmat_;
}
inline void CostingOptions::set_hazmat(bool value) {
  set_has_hazmat();
  hazmat_ = value;
}

// optional float weight = 36;
inline bool CostingOptions::has_weight() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CostingOptions::set_has_weight() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CostingOptions::clear_has_weight() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CostingOptions::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline float CostingOptions::weight() const {
  return weight_;
}
inline void CostingOptions::set_weight(float value) {
  set_has_weight();
  weight_ = value;
}

// optional float axle_load = 37;
inline bool CostingOptions::has_axle_load() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CostingOptions::set_has_axle_load() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CostingOptions::clear_has_axle_load() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CostingOptions::clear_axle_load() {
  axle_load_ = 0;
  clear_has_axle_load();
}
inline float CostingOptions::axle_load() const {
  return axle_load_;
}
inline void CostingOptions::set_axle_load(float value) {
  set_has_axle_load();
  axle_load_ = value;
}

// optional float height = 38;
inline bool CostingOptions::has_height() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CostingOptions::set_has_height() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CostingOptions::clear_has_height() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CostingOptions::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float CostingOptions::height() const {
  return height_;
}
inline void CostingOptions::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional float width = 39;
inline bool CostingOptions::has_width() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CostingOptions::set_has_width() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CostingOptions::clear_has_width() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CostingOptions::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float CostingOptions::width() const {
  return width_;
}
inline void CostingOptions::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float length = 40;
inline bool CostingOptions::has_length() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CostingOptions::set_has_length() {
  _has_bits_[1] |= 0x00000080u;
}
inline void CostingOptions::clear_has_length() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void CostingOptions::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float CostingOptions::length() const {
  return length_;
}
inline void CostingOptions::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional float cycling_speed = 41;
inline bool CostingOptions::has_cycling_speed() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void CostingOptions::set_has_cycling_speed() {
  _has_bits_[1] |= 0x00000100u;
}
inline void CostingOptions::clear_has_cycling_speed() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void CostingOptions::clear_cycling_speed() {
  cycling_speed_ = 0;
  clear_has_cycling_speed();
}
inline float CostingOptions::cycling_speed() const {
  return cycling_speed_;
}
inline void CostingOptions::set_cycling_speed(float value) {
  set_has_cycling_speed();
  cycling_speed_ = value;
}

// optional bool wheelchair = 42;
inline bool CostingOptions::has_wheelchair() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void CostingOptions::set_has_wheelchair() {
  _has_bits_[1] |= 0x00000200u;
}
inline void CostingOptions::clear_has_wheelchair() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void CostingOptions::clear_wheelchair() {
  wheelchair_ = false;
  clear_has_wheelchair();
}
inline bool CostingOptions::wheelchair() const {
  return wheelchair_;
}
inline void CostingOptions::set_wheelchair(bool value) {
  set_has_wheelchair();
  wheelchair_ = value;
}

// optional bool bicycle = 43;
inline bool CostingOptions::has_bicycle() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void CostingOptions::set_has_bicycle() {
  _has_bits_[1] |= 0x00000400u;
}
inline void CostingOptions::clear_has_bicycle() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void CostingOptions::clear_bicycle() {
  bicycle_ = false;
  clear_has_bicycle();
}
inline bool CostingOptions::bicycle() const {
  return bicycle_;
}
inline void CostingOptions::set_bicycle(bool value) {
  set_has_bicycle();
  bicycle_ = value;
}

// optional float use_bus = 44;
inline bool CostingOptions::has_use_bus() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void CostingOptions::set_has_use_bus() {
  _has_bits_[1] |= 0x00000800u;
}
inline void CostingOptions::clear_has_use_bus() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void CostingOptions::clear_use_bus() {
  use_bus_ = 0;
  clear_has_use_bus();
}
inline float CostingOptions::use_bus() const {
  return use_bus_;
}
inline void CostingOptions::set_use_bus(float value) {
  set_has_use_bus();
  use_bus_ = value;
}

// optional float use_rail = 45;
inline bool CostingOptions::has_use_rail() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void CostingOptions::set_has_use_rail() {
  _has_bits_[1] |= 0x00001000u;
}
inline void CostingOptions::clear_has_use_rail() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void CostingOptions::clear_use_rail() {
  use_rail_ = 0;
  clear_has_use_rail();
}
inline float CostingOptions::use_rail() const {
  return use_rail_;
}
inline void CostingOptions::set_use_rail(float value) {
  set_has_use_rail();
  use_rail_ = value;
}

// optional float use_transfers = 46;
inline bool CostingOptions::has_use_transfers() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void CostingOptions::set_has_use_transfers() {
  _has_bits_[1] |= 0x00002000u;
}
inline void CostingOptions::clear_has_use_transfers() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void CostingOptions::clear_use_transfers() {
  use_transfers_ = 0;
  clear_has_use_transfers();
}
inline float CostingOptions::use_transfers() const {
  return use_transfers_;
}
inline void CostingOptions::set_use_transfers(float value) {
  set_has_use_transfers();
  use_transfers_ = value;
}

// optional float transfer_cost = 47;
inline bool CostingOptions::has_transfer_cost() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void CostingOptions::set_has_transfer_cost() {
  _has_bits_[1] |= 0x00004000u;
}
inline void CostingOptions::clear_has_transfer_cost() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void CostingOptions::clear_transfer_cost() {
  transfer_cost_ = 0;
  clear_has_transfer_cost();
}
inline float CostingOptions::transfer_cost() const {
  return transfer_cost_;
}
inline void CostingOptions::set_transfer_cost(float value) {
  set_has_transfer_cost();
  transfer_cost_ = value;
}

// optional float transfer_penalty = 48;
inline bool CostingOptions::has_transfer_penalty() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void CostingOptions::set_has_transfer_penalty() {
  _has_bits_[1] |= 0x00008000u;
}
inline void CostingOptions::clear_has_transfer_penalty() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void CostingOptions::clear_transfer_penalty() {
  transfer_penalty_ = 0;
  clear_has_transfer_penalty();
}
inline float CostingOptions::transfer_penalty() const {
  return transfer_penalty_;
}
inline void CostingOptions::set_transfer_penalty(float value) {
  set_has_transfer_penalty();
  transfer_penalty_ = value;
}

// optional .valhalla.FilterAction filter_stop_action = 49;
inline bool CostingOptions::has_filter_stop_action() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void CostingOptions::set_has_filter_stop_action() {
  _has_bits_[1] |= 0x00010000u;
}
inline void CostingOptions::clear_has_filter_stop_action() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void CostingOptions::clear_filter_stop_action() {
  filter_stop_action_ = 0;
  clear_has_filter_stop_action();
}
inline ::valhalla::FilterAction CostingOptions::filter_stop_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_stop_action_);
}
inline void CostingOptions::set_filter_stop_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  set_has_filter_stop_action();
  filter_stop_action_ = value;
}

// repeated string filter_stop_ids = 50;
inline int CostingOptions::filter_stop_ids_size() const {
  return filter_stop_ids_.size();
}
inline void CostingOptions::clear_filter_stop_ids() {
  filter_stop_ids_.Clear();
}
inline const ::std::string& CostingOptions::filter_stop_ids(int index) const {
  return filter_stop_ids_.Get(index);
}
inline ::std::string* CostingOptions::mutable_filter_stop_ids(int index) {
  return filter_stop_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_stop_ids(int index, const ::std::string& value) {
  filter_stop_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_stop_ids(int index, const char* value) {
  filter_stop_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_stop_ids(int index, const char* value, size_t size) {
  filter_stop_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CostingOptions::add_filter_stop_ids() {
  return filter_stop_ids_.Add();
}
inline void CostingOptions::add_filter_stop_ids(const ::std::string& value) {
  filter_stop_ids_.Add()->assign(value);
}
inline void CostingOptions::add_filter_stop_ids(const char* value) {
  filter_stop_ids_.Add()->assign(value);
}
inline void CostingOptions::add_filter_stop_ids(const char* value, size_t size) {
  filter_stop_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostingOptions::filter_stop_ids() const {
  return filter_stop_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostingOptions::mutable_filter_stop_ids() {
  return &filter_stop_ids_;
}

// optional .valhalla.FilterAction filter_operator_action = 51;
inline bool CostingOptions::has_filter_operator_action() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void CostingOptions::set_has_filter_operator_action() {
  _has_bits_[1] |= 0x00040000u;
}
inline void CostingOptions::clear_has_filter_operator_action() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void CostingOptions::clear_filter_operator_action() {
  filter_operator_action_ = 0;
  clear_has_filter_operator_action();
}
inline ::valhalla::FilterAction CostingOptions::filter_operator_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_operator_action_);
}
inline void CostingOptions::set_filter_operator_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  set_has_filter_operator_action();
  filter_operator_action_ = value;
}

// repeated string filter_operator_ids = 52;
inline int CostingOptions::filter_operator_ids_size() const {
  return filter_operator_ids_.size();
}
inline void CostingOptions::clear_filter_operator_ids() {
  filter_operator_ids_.Clear();
}
inline const ::std::string& CostingOptions::filter_operator_ids(int index) const {
  return filter_operator_ids_.Get(index);
}
inline ::std::string* CostingOptions::mutable_filter_operator_ids(int index) {
  return filter_operator_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_operator_ids(int index, const ::std::string& value) {
  filter_operator_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_operator_ids(int index, const char* value) {
  filter_operator_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_operator_ids(int index, const char* value, size_t size) {
  filter_operator_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CostingOptions::add_filter_operator_ids() {
  return filter_operator_ids_.Add();
}
inline void CostingOptions::add_filter_operator_ids(const ::std::string& value) {
  filter_operator_ids_.Add()->assign(value);
}
inline void CostingOptions::add_filter_operator_ids(const char* value) {
  filter_operator_ids_.Add()->assign(value);
}
inline void CostingOptions::add_filter_operator_ids(const char* value, size_t size) {
  filter_operator_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostingOptions::filter_operator_ids() const {
  return filter_operator_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostingOptions::mutable_filter_operator_ids() {
  return &filter_operator_ids_;
}

// optional .valhalla.FilterAction filter_route_action = 53;
inline bool CostingOptions::has_filter_route_action() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void CostingOptions::set_has_filter_route_action() {
  _has_bits_[1] |= 0x00100000u;
}
inline void CostingOptions::clear_has_filter_route_action() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void CostingOptions::clear_filter_route_action() {
  filter_route_action_ = 0;
  clear_has_filter_route_action();
}
inline ::valhalla::FilterAction CostingOptions::filter_route_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_route_action_);
}
inline void CostingOptions::set_filter_route_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  set_has_filter_route_action();
  filter_route_action_ = value;
}

// repeated string filter_route_ids = 54;
inline int CostingOptions::filter_route_ids_size() const {
  return filter_route_ids_.size();
}
inline void CostingOptions::clear_filter_route_ids() {
  filter_route_ids_.Clear();
}
inline const ::std::string& CostingOptions::filter_route_ids(int index) const {
  return filter_route_ids_.Get(index);
}
inline ::std::string* CostingOptions::mutable_filter_route_ids(int index) {
  return filter_route_ids_.Mutable(index);
}
inline void CostingOptions::set_filter_route_ids(int index, const ::std::string& value) {
  filter_route_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_route_ids(int index, const char* value) {
  filter_route_ids_.Mutable(index)->assign(value);
}
inline void CostingOptions::set_filter_route_ids(int index, const char* value, size_t size) {
  filter_route_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CostingOptions::add_filter_route_ids() {
  return filter_route_ids_.Add();
}
inline void CostingOptions::add_filter_route_ids(const ::std::string& value) {
  filter_route_ids_.Add()->assign(value);
}
inline void CostingOptions::add_filter_route_ids(const char* value) {
  filter_route_ids_.Add()->assign(value);
}
inline void CostingOptions::add_filter_route_ids(const char* value, size_t size) {
  filter_route_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CostingOptions::filter_route_ids() const {
  return filter_route_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CostingOptions::mutable_filter_route_ids() {
  return &filter_route_ids_;
}

// optional uint32 flow_mask = 55;
inline bool CostingOptions::has_flow_mask() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void CostingOptions::set_has_flow_mask() {
  _has_bits_[1] |= 0x00400000u;
}
inline void CostingOptions::clear_has_flow_mask() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void CostingOptions::clear_flow_mask() {
  flow_mask_ = 0u;
  clear_has_flow_mask();
}
inline ::google::protobuf::uint32 CostingOptions::flow_mask() const {
  return flow_mask_;
}
inline void CostingOptions::set_flow_mask(::google::protobuf::uint32 value) {
  set_has_flow_mask();
  flow_mask_ = value;
}

// -------------------------------------------------------------------

// AvoidEdge

// optional uint64 id = 1;
inline bool AvoidEdge::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvoidEdge::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvoidEdge::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvoidEdge::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AvoidEdge::id() const {
  return id_;
}
inline void AvoidEdge::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional float percent_along = 2;
inline bool AvoidEdge::has_percent_along() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvoidEdge::set_has_percent_along() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvoidEdge::clear_has_percent_along() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvoidEdge::clear_percent_along() {
  percent_along_ = 0;
  clear_has_percent_along();
}
inline float AvoidEdge::percent_along() const {
  return percent_along_;
}
inline void AvoidEdge::set_percent_along(float value) {
  set_has_percent_along();
  percent_along_ = value;
}

// -------------------------------------------------------------------

// Options

// optional .valhalla.Options.Units units = 1;
inline bool Options::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Options::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Options::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Options::clear_units() {
  units_ = 0;
  clear_has_units();
}
inline ::valhalla::Options_Units Options::units() const {
  return static_cast< ::valhalla::Options_Units >(units_);
}
inline void Options::set_units(::valhalla::Options_Units value) {
  assert(::valhalla::Options_Units_IsValid(value));
  set_has_units();
  units_ = value;
}

// optional string language = 2 [default = "en-US"];
inline bool Options::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Options::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Options::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Options::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& Options::language() const {
  return *language_;
}
inline void Options::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void Options::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void Options::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  return language_;
}
inline ::std::string* Options::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void Options::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
}

// optional .valhalla.DirectionsType directions_type = 3 [default = instructions];
inline bool Options::has_directions_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Options::set_has_directions_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Options::clear_has_directions_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Options::clear_directions_type() {
  directions_type_ = 2;
  clear_has_directions_type();
}
inline ::valhalla::DirectionsType Options::directions_type() const {
  return static_cast< ::valhalla::DirectionsType >(directions_type_);
}
inline void Options::set_directions_type(::valhalla::DirectionsType value) {
  assert(::valhalla::DirectionsType_IsValid(value));
  set_has_directions_type();
  directions_type_ = value;
}

// optional .valhalla.Options.Format format = 4 [default = json];
inline bool Options::has_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Options::set_has_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Options::clear_has_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Options::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::valhalla::Options_Format Options::format() const {
  return static_cast< ::valhalla::Options_Format >(format_);
}
inline void Options::set_format(::valhalla::Options_Format value) {
  assert(::valhalla::Options_Format_IsValid(value));
  set_has_format();
  format_ = value;
}

// optional string id = 5;
inline bool Options::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Options::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Options::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Options::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Options::id() const {
  return *id_;
}
inline void Options::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Options::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Options::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Options::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jsonp = 6;
inline bool Options::has_jsonp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Options::set_has_jsonp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Options::clear_has_jsonp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Options::clear_jsonp() {
  if (jsonp_ != &::google::protobuf::internal::kEmptyString) {
    jsonp_->clear();
  }
  clear_has_jsonp();
}
inline const ::std::string& Options::jsonp() const {
  return *jsonp_;
}
inline void Options::set_jsonp(const ::std::string& value) {
  set_has_jsonp();
  if (jsonp_ == &::google::protobuf::internal::kEmptyString) {
    jsonp_ = new ::std::string;
  }
  jsonp_->assign(value);
}
inline void Options::set_jsonp(const char* value) {
  set_has_jsonp();
  if (jsonp_ == &::google::protobuf::internal::kEmptyString) {
    jsonp_ = new ::std::string;
  }
  jsonp_->assign(value);
}
inline void Options::set_jsonp(const char* value, size_t size) {
  set_has_jsonp();
  if (jsonp_ == &::google::protobuf::internal::kEmptyString) {
    jsonp_ = new ::std::string;
  }
  jsonp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_jsonp() {
  set_has_jsonp();
  if (jsonp_ == &::google::protobuf::internal::kEmptyString) {
    jsonp_ = new ::std::string;
  }
  return jsonp_;
}
inline ::std::string* Options::release_jsonp() {
  clear_has_jsonp();
  if (jsonp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsonp_;
    jsonp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_jsonp(::std::string* jsonp) {
  if (jsonp_ != &::google::protobuf::internal::kEmptyString) {
    delete jsonp_;
  }
  if (jsonp) {
    set_has_jsonp();
    jsonp_ = jsonp;
  } else {
    clear_has_jsonp();
    jsonp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string encoded_polyline = 7;
inline bool Options::has_encoded_polyline() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Options::set_has_encoded_polyline() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Options::clear_has_encoded_polyline() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Options::clear_encoded_polyline() {
  if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_->clear();
  }
  clear_has_encoded_polyline();
}
inline const ::std::string& Options::encoded_polyline() const {
  return *encoded_polyline_;
}
inline void Options::set_encoded_polyline(const ::std::string& value) {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  encoded_polyline_->assign(value);
}
inline void Options::set_encoded_polyline(const char* value) {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  encoded_polyline_->assign(value);
}
inline void Options::set_encoded_polyline(const char* value, size_t size) {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  encoded_polyline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_encoded_polyline() {
  set_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    encoded_polyline_ = new ::std::string;
  }
  return encoded_polyline_;
}
inline ::std::string* Options::release_encoded_polyline() {
  clear_has_encoded_polyline();
  if (encoded_polyline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_polyline_;
    encoded_polyline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_encoded_polyline(::std::string* encoded_polyline) {
  if (encoded_polyline_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_polyline_;
  }
  if (encoded_polyline) {
    set_has_encoded_polyline();
    encoded_polyline_ = encoded_polyline;
  } else {
    clear_has_encoded_polyline();
    encoded_polyline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.Options.Action action = 8;
inline bool Options::has_action() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Options::set_has_action() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Options::clear_has_action() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Options::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::valhalla::Options_Action Options::action() const {
  return static_cast< ::valhalla::Options_Action >(action_);
}
inline void Options::set_action(::valhalla::Options_Action value) {
  assert(::valhalla::Options_Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// optional bool do_not_track = 9 [default = false];
inline bool Options::has_do_not_track() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Options::set_has_do_not_track() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Options::clear_has_do_not_track() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Options::clear_do_not_track() {
  do_not_track_ = false;
  clear_has_do_not_track();
}
inline bool Options::do_not_track() const {
  return do_not_track_;
}
inline void Options::set_do_not_track(bool value) {
  set_has_do_not_track();
  do_not_track_ = value;
}

// optional bool range = 10 [default = false];
inline bool Options::has_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Options::set_has_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Options::clear_has_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Options::clear_range() {
  range_ = false;
  clear_has_range();
}
inline bool Options::range() const {
  return range_;
}
inline void Options::set_range(bool value) {
  set_has_range();
  range_ = value;
}

// optional bool verbose = 11 [default = false];
inline bool Options::has_verbose() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Options::set_has_verbose() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Options::clear_has_verbose() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Options::clear_verbose() {
  verbose_ = false;
  clear_has_verbose();
}
inline bool Options::verbose() const {
  return verbose_;
}
inline void Options::set_verbose(bool value) {
  set_has_verbose();
  verbose_ = value;
}

// optional .valhalla.Costing costing = 12;
inline bool Options::has_costing() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Options::set_has_costing() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Options::clear_has_costing() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Options::clear_costing() {
  costing_ = 0;
  clear_has_costing();
}
inline ::valhalla::Costing Options::costing() const {
  return static_cast< ::valhalla::Costing >(costing_);
}
inline void Options::set_costing(::valhalla::Costing value) {
  assert(::valhalla::Costing_IsValid(value));
  set_has_costing();
  costing_ = value;
}

// repeated .valhalla.CostingOptions costing_options = 13;
inline int Options::costing_options_size() const {
  return costing_options_.size();
}
inline void Options::clear_costing_options() {
  costing_options_.Clear();
}
inline const ::valhalla::CostingOptions& Options::costing_options(int index) const {
  return costing_options_.Get(index);
}
inline ::valhalla::CostingOptions* Options::mutable_costing_options(int index) {
  return costing_options_.Mutable(index);
}
inline ::valhalla::CostingOptions* Options::add_costing_options() {
  return costing_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >&
Options::costing_options() const {
  return costing_options_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::CostingOptions >*
Options::mutable_costing_options() {
  return &costing_options_;
}

// repeated .valhalla.Location locations = 14;
inline int Options::locations_size() const {
  return locations_.size();
}
inline void Options::clear_locations() {
  locations_.Clear();
}
inline const ::valhalla::Location& Options::locations(int index) const {
  return locations_.Get(index);
}
inline ::valhalla::Location* Options::mutable_locations(int index) {
  return locations_.Mutable(index);
}
inline ::valhalla::Location* Options::add_locations() {
  return locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::locations() const {
  return locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_locations() {
  return &locations_;
}

// repeated .valhalla.Location avoid_locations = 15;
inline int Options::avoid_locations_size() const {
  return avoid_locations_.size();
}
inline void Options::clear_avoid_locations() {
  avoid_locations_.Clear();
}
inline const ::valhalla::Location& Options::avoid_locations(int index) const {
  return avoid_locations_.Get(index);
}
inline ::valhalla::Location* Options::mutable_avoid_locations(int index) {
  return avoid_locations_.Mutable(index);
}
inline ::valhalla::Location* Options::add_avoid_locations() {
  return avoid_locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::avoid_locations() const {
  return avoid_locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_avoid_locations() {
  return &avoid_locations_;
}

// repeated .valhalla.Location sources = 16;
inline int Options::sources_size() const {
  return sources_.size();
}
inline void Options::clear_sources() {
  sources_.Clear();
}
inline const ::valhalla::Location& Options::sources(int index) const {
  return sources_.Get(index);
}
inline ::valhalla::Location* Options::mutable_sources(int index) {
  return sources_.Mutable(index);
}
inline ::valhalla::Location* Options::add_sources() {
  return sources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::sources() const {
  return sources_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_sources() {
  return &sources_;
}

// repeated .valhalla.Location targets = 17;
inline int Options::targets_size() const {
  return targets_.size();
}
inline void Options::clear_targets() {
  targets_.Clear();
}
inline const ::valhalla::Location& Options::targets(int index) const {
  return targets_.Get(index);
}
inline ::valhalla::Location* Options::mutable_targets(int index) {
  return targets_.Mutable(index);
}
inline ::valhalla::Location* Options::add_targets() {
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::targets() const {
  return targets_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_targets() {
  return &targets_;
}

// optional .valhalla.Options.DateTimeType date_time_type = 18;
inline bool Options::has_date_time_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Options::set_has_date_time_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Options::clear_has_date_time_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Options::clear_date_time_type() {
  date_time_type_ = 0;
  clear_has_date_time_type();
}
inline ::valhalla::Options_DateTimeType Options::date_time_type() const {
  return static_cast< ::valhalla::Options_DateTimeType >(date_time_type_);
}
inline void Options::set_date_time_type(::valhalla::Options_DateTimeType value) {
  assert(::valhalla::Options_DateTimeType_IsValid(value));
  set_has_date_time_type();
  date_time_type_ = value;
}

// optional string date_time = 19;
inline bool Options::has_date_time() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Options::set_has_date_time() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Options::clear_has_date_time() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Options::clear_date_time() {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    date_time_->clear();
  }
  clear_has_date_time();
}
inline const ::std::string& Options::date_time() const {
  return *date_time_;
}
inline void Options::set_date_time(const ::std::string& value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void Options::set_date_time(const char* value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void Options::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_date_time() {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  return date_time_;
}
inline ::std::string* Options::release_date_time() {
  clear_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_;
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_date_time(::std::string* date_time) {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_;
  }
  if (date_time) {
    set_has_date_time();
    date_time_ = date_time;
  } else {
    clear_has_date_time();
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .valhalla.Location shape = 20;
inline int Options::shape_size() const {
  return shape_.size();
}
inline void Options::clear_shape() {
  shape_.Clear();
}
inline const ::valhalla::Location& Options::shape(int index) const {
  return shape_.Get(index);
}
inline ::valhalla::Location* Options::mutable_shape(int index) {
  return shape_.Mutable(index);
}
inline ::valhalla::Location* Options::add_shape() {
  return shape_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_shape() {
  return &shape_;
}

// optional double resample_distance = 21;
inline bool Options::has_resample_distance() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Options::set_has_resample_distance() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Options::clear_has_resample_distance() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Options::clear_resample_distance() {
  resample_distance_ = 0;
  clear_has_resample_distance();
}
inline double Options::resample_distance() const {
  return resample_distance_;
}
inline void Options::set_resample_distance(double value) {
  set_has_resample_distance();
  resample_distance_ = value;
}

// repeated .valhalla.Contour contours = 22;
inline int Options::contours_size() const {
  return contours_.size();
}
inline void Options::clear_contours() {
  contours_.Clear();
}
inline const ::valhalla::Contour& Options::contours(int index) const {
  return contours_.Get(index);
}
inline ::valhalla::Contour* Options::mutable_contours(int index) {
  return contours_.Mutable(index);
}
inline ::valhalla::Contour* Options::add_contours() {
  return contours_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >&
Options::contours() const {
  return contours_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Contour >*
Options::mutable_contours() {
  return &contours_;
}

// optional bool polygons = 23;
inline bool Options::has_polygons() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Options::set_has_polygons() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Options::clear_has_polygons() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Options::clear_polygons() {
  polygons_ = false;
  clear_has_polygons();
}
inline bool Options::polygons() const {
  return polygons_;
}
inline void Options::set_polygons(bool value) {
  set_has_polygons();
  polygons_ = value;
}

// optional float denoise = 24 [default = 1];
inline bool Options::has_denoise() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Options::set_has_denoise() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Options::clear_has_denoise() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Options::clear_denoise() {
  denoise_ = 1;
  clear_has_denoise();
}
inline float Options::denoise() const {
  return denoise_;
}
inline void Options::set_denoise(float value) {
  set_has_denoise();
  denoise_ = value;
}

// optional float generalize = 25;
inline bool Options::has_generalize() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Options::set_has_generalize() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Options::clear_has_generalize() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Options::clear_generalize() {
  generalize_ = 0;
  clear_has_generalize();
}
inline float Options::generalize() const {
  return generalize_;
}
inline void Options::set_generalize(float value) {
  set_has_generalize();
  generalize_ = value;
}

// optional bool show_locations = 26;
inline bool Options::has_show_locations() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Options::set_has_show_locations() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Options::clear_has_show_locations() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Options::clear_show_locations() {
  show_locations_ = false;
  clear_has_show_locations();
}
inline bool Options::show_locations() const {
  return show_locations_;
}
inline void Options::set_show_locations(bool value) {
  set_has_show_locations();
  show_locations_ = value;
}

// repeated .valhalla.Location trace = 27;
inline int Options::trace_size() const {
  return trace_.size();
}
inline void Options::clear_trace() {
  trace_.Clear();
}
inline const ::valhalla::Location& Options::trace(int index) const {
  return trace_.Get(index);
}
inline ::valhalla::Location* Options::mutable_trace(int index) {
  return trace_.Mutable(index);
}
inline ::valhalla::Location* Options::add_trace() {
  return trace_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
Options::trace() const {
  return trace_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
Options::mutable_trace() {
  return &trace_;
}

// optional .valhalla.ShapeMatch shape_match = 28 [default = walk_or_snap];
inline bool Options::has_shape_match() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Options::set_has_shape_match() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Options::clear_has_shape_match() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Options::clear_shape_match() {
  shape_match_ = 2;
  clear_has_shape_match();
}
inline ::valhalla::ShapeMatch Options::shape_match() const {
  return static_cast< ::valhalla::ShapeMatch >(shape_match_);
}
inline void Options::set_shape_match(::valhalla::ShapeMatch value) {
  assert(::valhalla::ShapeMatch_IsValid(value));
  set_has_shape_match();
  shape_match_ = value;
}

// optional uint32 best_paths = 29 [default = 1];
inline bool Options::has_best_paths() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Options::set_has_best_paths() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Options::clear_has_best_paths() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Options::clear_best_paths() {
  best_paths_ = 1u;
  clear_has_best_paths();
}
inline ::google::protobuf::uint32 Options::best_paths() const {
  return best_paths_;
}
inline void Options::set_best_paths(::google::protobuf::uint32 value) {
  set_has_best_paths();
  best_paths_ = value;
}

// optional float gps_accuracy = 30;
inline bool Options::has_gps_accuracy() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Options::set_has_gps_accuracy() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Options::clear_has_gps_accuracy() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Options::clear_gps_accuracy() {
  gps_accuracy_ = 0;
  clear_has_gps_accuracy();
}
inline float Options::gps_accuracy() const {
  return gps_accuracy_;
}
inline void Options::set_gps_accuracy(float value) {
  set_has_gps_accuracy();
  gps_accuracy_ = value;
}

// optional float search_radius = 31;
inline bool Options::has_search_radius() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Options::set_has_search_radius() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Options::clear_has_search_radius() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Options::clear_search_radius() {
  search_radius_ = 0;
  clear_has_search_radius();
}
inline float Options::search_radius() const {
  return search_radius_;
}
inline void Options::set_search_radius(float value) {
  set_has_search_radius();
  search_radius_ = value;
}

// optional float turn_penalty_factor = 32;
inline bool Options::has_turn_penalty_factor() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Options::set_has_turn_penalty_factor() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Options::clear_has_turn_penalty_factor() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Options::clear_turn_penalty_factor() {
  turn_penalty_factor_ = 0;
  clear_has_turn_penalty_factor();
}
inline float Options::turn_penalty_factor() const {
  return turn_penalty_factor_;
}
inline void Options::set_turn_penalty_factor(float value) {
  set_has_turn_penalty_factor();
  turn_penalty_factor_ = value;
}

// optional .valhalla.FilterAction filter_action = 33;
inline bool Options::has_filter_action() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Options::set_has_filter_action() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Options::clear_has_filter_action() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Options::clear_filter_action() {
  filter_action_ = 0;
  clear_has_filter_action();
}
inline ::valhalla::FilterAction Options::filter_action() const {
  return static_cast< ::valhalla::FilterAction >(filter_action_);
}
inline void Options::set_filter_action(::valhalla::FilterAction value) {
  assert(::valhalla::FilterAction_IsValid(value));
  set_has_filter_action();
  filter_action_ = value;
}

// repeated string filter_attributes = 34;
inline int Options::filter_attributes_size() const {
  return filter_attributes_.size();
}
inline void Options::clear_filter_attributes() {
  filter_attributes_.Clear();
}
inline const ::std::string& Options::filter_attributes(int index) const {
  return filter_attributes_.Get(index);
}
inline ::std::string* Options::mutable_filter_attributes(int index) {
  return filter_attributes_.Mutable(index);
}
inline void Options::set_filter_attributes(int index, const ::std::string& value) {
  filter_attributes_.Mutable(index)->assign(value);
}
inline void Options::set_filter_attributes(int index, const char* value) {
  filter_attributes_.Mutable(index)->assign(value);
}
inline void Options::set_filter_attributes(int index, const char* value, size_t size) {
  filter_attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::add_filter_attributes() {
  return filter_attributes_.Add();
}
inline void Options::add_filter_attributes(const ::std::string& value) {
  filter_attributes_.Add()->assign(value);
}
inline void Options::add_filter_attributes(const char* value) {
  filter_attributes_.Add()->assign(value);
}
inline void Options::add_filter_attributes(const char* value, size_t size) {
  filter_attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Options::filter_attributes() const {
  return filter_attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Options::mutable_filter_attributes() {
  return &filter_attributes_;
}

// repeated .valhalla.AvoidEdge avoid_edges = 35;
inline int Options::avoid_edges_size() const {
  return avoid_edges_.size();
}
inline void Options::clear_avoid_edges() {
  avoid_edges_.Clear();
}
inline const ::valhalla::AvoidEdge& Options::avoid_edges(int index) const {
  return avoid_edges_.Get(index);
}
inline ::valhalla::AvoidEdge* Options::mutable_avoid_edges(int index) {
  return avoid_edges_.Mutable(index);
}
inline ::valhalla::AvoidEdge* Options::add_avoid_edges() {
  return avoid_edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >&
Options::avoid_edges() const {
  return avoid_edges_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::AvoidEdge >*
Options::mutable_avoid_edges() {
  return &avoid_edges_;
}

// optional float breakage_distance = 36;
inline bool Options::has_breakage_distance() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Options::set_has_breakage_distance() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Options::clear_has_breakage_distance() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Options::clear_breakage_distance() {
  breakage_distance_ = 0;
  clear_has_breakage_distance();
}
inline float Options::breakage_distance() const {
  return breakage_distance_;
}
inline void Options::set_breakage_distance(float value) {
  set_has_breakage_distance();
  breakage_distance_ = value;
}

// optional bool use_timestamps = 37 [default = false];
inline bool Options::has_use_timestamps() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Options::set_has_use_timestamps() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Options::clear_has_use_timestamps() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Options::clear_use_timestamps() {
  use_timestamps_ = false;
  clear_has_use_timestamps();
}
inline bool Options::use_timestamps() const {
  return use_timestamps_;
}
inline void Options::set_use_timestamps(bool value) {
  set_has_use_timestamps();
  use_timestamps_ = value;
}

// optional .valhalla.ShapeFormat shape_format = 38 [default = polyline6];
inline bool Options::has_shape_format() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Options::set_has_shape_format() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Options::clear_has_shape_format() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Options::clear_shape_format() {
  shape_format_ = 1;
  clear_has_shape_format();
}
inline ::valhalla::ShapeFormat Options::shape_format() const {
  return static_cast< ::valhalla::ShapeFormat >(shape_format_);
}
inline void Options::set_shape_format(::valhalla::ShapeFormat value) {
  assert(::valhalla::ShapeFormat_IsValid(value));
  set_has_shape_format();
  shape_format_ = value;
}

// optional uint32 alternates = 39;
inline bool Options::has_alternates() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Options::set_has_alternates() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Options::clear_has_alternates() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Options::clear_alternates() {
  alternates_ = 0u;
  clear_has_alternates();
}
inline ::google::protobuf::uint32 Options::alternates() const {
  return alternates_;
}
inline void Options::set_alternates(::google::protobuf::uint32 value) {
  set_has_alternates();
  alternates_ = value;
}

// optional float interpolation_distance = 40;
inline bool Options::has_interpolation_distance() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Options::set_has_interpolation_distance() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Options::clear_has_interpolation_distance() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void Options::clear_interpolation_distance() {
  interpolation_distance_ = 0;
  clear_has_interpolation_distance();
}
inline float Options::interpolation_distance() const {
  return interpolation_distance_;
}
inline void Options::set_interpolation_distance(float value) {
  set_has_interpolation_distance();
  interpolation_distance_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_options_2eproto__INCLUDED
