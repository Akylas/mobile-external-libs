// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trip.proto

#ifndef PROTOBUF_trip_2eproto__INCLUDED
#define PROTOBUF_trip_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "tripcommon.pb.h"
// @@protoc_insertion_point(includes)

namespace valhalla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trip_2eproto();
void protobuf_AssignDesc_trip_2eproto();
void protobuf_ShutdownFile_trip_2eproto();

class TripLeg;
class TripLeg_SignElement;
class TripLeg_Sign;
class TripLeg_TransitRouteInfo;
class TripLeg_LaneConnectivity;
class TripLeg_TrafficSegment;
class TripLeg_Edge;
class TripLeg_IntersectingEdge;
class TripLeg_Node;
class TripLeg_Admin;
class TripLeg_ShapeAttributes;
class TripRoute;
class Trip;

enum TripLeg_Node_Type {
  TripLeg_Node_Type_kStreetIntersection = 0,
  TripLeg_Node_Type_kGate = 1,
  TripLeg_Node_Type_kBollard = 2,
  TripLeg_Node_Type_kTollBooth = 3,
  TripLeg_Node_Type_kTransitEgress = 4,
  TripLeg_Node_Type_kTransitStation = 5,
  TripLeg_Node_Type_kTransitPlatform = 6,
  TripLeg_Node_Type_kBikeShare = 7,
  TripLeg_Node_Type_kParking = 8,
  TripLeg_Node_Type_kMotorwayJunction = 9,
  TripLeg_Node_Type_kBorderControl = 10
};
bool TripLeg_Node_Type_IsValid(int value);
const TripLeg_Node_Type TripLeg_Node_Type_Type_MIN = TripLeg_Node_Type_kStreetIntersection;
const TripLeg_Node_Type TripLeg_Node_Type_Type_MAX = TripLeg_Node_Type_kBorderControl;
const int TripLeg_Node_Type_Type_ARRAYSIZE = TripLeg_Node_Type_Type_MAX + 1;

enum TripLeg_Traversability {
  TripLeg_Traversability_kNone = 0,
  TripLeg_Traversability_kForward = 1,
  TripLeg_Traversability_kBackward = 2,
  TripLeg_Traversability_kBoth = 3
};
bool TripLeg_Traversability_IsValid(int value);
const TripLeg_Traversability TripLeg_Traversability_Traversability_MIN = TripLeg_Traversability_kNone;
const TripLeg_Traversability TripLeg_Traversability_Traversability_MAX = TripLeg_Traversability_kBoth;
const int TripLeg_Traversability_Traversability_ARRAYSIZE = TripLeg_Traversability_Traversability_MAX + 1;

enum TripLeg_RoadClass {
  TripLeg_RoadClass_kMotorway = 0,
  TripLeg_RoadClass_kTrunk = 1,
  TripLeg_RoadClass_kPrimary = 2,
  TripLeg_RoadClass_kSecondary = 3,
  TripLeg_RoadClass_kTertiary = 4,
  TripLeg_RoadClass_kUnclassified = 5,
  TripLeg_RoadClass_kResidential = 6,
  TripLeg_RoadClass_kServiceOther = 7
};
bool TripLeg_RoadClass_IsValid(int value);
const TripLeg_RoadClass TripLeg_RoadClass_RoadClass_MIN = TripLeg_RoadClass_kMotorway;
const TripLeg_RoadClass TripLeg_RoadClass_RoadClass_MAX = TripLeg_RoadClass_kServiceOther;
const int TripLeg_RoadClass_RoadClass_ARRAYSIZE = TripLeg_RoadClass_RoadClass_MAX + 1;

enum TripLeg_Use {
  TripLeg_Use_kRoadUse = 0,
  TripLeg_Use_kRampUse = 1,
  TripLeg_Use_kTurnChannelUse = 2,
  TripLeg_Use_kTrackUse = 3,
  TripLeg_Use_kDrivewayUse = 4,
  TripLeg_Use_kAlleyUse = 5,
  TripLeg_Use_kParkingAisleUse = 6,
  TripLeg_Use_kEmergencyAccessUse = 7,
  TripLeg_Use_kDriveThruUse = 8,
  TripLeg_Use_kCuldesacUse = 9,
  TripLeg_Use_kCyclewayUse = 20,
  TripLeg_Use_kMountainBikeUse = 21,
  TripLeg_Use_kSidewalkUse = 24,
  TripLeg_Use_kFootwayUse = 25,
  TripLeg_Use_kStepsUse = 26,
  TripLeg_Use_kPathUse = 27,
  TripLeg_Use_kPedestrianUse = 28,
  TripLeg_Use_kBridlewayUse = 29,
  TripLeg_Use_kOtherUse = 40,
  TripLeg_Use_kFerryUse = 41,
  TripLeg_Use_kRailFerryUse = 42,
  TripLeg_Use_kRailUse = 50,
  TripLeg_Use_kBusUse = 51,
  TripLeg_Use_kEgressConnectionUse = 52,
  TripLeg_Use_kPlatformConnectionUse = 53,
  TripLeg_Use_kTransitConnectionUse = 54
};
bool TripLeg_Use_IsValid(int value);
const TripLeg_Use TripLeg_Use_Use_MIN = TripLeg_Use_kRoadUse;
const TripLeg_Use TripLeg_Use_Use_MAX = TripLeg_Use_kTransitConnectionUse;
const int TripLeg_Use_Use_ARRAYSIZE = TripLeg_Use_Use_MAX + 1;

enum TripLeg_Surface {
  TripLeg_Surface_kPavedSmooth = 0,
  TripLeg_Surface_kPaved = 1,
  TripLeg_Surface_kPavedRough = 2,
  TripLeg_Surface_kCompacted = 3,
  TripLeg_Surface_kDirt = 4,
  TripLeg_Surface_kGravel = 5,
  TripLeg_Surface_kPath = 6,
  TripLeg_Surface_kImpassable = 7
};
bool TripLeg_Surface_IsValid(int value);
const TripLeg_Surface TripLeg_Surface_Surface_MIN = TripLeg_Surface_kPavedSmooth;
const TripLeg_Surface TripLeg_Surface_Surface_MAX = TripLeg_Surface_kImpassable;
const int TripLeg_Surface_Surface_ARRAYSIZE = TripLeg_Surface_Surface_MAX + 1;

enum TripLeg_TravelMode {
  TripLeg_TravelMode_kDrive = 0,
  TripLeg_TravelMode_kPedestrian = 1,
  TripLeg_TravelMode_kBicycle = 2,
  TripLeg_TravelMode_kTransit = 3
};
bool TripLeg_TravelMode_IsValid(int value);
const TripLeg_TravelMode TripLeg_TravelMode_TravelMode_MIN = TripLeg_TravelMode_kDrive;
const TripLeg_TravelMode TripLeg_TravelMode_TravelMode_MAX = TripLeg_TravelMode_kTransit;
const int TripLeg_TravelMode_TravelMode_ARRAYSIZE = TripLeg_TravelMode_TravelMode_MAX + 1;

enum TripLeg_VehicleType {
  TripLeg_VehicleType_kCar = 0,
  TripLeg_VehicleType_kMotorcycle = 1,
  TripLeg_VehicleType_kAutoBus = 2,
  TripLeg_VehicleType_kTractorTrailer = 3,
  TripLeg_VehicleType_kMotorScooter = 4
};
bool TripLeg_VehicleType_IsValid(int value);
const TripLeg_VehicleType TripLeg_VehicleType_VehicleType_MIN = TripLeg_VehicleType_kCar;
const TripLeg_VehicleType TripLeg_VehicleType_VehicleType_MAX = TripLeg_VehicleType_kMotorScooter;
const int TripLeg_VehicleType_VehicleType_ARRAYSIZE = TripLeg_VehicleType_VehicleType_MAX + 1;

enum TripLeg_PedestrianType {
  TripLeg_PedestrianType_kFoot = 0,
  TripLeg_PedestrianType_kWheelchair = 1,
  TripLeg_PedestrianType_kSegway = 2
};
bool TripLeg_PedestrianType_IsValid(int value);
const TripLeg_PedestrianType TripLeg_PedestrianType_PedestrianType_MIN = TripLeg_PedestrianType_kFoot;
const TripLeg_PedestrianType TripLeg_PedestrianType_PedestrianType_MAX = TripLeg_PedestrianType_kSegway;
const int TripLeg_PedestrianType_PedestrianType_ARRAYSIZE = TripLeg_PedestrianType_PedestrianType_MAX + 1;

enum TripLeg_BicycleType {
  TripLeg_BicycleType_kRoad = 0,
  TripLeg_BicycleType_kCross = 1,
  TripLeg_BicycleType_kHybrid = 2,
  TripLeg_BicycleType_kMountain = 3
};
bool TripLeg_BicycleType_IsValid(int value);
const TripLeg_BicycleType TripLeg_BicycleType_BicycleType_MIN = TripLeg_BicycleType_kRoad;
const TripLeg_BicycleType TripLeg_BicycleType_BicycleType_MAX = TripLeg_BicycleType_kMountain;
const int TripLeg_BicycleType_BicycleType_ARRAYSIZE = TripLeg_BicycleType_BicycleType_MAX + 1;

enum TripLeg_TransitType {
  TripLeg_TransitType_kTram = 0,
  TripLeg_TransitType_kMetro = 1,
  TripLeg_TransitType_kRail = 2,
  TripLeg_TransitType_kBus = 3,
  TripLeg_TransitType_kFerry = 4,
  TripLeg_TransitType_kCableCar = 5,
  TripLeg_TransitType_kGondola = 6,
  TripLeg_TransitType_kFunicular = 7
};
bool TripLeg_TransitType_IsValid(int value);
const TripLeg_TransitType TripLeg_TransitType_TransitType_MIN = TripLeg_TransitType_kTram;
const TripLeg_TransitType TripLeg_TransitType_TransitType_MAX = TripLeg_TransitType_kFunicular;
const int TripLeg_TransitType_TransitType_ARRAYSIZE = TripLeg_TransitType_TransitType_MAX + 1;

enum TripLeg_CycleLane {
  TripLeg_CycleLane_kNoCycleLane = 0,
  TripLeg_CycleLane_kShared = 1,
  TripLeg_CycleLane_kDedicated = 2,
  TripLeg_CycleLane_kSeparated = 3
};
bool TripLeg_CycleLane_IsValid(int value);
const TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MIN = TripLeg_CycleLane_kNoCycleLane;
const TripLeg_CycleLane TripLeg_CycleLane_CycleLane_MAX = TripLeg_CycleLane_kSeparated;
const int TripLeg_CycleLane_CycleLane_ARRAYSIZE = TripLeg_CycleLane_CycleLane_MAX + 1;

enum TripLeg_Sidewalk {
  TripLeg_Sidewalk_kNoSidewalk = 0,
  TripLeg_Sidewalk_kLeft = 1,
  TripLeg_Sidewalk_kRight = 2,
  TripLeg_Sidewalk_kBothSides = 3
};
bool TripLeg_Sidewalk_IsValid(int value);
const TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MIN = TripLeg_Sidewalk_kNoSidewalk;
const TripLeg_Sidewalk TripLeg_Sidewalk_Sidewalk_MAX = TripLeg_Sidewalk_kBothSides;
const int TripLeg_Sidewalk_Sidewalk_ARRAYSIZE = TripLeg_Sidewalk_Sidewalk_MAX + 1;

// ===================================================================

class TripLeg_SignElement : public ::google::protobuf::MessageLite {
 public:
  TripLeg_SignElement();
  virtual ~TripLeg_SignElement();

  TripLeg_SignElement(const TripLeg_SignElement& from);

  inline TripLeg_SignElement& operator=(const TripLeg_SignElement& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_SignElement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_SignElement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_SignElement* other);

  // implements Message ----------------------------------------------

  TripLeg_SignElement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_SignElement& from);
  void MergeFrom(const TripLeg_SignElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool is_route_number = 2;
  inline bool has_is_route_number() const;
  inline void clear_is_route_number();
  static const int kIsRouteNumberFieldNumber = 2;
  inline bool is_route_number() const;
  inline void set_is_route_number(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.SignElement)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_is_route_number();
  inline void clear_has_is_route_number();

  ::std::string* text_;
  bool is_route_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_SignElement* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Sign : public ::google::protobuf::MessageLite {
 public:
  TripLeg_Sign();
  virtual ~TripLeg_Sign();

  TripLeg_Sign(const TripLeg_Sign& from);

  inline TripLeg_Sign& operator=(const TripLeg_Sign& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Sign& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Sign* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Sign* other);

  // implements Message ----------------------------------------------

  TripLeg_Sign* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Sign& from);
  void MergeFrom(const TripLeg_Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
  inline int exit_numbers_size() const;
  inline void clear_exit_numbers();
  static const int kExitNumbersFieldNumber = 1;
  inline const ::valhalla::TripLeg_SignElement& exit_numbers(int index) const;
  inline ::valhalla::TripLeg_SignElement* mutable_exit_numbers(int index);
  inline ::valhalla::TripLeg_SignElement* add_exit_numbers();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
      exit_numbers() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
      mutable_exit_numbers();

  // repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
  inline int exit_onto_streets_size() const;
  inline void clear_exit_onto_streets();
  static const int kExitOntoStreetsFieldNumber = 2;
  inline const ::valhalla::TripLeg_SignElement& exit_onto_streets(int index) const;
  inline ::valhalla::TripLeg_SignElement* mutable_exit_onto_streets(int index);
  inline ::valhalla::TripLeg_SignElement* add_exit_onto_streets();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
      exit_onto_streets() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
      mutable_exit_onto_streets();

  // repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
  inline int exit_toward_locations_size() const;
  inline void clear_exit_toward_locations();
  static const int kExitTowardLocationsFieldNumber = 3;
  inline const ::valhalla::TripLeg_SignElement& exit_toward_locations(int index) const;
  inline ::valhalla::TripLeg_SignElement* mutable_exit_toward_locations(int index);
  inline ::valhalla::TripLeg_SignElement* add_exit_toward_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
      exit_toward_locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
      mutable_exit_toward_locations();

  // repeated .valhalla.TripLeg.SignElement exit_names = 4;
  inline int exit_names_size() const;
  inline void clear_exit_names();
  static const int kExitNamesFieldNumber = 4;
  inline const ::valhalla::TripLeg_SignElement& exit_names(int index) const;
  inline ::valhalla::TripLeg_SignElement* mutable_exit_names(int index);
  inline ::valhalla::TripLeg_SignElement* add_exit_names();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
      exit_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
      mutable_exit_names();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Sign)
 private:

  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement > exit_numbers_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement > exit_onto_streets_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement > exit_toward_locations_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement > exit_names_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Sign* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_TransitRouteInfo : public ::google::protobuf::MessageLite {
 public:
  TripLeg_TransitRouteInfo();
  virtual ~TripLeg_TransitRouteInfo();

  TripLeg_TransitRouteInfo(const TripLeg_TransitRouteInfo& from);

  inline TripLeg_TransitRouteInfo& operator=(const TripLeg_TransitRouteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_TransitRouteInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_TransitRouteInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_TransitRouteInfo* other);

  // implements Message ----------------------------------------------

  TripLeg_TransitRouteInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_TransitRouteInfo& from);
  void MergeFrom(const TripLeg_TransitRouteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string onestop_id = 1;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 1;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional uint32 block_id = 2;
  inline bool has_block_id() const;
  inline void clear_block_id();
  static const int kBlockIdFieldNumber = 2;
  inline ::google::protobuf::uint32 block_id() const;
  inline void set_block_id(::google::protobuf::uint32 value);

  // optional uint32 trip_id = 3;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 3;
  inline ::google::protobuf::uint32 trip_id() const;
  inline void set_trip_id(::google::protobuf::uint32 value);

  // optional string short_name = 4;
  inline bool has_short_name() const;
  inline void clear_short_name();
  static const int kShortNameFieldNumber = 4;
  inline const ::std::string& short_name() const;
  inline void set_short_name(const ::std::string& value);
  inline void set_short_name(const char* value);
  inline void set_short_name(const char* value, size_t size);
  inline ::std::string* mutable_short_name();
  inline ::std::string* release_short_name();
  inline void set_allocated_short_name(::std::string* short_name);

  // optional string long_name = 5;
  inline bool has_long_name() const;
  inline void clear_long_name();
  static const int kLongNameFieldNumber = 5;
  inline const ::std::string& long_name() const;
  inline void set_long_name(const ::std::string& value);
  inline void set_long_name(const char* value);
  inline void set_long_name(const char* value, size_t size);
  inline ::std::string* mutable_long_name();
  inline ::std::string* release_long_name();
  inline void set_allocated_long_name(::std::string* long_name);

  // optional string headsign = 6;
  inline bool has_headsign() const;
  inline void clear_headsign();
  static const int kHeadsignFieldNumber = 6;
  inline const ::std::string& headsign() const;
  inline void set_headsign(const ::std::string& value);
  inline void set_headsign(const char* value);
  inline void set_headsign(const char* value, size_t size);
  inline ::std::string* mutable_headsign();
  inline ::std::string* release_headsign();
  inline void set_allocated_headsign(::std::string* headsign);

  // optional uint32 color = 7;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 7;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 text_color = 8;
  inline bool has_text_color() const;
  inline void clear_text_color();
  static const int kTextColorFieldNumber = 8;
  inline ::google::protobuf::uint32 text_color() const;
  inline void set_text_color(::google::protobuf::uint32 value);

  // optional string description = 9;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 9;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string operator_onestop_id = 10;
  inline bool has_operator_onestop_id() const;
  inline void clear_operator_onestop_id();
  static const int kOperatorOnestopIdFieldNumber = 10;
  inline const ::std::string& operator_onestop_id() const;
  inline void set_operator_onestop_id(const ::std::string& value);
  inline void set_operator_onestop_id(const char* value);
  inline void set_operator_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_operator_onestop_id();
  inline ::std::string* release_operator_onestop_id();
  inline void set_allocated_operator_onestop_id(::std::string* operator_onestop_id);

  // optional string operator_name = 11;
  inline bool has_operator_name() const;
  inline void clear_operator_name();
  static const int kOperatorNameFieldNumber = 11;
  inline const ::std::string& operator_name() const;
  inline void set_operator_name(const ::std::string& value);
  inline void set_operator_name(const char* value);
  inline void set_operator_name(const char* value, size_t size);
  inline ::std::string* mutable_operator_name();
  inline ::std::string* release_operator_name();
  inline void set_allocated_operator_name(::std::string* operator_name);

  // optional string operator_url = 12;
  inline bool has_operator_url() const;
  inline void clear_operator_url();
  static const int kOperatorUrlFieldNumber = 12;
  inline const ::std::string& operator_url() const;
  inline void set_operator_url(const ::std::string& value);
  inline void set_operator_url(const char* value);
  inline void set_operator_url(const char* value, size_t size);
  inline ::std::string* mutable_operator_url();
  inline ::std::string* release_operator_url();
  inline void set_allocated_operator_url(::std::string* operator_url);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TransitRouteInfo)
 private:
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_block_id();
  inline void clear_has_block_id();
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_short_name();
  inline void clear_has_short_name();
  inline void set_has_long_name();
  inline void clear_has_long_name();
  inline void set_has_headsign();
  inline void clear_has_headsign();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_text_color();
  inline void clear_has_text_color();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_operator_onestop_id();
  inline void clear_has_operator_onestop_id();
  inline void set_has_operator_name();
  inline void clear_has_operator_name();
  inline void set_has_operator_url();
  inline void clear_has_operator_url();

  ::std::string* onestop_id_;
  ::google::protobuf::uint32 block_id_;
  ::google::protobuf::uint32 trip_id_;
  ::std::string* short_name_;
  ::std::string* long_name_;
  ::std::string* headsign_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 text_color_;
  ::std::string* description_;
  ::std::string* operator_onestop_id_;
  ::std::string* operator_name_;
  ::std::string* operator_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_TransitRouteInfo* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_LaneConnectivity : public ::google::protobuf::MessageLite {
 public:
  TripLeg_LaneConnectivity();
  virtual ~TripLeg_LaneConnectivity();

  TripLeg_LaneConnectivity(const TripLeg_LaneConnectivity& from);

  inline TripLeg_LaneConnectivity& operator=(const TripLeg_LaneConnectivity& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_LaneConnectivity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_LaneConnectivity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_LaneConnectivity* other);

  // implements Message ----------------------------------------------

  TripLeg_LaneConnectivity* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_LaneConnectivity& from);
  void MergeFrom(const TripLeg_LaneConnectivity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 from_way_id = 1;
  inline bool has_from_way_id() const;
  inline void clear_from_way_id();
  static const int kFromWayIdFieldNumber = 1;
  inline ::google::protobuf::uint64 from_way_id() const;
  inline void set_from_way_id(::google::protobuf::uint64 value);

  // optional string from_lanes = 2;
  inline bool has_from_lanes() const;
  inline void clear_from_lanes();
  static const int kFromLanesFieldNumber = 2;
  inline const ::std::string& from_lanes() const;
  inline void set_from_lanes(const ::std::string& value);
  inline void set_from_lanes(const char* value);
  inline void set_from_lanes(const char* value, size_t size);
  inline ::std::string* mutable_from_lanes();
  inline ::std::string* release_from_lanes();
  inline void set_allocated_from_lanes(::std::string* from_lanes);

  // optional string to_lanes = 3;
  inline bool has_to_lanes() const;
  inline void clear_to_lanes();
  static const int kToLanesFieldNumber = 3;
  inline const ::std::string& to_lanes() const;
  inline void set_to_lanes(const ::std::string& value);
  inline void set_to_lanes(const char* value);
  inline void set_to_lanes(const char* value, size_t size);
  inline ::std::string* mutable_to_lanes();
  inline ::std::string* release_to_lanes();
  inline void set_allocated_to_lanes(::std::string* to_lanes);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.LaneConnectivity)
 private:
  inline void set_has_from_way_id();
  inline void clear_has_from_way_id();
  inline void set_has_from_lanes();
  inline void clear_has_from_lanes();
  inline void set_has_to_lanes();
  inline void clear_has_to_lanes();

  ::google::protobuf::uint64 from_way_id_;
  ::std::string* from_lanes_;
  ::std::string* to_lanes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_LaneConnectivity* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_TrafficSegment : public ::google::protobuf::MessageLite {
 public:
  TripLeg_TrafficSegment();
  virtual ~TripLeg_TrafficSegment();

  TripLeg_TrafficSegment(const TripLeg_TrafficSegment& from);

  inline TripLeg_TrafficSegment& operator=(const TripLeg_TrafficSegment& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_TrafficSegment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_TrafficSegment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_TrafficSegment* other);

  // implements Message ----------------------------------------------

  TripLeg_TrafficSegment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_TrafficSegment& from);
  void MergeFrom(const TripLeg_TrafficSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 segment_id = 1;
  inline bool has_segment_id() const;
  inline void clear_segment_id();
  static const int kSegmentIdFieldNumber = 1;
  inline ::google::protobuf::uint64 segment_id() const;
  inline void set_segment_id(::google::protobuf::uint64 value);

  // optional float begin_percent = 2;
  inline bool has_begin_percent() const;
  inline void clear_begin_percent();
  static const int kBeginPercentFieldNumber = 2;
  inline float begin_percent() const;
  inline void set_begin_percent(float value);

  // optional float end_percent = 3;
  inline bool has_end_percent() const;
  inline void clear_end_percent();
  static const int kEndPercentFieldNumber = 3;
  inline float end_percent() const;
  inline void set_end_percent(float value);

  // optional bool starts_segment = 4;
  inline bool has_starts_segment() const;
  inline void clear_starts_segment();
  static const int kStartsSegmentFieldNumber = 4;
  inline bool starts_segment() const;
  inline void set_starts_segment(bool value);

  // optional bool ends_segment = 5;
  inline bool has_ends_segment() const;
  inline void clear_ends_segment();
  static const int kEndsSegmentFieldNumber = 5;
  inline bool ends_segment() const;
  inline void set_ends_segment(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.TrafficSegment)
 private:
  inline void set_has_segment_id();
  inline void clear_has_segment_id();
  inline void set_has_begin_percent();
  inline void clear_has_begin_percent();
  inline void set_has_end_percent();
  inline void clear_has_end_percent();
  inline void set_has_starts_segment();
  inline void clear_has_starts_segment();
  inline void set_has_ends_segment();
  inline void clear_has_ends_segment();

  ::google::protobuf::uint64 segment_id_;
  float begin_percent_;
  float end_percent_;
  bool starts_segment_;
  bool ends_segment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_TrafficSegment* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Edge : public ::google::protobuf::MessageLite {
 public:
  TripLeg_Edge();
  virtual ~TripLeg_Edge();

  TripLeg_Edge(const TripLeg_Edge& from);

  inline TripLeg_Edge& operator=(const TripLeg_Edge& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Edge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Edge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Edge* other);

  // implements Message ----------------------------------------------

  TripLeg_Edge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Edge& from);
  void MergeFrom(const TripLeg_Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.StreetName name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::valhalla::StreetName& name(int index) const;
  inline ::valhalla::StreetName* mutable_name(int index);
  inline ::valhalla::StreetName* add_name();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
      name() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
      mutable_name();

  // optional float length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline float length() const;
  inline void set_length(float value);

  // optional float speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline float speed() const;
  inline void set_speed(float value);

  // optional .valhalla.TripLeg.RoadClass road_class = 4;
  inline bool has_road_class() const;
  inline void clear_road_class();
  static const int kRoadClassFieldNumber = 4;
  inline ::valhalla::TripLeg_RoadClass road_class() const;
  inline void set_road_class(::valhalla::TripLeg_RoadClass value);

  // optional uint32 begin_heading = 5;
  inline bool has_begin_heading() const;
  inline void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 5;
  inline ::google::protobuf::uint32 begin_heading() const;
  inline void set_begin_heading(::google::protobuf::uint32 value);

  // optional uint32 end_heading = 6;
  inline bool has_end_heading() const;
  inline void clear_end_heading();
  static const int kEndHeadingFieldNumber = 6;
  inline ::google::protobuf::uint32 end_heading() const;
  inline void set_end_heading(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 7;
  inline bool has_begin_shape_index() const;
  inline void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 begin_shape_index() const;
  inline void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 8;
  inline bool has_end_shape_index() const;
  inline void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 end_shape_index() const;
  inline void set_end_shape_index(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.Traversability traversability = 9;
  inline bool has_traversability() const;
  inline void clear_traversability();
  static const int kTraversabilityFieldNumber = 9;
  inline ::valhalla::TripLeg_Traversability traversability() const;
  inline void set_traversability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Use use = 10;
  inline bool has_use() const;
  inline void clear_use();
  static const int kUseFieldNumber = 10;
  inline ::valhalla::TripLeg_Use use() const;
  inline void set_use(::valhalla::TripLeg_Use value);

  // optional bool toll = 11;
  inline bool has_toll() const;
  inline void clear_toll();
  static const int kTollFieldNumber = 11;
  inline bool toll() const;
  inline void set_toll(bool value);

  // optional bool unpaved = 12;
  inline bool has_unpaved() const;
  inline void clear_unpaved();
  static const int kUnpavedFieldNumber = 12;
  inline bool unpaved() const;
  inline void set_unpaved(bool value);

  // optional bool tunnel = 13;
  inline bool has_tunnel() const;
  inline void clear_tunnel();
  static const int kTunnelFieldNumber = 13;
  inline bool tunnel() const;
  inline void set_tunnel(bool value);

  // optional bool bridge = 14;
  inline bool has_bridge() const;
  inline void clear_bridge();
  static const int kBridgeFieldNumber = 14;
  inline bool bridge() const;
  inline void set_bridge(bool value);

  // optional bool roundabout = 15;
  inline bool has_roundabout() const;
  inline void clear_roundabout();
  static const int kRoundaboutFieldNumber = 15;
  inline bool roundabout() const;
  inline void set_roundabout(bool value);

  // optional bool internal_intersection = 16;
  inline bool has_internal_intersection() const;
  inline void clear_internal_intersection();
  static const int kInternalIntersectionFieldNumber = 16;
  inline bool internal_intersection() const;
  inline void set_internal_intersection(bool value);

  // optional bool drive_on_right = 17 [default = true];
  inline bool has_drive_on_right() const;
  inline void clear_drive_on_right();
  static const int kDriveOnRightFieldNumber = 17;
  inline bool drive_on_right() const;
  inline void set_drive_on_right(bool value);

  // optional .valhalla.TripLeg.Surface surface = 18;
  inline bool has_surface() const;
  inline void clear_surface();
  static const int kSurfaceFieldNumber = 18;
  inline ::valhalla::TripLeg_Surface surface() const;
  inline void set_surface(::valhalla::TripLeg_Surface value);

  // optional .valhalla.TripLeg.Sign sign = 19;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 19;
  inline const ::valhalla::TripLeg_Sign& sign() const;
  inline ::valhalla::TripLeg_Sign* mutable_sign();
  inline ::valhalla::TripLeg_Sign* release_sign();
  inline void set_allocated_sign(::valhalla::TripLeg_Sign* sign);

  // optional .valhalla.TripLeg.TravelMode travel_mode = 20;
  inline bool has_travel_mode() const;
  inline void clear_travel_mode();
  static const int kTravelModeFieldNumber = 20;
  inline ::valhalla::TripLeg_TravelMode travel_mode() const;
  inline void set_travel_mode(::valhalla::TripLeg_TravelMode value);

  // optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
  inline bool has_vehicle_type() const;
  inline void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 21;
  inline ::valhalla::TripLeg_VehicleType vehicle_type() const;
  inline void set_vehicle_type(::valhalla::TripLeg_VehicleType value);

  // optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
  inline bool has_pedestrian_type() const;
  inline void clear_pedestrian_type();
  static const int kPedestrianTypeFieldNumber = 22;
  inline ::valhalla::TripLeg_PedestrianType pedestrian_type() const;
  inline void set_pedestrian_type(::valhalla::TripLeg_PedestrianType value);

  // optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
  inline bool has_bicycle_type() const;
  inline void clear_bicycle_type();
  static const int kBicycleTypeFieldNumber = 23;
  inline ::valhalla::TripLeg_BicycleType bicycle_type() const;
  inline void set_bicycle_type(::valhalla::TripLeg_BicycleType value);

  // optional .valhalla.TripLeg.TransitType transit_type = 24;
  inline bool has_transit_type() const;
  inline void clear_transit_type();
  static const int kTransitTypeFieldNumber = 24;
  inline ::valhalla::TripLeg_TransitType transit_type() const;
  inline void set_transit_type(::valhalla::TripLeg_TransitType value);

  // optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
  inline bool has_transit_route_info() const;
  inline void clear_transit_route_info();
  static const int kTransitRouteInfoFieldNumber = 25;
  inline const ::valhalla::TripLeg_TransitRouteInfo& transit_route_info() const;
  inline ::valhalla::TripLeg_TransitRouteInfo* mutable_transit_route_info();
  inline ::valhalla::TripLeg_TransitRouteInfo* release_transit_route_info();
  inline void set_allocated_transit_route_info(::valhalla::TripLeg_TransitRouteInfo* transit_route_info);

  // optional uint64 id = 26;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 26;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint64 way_id = 27;
  inline bool has_way_id() const;
  inline void clear_way_id();
  static const int kWayIdFieldNumber = 27;
  inline ::google::protobuf::uint64 way_id() const;
  inline void set_way_id(::google::protobuf::uint64 value);

  // optional float weighted_grade = 28;
  inline bool has_weighted_grade() const;
  inline void clear_weighted_grade();
  static const int kWeightedGradeFieldNumber = 28;
  inline float weighted_grade() const;
  inline void set_weighted_grade(float value);

  // optional int32 max_upward_grade = 29;
  inline bool has_max_upward_grade() const;
  inline void clear_max_upward_grade();
  static const int kMaxUpwardGradeFieldNumber = 29;
  inline ::google::protobuf::int32 max_upward_grade() const;
  inline void set_max_upward_grade(::google::protobuf::int32 value);

  // optional int32 max_downward_grade = 30;
  inline bool has_max_downward_grade() const;
  inline void clear_max_downward_grade();
  static const int kMaxDownwardGradeFieldNumber = 30;
  inline ::google::protobuf::int32 max_downward_grade() const;
  inline void set_max_downward_grade(::google::protobuf::int32 value);

  // optional uint32 lane_count = 31;
  inline bool has_lane_count() const;
  inline void clear_lane_count();
  static const int kLaneCountFieldNumber = 31;
  inline ::google::protobuf::uint32 lane_count() const;
  inline void set_lane_count(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
  inline bool has_cycle_lane() const;
  inline void clear_cycle_lane();
  static const int kCycleLaneFieldNumber = 32;
  inline ::valhalla::TripLeg_CycleLane cycle_lane() const;
  inline void set_cycle_lane(::valhalla::TripLeg_CycleLane value);

  // optional uint32 bicycle_network = 33;
  inline bool has_bicycle_network() const;
  inline void clear_bicycle_network();
  static const int kBicycleNetworkFieldNumber = 33;
  inline ::google::protobuf::uint32 bicycle_network() const;
  inline void set_bicycle_network(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
  inline bool has_sidewalk() const;
  inline void clear_sidewalk();
  static const int kSidewalkFieldNumber = 34;
  inline ::valhalla::TripLeg_Sidewalk sidewalk() const;
  inline void set_sidewalk(::valhalla::TripLeg_Sidewalk value);

  // optional uint32 density = 35;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 35;
  inline ::google::protobuf::uint32 density() const;
  inline void set_density(::google::protobuf::uint32 value);

  // optional uint32 speed_limit = 36;
  inline bool has_speed_limit() const;
  inline void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 36;
  inline ::google::protobuf::uint32 speed_limit() const;
  inline void set_speed_limit(::google::protobuf::uint32 value);

  // optional float truck_speed = 37;
  inline bool has_truck_speed() const;
  inline void clear_truck_speed();
  static const int kTruckSpeedFieldNumber = 37;
  inline float truck_speed() const;
  inline void set_truck_speed(float value);

  // optional bool truck_route = 38;
  inline bool has_truck_route() const;
  inline void clear_truck_route();
  static const int kTruckRouteFieldNumber = 38;
  inline bool truck_route() const;
  inline void set_truck_route(bool value);

  // repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
  inline int lane_connectivity_size() const;
  inline void clear_lane_connectivity();
  static const int kLaneConnectivityFieldNumber = 39;
  inline const ::valhalla::TripLeg_LaneConnectivity& lane_connectivity(int index) const;
  inline ::valhalla::TripLeg_LaneConnectivity* mutable_lane_connectivity(int index);
  inline ::valhalla::TripLeg_LaneConnectivity* add_lane_connectivity();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
      lane_connectivity() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
      mutable_lane_connectivity();

  // optional int32 mean_elevation = 40;
  inline bool has_mean_elevation() const;
  inline void clear_mean_elevation();
  static const int kMeanElevationFieldNumber = 40;
  inline ::google::protobuf::int32 mean_elevation() const;
  inline void set_mean_elevation(::google::protobuf::int32 value);

  // repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
  inline int traffic_segment_size() const;
  inline void clear_traffic_segment();
  static const int kTrafficSegmentFieldNumber = 41;
  inline const ::valhalla::TripLeg_TrafficSegment& traffic_segment(int index) const;
  inline ::valhalla::TripLeg_TrafficSegment* mutable_traffic_segment(int index);
  inline ::valhalla::TripLeg_TrafficSegment* add_traffic_segment();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
      traffic_segment() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
      mutable_traffic_segment();

  // repeated .valhalla.TurnLane turn_lanes = 42;
  inline int turn_lanes_size() const;
  inline void clear_turn_lanes();
  static const int kTurnLanesFieldNumber = 42;
  inline const ::valhalla::TurnLane& turn_lanes(int index) const;
  inline ::valhalla::TurnLane* mutable_turn_lanes(int index);
  inline ::valhalla::TurnLane* add_turn_lanes();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >&
      turn_lanes() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >*
      mutable_turn_lanes();

  // optional bool has_time_restrictions = 43;
  inline bool has_has_time_restrictions() const;
  inline void clear_has_time_restrictions();
  static const int kHasTimeRestrictionsFieldNumber = 43;
  inline bool has_time_restrictions() const;
  inline void set_has_time_restrictions(bool value);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Edge)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_road_class();
  inline void clear_has_road_class();
  inline void set_has_begin_heading();
  inline void clear_has_begin_heading();
  inline void set_has_end_heading();
  inline void clear_has_end_heading();
  inline void set_has_begin_shape_index();
  inline void clear_has_begin_shape_index();
  inline void set_has_end_shape_index();
  inline void clear_has_end_shape_index();
  inline void set_has_traversability();
  inline void clear_has_traversability();
  inline void set_has_use();
  inline void clear_has_use();
  inline void set_has_toll();
  inline void clear_has_toll();
  inline void set_has_unpaved();
  inline void clear_has_unpaved();
  inline void set_has_tunnel();
  inline void clear_has_tunnel();
  inline void set_has_bridge();
  inline void clear_has_bridge();
  inline void set_has_roundabout();
  inline void clear_has_roundabout();
  inline void set_has_internal_intersection();
  inline void clear_has_internal_intersection();
  inline void set_has_drive_on_right();
  inline void clear_has_drive_on_right();
  inline void set_has_surface();
  inline void clear_has_surface();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_travel_mode();
  inline void clear_has_travel_mode();
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();
  inline void set_has_pedestrian_type();
  inline void clear_has_pedestrian_type();
  inline void set_has_bicycle_type();
  inline void clear_has_bicycle_type();
  inline void set_has_transit_type();
  inline void clear_has_transit_type();
  inline void set_has_transit_route_info();
  inline void clear_has_transit_route_info();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_way_id();
  inline void clear_has_way_id();
  inline void set_has_weighted_grade();
  inline void clear_has_weighted_grade();
  inline void set_has_max_upward_grade();
  inline void clear_has_max_upward_grade();
  inline void set_has_max_downward_grade();
  inline void clear_has_max_downward_grade();
  inline void set_has_lane_count();
  inline void clear_has_lane_count();
  inline void set_has_cycle_lane();
  inline void clear_has_cycle_lane();
  inline void set_has_bicycle_network();
  inline void clear_has_bicycle_network();
  inline void set_has_sidewalk();
  inline void clear_has_sidewalk();
  inline void set_has_density();
  inline void clear_has_density();
  inline void set_has_speed_limit();
  inline void clear_has_speed_limit();
  inline void set_has_truck_speed();
  inline void clear_has_truck_speed();
  inline void set_has_truck_route();
  inline void clear_has_truck_route();
  inline void set_has_mean_elevation();
  inline void clear_has_mean_elevation();
  inline void set_has_has_time_restrictions();
  inline void clear_has_has_time_restrictions();

  ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName > name_;
  float length_;
  float speed_;
  int road_class_;
  ::google::protobuf::uint32 begin_heading_;
  ::google::protobuf::uint32 end_heading_;
  ::google::protobuf::uint32 begin_shape_index_;
  ::google::protobuf::uint32 end_shape_index_;
  int traversability_;
  int use_;
  bool toll_;
  bool unpaved_;
  bool tunnel_;
  bool bridge_;
  ::valhalla::TripLeg_Sign* sign_;
  int surface_;
  int travel_mode_;
  int vehicle_type_;
  bool roundabout_;
  bool internal_intersection_;
  bool drive_on_right_;
  bool truck_route_;
  int pedestrian_type_;
  int bicycle_type_;
  ::valhalla::TripLeg_TransitRouteInfo* transit_route_info_;
  ::google::protobuf::uint64 id_;
  int transit_type_;
  float weighted_grade_;
  ::google::protobuf::uint64 way_id_;
  ::google::protobuf::int32 max_upward_grade_;
  ::google::protobuf::int32 max_downward_grade_;
  ::google::protobuf::uint32 lane_count_;
  int cycle_lane_;
  ::google::protobuf::uint32 bicycle_network_;
  int sidewalk_;
  ::google::protobuf::uint32 density_;
  ::google::protobuf::uint32 speed_limit_;
  float truck_speed_;
  ::google::protobuf::int32 mean_elevation_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity > lane_connectivity_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment > traffic_segment_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane > turn_lanes_;
  bool has_time_restrictions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Edge* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_IntersectingEdge : public ::google::protobuf::MessageLite {
 public:
  TripLeg_IntersectingEdge();
  virtual ~TripLeg_IntersectingEdge();

  TripLeg_IntersectingEdge(const TripLeg_IntersectingEdge& from);

  inline TripLeg_IntersectingEdge& operator=(const TripLeg_IntersectingEdge& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_IntersectingEdge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_IntersectingEdge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_IntersectingEdge* other);

  // implements Message ----------------------------------------------

  TripLeg_IntersectingEdge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_IntersectingEdge& from);
  void MergeFrom(const TripLeg_IntersectingEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 begin_heading = 1;
  inline bool has_begin_heading() const;
  inline void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 1;
  inline ::google::protobuf::uint32 begin_heading() const;
  inline void set_begin_heading(::google::protobuf::uint32 value);

  // optional bool prev_name_consistency = 2;
  inline bool has_prev_name_consistency() const;
  inline void clear_prev_name_consistency();
  static const int kPrevNameConsistencyFieldNumber = 2;
  inline bool prev_name_consistency() const;
  inline void set_prev_name_consistency(bool value);

  // optional bool curr_name_consistency = 3;
  inline bool has_curr_name_consistency() const;
  inline void clear_curr_name_consistency();
  static const int kCurrNameConsistencyFieldNumber = 3;
  inline bool curr_name_consistency() const;
  inline void set_curr_name_consistency(bool value);

  // optional .valhalla.TripLeg.Traversability driveability = 4;
  inline bool has_driveability() const;
  inline void clear_driveability();
  static const int kDriveabilityFieldNumber = 4;
  inline ::valhalla::TripLeg_Traversability driveability() const;
  inline void set_driveability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Traversability cyclability = 5;
  inline bool has_cyclability() const;
  inline void clear_cyclability();
  static const int kCyclabilityFieldNumber = 5;
  inline ::valhalla::TripLeg_Traversability cyclability() const;
  inline void set_cyclability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Traversability walkability = 6;
  inline bool has_walkability() const;
  inline void clear_walkability();
  static const int kWalkabilityFieldNumber = 6;
  inline ::valhalla::TripLeg_Traversability walkability() const;
  inline void set_walkability(::valhalla::TripLeg_Traversability value);

  // optional .valhalla.TripLeg.Use use = 7;
  inline bool has_use() const;
  inline void clear_use();
  static const int kUseFieldNumber = 7;
  inline ::valhalla::TripLeg_Use use() const;
  inline void set_use(::valhalla::TripLeg_Use value);

  // optional .valhalla.TripLeg.RoadClass road_class = 8;
  inline bool has_road_class() const;
  inline void clear_road_class();
  static const int kRoadClassFieldNumber = 8;
  inline ::valhalla::TripLeg_RoadClass road_class() const;
  inline void set_road_class(::valhalla::TripLeg_RoadClass value);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.IntersectingEdge)
 private:
  inline void set_has_begin_heading();
  inline void clear_has_begin_heading();
  inline void set_has_prev_name_consistency();
  inline void clear_has_prev_name_consistency();
  inline void set_has_curr_name_consistency();
  inline void clear_has_curr_name_consistency();
  inline void set_has_driveability();
  inline void clear_has_driveability();
  inline void set_has_cyclability();
  inline void clear_has_cyclability();
  inline void set_has_walkability();
  inline void clear_has_walkability();
  inline void set_has_use();
  inline void clear_has_use();
  inline void set_has_road_class();
  inline void clear_has_road_class();

  ::google::protobuf::uint32 begin_heading_;
  bool prev_name_consistency_;
  bool curr_name_consistency_;
  int driveability_;
  int cyclability_;
  int walkability_;
  int use_;
  int road_class_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_IntersectingEdge* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Node : public ::google::protobuf::MessageLite {
 public:
  TripLeg_Node();
  virtual ~TripLeg_Node();

  TripLeg_Node(const TripLeg_Node& from);

  inline TripLeg_Node& operator=(const TripLeg_Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Node& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Node* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Node* other);

  // implements Message ----------------------------------------------

  TripLeg_Node* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Node& from);
  void MergeFrom(const TripLeg_Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripLeg_Node_Type Type;
  static const Type kStreetIntersection = TripLeg_Node_Type_kStreetIntersection;
  static const Type kGate = TripLeg_Node_Type_kGate;
  static const Type kBollard = TripLeg_Node_Type_kBollard;
  static const Type kTollBooth = TripLeg_Node_Type_kTollBooth;
  static const Type kTransitEgress = TripLeg_Node_Type_kTransitEgress;
  static const Type kTransitStation = TripLeg_Node_Type_kTransitStation;
  static const Type kTransitPlatform = TripLeg_Node_Type_kTransitPlatform;
  static const Type kBikeShare = TripLeg_Node_Type_kBikeShare;
  static const Type kParking = TripLeg_Node_Type_kParking;
  static const Type kMotorwayJunction = TripLeg_Node_Type_kMotorwayJunction;
  static const Type kBorderControl = TripLeg_Node_Type_kBorderControl;
  static inline bool Type_IsValid(int value) {
    return TripLeg_Node_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripLeg_Node_Type_Type_MIN;
  static const Type Type_MAX =
    TripLeg_Node_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripLeg_Node_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .valhalla.TripLeg.Edge edge = 1;
  inline bool has_edge() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 1;
  inline const ::valhalla::TripLeg_Edge& edge() const;
  inline ::valhalla::TripLeg_Edge* mutable_edge();
  inline ::valhalla::TripLeg_Edge* release_edge();
  inline void set_allocated_edge(::valhalla::TripLeg_Edge* edge);

  // repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
  inline int intersecting_edge_size() const;
  inline void clear_intersecting_edge();
  static const int kIntersectingEdgeFieldNumber = 2;
  inline const ::valhalla::TripLeg_IntersectingEdge& intersecting_edge(int index) const;
  inline ::valhalla::TripLeg_IntersectingEdge* mutable_intersecting_edge(int index);
  inline ::valhalla::TripLeg_IntersectingEdge* add_intersecting_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
      intersecting_edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
      mutable_intersecting_edge();

  // optional double elapsed_time = 3;
  inline bool has_elapsed_time() const;
  inline void clear_elapsed_time();
  static const int kElapsedTimeFieldNumber = 3;
  inline double elapsed_time() const;
  inline void set_elapsed_time(double value);

  // optional uint32 admin_index = 4;
  inline bool has_admin_index() const;
  inline void clear_admin_index();
  static const int kAdminIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 admin_index() const;
  inline void set_admin_index(::google::protobuf::uint32 value);

  // optional .valhalla.TripLeg.Node.Type type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::valhalla::TripLeg_Node_Type type() const;
  inline void set_type(::valhalla::TripLeg_Node_Type value);

  // optional bool fork = 6;
  inline bool has_fork() const;
  inline void clear_fork();
  static const int kForkFieldNumber = 6;
  inline bool fork() const;
  inline void set_fork(bool value);

  // optional .valhalla.TransitPlatformInfo transit_platform_info = 7;
  inline bool has_transit_platform_info() const;
  inline void clear_transit_platform_info();
  static const int kTransitPlatformInfoFieldNumber = 7;
  inline const ::valhalla::TransitPlatformInfo& transit_platform_info() const;
  inline ::valhalla::TransitPlatformInfo* mutable_transit_platform_info();
  inline ::valhalla::TransitPlatformInfo* release_transit_platform_info();
  inline void set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info);

  // optional .valhalla.TransitStationInfo transit_station_info = 8;
  inline bool has_transit_station_info() const;
  inline void clear_transit_station_info();
  static const int kTransitStationInfoFieldNumber = 8;
  inline const ::valhalla::TransitStationInfo& transit_station_info() const;
  inline ::valhalla::TransitStationInfo* mutable_transit_station_info();
  inline ::valhalla::TransitStationInfo* release_transit_station_info();
  inline void set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info);

  // optional .valhalla.TransitEgressInfo transit_egress_info = 9;
  inline bool has_transit_egress_info() const;
  inline void clear_transit_egress_info();
  static const int kTransitEgressInfoFieldNumber = 9;
  inline const ::valhalla::TransitEgressInfo& transit_egress_info() const;
  inline ::valhalla::TransitEgressInfo* mutable_transit_egress_info();
  inline ::valhalla::TransitEgressInfo* release_transit_egress_info();
  inline void set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info);

  // optional string time_zone = 10;
  inline bool has_time_zone() const;
  inline void clear_time_zone();
  static const int kTimeZoneFieldNumber = 10;
  inline const ::std::string& time_zone() const;
  inline void set_time_zone(const ::std::string& value);
  inline void set_time_zone(const char* value);
  inline void set_time_zone(const char* value, size_t size);
  inline ::std::string* mutable_time_zone();
  inline ::std::string* release_time_zone();
  inline void set_allocated_time_zone(::std::string* time_zone);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Node)
 private:
  inline void set_has_edge();
  inline void clear_has_edge();
  inline void set_has_elapsed_time();
  inline void clear_has_elapsed_time();
  inline void set_has_admin_index();
  inline void clear_has_admin_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_fork();
  inline void clear_has_fork();
  inline void set_has_transit_platform_info();
  inline void clear_has_transit_platform_info();
  inline void set_has_transit_station_info();
  inline void clear_has_transit_station_info();
  inline void set_has_transit_egress_info();
  inline void clear_has_transit_egress_info();
  inline void set_has_time_zone();
  inline void clear_has_time_zone();

  ::valhalla::TripLeg_Edge* edge_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge > intersecting_edge_;
  double elapsed_time_;
  ::google::protobuf::uint32 admin_index_;
  int type_;
  ::valhalla::TransitPlatformInfo* transit_platform_info_;
  ::valhalla::TransitStationInfo* transit_station_info_;
  ::valhalla::TransitEgressInfo* transit_egress_info_;
  ::std::string* time_zone_;
  bool fork_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Node* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_Admin : public ::google::protobuf::MessageLite {
 public:
  TripLeg_Admin();
  virtual ~TripLeg_Admin();

  TripLeg_Admin(const TripLeg_Admin& from);

  inline TripLeg_Admin& operator=(const TripLeg_Admin& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_Admin& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_Admin* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_Admin* other);

  // implements Message ----------------------------------------------

  TripLeg_Admin* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_Admin& from);
  void MergeFrom(const TripLeg_Admin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string country_code = 1;
  inline bool has_country_code() const;
  inline void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  inline const ::std::string& country_code() const;
  inline void set_country_code(const ::std::string& value);
  inline void set_country_code(const char* value);
  inline void set_country_code(const char* value, size_t size);
  inline ::std::string* mutable_country_code();
  inline ::std::string* release_country_code();
  inline void set_allocated_country_code(::std::string* country_code);

  // optional string country_text = 2;
  inline bool has_country_text() const;
  inline void clear_country_text();
  static const int kCountryTextFieldNumber = 2;
  inline const ::std::string& country_text() const;
  inline void set_country_text(const ::std::string& value);
  inline void set_country_text(const char* value);
  inline void set_country_text(const char* value, size_t size);
  inline ::std::string* mutable_country_text();
  inline ::std::string* release_country_text();
  inline void set_allocated_country_text(::std::string* country_text);

  // optional string state_code = 3;
  inline bool has_state_code() const;
  inline void clear_state_code();
  static const int kStateCodeFieldNumber = 3;
  inline const ::std::string& state_code() const;
  inline void set_state_code(const ::std::string& value);
  inline void set_state_code(const char* value);
  inline void set_state_code(const char* value, size_t size);
  inline ::std::string* mutable_state_code();
  inline ::std::string* release_state_code();
  inline void set_allocated_state_code(::std::string* state_code);

  // optional string state_text = 4;
  inline bool has_state_text() const;
  inline void clear_state_text();
  static const int kStateTextFieldNumber = 4;
  inline const ::std::string& state_text() const;
  inline void set_state_text(const ::std::string& value);
  inline void set_state_text(const char* value);
  inline void set_state_text(const char* value, size_t size);
  inline ::std::string* mutable_state_text();
  inline ::std::string* release_state_text();
  inline void set_allocated_state_text(::std::string* state_text);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.Admin)
 private:
  inline void set_has_country_code();
  inline void clear_has_country_code();
  inline void set_has_country_text();
  inline void clear_has_country_text();
  inline void set_has_state_code();
  inline void clear_has_state_code();
  inline void set_has_state_text();
  inline void clear_has_state_text();

  ::std::string* country_code_;
  ::std::string* country_text_;
  ::std::string* state_code_;
  ::std::string* state_text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_Admin* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg_ShapeAttributes : public ::google::protobuf::MessageLite {
 public:
  TripLeg_ShapeAttributes();
  virtual ~TripLeg_ShapeAttributes();

  TripLeg_ShapeAttributes(const TripLeg_ShapeAttributes& from);

  inline TripLeg_ShapeAttributes& operator=(const TripLeg_ShapeAttributes& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg_ShapeAttributes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg_ShapeAttributes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg_ShapeAttributes* other);

  // implements Message ----------------------------------------------

  TripLeg_ShapeAttributes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg_ShapeAttributes& from);
  void MergeFrom(const TripLeg_ShapeAttributes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 time = 1 [packed = true];
  inline int time_size() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time(int index) const;
  inline void set_time(int index, ::google::protobuf::uint32 value);
  inline void add_time(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      time() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_time();

  // repeated uint32 length = 2 [packed = true];
  inline int length_size() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline ::google::protobuf::uint32 length(int index) const;
  inline void set_length(int index, ::google::protobuf::uint32 value);
  inline void add_length(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      length() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_length();

  // repeated uint32 speed = 3 [packed = true];
  inline int speed_size() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline ::google::protobuf::uint32 speed(int index) const;
  inline void set_speed(int index, ::google::protobuf::uint32 value);
  inline void add_speed(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      speed() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_speed();

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg.ShapeAttributes)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > time_;
  mutable int _time_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > length_;
  mutable int _length_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > speed_;
  mutable int _speed_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg_ShapeAttributes* default_instance_;
};
// -------------------------------------------------------------------

class TripLeg : public ::google::protobuf::MessageLite {
 public:
  TripLeg();
  virtual ~TripLeg();

  TripLeg(const TripLeg& from);

  inline TripLeg& operator=(const TripLeg& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripLeg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripLeg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripLeg* other);

  // implements Message ----------------------------------------------

  TripLeg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripLeg& from);
  void MergeFrom(const TripLeg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripLeg_SignElement SignElement;
  typedef TripLeg_Sign Sign;
  typedef TripLeg_TransitRouteInfo TransitRouteInfo;
  typedef TripLeg_LaneConnectivity LaneConnectivity;
  typedef TripLeg_TrafficSegment TrafficSegment;
  typedef TripLeg_Edge Edge;
  typedef TripLeg_IntersectingEdge IntersectingEdge;
  typedef TripLeg_Node Node;
  typedef TripLeg_Admin Admin;
  typedef TripLeg_ShapeAttributes ShapeAttributes;

  typedef TripLeg_Traversability Traversability;
  static const Traversability kNone = TripLeg_Traversability_kNone;
  static const Traversability kForward = TripLeg_Traversability_kForward;
  static const Traversability kBackward = TripLeg_Traversability_kBackward;
  static const Traversability kBoth = TripLeg_Traversability_kBoth;
  static inline bool Traversability_IsValid(int value) {
    return TripLeg_Traversability_IsValid(value);
  }
  static const Traversability Traversability_MIN =
    TripLeg_Traversability_Traversability_MIN;
  static const Traversability Traversability_MAX =
    TripLeg_Traversability_Traversability_MAX;
  static const int Traversability_ARRAYSIZE =
    TripLeg_Traversability_Traversability_ARRAYSIZE;

  typedef TripLeg_RoadClass RoadClass;
  static const RoadClass kMotorway = TripLeg_RoadClass_kMotorway;
  static const RoadClass kTrunk = TripLeg_RoadClass_kTrunk;
  static const RoadClass kPrimary = TripLeg_RoadClass_kPrimary;
  static const RoadClass kSecondary = TripLeg_RoadClass_kSecondary;
  static const RoadClass kTertiary = TripLeg_RoadClass_kTertiary;
  static const RoadClass kUnclassified = TripLeg_RoadClass_kUnclassified;
  static const RoadClass kResidential = TripLeg_RoadClass_kResidential;
  static const RoadClass kServiceOther = TripLeg_RoadClass_kServiceOther;
  static inline bool RoadClass_IsValid(int value) {
    return TripLeg_RoadClass_IsValid(value);
  }
  static const RoadClass RoadClass_MIN =
    TripLeg_RoadClass_RoadClass_MIN;
  static const RoadClass RoadClass_MAX =
    TripLeg_RoadClass_RoadClass_MAX;
  static const int RoadClass_ARRAYSIZE =
    TripLeg_RoadClass_RoadClass_ARRAYSIZE;

  typedef TripLeg_Use Use;
  static const Use kRoadUse = TripLeg_Use_kRoadUse;
  static const Use kRampUse = TripLeg_Use_kRampUse;
  static const Use kTurnChannelUse = TripLeg_Use_kTurnChannelUse;
  static const Use kTrackUse = TripLeg_Use_kTrackUse;
  static const Use kDrivewayUse = TripLeg_Use_kDrivewayUse;
  static const Use kAlleyUse = TripLeg_Use_kAlleyUse;
  static const Use kParkingAisleUse = TripLeg_Use_kParkingAisleUse;
  static const Use kEmergencyAccessUse = TripLeg_Use_kEmergencyAccessUse;
  static const Use kDriveThruUse = TripLeg_Use_kDriveThruUse;
  static const Use kCuldesacUse = TripLeg_Use_kCuldesacUse;
  static const Use kCyclewayUse = TripLeg_Use_kCyclewayUse;
  static const Use kMountainBikeUse = TripLeg_Use_kMountainBikeUse;
  static const Use kSidewalkUse = TripLeg_Use_kSidewalkUse;
  static const Use kFootwayUse = TripLeg_Use_kFootwayUse;
  static const Use kStepsUse = TripLeg_Use_kStepsUse;
  static const Use kPathUse = TripLeg_Use_kPathUse;
  static const Use kPedestrianUse = TripLeg_Use_kPedestrianUse;
  static const Use kBridlewayUse = TripLeg_Use_kBridlewayUse;
  static const Use kOtherUse = TripLeg_Use_kOtherUse;
  static const Use kFerryUse = TripLeg_Use_kFerryUse;
  static const Use kRailFerryUse = TripLeg_Use_kRailFerryUse;
  static const Use kRailUse = TripLeg_Use_kRailUse;
  static const Use kBusUse = TripLeg_Use_kBusUse;
  static const Use kEgressConnectionUse = TripLeg_Use_kEgressConnectionUse;
  static const Use kPlatformConnectionUse = TripLeg_Use_kPlatformConnectionUse;
  static const Use kTransitConnectionUse = TripLeg_Use_kTransitConnectionUse;
  static inline bool Use_IsValid(int value) {
    return TripLeg_Use_IsValid(value);
  }
  static const Use Use_MIN =
    TripLeg_Use_Use_MIN;
  static const Use Use_MAX =
    TripLeg_Use_Use_MAX;
  static const int Use_ARRAYSIZE =
    TripLeg_Use_Use_ARRAYSIZE;

  typedef TripLeg_Surface Surface;
  static const Surface kPavedSmooth = TripLeg_Surface_kPavedSmooth;
  static const Surface kPaved = TripLeg_Surface_kPaved;
  static const Surface kPavedRough = TripLeg_Surface_kPavedRough;
  static const Surface kCompacted = TripLeg_Surface_kCompacted;
  static const Surface kDirt = TripLeg_Surface_kDirt;
  static const Surface kGravel = TripLeg_Surface_kGravel;
  static const Surface kPath = TripLeg_Surface_kPath;
  static const Surface kImpassable = TripLeg_Surface_kImpassable;
  static inline bool Surface_IsValid(int value) {
    return TripLeg_Surface_IsValid(value);
  }
  static const Surface Surface_MIN =
    TripLeg_Surface_Surface_MIN;
  static const Surface Surface_MAX =
    TripLeg_Surface_Surface_MAX;
  static const int Surface_ARRAYSIZE =
    TripLeg_Surface_Surface_ARRAYSIZE;

  typedef TripLeg_TravelMode TravelMode;
  static const TravelMode kDrive = TripLeg_TravelMode_kDrive;
  static const TravelMode kPedestrian = TripLeg_TravelMode_kPedestrian;
  static const TravelMode kBicycle = TripLeg_TravelMode_kBicycle;
  static const TravelMode kTransit = TripLeg_TravelMode_kTransit;
  static inline bool TravelMode_IsValid(int value) {
    return TripLeg_TravelMode_IsValid(value);
  }
  static const TravelMode TravelMode_MIN =
    TripLeg_TravelMode_TravelMode_MIN;
  static const TravelMode TravelMode_MAX =
    TripLeg_TravelMode_TravelMode_MAX;
  static const int TravelMode_ARRAYSIZE =
    TripLeg_TravelMode_TravelMode_ARRAYSIZE;

  typedef TripLeg_VehicleType VehicleType;
  static const VehicleType kCar = TripLeg_VehicleType_kCar;
  static const VehicleType kMotorcycle = TripLeg_VehicleType_kMotorcycle;
  static const VehicleType kAutoBus = TripLeg_VehicleType_kAutoBus;
  static const VehicleType kTractorTrailer = TripLeg_VehicleType_kTractorTrailer;
  static const VehicleType kMotorScooter = TripLeg_VehicleType_kMotorScooter;
  static inline bool VehicleType_IsValid(int value) {
    return TripLeg_VehicleType_IsValid(value);
  }
  static const VehicleType VehicleType_MIN =
    TripLeg_VehicleType_VehicleType_MIN;
  static const VehicleType VehicleType_MAX =
    TripLeg_VehicleType_VehicleType_MAX;
  static const int VehicleType_ARRAYSIZE =
    TripLeg_VehicleType_VehicleType_ARRAYSIZE;

  typedef TripLeg_PedestrianType PedestrianType;
  static const PedestrianType kFoot = TripLeg_PedestrianType_kFoot;
  static const PedestrianType kWheelchair = TripLeg_PedestrianType_kWheelchair;
  static const PedestrianType kSegway = TripLeg_PedestrianType_kSegway;
  static inline bool PedestrianType_IsValid(int value) {
    return TripLeg_PedestrianType_IsValid(value);
  }
  static const PedestrianType PedestrianType_MIN =
    TripLeg_PedestrianType_PedestrianType_MIN;
  static const PedestrianType PedestrianType_MAX =
    TripLeg_PedestrianType_PedestrianType_MAX;
  static const int PedestrianType_ARRAYSIZE =
    TripLeg_PedestrianType_PedestrianType_ARRAYSIZE;

  typedef TripLeg_BicycleType BicycleType;
  static const BicycleType kRoad = TripLeg_BicycleType_kRoad;
  static const BicycleType kCross = TripLeg_BicycleType_kCross;
  static const BicycleType kHybrid = TripLeg_BicycleType_kHybrid;
  static const BicycleType kMountain = TripLeg_BicycleType_kMountain;
  static inline bool BicycleType_IsValid(int value) {
    return TripLeg_BicycleType_IsValid(value);
  }
  static const BicycleType BicycleType_MIN =
    TripLeg_BicycleType_BicycleType_MIN;
  static const BicycleType BicycleType_MAX =
    TripLeg_BicycleType_BicycleType_MAX;
  static const int BicycleType_ARRAYSIZE =
    TripLeg_BicycleType_BicycleType_ARRAYSIZE;

  typedef TripLeg_TransitType TransitType;
  static const TransitType kTram = TripLeg_TransitType_kTram;
  static const TransitType kMetro = TripLeg_TransitType_kMetro;
  static const TransitType kRail = TripLeg_TransitType_kRail;
  static const TransitType kBus = TripLeg_TransitType_kBus;
  static const TransitType kFerry = TripLeg_TransitType_kFerry;
  static const TransitType kCableCar = TripLeg_TransitType_kCableCar;
  static const TransitType kGondola = TripLeg_TransitType_kGondola;
  static const TransitType kFunicular = TripLeg_TransitType_kFunicular;
  static inline bool TransitType_IsValid(int value) {
    return TripLeg_TransitType_IsValid(value);
  }
  static const TransitType TransitType_MIN =
    TripLeg_TransitType_TransitType_MIN;
  static const TransitType TransitType_MAX =
    TripLeg_TransitType_TransitType_MAX;
  static const int TransitType_ARRAYSIZE =
    TripLeg_TransitType_TransitType_ARRAYSIZE;

  typedef TripLeg_CycleLane CycleLane;
  static const CycleLane kNoCycleLane = TripLeg_CycleLane_kNoCycleLane;
  static const CycleLane kShared = TripLeg_CycleLane_kShared;
  static const CycleLane kDedicated = TripLeg_CycleLane_kDedicated;
  static const CycleLane kSeparated = TripLeg_CycleLane_kSeparated;
  static inline bool CycleLane_IsValid(int value) {
    return TripLeg_CycleLane_IsValid(value);
  }
  static const CycleLane CycleLane_MIN =
    TripLeg_CycleLane_CycleLane_MIN;
  static const CycleLane CycleLane_MAX =
    TripLeg_CycleLane_CycleLane_MAX;
  static const int CycleLane_ARRAYSIZE =
    TripLeg_CycleLane_CycleLane_ARRAYSIZE;

  typedef TripLeg_Sidewalk Sidewalk;
  static const Sidewalk kNoSidewalk = TripLeg_Sidewalk_kNoSidewalk;
  static const Sidewalk kLeft = TripLeg_Sidewalk_kLeft;
  static const Sidewalk kRight = TripLeg_Sidewalk_kRight;
  static const Sidewalk kBothSides = TripLeg_Sidewalk_kBothSides;
  static inline bool Sidewalk_IsValid(int value) {
    return TripLeg_Sidewalk_IsValid(value);
  }
  static const Sidewalk Sidewalk_MIN =
    TripLeg_Sidewalk_Sidewalk_MIN;
  static const Sidewalk Sidewalk_MAX =
    TripLeg_Sidewalk_Sidewalk_MAX;
  static const int Sidewalk_ARRAYSIZE =
    TripLeg_Sidewalk_Sidewalk_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint64 osm_changeset = 1;
  inline bool has_osm_changeset() const;
  inline void clear_osm_changeset();
  static const int kOsmChangesetFieldNumber = 1;
  inline ::google::protobuf::uint64 osm_changeset() const;
  inline void set_osm_changeset(::google::protobuf::uint64 value);

  // optional uint64 trip_id = 2;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 2;
  inline ::google::protobuf::uint64 trip_id() const;
  inline void set_trip_id(::google::protobuf::uint64 value);

  // optional uint32 leg_id = 3;
  inline bool has_leg_id() const;
  inline void clear_leg_id();
  static const int kLegIdFieldNumber = 3;
  inline ::google::protobuf::uint32 leg_id() const;
  inline void set_leg_id(::google::protobuf::uint32 value);

  // optional uint32 leg_count = 4;
  inline bool has_leg_count() const;
  inline void clear_leg_count();
  static const int kLegCountFieldNumber = 4;
  inline ::google::protobuf::uint32 leg_count() const;
  inline void set_leg_count(::google::protobuf::uint32 value);

  // repeated .valhalla.Location location = 5;
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 5;
  inline const ::valhalla::Location& location(int index) const;
  inline ::valhalla::Location* mutable_location(int index);
  inline ::valhalla::Location* add_location();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
      location() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
      mutable_location();

  // repeated .valhalla.TripLeg.Node node = 6;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 6;
  inline const ::valhalla::TripLeg_Node& node(int index) const;
  inline ::valhalla::TripLeg_Node* mutable_node(int index);
  inline ::valhalla::TripLeg_Node* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >*
      mutable_node();

  // repeated .valhalla.TripLeg.Admin admin = 7;
  inline int admin_size() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 7;
  inline const ::valhalla::TripLeg_Admin& admin(int index) const;
  inline ::valhalla::TripLeg_Admin* mutable_admin(int index);
  inline ::valhalla::TripLeg_Admin* add_admin();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
      admin() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
      mutable_admin();

  // optional string shape = 8;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 8;
  inline const ::std::string& shape() const;
  inline void set_shape(const ::std::string& value);
  inline void set_shape(const char* value);
  inline void set_shape(const char* value, size_t size);
  inline ::std::string* mutable_shape();
  inline ::std::string* release_shape();
  inline void set_allocated_shape(::std::string* shape);

  // optional .valhalla.BoundingBox bbox = 9;
  inline bool has_bbox() const;
  inline void clear_bbox();
  static const int kBboxFieldNumber = 9;
  inline const ::valhalla::BoundingBox& bbox() const;
  inline ::valhalla::BoundingBox* mutable_bbox();
  inline ::valhalla::BoundingBox* release_bbox();
  inline void set_allocated_bbox(::valhalla::BoundingBox* bbox);

  // optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
  inline bool has_shape_attributes() const;
  inline void clear_shape_attributes();
  static const int kShapeAttributesFieldNumber = 10;
  inline const ::valhalla::TripLeg_ShapeAttributes& shape_attributes() const;
  inline ::valhalla::TripLeg_ShapeAttributes* mutable_shape_attributes();
  inline ::valhalla::TripLeg_ShapeAttributes* release_shape_attributes();
  inline void set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes);

  // @@protoc_insertion_point(class_scope:valhalla.TripLeg)
 private:
  inline void set_has_osm_changeset();
  inline void clear_has_osm_changeset();
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_leg_id();
  inline void clear_has_leg_id();
  inline void set_has_leg_count();
  inline void clear_has_leg_count();
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_bbox();
  inline void clear_has_bbox();
  inline void set_has_shape_attributes();
  inline void clear_has_shape_attributes();

  ::google::protobuf::uint64 osm_changeset_;
  ::google::protobuf::uint64 trip_id_;
  ::google::protobuf::uint32 leg_id_;
  ::google::protobuf::uint32 leg_count_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::Location > location_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node > node_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin > admin_;
  ::std::string* shape_;
  ::valhalla::BoundingBox* bbox_;
  ::valhalla::TripLeg_ShapeAttributes* shape_attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripLeg* default_instance_;
};
// -------------------------------------------------------------------

class TripRoute : public ::google::protobuf::MessageLite {
 public:
  TripRoute();
  virtual ~TripRoute();

  TripRoute(const TripRoute& from);

  inline TripRoute& operator=(const TripRoute& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripRoute& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripRoute* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripRoute* other);

  // implements Message ----------------------------------------------

  TripRoute* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripRoute& from);
  void MergeFrom(const TripRoute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.TripLeg legs = 1;
  inline int legs_size() const;
  inline void clear_legs();
  static const int kLegsFieldNumber = 1;
  inline const ::valhalla::TripLeg& legs(int index) const;
  inline ::valhalla::TripLeg* mutable_legs(int index);
  inline ::valhalla::TripLeg* add_legs();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >&
      legs() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >*
      mutable_legs();

  // @@protoc_insertion_point(class_scope:valhalla.TripRoute)
 private:

  ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg > legs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static TripRoute* default_instance_;
};
// -------------------------------------------------------------------

class Trip : public ::google::protobuf::MessageLite {
 public:
  Trip();
  virtual ~Trip();

  Trip(const Trip& from);

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }

  static const Trip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Trip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Trip* other);

  // implements Message ----------------------------------------------

  Trip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Trip& from);
  void MergeFrom(const Trip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .valhalla.TripRoute routes = 1;
  inline int routes_size() const;
  inline void clear_routes();
  static const int kRoutesFieldNumber = 1;
  inline const ::valhalla::TripRoute& routes(int index) const;
  inline ::valhalla::TripRoute* mutable_routes(int index);
  inline ::valhalla::TripRoute* add_routes();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >&
      routes() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >*
      mutable_routes();

  // @@protoc_insertion_point(class_scope:valhalla.Trip)
 private:

  ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute > routes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_trip_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_trip_2eproto();
  #endif
  friend void protobuf_AssignDesc_trip_2eproto();
  friend void protobuf_ShutdownFile_trip_2eproto();

  void InitAsDefaultInstance();
  static Trip* default_instance_;
};
// ===================================================================


// ===================================================================

// TripLeg_SignElement

// optional string text = 1;
inline bool TripLeg_SignElement::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_SignElement::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_SignElement::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_SignElement::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TripLeg_SignElement::text() const {
  return *text_;
}
inline void TripLeg_SignElement::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TripLeg_SignElement::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TripLeg_SignElement::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_SignElement::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TripLeg_SignElement::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_SignElement::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_route_number = 2;
inline bool TripLeg_SignElement::has_is_route_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_SignElement::set_has_is_route_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_SignElement::clear_has_is_route_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_SignElement::clear_is_route_number() {
  is_route_number_ = false;
  clear_has_is_route_number();
}
inline bool TripLeg_SignElement::is_route_number() const {
  return is_route_number_;
}
inline void TripLeg_SignElement::set_is_route_number(bool value) {
  set_has_is_route_number();
  is_route_number_ = value;
}

// -------------------------------------------------------------------

// TripLeg_Sign

// repeated .valhalla.TripLeg.SignElement exit_numbers = 1;
inline int TripLeg_Sign::exit_numbers_size() const {
  return exit_numbers_.size();
}
inline void TripLeg_Sign::clear_exit_numbers() {
  exit_numbers_.Clear();
}
inline const ::valhalla::TripLeg_SignElement& TripLeg_Sign::exit_numbers(int index) const {
  return exit_numbers_.Get(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::mutable_exit_numbers(int index) {
  return exit_numbers_.Mutable(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::add_exit_numbers() {
  return exit_numbers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
TripLeg_Sign::exit_numbers() const {
  return exit_numbers_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
TripLeg_Sign::mutable_exit_numbers() {
  return &exit_numbers_;
}

// repeated .valhalla.TripLeg.SignElement exit_onto_streets = 2;
inline int TripLeg_Sign::exit_onto_streets_size() const {
  return exit_onto_streets_.size();
}
inline void TripLeg_Sign::clear_exit_onto_streets() {
  exit_onto_streets_.Clear();
}
inline const ::valhalla::TripLeg_SignElement& TripLeg_Sign::exit_onto_streets(int index) const {
  return exit_onto_streets_.Get(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::mutable_exit_onto_streets(int index) {
  return exit_onto_streets_.Mutable(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::add_exit_onto_streets() {
  return exit_onto_streets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
TripLeg_Sign::exit_onto_streets() const {
  return exit_onto_streets_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
TripLeg_Sign::mutable_exit_onto_streets() {
  return &exit_onto_streets_;
}

// repeated .valhalla.TripLeg.SignElement exit_toward_locations = 3;
inline int TripLeg_Sign::exit_toward_locations_size() const {
  return exit_toward_locations_.size();
}
inline void TripLeg_Sign::clear_exit_toward_locations() {
  exit_toward_locations_.Clear();
}
inline const ::valhalla::TripLeg_SignElement& TripLeg_Sign::exit_toward_locations(int index) const {
  return exit_toward_locations_.Get(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::mutable_exit_toward_locations(int index) {
  return exit_toward_locations_.Mutable(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::add_exit_toward_locations() {
  return exit_toward_locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
TripLeg_Sign::exit_toward_locations() const {
  return exit_toward_locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
TripLeg_Sign::mutable_exit_toward_locations() {
  return &exit_toward_locations_;
}

// repeated .valhalla.TripLeg.SignElement exit_names = 4;
inline int TripLeg_Sign::exit_names_size() const {
  return exit_names_.size();
}
inline void TripLeg_Sign::clear_exit_names() {
  exit_names_.Clear();
}
inline const ::valhalla::TripLeg_SignElement& TripLeg_Sign::exit_names(int index) const {
  return exit_names_.Get(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::mutable_exit_names(int index) {
  return exit_names_.Mutable(index);
}
inline ::valhalla::TripLeg_SignElement* TripLeg_Sign::add_exit_names() {
  return exit_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >&
TripLeg_Sign::exit_names() const {
  return exit_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_SignElement >*
TripLeg_Sign::mutable_exit_names() {
  return &exit_names_;
}

// -------------------------------------------------------------------

// TripLeg_TransitRouteInfo

// optional string onestop_id = 1;
inline bool TripLeg_TransitRouteInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_TransitRouteInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_TransitRouteInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TripLeg_TransitRouteInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TripLeg_TransitRouteInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 block_id = 2;
inline bool TripLeg_TransitRouteInfo::has_block_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_block_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_TransitRouteInfo::clear_has_block_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_TransitRouteInfo::clear_block_id() {
  block_id_ = 0u;
  clear_has_block_id();
}
inline ::google::protobuf::uint32 TripLeg_TransitRouteInfo::block_id() const {
  return block_id_;
}
inline void TripLeg_TransitRouteInfo::set_block_id(::google::protobuf::uint32 value) {
  set_has_block_id();
  block_id_ = value;
}

// optional uint32 trip_id = 3;
inline bool TripLeg_TransitRouteInfo::has_trip_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_trip_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_TransitRouteInfo::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_TransitRouteInfo::clear_trip_id() {
  trip_id_ = 0u;
  clear_has_trip_id();
}
inline ::google::protobuf::uint32 TripLeg_TransitRouteInfo::trip_id() const {
  return trip_id_;
}
inline void TripLeg_TransitRouteInfo::set_trip_id(::google::protobuf::uint32 value) {
  set_has_trip_id();
  trip_id_ = value;
}

// optional string short_name = 4;
inline bool TripLeg_TransitRouteInfo::has_short_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_short_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg_TransitRouteInfo::clear_has_short_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg_TransitRouteInfo::clear_short_name() {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    short_name_->clear();
  }
  clear_has_short_name();
}
inline const ::std::string& TripLeg_TransitRouteInfo::short_name() const {
  return *short_name_;
}
inline void TripLeg_TransitRouteInfo::set_short_name(const ::std::string& value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_short_name(const char* value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_short_name(const char* value, size_t size) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_short_name() {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  return short_name_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_short_name() {
  clear_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_name_;
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_short_name(::std::string* short_name) {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    delete short_name_;
  }
  if (short_name) {
    set_has_short_name();
    short_name_ = short_name;
  } else {
    clear_has_short_name();
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string long_name = 5;
inline bool TripLeg_TransitRouteInfo::has_long_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_long_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripLeg_TransitRouteInfo::clear_has_long_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripLeg_TransitRouteInfo::clear_long_name() {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    long_name_->clear();
  }
  clear_has_long_name();
}
inline const ::std::string& TripLeg_TransitRouteInfo::long_name() const {
  return *long_name_;
}
inline void TripLeg_TransitRouteInfo::set_long_name(const ::std::string& value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_long_name(const char* value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_long_name(const char* value, size_t size) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_long_name() {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  return long_name_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_long_name() {
  clear_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = long_name_;
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_long_name(::std::string* long_name) {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    delete long_name_;
  }
  if (long_name) {
    set_has_long_name();
    long_name_ = long_name;
  } else {
    clear_has_long_name();
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string headsign = 6;
inline bool TripLeg_TransitRouteInfo::has_headsign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_headsign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripLeg_TransitRouteInfo::clear_has_headsign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripLeg_TransitRouteInfo::clear_headsign() {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    headsign_->clear();
  }
  clear_has_headsign();
}
inline const ::std::string& TripLeg_TransitRouteInfo::headsign() const {
  return *headsign_;
}
inline void TripLeg_TransitRouteInfo::set_headsign(const ::std::string& value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_headsign(const char* value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_headsign(const char* value, size_t size) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_headsign() {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  return headsign_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_headsign() {
  clear_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headsign_;
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_headsign(::std::string* headsign) {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    delete headsign_;
  }
  if (headsign) {
    set_has_headsign();
    headsign_ = headsign;
  } else {
    clear_has_headsign();
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 color = 7;
inline bool TripLeg_TransitRouteInfo::has_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripLeg_TransitRouteInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripLeg_TransitRouteInfo::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 TripLeg_TransitRouteInfo::color() const {
  return color_;
}
inline void TripLeg_TransitRouteInfo::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// optional uint32 text_color = 8;
inline bool TripLeg_TransitRouteInfo::has_text_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_text_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripLeg_TransitRouteInfo::clear_has_text_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripLeg_TransitRouteInfo::clear_text_color() {
  text_color_ = 0u;
  clear_has_text_color();
}
inline ::google::protobuf::uint32 TripLeg_TransitRouteInfo::text_color() const {
  return text_color_;
}
inline void TripLeg_TransitRouteInfo::set_text_color(::google::protobuf::uint32 value) {
  set_has_text_color();
  text_color_ = value;
}

// optional string description = 9;
inline bool TripLeg_TransitRouteInfo::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripLeg_TransitRouteInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripLeg_TransitRouteInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TripLeg_TransitRouteInfo::description() const {
  return *description_;
}
inline void TripLeg_TransitRouteInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_onestop_id = 10;
inline bool TripLeg_TransitRouteInfo::has_operator_onestop_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_operator_onestop_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripLeg_TransitRouteInfo::clear_has_operator_onestop_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripLeg_TransitRouteInfo::clear_operator_onestop_id() {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_->clear();
  }
  clear_has_operator_onestop_id();
}
inline const ::std::string& TripLeg_TransitRouteInfo::operator_onestop_id() const {
  return *operator_onestop_id_;
}
inline void TripLeg_TransitRouteInfo::set_operator_onestop_id(const ::std::string& value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_operator_onestop_id(const char* value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_operator_onestop_id(const char* value, size_t size) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_operator_onestop_id() {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  return operator_onestop_id_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_operator_onestop_id() {
  clear_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_onestop_id_;
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_operator_onestop_id(::std::string* operator_onestop_id) {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_onestop_id_;
  }
  if (operator_onestop_id) {
    set_has_operator_onestop_id();
    operator_onestop_id_ = operator_onestop_id;
  } else {
    clear_has_operator_onestop_id();
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_name = 11;
inline bool TripLeg_TransitRouteInfo::has_operator_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_operator_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripLeg_TransitRouteInfo::clear_has_operator_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripLeg_TransitRouteInfo::clear_operator_name() {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    operator_name_->clear();
  }
  clear_has_operator_name();
}
inline const ::std::string& TripLeg_TransitRouteInfo::operator_name() const {
  return *operator_name_;
}
inline void TripLeg_TransitRouteInfo::set_operator_name(const ::std::string& value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_operator_name(const char* value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_operator_name(const char* value, size_t size) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_operator_name() {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  return operator_name_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_operator_name() {
  clear_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_name_;
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_operator_name(::std::string* operator_name) {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_name_;
  }
  if (operator_name) {
    set_has_operator_name();
    operator_name_ = operator_name;
  } else {
    clear_has_operator_name();
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_url = 12;
inline bool TripLeg_TransitRouteInfo::has_operator_url() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TripLeg_TransitRouteInfo::set_has_operator_url() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TripLeg_TransitRouteInfo::clear_has_operator_url() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TripLeg_TransitRouteInfo::clear_operator_url() {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    operator_url_->clear();
  }
  clear_has_operator_url();
}
inline const ::std::string& TripLeg_TransitRouteInfo::operator_url() const {
  return *operator_url_;
}
inline void TripLeg_TransitRouteInfo::set_operator_url(const ::std::string& value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_operator_url(const char* value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void TripLeg_TransitRouteInfo::set_operator_url(const char* value, size_t size) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_TransitRouteInfo::mutable_operator_url() {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  return operator_url_;
}
inline ::std::string* TripLeg_TransitRouteInfo::release_operator_url() {
  clear_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_url_;
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_TransitRouteInfo::set_allocated_operator_url(::std::string* operator_url) {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_url_;
  }
  if (operator_url) {
    set_has_operator_url();
    operator_url_ = operator_url;
  } else {
    clear_has_operator_url();
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TripLeg_LaneConnectivity

// optional uint64 from_way_id = 1;
inline bool TripLeg_LaneConnectivity::has_from_way_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_LaneConnectivity::set_has_from_way_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_LaneConnectivity::clear_has_from_way_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_LaneConnectivity::clear_from_way_id() {
  from_way_id_ = GOOGLE_ULONGLONG(0);
  clear_has_from_way_id();
}
inline ::google::protobuf::uint64 TripLeg_LaneConnectivity::from_way_id() const {
  return from_way_id_;
}
inline void TripLeg_LaneConnectivity::set_from_way_id(::google::protobuf::uint64 value) {
  set_has_from_way_id();
  from_way_id_ = value;
}

// optional string from_lanes = 2;
inline bool TripLeg_LaneConnectivity::has_from_lanes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_LaneConnectivity::set_has_from_lanes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_LaneConnectivity::clear_has_from_lanes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_LaneConnectivity::clear_from_lanes() {
  if (from_lanes_ != &::google::protobuf::internal::kEmptyString) {
    from_lanes_->clear();
  }
  clear_has_from_lanes();
}
inline const ::std::string& TripLeg_LaneConnectivity::from_lanes() const {
  return *from_lanes_;
}
inline void TripLeg_LaneConnectivity::set_from_lanes(const ::std::string& value) {
  set_has_from_lanes();
  if (from_lanes_ == &::google::protobuf::internal::kEmptyString) {
    from_lanes_ = new ::std::string;
  }
  from_lanes_->assign(value);
}
inline void TripLeg_LaneConnectivity::set_from_lanes(const char* value) {
  set_has_from_lanes();
  if (from_lanes_ == &::google::protobuf::internal::kEmptyString) {
    from_lanes_ = new ::std::string;
  }
  from_lanes_->assign(value);
}
inline void TripLeg_LaneConnectivity::set_from_lanes(const char* value, size_t size) {
  set_has_from_lanes();
  if (from_lanes_ == &::google::protobuf::internal::kEmptyString) {
    from_lanes_ = new ::std::string;
  }
  from_lanes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_LaneConnectivity::mutable_from_lanes() {
  set_has_from_lanes();
  if (from_lanes_ == &::google::protobuf::internal::kEmptyString) {
    from_lanes_ = new ::std::string;
  }
  return from_lanes_;
}
inline ::std::string* TripLeg_LaneConnectivity::release_from_lanes() {
  clear_has_from_lanes();
  if (from_lanes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_lanes_;
    from_lanes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_LaneConnectivity::set_allocated_from_lanes(::std::string* from_lanes) {
  if (from_lanes_ != &::google::protobuf::internal::kEmptyString) {
    delete from_lanes_;
  }
  if (from_lanes) {
    set_has_from_lanes();
    from_lanes_ = from_lanes;
  } else {
    clear_has_from_lanes();
    from_lanes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to_lanes = 3;
inline bool TripLeg_LaneConnectivity::has_to_lanes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_LaneConnectivity::set_has_to_lanes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_LaneConnectivity::clear_has_to_lanes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_LaneConnectivity::clear_to_lanes() {
  if (to_lanes_ != &::google::protobuf::internal::kEmptyString) {
    to_lanes_->clear();
  }
  clear_has_to_lanes();
}
inline const ::std::string& TripLeg_LaneConnectivity::to_lanes() const {
  return *to_lanes_;
}
inline void TripLeg_LaneConnectivity::set_to_lanes(const ::std::string& value) {
  set_has_to_lanes();
  if (to_lanes_ == &::google::protobuf::internal::kEmptyString) {
    to_lanes_ = new ::std::string;
  }
  to_lanes_->assign(value);
}
inline void TripLeg_LaneConnectivity::set_to_lanes(const char* value) {
  set_has_to_lanes();
  if (to_lanes_ == &::google::protobuf::internal::kEmptyString) {
    to_lanes_ = new ::std::string;
  }
  to_lanes_->assign(value);
}
inline void TripLeg_LaneConnectivity::set_to_lanes(const char* value, size_t size) {
  set_has_to_lanes();
  if (to_lanes_ == &::google::protobuf::internal::kEmptyString) {
    to_lanes_ = new ::std::string;
  }
  to_lanes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_LaneConnectivity::mutable_to_lanes() {
  set_has_to_lanes();
  if (to_lanes_ == &::google::protobuf::internal::kEmptyString) {
    to_lanes_ = new ::std::string;
  }
  return to_lanes_;
}
inline ::std::string* TripLeg_LaneConnectivity::release_to_lanes() {
  clear_has_to_lanes();
  if (to_lanes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_lanes_;
    to_lanes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_LaneConnectivity::set_allocated_to_lanes(::std::string* to_lanes) {
  if (to_lanes_ != &::google::protobuf::internal::kEmptyString) {
    delete to_lanes_;
  }
  if (to_lanes) {
    set_has_to_lanes();
    to_lanes_ = to_lanes;
  } else {
    clear_has_to_lanes();
    to_lanes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TripLeg_TrafficSegment

// optional uint64 segment_id = 1;
inline bool TripLeg_TrafficSegment::has_segment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_TrafficSegment::set_has_segment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_TrafficSegment::clear_has_segment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_TrafficSegment::clear_segment_id() {
  segment_id_ = GOOGLE_ULONGLONG(0);
  clear_has_segment_id();
}
inline ::google::protobuf::uint64 TripLeg_TrafficSegment::segment_id() const {
  return segment_id_;
}
inline void TripLeg_TrafficSegment::set_segment_id(::google::protobuf::uint64 value) {
  set_has_segment_id();
  segment_id_ = value;
}

// optional float begin_percent = 2;
inline bool TripLeg_TrafficSegment::has_begin_percent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_TrafficSegment::set_has_begin_percent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_TrafficSegment::clear_has_begin_percent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_TrafficSegment::clear_begin_percent() {
  begin_percent_ = 0;
  clear_has_begin_percent();
}
inline float TripLeg_TrafficSegment::begin_percent() const {
  return begin_percent_;
}
inline void TripLeg_TrafficSegment::set_begin_percent(float value) {
  set_has_begin_percent();
  begin_percent_ = value;
}

// optional float end_percent = 3;
inline bool TripLeg_TrafficSegment::has_end_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_TrafficSegment::set_has_end_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_TrafficSegment::clear_has_end_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_TrafficSegment::clear_end_percent() {
  end_percent_ = 0;
  clear_has_end_percent();
}
inline float TripLeg_TrafficSegment::end_percent() const {
  return end_percent_;
}
inline void TripLeg_TrafficSegment::set_end_percent(float value) {
  set_has_end_percent();
  end_percent_ = value;
}

// optional bool starts_segment = 4;
inline bool TripLeg_TrafficSegment::has_starts_segment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg_TrafficSegment::set_has_starts_segment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg_TrafficSegment::clear_has_starts_segment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg_TrafficSegment::clear_starts_segment() {
  starts_segment_ = false;
  clear_has_starts_segment();
}
inline bool TripLeg_TrafficSegment::starts_segment() const {
  return starts_segment_;
}
inline void TripLeg_TrafficSegment::set_starts_segment(bool value) {
  set_has_starts_segment();
  starts_segment_ = value;
}

// optional bool ends_segment = 5;
inline bool TripLeg_TrafficSegment::has_ends_segment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripLeg_TrafficSegment::set_has_ends_segment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripLeg_TrafficSegment::clear_has_ends_segment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripLeg_TrafficSegment::clear_ends_segment() {
  ends_segment_ = false;
  clear_has_ends_segment();
}
inline bool TripLeg_TrafficSegment::ends_segment() const {
  return ends_segment_;
}
inline void TripLeg_TrafficSegment::set_ends_segment(bool value) {
  set_has_ends_segment();
  ends_segment_ = value;
}

// -------------------------------------------------------------------

// TripLeg_Edge

// repeated .valhalla.StreetName name = 1;
inline int TripLeg_Edge::name_size() const {
  return name_.size();
}
inline void TripLeg_Edge::clear_name() {
  name_.Clear();
}
inline const ::valhalla::StreetName& TripLeg_Edge::name(int index) const {
  return name_.Get(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::mutable_name(int index) {
  return name_.Mutable(index);
}
inline ::valhalla::StreetName* TripLeg_Edge::add_name() {
  return name_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >&
TripLeg_Edge::name() const {
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::StreetName >*
TripLeg_Edge::mutable_name() {
  return &name_;
}

// optional float length = 2;
inline bool TripLeg_Edge::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_Edge::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_Edge::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_Edge::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float TripLeg_Edge::length() const {
  return length_;
}
inline void TripLeg_Edge::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional float speed = 3;
inline bool TripLeg_Edge::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_Edge::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_Edge::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_Edge::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float TripLeg_Edge::speed() const {
  return speed_;
}
inline void TripLeg_Edge::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional .valhalla.TripLeg.RoadClass road_class = 4;
inline bool TripLeg_Edge::has_road_class() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg_Edge::set_has_road_class() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg_Edge::clear_has_road_class() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg_Edge::clear_road_class() {
  road_class_ = 0;
  clear_has_road_class();
}
inline ::valhalla::TripLeg_RoadClass TripLeg_Edge::road_class() const {
  return static_cast< ::valhalla::TripLeg_RoadClass >(road_class_);
}
inline void TripLeg_Edge::set_road_class(::valhalla::TripLeg_RoadClass value) {
  assert(::valhalla::TripLeg_RoadClass_IsValid(value));
  set_has_road_class();
  road_class_ = value;
}

// optional uint32 begin_heading = 5;
inline bool TripLeg_Edge::has_begin_heading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripLeg_Edge::set_has_begin_heading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripLeg_Edge::clear_has_begin_heading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripLeg_Edge::clear_begin_heading() {
  begin_heading_ = 0u;
  clear_has_begin_heading();
}
inline ::google::protobuf::uint32 TripLeg_Edge::begin_heading() const {
  return begin_heading_;
}
inline void TripLeg_Edge::set_begin_heading(::google::protobuf::uint32 value) {
  set_has_begin_heading();
  begin_heading_ = value;
}

// optional uint32 end_heading = 6;
inline bool TripLeg_Edge::has_end_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripLeg_Edge::set_has_end_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripLeg_Edge::clear_has_end_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripLeg_Edge::clear_end_heading() {
  end_heading_ = 0u;
  clear_has_end_heading();
}
inline ::google::protobuf::uint32 TripLeg_Edge::end_heading() const {
  return end_heading_;
}
inline void TripLeg_Edge::set_end_heading(::google::protobuf::uint32 value) {
  set_has_end_heading();
  end_heading_ = value;
}

// optional uint32 begin_shape_index = 7;
inline bool TripLeg_Edge::has_begin_shape_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripLeg_Edge::set_has_begin_shape_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripLeg_Edge::clear_has_begin_shape_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripLeg_Edge::clear_begin_shape_index() {
  begin_shape_index_ = 0u;
  clear_has_begin_shape_index();
}
inline ::google::protobuf::uint32 TripLeg_Edge::begin_shape_index() const {
  return begin_shape_index_;
}
inline void TripLeg_Edge::set_begin_shape_index(::google::protobuf::uint32 value) {
  set_has_begin_shape_index();
  begin_shape_index_ = value;
}

// optional uint32 end_shape_index = 8;
inline bool TripLeg_Edge::has_end_shape_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripLeg_Edge::set_has_end_shape_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripLeg_Edge::clear_has_end_shape_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripLeg_Edge::clear_end_shape_index() {
  end_shape_index_ = 0u;
  clear_has_end_shape_index();
}
inline ::google::protobuf::uint32 TripLeg_Edge::end_shape_index() const {
  return end_shape_index_;
}
inline void TripLeg_Edge::set_end_shape_index(::google::protobuf::uint32 value) {
  set_has_end_shape_index();
  end_shape_index_ = value;
}

// optional .valhalla.TripLeg.Traversability traversability = 9;
inline bool TripLeg_Edge::has_traversability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripLeg_Edge::set_has_traversability() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripLeg_Edge::clear_has_traversability() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripLeg_Edge::clear_traversability() {
  traversability_ = 0;
  clear_has_traversability();
}
inline ::valhalla::TripLeg_Traversability TripLeg_Edge::traversability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(traversability_);
}
inline void TripLeg_Edge::set_traversability(::valhalla::TripLeg_Traversability value) {
  assert(::valhalla::TripLeg_Traversability_IsValid(value));
  set_has_traversability();
  traversability_ = value;
}

// optional .valhalla.TripLeg.Use use = 10;
inline bool TripLeg_Edge::has_use() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripLeg_Edge::set_has_use() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripLeg_Edge::clear_has_use() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripLeg_Edge::clear_use() {
  use_ = 0;
  clear_has_use();
}
inline ::valhalla::TripLeg_Use TripLeg_Edge::use() const {
  return static_cast< ::valhalla::TripLeg_Use >(use_);
}
inline void TripLeg_Edge::set_use(::valhalla::TripLeg_Use value) {
  assert(::valhalla::TripLeg_Use_IsValid(value));
  set_has_use();
  use_ = value;
}

// optional bool toll = 11;
inline bool TripLeg_Edge::has_toll() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripLeg_Edge::set_has_toll() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripLeg_Edge::clear_has_toll() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripLeg_Edge::clear_toll() {
  toll_ = false;
  clear_has_toll();
}
inline bool TripLeg_Edge::toll() const {
  return toll_;
}
inline void TripLeg_Edge::set_toll(bool value) {
  set_has_toll();
  toll_ = value;
}

// optional bool unpaved = 12;
inline bool TripLeg_Edge::has_unpaved() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TripLeg_Edge::set_has_unpaved() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TripLeg_Edge::clear_has_unpaved() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TripLeg_Edge::clear_unpaved() {
  unpaved_ = false;
  clear_has_unpaved();
}
inline bool TripLeg_Edge::unpaved() const {
  return unpaved_;
}
inline void TripLeg_Edge::set_unpaved(bool value) {
  set_has_unpaved();
  unpaved_ = value;
}

// optional bool tunnel = 13;
inline bool TripLeg_Edge::has_tunnel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TripLeg_Edge::set_has_tunnel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TripLeg_Edge::clear_has_tunnel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TripLeg_Edge::clear_tunnel() {
  tunnel_ = false;
  clear_has_tunnel();
}
inline bool TripLeg_Edge::tunnel() const {
  return tunnel_;
}
inline void TripLeg_Edge::set_tunnel(bool value) {
  set_has_tunnel();
  tunnel_ = value;
}

// optional bool bridge = 14;
inline bool TripLeg_Edge::has_bridge() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TripLeg_Edge::set_has_bridge() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TripLeg_Edge::clear_has_bridge() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TripLeg_Edge::clear_bridge() {
  bridge_ = false;
  clear_has_bridge();
}
inline bool TripLeg_Edge::bridge() const {
  return bridge_;
}
inline void TripLeg_Edge::set_bridge(bool value) {
  set_has_bridge();
  bridge_ = value;
}

// optional bool roundabout = 15;
inline bool TripLeg_Edge::has_roundabout() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TripLeg_Edge::set_has_roundabout() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TripLeg_Edge::clear_has_roundabout() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TripLeg_Edge::clear_roundabout() {
  roundabout_ = false;
  clear_has_roundabout();
}
inline bool TripLeg_Edge::roundabout() const {
  return roundabout_;
}
inline void TripLeg_Edge::set_roundabout(bool value) {
  set_has_roundabout();
  roundabout_ = value;
}

// optional bool internal_intersection = 16;
inline bool TripLeg_Edge::has_internal_intersection() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TripLeg_Edge::set_has_internal_intersection() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TripLeg_Edge::clear_has_internal_intersection() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TripLeg_Edge::clear_internal_intersection() {
  internal_intersection_ = false;
  clear_has_internal_intersection();
}
inline bool TripLeg_Edge::internal_intersection() const {
  return internal_intersection_;
}
inline void TripLeg_Edge::set_internal_intersection(bool value) {
  set_has_internal_intersection();
  internal_intersection_ = value;
}

// optional bool drive_on_right = 17 [default = true];
inline bool TripLeg_Edge::has_drive_on_right() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TripLeg_Edge::set_has_drive_on_right() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TripLeg_Edge::clear_has_drive_on_right() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TripLeg_Edge::clear_drive_on_right() {
  drive_on_right_ = true;
  clear_has_drive_on_right();
}
inline bool TripLeg_Edge::drive_on_right() const {
  return drive_on_right_;
}
inline void TripLeg_Edge::set_drive_on_right(bool value) {
  set_has_drive_on_right();
  drive_on_right_ = value;
}

// optional .valhalla.TripLeg.Surface surface = 18;
inline bool TripLeg_Edge::has_surface() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TripLeg_Edge::set_has_surface() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TripLeg_Edge::clear_has_surface() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TripLeg_Edge::clear_surface() {
  surface_ = 0;
  clear_has_surface();
}
inline ::valhalla::TripLeg_Surface TripLeg_Edge::surface() const {
  return static_cast< ::valhalla::TripLeg_Surface >(surface_);
}
inline void TripLeg_Edge::set_surface(::valhalla::TripLeg_Surface value) {
  assert(::valhalla::TripLeg_Surface_IsValid(value));
  set_has_surface();
  surface_ = value;
}

// optional .valhalla.TripLeg.Sign sign = 19;
inline bool TripLeg_Edge::has_sign() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TripLeg_Edge::set_has_sign() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TripLeg_Edge::clear_has_sign() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TripLeg_Edge::clear_sign() {
  if (sign_ != NULL) sign_->::valhalla::TripLeg_Sign::Clear();
  clear_has_sign();
}
inline const ::valhalla::TripLeg_Sign& TripLeg_Edge::sign() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sign_ != NULL ? *sign_ : *default_instance().sign_;
#else
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
#endif
}
inline ::valhalla::TripLeg_Sign* TripLeg_Edge::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::valhalla::TripLeg_Sign;
  return sign_;
}
inline ::valhalla::TripLeg_Sign* TripLeg_Edge::release_sign() {
  clear_has_sign();
  ::valhalla::TripLeg_Sign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void TripLeg_Edge::set_allocated_sign(::valhalla::TripLeg_Sign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
}

// optional .valhalla.TripLeg.TravelMode travel_mode = 20;
inline bool TripLeg_Edge::has_travel_mode() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TripLeg_Edge::set_has_travel_mode() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TripLeg_Edge::clear_has_travel_mode() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TripLeg_Edge::clear_travel_mode() {
  travel_mode_ = 0;
  clear_has_travel_mode();
}
inline ::valhalla::TripLeg_TravelMode TripLeg_Edge::travel_mode() const {
  return static_cast< ::valhalla::TripLeg_TravelMode >(travel_mode_);
}
inline void TripLeg_Edge::set_travel_mode(::valhalla::TripLeg_TravelMode value) {
  assert(::valhalla::TripLeg_TravelMode_IsValid(value));
  set_has_travel_mode();
  travel_mode_ = value;
}

// optional .valhalla.TripLeg.VehicleType vehicle_type = 21;
inline bool TripLeg_Edge::has_vehicle_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TripLeg_Edge::set_has_vehicle_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TripLeg_Edge::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TripLeg_Edge::clear_vehicle_type() {
  vehicle_type_ = 0;
  clear_has_vehicle_type();
}
inline ::valhalla::TripLeg_VehicleType TripLeg_Edge::vehicle_type() const {
  return static_cast< ::valhalla::TripLeg_VehicleType >(vehicle_type_);
}
inline void TripLeg_Edge::set_vehicle_type(::valhalla::TripLeg_VehicleType value) {
  assert(::valhalla::TripLeg_VehicleType_IsValid(value));
  set_has_vehicle_type();
  vehicle_type_ = value;
}

// optional .valhalla.TripLeg.PedestrianType pedestrian_type = 22;
inline bool TripLeg_Edge::has_pedestrian_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TripLeg_Edge::set_has_pedestrian_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TripLeg_Edge::clear_has_pedestrian_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TripLeg_Edge::clear_pedestrian_type() {
  pedestrian_type_ = 0;
  clear_has_pedestrian_type();
}
inline ::valhalla::TripLeg_PedestrianType TripLeg_Edge::pedestrian_type() const {
  return static_cast< ::valhalla::TripLeg_PedestrianType >(pedestrian_type_);
}
inline void TripLeg_Edge::set_pedestrian_type(::valhalla::TripLeg_PedestrianType value) {
  assert(::valhalla::TripLeg_PedestrianType_IsValid(value));
  set_has_pedestrian_type();
  pedestrian_type_ = value;
}

// optional .valhalla.TripLeg.BicycleType bicycle_type = 23;
inline bool TripLeg_Edge::has_bicycle_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TripLeg_Edge::set_has_bicycle_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TripLeg_Edge::clear_has_bicycle_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TripLeg_Edge::clear_bicycle_type() {
  bicycle_type_ = 0;
  clear_has_bicycle_type();
}
inline ::valhalla::TripLeg_BicycleType TripLeg_Edge::bicycle_type() const {
  return static_cast< ::valhalla::TripLeg_BicycleType >(bicycle_type_);
}
inline void TripLeg_Edge::set_bicycle_type(::valhalla::TripLeg_BicycleType value) {
  assert(::valhalla::TripLeg_BicycleType_IsValid(value));
  set_has_bicycle_type();
  bicycle_type_ = value;
}

// optional .valhalla.TripLeg.TransitType transit_type = 24;
inline bool TripLeg_Edge::has_transit_type() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TripLeg_Edge::set_has_transit_type() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TripLeg_Edge::clear_has_transit_type() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TripLeg_Edge::clear_transit_type() {
  transit_type_ = 0;
  clear_has_transit_type();
}
inline ::valhalla::TripLeg_TransitType TripLeg_Edge::transit_type() const {
  return static_cast< ::valhalla::TripLeg_TransitType >(transit_type_);
}
inline void TripLeg_Edge::set_transit_type(::valhalla::TripLeg_TransitType value) {
  assert(::valhalla::TripLeg_TransitType_IsValid(value));
  set_has_transit_type();
  transit_type_ = value;
}

// optional .valhalla.TripLeg.TransitRouteInfo transit_route_info = 25;
inline bool TripLeg_Edge::has_transit_route_info() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TripLeg_Edge::set_has_transit_route_info() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TripLeg_Edge::clear_has_transit_route_info() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TripLeg_Edge::clear_transit_route_info() {
  if (transit_route_info_ != NULL) transit_route_info_->::valhalla::TripLeg_TransitRouteInfo::Clear();
  clear_has_transit_route_info();
}
inline const ::valhalla::TripLeg_TransitRouteInfo& TripLeg_Edge::transit_route_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance().transit_route_info_;
#else
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance_->transit_route_info_;
#endif
}
inline ::valhalla::TripLeg_TransitRouteInfo* TripLeg_Edge::mutable_transit_route_info() {
  set_has_transit_route_info();
  if (transit_route_info_ == NULL) transit_route_info_ = new ::valhalla::TripLeg_TransitRouteInfo;
  return transit_route_info_;
}
inline ::valhalla::TripLeg_TransitRouteInfo* TripLeg_Edge::release_transit_route_info() {
  clear_has_transit_route_info();
  ::valhalla::TripLeg_TransitRouteInfo* temp = transit_route_info_;
  transit_route_info_ = NULL;
  return temp;
}
inline void TripLeg_Edge::set_allocated_transit_route_info(::valhalla::TripLeg_TransitRouteInfo* transit_route_info) {
  delete transit_route_info_;
  transit_route_info_ = transit_route_info;
  if (transit_route_info) {
    set_has_transit_route_info();
  } else {
    clear_has_transit_route_info();
  }
}

// optional uint64 id = 26;
inline bool TripLeg_Edge::has_id() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TripLeg_Edge::set_has_id() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TripLeg_Edge::clear_has_id() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TripLeg_Edge::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TripLeg_Edge::id() const {
  return id_;
}
inline void TripLeg_Edge::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 way_id = 27;
inline bool TripLeg_Edge::has_way_id() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TripLeg_Edge::set_has_way_id() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TripLeg_Edge::clear_has_way_id() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TripLeg_Edge::clear_way_id() {
  way_id_ = GOOGLE_ULONGLONG(0);
  clear_has_way_id();
}
inline ::google::protobuf::uint64 TripLeg_Edge::way_id() const {
  return way_id_;
}
inline void TripLeg_Edge::set_way_id(::google::protobuf::uint64 value) {
  set_has_way_id();
  way_id_ = value;
}

// optional float weighted_grade = 28;
inline bool TripLeg_Edge::has_weighted_grade() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TripLeg_Edge::set_has_weighted_grade() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TripLeg_Edge::clear_has_weighted_grade() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TripLeg_Edge::clear_weighted_grade() {
  weighted_grade_ = 0;
  clear_has_weighted_grade();
}
inline float TripLeg_Edge::weighted_grade() const {
  return weighted_grade_;
}
inline void TripLeg_Edge::set_weighted_grade(float value) {
  set_has_weighted_grade();
  weighted_grade_ = value;
}

// optional int32 max_upward_grade = 29;
inline bool TripLeg_Edge::has_max_upward_grade() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TripLeg_Edge::set_has_max_upward_grade() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TripLeg_Edge::clear_has_max_upward_grade() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TripLeg_Edge::clear_max_upward_grade() {
  max_upward_grade_ = 0;
  clear_has_max_upward_grade();
}
inline ::google::protobuf::int32 TripLeg_Edge::max_upward_grade() const {
  return max_upward_grade_;
}
inline void TripLeg_Edge::set_max_upward_grade(::google::protobuf::int32 value) {
  set_has_max_upward_grade();
  max_upward_grade_ = value;
}

// optional int32 max_downward_grade = 30;
inline bool TripLeg_Edge::has_max_downward_grade() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TripLeg_Edge::set_has_max_downward_grade() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TripLeg_Edge::clear_has_max_downward_grade() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TripLeg_Edge::clear_max_downward_grade() {
  max_downward_grade_ = 0;
  clear_has_max_downward_grade();
}
inline ::google::protobuf::int32 TripLeg_Edge::max_downward_grade() const {
  return max_downward_grade_;
}
inline void TripLeg_Edge::set_max_downward_grade(::google::protobuf::int32 value) {
  set_has_max_downward_grade();
  max_downward_grade_ = value;
}

// optional uint32 lane_count = 31;
inline bool TripLeg_Edge::has_lane_count() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TripLeg_Edge::set_has_lane_count() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TripLeg_Edge::clear_has_lane_count() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TripLeg_Edge::clear_lane_count() {
  lane_count_ = 0u;
  clear_has_lane_count();
}
inline ::google::protobuf::uint32 TripLeg_Edge::lane_count() const {
  return lane_count_;
}
inline void TripLeg_Edge::set_lane_count(::google::protobuf::uint32 value) {
  set_has_lane_count();
  lane_count_ = value;
}

// optional .valhalla.TripLeg.CycleLane cycle_lane = 32;
inline bool TripLeg_Edge::has_cycle_lane() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TripLeg_Edge::set_has_cycle_lane() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TripLeg_Edge::clear_has_cycle_lane() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TripLeg_Edge::clear_cycle_lane() {
  cycle_lane_ = 0;
  clear_has_cycle_lane();
}
inline ::valhalla::TripLeg_CycleLane TripLeg_Edge::cycle_lane() const {
  return static_cast< ::valhalla::TripLeg_CycleLane >(cycle_lane_);
}
inline void TripLeg_Edge::set_cycle_lane(::valhalla::TripLeg_CycleLane value) {
  assert(::valhalla::TripLeg_CycleLane_IsValid(value));
  set_has_cycle_lane();
  cycle_lane_ = value;
}

// optional uint32 bicycle_network = 33;
inline bool TripLeg_Edge::has_bicycle_network() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TripLeg_Edge::set_has_bicycle_network() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TripLeg_Edge::clear_has_bicycle_network() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TripLeg_Edge::clear_bicycle_network() {
  bicycle_network_ = 0u;
  clear_has_bicycle_network();
}
inline ::google::protobuf::uint32 TripLeg_Edge::bicycle_network() const {
  return bicycle_network_;
}
inline void TripLeg_Edge::set_bicycle_network(::google::protobuf::uint32 value) {
  set_has_bicycle_network();
  bicycle_network_ = value;
}

// optional .valhalla.TripLeg.Sidewalk sidewalk = 34;
inline bool TripLeg_Edge::has_sidewalk() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TripLeg_Edge::set_has_sidewalk() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TripLeg_Edge::clear_has_sidewalk() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TripLeg_Edge::clear_sidewalk() {
  sidewalk_ = 0;
  clear_has_sidewalk();
}
inline ::valhalla::TripLeg_Sidewalk TripLeg_Edge::sidewalk() const {
  return static_cast< ::valhalla::TripLeg_Sidewalk >(sidewalk_);
}
inline void TripLeg_Edge::set_sidewalk(::valhalla::TripLeg_Sidewalk value) {
  assert(::valhalla::TripLeg_Sidewalk_IsValid(value));
  set_has_sidewalk();
  sidewalk_ = value;
}

// optional uint32 density = 35;
inline bool TripLeg_Edge::has_density() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TripLeg_Edge::set_has_density() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TripLeg_Edge::clear_has_density() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TripLeg_Edge::clear_density() {
  density_ = 0u;
  clear_has_density();
}
inline ::google::protobuf::uint32 TripLeg_Edge::density() const {
  return density_;
}
inline void TripLeg_Edge::set_density(::google::protobuf::uint32 value) {
  set_has_density();
  density_ = value;
}

// optional uint32 speed_limit = 36;
inline bool TripLeg_Edge::has_speed_limit() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TripLeg_Edge::set_has_speed_limit() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TripLeg_Edge::clear_has_speed_limit() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TripLeg_Edge::clear_speed_limit() {
  speed_limit_ = 0u;
  clear_has_speed_limit();
}
inline ::google::protobuf::uint32 TripLeg_Edge::speed_limit() const {
  return speed_limit_;
}
inline void TripLeg_Edge::set_speed_limit(::google::protobuf::uint32 value) {
  set_has_speed_limit();
  speed_limit_ = value;
}

// optional float truck_speed = 37;
inline bool TripLeg_Edge::has_truck_speed() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TripLeg_Edge::set_has_truck_speed() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TripLeg_Edge::clear_has_truck_speed() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TripLeg_Edge::clear_truck_speed() {
  truck_speed_ = 0;
  clear_has_truck_speed();
}
inline float TripLeg_Edge::truck_speed() const {
  return truck_speed_;
}
inline void TripLeg_Edge::set_truck_speed(float value) {
  set_has_truck_speed();
  truck_speed_ = value;
}

// optional bool truck_route = 38;
inline bool TripLeg_Edge::has_truck_route() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TripLeg_Edge::set_has_truck_route() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TripLeg_Edge::clear_has_truck_route() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TripLeg_Edge::clear_truck_route() {
  truck_route_ = false;
  clear_has_truck_route();
}
inline bool TripLeg_Edge::truck_route() const {
  return truck_route_;
}
inline void TripLeg_Edge::set_truck_route(bool value) {
  set_has_truck_route();
  truck_route_ = value;
}

// repeated .valhalla.TripLeg.LaneConnectivity lane_connectivity = 39;
inline int TripLeg_Edge::lane_connectivity_size() const {
  return lane_connectivity_.size();
}
inline void TripLeg_Edge::clear_lane_connectivity() {
  lane_connectivity_.Clear();
}
inline const ::valhalla::TripLeg_LaneConnectivity& TripLeg_Edge::lane_connectivity(int index) const {
  return lane_connectivity_.Get(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::mutable_lane_connectivity(int index) {
  return lane_connectivity_.Mutable(index);
}
inline ::valhalla::TripLeg_LaneConnectivity* TripLeg_Edge::add_lane_connectivity() {
  return lane_connectivity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >&
TripLeg_Edge::lane_connectivity() const {
  return lane_connectivity_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_LaneConnectivity >*
TripLeg_Edge::mutable_lane_connectivity() {
  return &lane_connectivity_;
}

// optional int32 mean_elevation = 40;
inline bool TripLeg_Edge::has_mean_elevation() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TripLeg_Edge::set_has_mean_elevation() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TripLeg_Edge::clear_has_mean_elevation() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TripLeg_Edge::clear_mean_elevation() {
  mean_elevation_ = 0;
  clear_has_mean_elevation();
}
inline ::google::protobuf::int32 TripLeg_Edge::mean_elevation() const {
  return mean_elevation_;
}
inline void TripLeg_Edge::set_mean_elevation(::google::protobuf::int32 value) {
  set_has_mean_elevation();
  mean_elevation_ = value;
}

// repeated .valhalla.TripLeg.TrafficSegment traffic_segment = 41;
inline int TripLeg_Edge::traffic_segment_size() const {
  return traffic_segment_.size();
}
inline void TripLeg_Edge::clear_traffic_segment() {
  traffic_segment_.Clear();
}
inline const ::valhalla::TripLeg_TrafficSegment& TripLeg_Edge::traffic_segment(int index) const {
  return traffic_segment_.Get(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::mutable_traffic_segment(int index) {
  return traffic_segment_.Mutable(index);
}
inline ::valhalla::TripLeg_TrafficSegment* TripLeg_Edge::add_traffic_segment() {
  return traffic_segment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >&
TripLeg_Edge::traffic_segment() const {
  return traffic_segment_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_TrafficSegment >*
TripLeg_Edge::mutable_traffic_segment() {
  return &traffic_segment_;
}

// repeated .valhalla.TurnLane turn_lanes = 42;
inline int TripLeg_Edge::turn_lanes_size() const {
  return turn_lanes_.size();
}
inline void TripLeg_Edge::clear_turn_lanes() {
  turn_lanes_.Clear();
}
inline const ::valhalla::TurnLane& TripLeg_Edge::turn_lanes(int index) const {
  return turn_lanes_.Get(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::mutable_turn_lanes(int index) {
  return turn_lanes_.Mutable(index);
}
inline ::valhalla::TurnLane* TripLeg_Edge::add_turn_lanes() {
  return turn_lanes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >&
TripLeg_Edge::turn_lanes() const {
  return turn_lanes_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TurnLane >*
TripLeg_Edge::mutable_turn_lanes() {
  return &turn_lanes_;
}

// optional bool has_time_restrictions = 43;
inline bool TripLeg_Edge::has_has_time_restrictions() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void TripLeg_Edge::set_has_has_time_restrictions() {
  _has_bits_[1] |= 0x00000400u;
}
inline void TripLeg_Edge::clear_has_has_time_restrictions() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void TripLeg_Edge::clear_has_time_restrictions() {
  has_time_restrictions_ = false;
  clear_has_has_time_restrictions();
}
inline bool TripLeg_Edge::has_time_restrictions() const {
  return has_time_restrictions_;
}
inline void TripLeg_Edge::set_has_time_restrictions(bool value) {
  set_has_has_time_restrictions();
  has_time_restrictions_ = value;
}

// -------------------------------------------------------------------

// TripLeg_IntersectingEdge

// optional uint32 begin_heading = 1;
inline bool TripLeg_IntersectingEdge::has_begin_heading() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_begin_heading() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_IntersectingEdge::clear_has_begin_heading() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_IntersectingEdge::clear_begin_heading() {
  begin_heading_ = 0u;
  clear_has_begin_heading();
}
inline ::google::protobuf::uint32 TripLeg_IntersectingEdge::begin_heading() const {
  return begin_heading_;
}
inline void TripLeg_IntersectingEdge::set_begin_heading(::google::protobuf::uint32 value) {
  set_has_begin_heading();
  begin_heading_ = value;
}

// optional bool prev_name_consistency = 2;
inline bool TripLeg_IntersectingEdge::has_prev_name_consistency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_prev_name_consistency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_IntersectingEdge::clear_has_prev_name_consistency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_IntersectingEdge::clear_prev_name_consistency() {
  prev_name_consistency_ = false;
  clear_has_prev_name_consistency();
}
inline bool TripLeg_IntersectingEdge::prev_name_consistency() const {
  return prev_name_consistency_;
}
inline void TripLeg_IntersectingEdge::set_prev_name_consistency(bool value) {
  set_has_prev_name_consistency();
  prev_name_consistency_ = value;
}

// optional bool curr_name_consistency = 3;
inline bool TripLeg_IntersectingEdge::has_curr_name_consistency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_curr_name_consistency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_IntersectingEdge::clear_has_curr_name_consistency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_IntersectingEdge::clear_curr_name_consistency() {
  curr_name_consistency_ = false;
  clear_has_curr_name_consistency();
}
inline bool TripLeg_IntersectingEdge::curr_name_consistency() const {
  return curr_name_consistency_;
}
inline void TripLeg_IntersectingEdge::set_curr_name_consistency(bool value) {
  set_has_curr_name_consistency();
  curr_name_consistency_ = value;
}

// optional .valhalla.TripLeg.Traversability driveability = 4;
inline bool TripLeg_IntersectingEdge::has_driveability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_driveability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg_IntersectingEdge::clear_has_driveability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg_IntersectingEdge::clear_driveability() {
  driveability_ = 0;
  clear_has_driveability();
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::driveability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(driveability_);
}
inline void TripLeg_IntersectingEdge::set_driveability(::valhalla::TripLeg_Traversability value) {
  assert(::valhalla::TripLeg_Traversability_IsValid(value));
  set_has_driveability();
  driveability_ = value;
}

// optional .valhalla.TripLeg.Traversability cyclability = 5;
inline bool TripLeg_IntersectingEdge::has_cyclability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_cyclability() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripLeg_IntersectingEdge::clear_has_cyclability() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripLeg_IntersectingEdge::clear_cyclability() {
  cyclability_ = 0;
  clear_has_cyclability();
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::cyclability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(cyclability_);
}
inline void TripLeg_IntersectingEdge::set_cyclability(::valhalla::TripLeg_Traversability value) {
  assert(::valhalla::TripLeg_Traversability_IsValid(value));
  set_has_cyclability();
  cyclability_ = value;
}

// optional .valhalla.TripLeg.Traversability walkability = 6;
inline bool TripLeg_IntersectingEdge::has_walkability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_walkability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripLeg_IntersectingEdge::clear_has_walkability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripLeg_IntersectingEdge::clear_walkability() {
  walkability_ = 0;
  clear_has_walkability();
}
inline ::valhalla::TripLeg_Traversability TripLeg_IntersectingEdge::walkability() const {
  return static_cast< ::valhalla::TripLeg_Traversability >(walkability_);
}
inline void TripLeg_IntersectingEdge::set_walkability(::valhalla::TripLeg_Traversability value) {
  assert(::valhalla::TripLeg_Traversability_IsValid(value));
  set_has_walkability();
  walkability_ = value;
}

// optional .valhalla.TripLeg.Use use = 7;
inline bool TripLeg_IntersectingEdge::has_use() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_use() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripLeg_IntersectingEdge::clear_has_use() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripLeg_IntersectingEdge::clear_use() {
  use_ = 0;
  clear_has_use();
}
inline ::valhalla::TripLeg_Use TripLeg_IntersectingEdge::use() const {
  return static_cast< ::valhalla::TripLeg_Use >(use_);
}
inline void TripLeg_IntersectingEdge::set_use(::valhalla::TripLeg_Use value) {
  assert(::valhalla::TripLeg_Use_IsValid(value));
  set_has_use();
  use_ = value;
}

// optional .valhalla.TripLeg.RoadClass road_class = 8;
inline bool TripLeg_IntersectingEdge::has_road_class() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripLeg_IntersectingEdge::set_has_road_class() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripLeg_IntersectingEdge::clear_has_road_class() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripLeg_IntersectingEdge::clear_road_class() {
  road_class_ = 0;
  clear_has_road_class();
}
inline ::valhalla::TripLeg_RoadClass TripLeg_IntersectingEdge::road_class() const {
  return static_cast< ::valhalla::TripLeg_RoadClass >(road_class_);
}
inline void TripLeg_IntersectingEdge::set_road_class(::valhalla::TripLeg_RoadClass value) {
  assert(::valhalla::TripLeg_RoadClass_IsValid(value));
  set_has_road_class();
  road_class_ = value;
}

// -------------------------------------------------------------------

// TripLeg_Node

// optional .valhalla.TripLeg.Edge edge = 1;
inline bool TripLeg_Node::has_edge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_Node::set_has_edge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_Node::clear_has_edge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_Node::clear_edge() {
  if (edge_ != NULL) edge_->::valhalla::TripLeg_Edge::Clear();
  clear_has_edge();
}
inline const ::valhalla::TripLeg_Edge& TripLeg_Node::edge() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return edge_ != NULL ? *edge_ : *default_instance().edge_;
#else
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
#endif
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::mutable_edge() {
  set_has_edge();
  if (edge_ == NULL) edge_ = new ::valhalla::TripLeg_Edge;
  return edge_;
}
inline ::valhalla::TripLeg_Edge* TripLeg_Node::release_edge() {
  clear_has_edge();
  ::valhalla::TripLeg_Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_edge(::valhalla::TripLeg_Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    set_has_edge();
  } else {
    clear_has_edge();
  }
}

// repeated .valhalla.TripLeg.IntersectingEdge intersecting_edge = 2;
inline int TripLeg_Node::intersecting_edge_size() const {
  return intersecting_edge_.size();
}
inline void TripLeg_Node::clear_intersecting_edge() {
  intersecting_edge_.Clear();
}
inline const ::valhalla::TripLeg_IntersectingEdge& TripLeg_Node::intersecting_edge(int index) const {
  return intersecting_edge_.Get(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::mutable_intersecting_edge(int index) {
  return intersecting_edge_.Mutable(index);
}
inline ::valhalla::TripLeg_IntersectingEdge* TripLeg_Node::add_intersecting_edge() {
  return intersecting_edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >&
TripLeg_Node::intersecting_edge() const {
  return intersecting_edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_IntersectingEdge >*
TripLeg_Node::mutable_intersecting_edge() {
  return &intersecting_edge_;
}

// optional double elapsed_time = 3;
inline bool TripLeg_Node::has_elapsed_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_Node::set_has_elapsed_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_Node::clear_has_elapsed_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_Node::clear_elapsed_time() {
  elapsed_time_ = 0;
  clear_has_elapsed_time();
}
inline double TripLeg_Node::elapsed_time() const {
  return elapsed_time_;
}
inline void TripLeg_Node::set_elapsed_time(double value) {
  set_has_elapsed_time();
  elapsed_time_ = value;
}

// optional uint32 admin_index = 4;
inline bool TripLeg_Node::has_admin_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg_Node::set_has_admin_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg_Node::clear_has_admin_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg_Node::clear_admin_index() {
  admin_index_ = 0u;
  clear_has_admin_index();
}
inline ::google::protobuf::uint32 TripLeg_Node::admin_index() const {
  return admin_index_;
}
inline void TripLeg_Node::set_admin_index(::google::protobuf::uint32 value) {
  set_has_admin_index();
  admin_index_ = value;
}

// optional .valhalla.TripLeg.Node.Type type = 5;
inline bool TripLeg_Node::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripLeg_Node::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripLeg_Node::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripLeg_Node::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::TripLeg_Node_Type TripLeg_Node::type() const {
  return static_cast< ::valhalla::TripLeg_Node_Type >(type_);
}
inline void TripLeg_Node::set_type(::valhalla::TripLeg_Node_Type value) {
  assert(::valhalla::TripLeg_Node_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool fork = 6;
inline bool TripLeg_Node::has_fork() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripLeg_Node::set_has_fork() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripLeg_Node::clear_has_fork() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripLeg_Node::clear_fork() {
  fork_ = false;
  clear_has_fork();
}
inline bool TripLeg_Node::fork() const {
  return fork_;
}
inline void TripLeg_Node::set_fork(bool value) {
  set_has_fork();
  fork_ = value;
}

// optional .valhalla.TransitPlatformInfo transit_platform_info = 7;
inline bool TripLeg_Node::has_transit_platform_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripLeg_Node::set_has_transit_platform_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripLeg_Node::clear_has_transit_platform_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripLeg_Node::clear_transit_platform_info() {
  if (transit_platform_info_ != NULL) transit_platform_info_->::valhalla::TransitPlatformInfo::Clear();
  clear_has_transit_platform_info();
}
inline const ::valhalla::TransitPlatformInfo& TripLeg_Node::transit_platform_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_platform_info_ != NULL ? *transit_platform_info_ : *default_instance().transit_platform_info_;
#else
  return transit_platform_info_ != NULL ? *transit_platform_info_ : *default_instance_->transit_platform_info_;
#endif
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::mutable_transit_platform_info() {
  set_has_transit_platform_info();
  if (transit_platform_info_ == NULL) transit_platform_info_ = new ::valhalla::TransitPlatformInfo;
  return transit_platform_info_;
}
inline ::valhalla::TransitPlatformInfo* TripLeg_Node::release_transit_platform_info() {
  clear_has_transit_platform_info();
  ::valhalla::TransitPlatformInfo* temp = transit_platform_info_;
  transit_platform_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_transit_platform_info(::valhalla::TransitPlatformInfo* transit_platform_info) {
  delete transit_platform_info_;
  transit_platform_info_ = transit_platform_info;
  if (transit_platform_info) {
    set_has_transit_platform_info();
  } else {
    clear_has_transit_platform_info();
  }
}

// optional .valhalla.TransitStationInfo transit_station_info = 8;
inline bool TripLeg_Node::has_transit_station_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripLeg_Node::set_has_transit_station_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripLeg_Node::clear_has_transit_station_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripLeg_Node::clear_transit_station_info() {
  if (transit_station_info_ != NULL) transit_station_info_->::valhalla::TransitStationInfo::Clear();
  clear_has_transit_station_info();
}
inline const ::valhalla::TransitStationInfo& TripLeg_Node::transit_station_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_station_info_ != NULL ? *transit_station_info_ : *default_instance().transit_station_info_;
#else
  return transit_station_info_ != NULL ? *transit_station_info_ : *default_instance_->transit_station_info_;
#endif
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::mutable_transit_station_info() {
  set_has_transit_station_info();
  if (transit_station_info_ == NULL) transit_station_info_ = new ::valhalla::TransitStationInfo;
  return transit_station_info_;
}
inline ::valhalla::TransitStationInfo* TripLeg_Node::release_transit_station_info() {
  clear_has_transit_station_info();
  ::valhalla::TransitStationInfo* temp = transit_station_info_;
  transit_station_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_transit_station_info(::valhalla::TransitStationInfo* transit_station_info) {
  delete transit_station_info_;
  transit_station_info_ = transit_station_info;
  if (transit_station_info) {
    set_has_transit_station_info();
  } else {
    clear_has_transit_station_info();
  }
}

// optional .valhalla.TransitEgressInfo transit_egress_info = 9;
inline bool TripLeg_Node::has_transit_egress_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripLeg_Node::set_has_transit_egress_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripLeg_Node::clear_has_transit_egress_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripLeg_Node::clear_transit_egress_info() {
  if (transit_egress_info_ != NULL) transit_egress_info_->::valhalla::TransitEgressInfo::Clear();
  clear_has_transit_egress_info();
}
inline const ::valhalla::TransitEgressInfo& TripLeg_Node::transit_egress_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return transit_egress_info_ != NULL ? *transit_egress_info_ : *default_instance().transit_egress_info_;
#else
  return transit_egress_info_ != NULL ? *transit_egress_info_ : *default_instance_->transit_egress_info_;
#endif
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::mutable_transit_egress_info() {
  set_has_transit_egress_info();
  if (transit_egress_info_ == NULL) transit_egress_info_ = new ::valhalla::TransitEgressInfo;
  return transit_egress_info_;
}
inline ::valhalla::TransitEgressInfo* TripLeg_Node::release_transit_egress_info() {
  clear_has_transit_egress_info();
  ::valhalla::TransitEgressInfo* temp = transit_egress_info_;
  transit_egress_info_ = NULL;
  return temp;
}
inline void TripLeg_Node::set_allocated_transit_egress_info(::valhalla::TransitEgressInfo* transit_egress_info) {
  delete transit_egress_info_;
  transit_egress_info_ = transit_egress_info;
  if (transit_egress_info) {
    set_has_transit_egress_info();
  } else {
    clear_has_transit_egress_info();
  }
}

// optional string time_zone = 10;
inline bool TripLeg_Node::has_time_zone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripLeg_Node::set_has_time_zone() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripLeg_Node::clear_has_time_zone() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripLeg_Node::clear_time_zone() {
  if (time_zone_ != &::google::protobuf::internal::kEmptyString) {
    time_zone_->clear();
  }
  clear_has_time_zone();
}
inline const ::std::string& TripLeg_Node::time_zone() const {
  return *time_zone_;
}
inline void TripLeg_Node::set_time_zone(const ::std::string& value) {
  set_has_time_zone();
  if (time_zone_ == &::google::protobuf::internal::kEmptyString) {
    time_zone_ = new ::std::string;
  }
  time_zone_->assign(value);
}
inline void TripLeg_Node::set_time_zone(const char* value) {
  set_has_time_zone();
  if (time_zone_ == &::google::protobuf::internal::kEmptyString) {
    time_zone_ = new ::std::string;
  }
  time_zone_->assign(value);
}
inline void TripLeg_Node::set_time_zone(const char* value, size_t size) {
  set_has_time_zone();
  if (time_zone_ == &::google::protobuf::internal::kEmptyString) {
    time_zone_ = new ::std::string;
  }
  time_zone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_Node::mutable_time_zone() {
  set_has_time_zone();
  if (time_zone_ == &::google::protobuf::internal::kEmptyString) {
    time_zone_ = new ::std::string;
  }
  return time_zone_;
}
inline ::std::string* TripLeg_Node::release_time_zone() {
  clear_has_time_zone();
  if (time_zone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_zone_;
    time_zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_Node::set_allocated_time_zone(::std::string* time_zone) {
  if (time_zone_ != &::google::protobuf::internal::kEmptyString) {
    delete time_zone_;
  }
  if (time_zone) {
    set_has_time_zone();
    time_zone_ = time_zone;
  } else {
    clear_has_time_zone();
    time_zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TripLeg_Admin

// optional string country_code = 1;
inline bool TripLeg_Admin::has_country_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg_Admin::set_has_country_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg_Admin::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg_Admin::clear_country_code() {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    country_code_->clear();
  }
  clear_has_country_code();
}
inline const ::std::string& TripLeg_Admin::country_code() const {
  return *country_code_;
}
inline void TripLeg_Admin::set_country_code(const ::std::string& value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
}
inline void TripLeg_Admin::set_country_code(const char* value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
}
inline void TripLeg_Admin::set_country_code(const char* value, size_t size) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_Admin::mutable_country_code() {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  return country_code_;
}
inline ::std::string* TripLeg_Admin::release_country_code() {
  clear_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_code_;
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_Admin::set_allocated_country_code(::std::string* country_code) {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete country_code_;
  }
  if (country_code) {
    set_has_country_code();
    country_code_ = country_code;
  } else {
    clear_has_country_code();
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country_text = 2;
inline bool TripLeg_Admin::has_country_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg_Admin::set_has_country_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg_Admin::clear_has_country_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg_Admin::clear_country_text() {
  if (country_text_ != &::google::protobuf::internal::kEmptyString) {
    country_text_->clear();
  }
  clear_has_country_text();
}
inline const ::std::string& TripLeg_Admin::country_text() const {
  return *country_text_;
}
inline void TripLeg_Admin::set_country_text(const ::std::string& value) {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  country_text_->assign(value);
}
inline void TripLeg_Admin::set_country_text(const char* value) {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  country_text_->assign(value);
}
inline void TripLeg_Admin::set_country_text(const char* value, size_t size) {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  country_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_Admin::mutable_country_text() {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  return country_text_;
}
inline ::std::string* TripLeg_Admin::release_country_text() {
  clear_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_text_;
    country_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_Admin::set_allocated_country_text(::std::string* country_text) {
  if (country_text_ != &::google::protobuf::internal::kEmptyString) {
    delete country_text_;
  }
  if (country_text) {
    set_has_country_text();
    country_text_ = country_text;
  } else {
    clear_has_country_text();
    country_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state_code = 3;
inline bool TripLeg_Admin::has_state_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg_Admin::set_has_state_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg_Admin::clear_has_state_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg_Admin::clear_state_code() {
  if (state_code_ != &::google::protobuf::internal::kEmptyString) {
    state_code_->clear();
  }
  clear_has_state_code();
}
inline const ::std::string& TripLeg_Admin::state_code() const {
  return *state_code_;
}
inline void TripLeg_Admin::set_state_code(const ::std::string& value) {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  state_code_->assign(value);
}
inline void TripLeg_Admin::set_state_code(const char* value) {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  state_code_->assign(value);
}
inline void TripLeg_Admin::set_state_code(const char* value, size_t size) {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  state_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_Admin::mutable_state_code() {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  return state_code_;
}
inline ::std::string* TripLeg_Admin::release_state_code() {
  clear_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_code_;
    state_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_Admin::set_allocated_state_code(::std::string* state_code) {
  if (state_code_ != &::google::protobuf::internal::kEmptyString) {
    delete state_code_;
  }
  if (state_code) {
    set_has_state_code();
    state_code_ = state_code;
  } else {
    clear_has_state_code();
    state_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state_text = 4;
inline bool TripLeg_Admin::has_state_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg_Admin::set_has_state_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg_Admin::clear_has_state_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg_Admin::clear_state_text() {
  if (state_text_ != &::google::protobuf::internal::kEmptyString) {
    state_text_->clear();
  }
  clear_has_state_text();
}
inline const ::std::string& TripLeg_Admin::state_text() const {
  return *state_text_;
}
inline void TripLeg_Admin::set_state_text(const ::std::string& value) {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  state_text_->assign(value);
}
inline void TripLeg_Admin::set_state_text(const char* value) {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  state_text_->assign(value);
}
inline void TripLeg_Admin::set_state_text(const char* value, size_t size) {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  state_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg_Admin::mutable_state_text() {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  return state_text_;
}
inline ::std::string* TripLeg_Admin::release_state_text() {
  clear_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_text_;
    state_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg_Admin::set_allocated_state_text(::std::string* state_text) {
  if (state_text_ != &::google::protobuf::internal::kEmptyString) {
    delete state_text_;
  }
  if (state_text) {
    set_has_state_text();
    state_text_ = state_text;
  } else {
    clear_has_state_text();
    state_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TripLeg_ShapeAttributes

// repeated uint32 time = 1 [packed = true];
inline int TripLeg_ShapeAttributes::time_size() const {
  return time_.size();
}
inline void TripLeg_ShapeAttributes::clear_time() {
  time_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::time(int index) const {
  return time_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_time(int index, ::google::protobuf::uint32 value) {
  time_.Set(index, value);
}
inline void TripLeg_ShapeAttributes::add_time(::google::protobuf::uint32 value) {
  time_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::time() const {
  return time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_time() {
  return &time_;
}

// repeated uint32 length = 2 [packed = true];
inline int TripLeg_ShapeAttributes::length_size() const {
  return length_.size();
}
inline void TripLeg_ShapeAttributes::clear_length() {
  length_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::length(int index) const {
  return length_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_length(int index, ::google::protobuf::uint32 value) {
  length_.Set(index, value);
}
inline void TripLeg_ShapeAttributes::add_length(::google::protobuf::uint32 value) {
  length_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::length() const {
  return length_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_length() {
  return &length_;
}

// repeated uint32 speed = 3 [packed = true];
inline int TripLeg_ShapeAttributes::speed_size() const {
  return speed_.size();
}
inline void TripLeg_ShapeAttributes::clear_speed() {
  speed_.Clear();
}
inline ::google::protobuf::uint32 TripLeg_ShapeAttributes::speed(int index) const {
  return speed_.Get(index);
}
inline void TripLeg_ShapeAttributes::set_speed(int index, ::google::protobuf::uint32 value) {
  speed_.Set(index, value);
}
inline void TripLeg_ShapeAttributes::add_speed(::google::protobuf::uint32 value) {
  speed_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TripLeg_ShapeAttributes::speed() const {
  return speed_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TripLeg_ShapeAttributes::mutable_speed() {
  return &speed_;
}

// -------------------------------------------------------------------

// TripLeg

// optional uint64 osm_changeset = 1;
inline bool TripLeg::has_osm_changeset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripLeg::set_has_osm_changeset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripLeg::clear_has_osm_changeset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripLeg::clear_osm_changeset() {
  osm_changeset_ = GOOGLE_ULONGLONG(0);
  clear_has_osm_changeset();
}
inline ::google::protobuf::uint64 TripLeg::osm_changeset() const {
  return osm_changeset_;
}
inline void TripLeg::set_osm_changeset(::google::protobuf::uint64 value) {
  set_has_osm_changeset();
  osm_changeset_ = value;
}

// optional uint64 trip_id = 2;
inline bool TripLeg::has_trip_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripLeg::set_has_trip_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripLeg::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripLeg::clear_trip_id() {
  trip_id_ = GOOGLE_ULONGLONG(0);
  clear_has_trip_id();
}
inline ::google::protobuf::uint64 TripLeg::trip_id() const {
  return trip_id_;
}
inline void TripLeg::set_trip_id(::google::protobuf::uint64 value) {
  set_has_trip_id();
  trip_id_ = value;
}

// optional uint32 leg_id = 3;
inline bool TripLeg::has_leg_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripLeg::set_has_leg_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripLeg::clear_has_leg_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripLeg::clear_leg_id() {
  leg_id_ = 0u;
  clear_has_leg_id();
}
inline ::google::protobuf::uint32 TripLeg::leg_id() const {
  return leg_id_;
}
inline void TripLeg::set_leg_id(::google::protobuf::uint32 value) {
  set_has_leg_id();
  leg_id_ = value;
}

// optional uint32 leg_count = 4;
inline bool TripLeg::has_leg_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripLeg::set_has_leg_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripLeg::clear_has_leg_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripLeg::clear_leg_count() {
  leg_count_ = 0u;
  clear_has_leg_count();
}
inline ::google::protobuf::uint32 TripLeg::leg_count() const {
  return leg_count_;
}
inline void TripLeg::set_leg_count(::google::protobuf::uint32 value) {
  set_has_leg_count();
  leg_count_ = value;
}

// repeated .valhalla.Location location = 5;
inline int TripLeg::location_size() const {
  return location_.size();
}
inline void TripLeg::clear_location() {
  location_.Clear();
}
inline const ::valhalla::Location& TripLeg::location(int index) const {
  return location_.Get(index);
}
inline ::valhalla::Location* TripLeg::mutable_location(int index) {
  return location_.Mutable(index);
}
inline ::valhalla::Location* TripLeg::add_location() {
  return location_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::Location >&
TripLeg::location() const {
  return location_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::Location >*
TripLeg::mutable_location() {
  return &location_;
}

// repeated .valhalla.TripLeg.Node node = 6;
inline int TripLeg::node_size() const {
  return node_.size();
}
inline void TripLeg::clear_node() {
  node_.Clear();
}
inline const ::valhalla::TripLeg_Node& TripLeg::node(int index) const {
  return node_.Get(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::mutable_node(int index) {
  return node_.Mutable(index);
}
inline ::valhalla::TripLeg_Node* TripLeg::add_node() {
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >&
TripLeg::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Node >*
TripLeg::mutable_node() {
  return &node_;
}

// repeated .valhalla.TripLeg.Admin admin = 7;
inline int TripLeg::admin_size() const {
  return admin_.size();
}
inline void TripLeg::clear_admin() {
  admin_.Clear();
}
inline const ::valhalla::TripLeg_Admin& TripLeg::admin(int index) const {
  return admin_.Get(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::mutable_admin(int index) {
  return admin_.Mutable(index);
}
inline ::valhalla::TripLeg_Admin* TripLeg::add_admin() {
  return admin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >&
TripLeg::admin() const {
  return admin_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg_Admin >*
TripLeg::mutable_admin() {
  return &admin_;
}

// optional string shape = 8;
inline bool TripLeg::has_shape() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripLeg::set_has_shape() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripLeg::clear_has_shape() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripLeg::clear_shape() {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    shape_->clear();
  }
  clear_has_shape();
}
inline const ::std::string& TripLeg::shape() const {
  return *shape_;
}
inline void TripLeg::set_shape(const ::std::string& value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void TripLeg::set_shape(const char* value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void TripLeg::set_shape(const char* value, size_t size) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripLeg::mutable_shape() {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  return shape_;
}
inline ::std::string* TripLeg::release_shape() {
  clear_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shape_;
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripLeg::set_allocated_shape(::std::string* shape) {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    delete shape_;
  }
  if (shape) {
    set_has_shape();
    shape_ = shape;
  } else {
    clear_has_shape();
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.BoundingBox bbox = 9;
inline bool TripLeg::has_bbox() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripLeg::set_has_bbox() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripLeg::clear_has_bbox() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripLeg::clear_bbox() {
  if (bbox_ != NULL) bbox_->::valhalla::BoundingBox::Clear();
  clear_has_bbox();
}
inline const ::valhalla::BoundingBox& TripLeg::bbox() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bbox_ != NULL ? *bbox_ : *default_instance().bbox_;
#else
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
#endif
}
inline ::valhalla::BoundingBox* TripLeg::mutable_bbox() {
  set_has_bbox();
  if (bbox_ == NULL) bbox_ = new ::valhalla::BoundingBox;
  return bbox_;
}
inline ::valhalla::BoundingBox* TripLeg::release_bbox() {
  clear_has_bbox();
  ::valhalla::BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void TripLeg::set_allocated_bbox(::valhalla::BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    set_has_bbox();
  } else {
    clear_has_bbox();
  }
}

// optional .valhalla.TripLeg.ShapeAttributes shape_attributes = 10;
inline bool TripLeg::has_shape_attributes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripLeg::set_has_shape_attributes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripLeg::clear_has_shape_attributes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripLeg::clear_shape_attributes() {
  if (shape_attributes_ != NULL) shape_attributes_->::valhalla::TripLeg_ShapeAttributes::Clear();
  clear_has_shape_attributes();
}
inline const ::valhalla::TripLeg_ShapeAttributes& TripLeg::shape_attributes() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return shape_attributes_ != NULL ? *shape_attributes_ : *default_instance().shape_attributes_;
#else
  return shape_attributes_ != NULL ? *shape_attributes_ : *default_instance_->shape_attributes_;
#endif
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::mutable_shape_attributes() {
  set_has_shape_attributes();
  if (shape_attributes_ == NULL) shape_attributes_ = new ::valhalla::TripLeg_ShapeAttributes;
  return shape_attributes_;
}
inline ::valhalla::TripLeg_ShapeAttributes* TripLeg::release_shape_attributes() {
  clear_has_shape_attributes();
  ::valhalla::TripLeg_ShapeAttributes* temp = shape_attributes_;
  shape_attributes_ = NULL;
  return temp;
}
inline void TripLeg::set_allocated_shape_attributes(::valhalla::TripLeg_ShapeAttributes* shape_attributes) {
  delete shape_attributes_;
  shape_attributes_ = shape_attributes;
  if (shape_attributes) {
    set_has_shape_attributes();
  } else {
    clear_has_shape_attributes();
  }
}

// -------------------------------------------------------------------

// TripRoute

// repeated .valhalla.TripLeg legs = 1;
inline int TripRoute::legs_size() const {
  return legs_.size();
}
inline void TripRoute::clear_legs() {
  legs_.Clear();
}
inline const ::valhalla::TripLeg& TripRoute::legs(int index) const {
  return legs_.Get(index);
}
inline ::valhalla::TripLeg* TripRoute::mutable_legs(int index) {
  return legs_.Mutable(index);
}
inline ::valhalla::TripLeg* TripRoute::add_legs() {
  return legs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >&
TripRoute::legs() const {
  return legs_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripLeg >*
TripRoute::mutable_legs() {
  return &legs_;
}

// -------------------------------------------------------------------

// Trip

// repeated .valhalla.TripRoute routes = 1;
inline int Trip::routes_size() const {
  return routes_.size();
}
inline void Trip::clear_routes() {
  routes_.Clear();
}
inline const ::valhalla::TripRoute& Trip::routes(int index) const {
  return routes_.Get(index);
}
inline ::valhalla::TripRoute* Trip::mutable_routes(int index) {
  return routes_.Mutable(index);
}
inline ::valhalla::TripRoute* Trip::add_routes() {
  return routes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >&
Trip::routes() const {
  return routes_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::TripRoute >*
Trip::mutable_routes() {
  return &routes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace valhalla

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trip_2eproto__INCLUDED
