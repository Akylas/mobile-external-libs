// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trippath.proto

#ifndef PROTOBUF_trippath_2eproto__INCLUDED
#define PROTOBUF_trippath_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace valhalla {
namespace odin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trippath_2eproto();
void protobuf_AssignDesc_trippath_2eproto();
void protobuf_ShutdownFile_trippath_2eproto();

class TripPath;
class TripPath_LatLng;
class TripPath_BoundingBox;
class TripPath_Location;
class TripPath_Sign;
class TripPath_TransitRouteInfo;
class TripPath_Edge;
class TripPath_IntersectingEdge;
class TripPath_TransitStopInfo;
class TripPath_Node;
class TripPath_Admin;

enum TripPath_Location_Type {
  TripPath_Location_Type_kBreak = 0,
  TripPath_Location_Type_kThrough = 1
};
bool TripPath_Location_Type_IsValid(int value);
const TripPath_Location_Type TripPath_Location_Type_Type_MIN = TripPath_Location_Type_kBreak;
const TripPath_Location_Type TripPath_Location_Type_Type_MAX = TripPath_Location_Type_kThrough;
const int TripPath_Location_Type_Type_ARRAYSIZE = TripPath_Location_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_Location_Type_descriptor();
inline const ::std::string& TripPath_Location_Type_Name(TripPath_Location_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_Location_Type_descriptor(), value);
}
inline bool TripPath_Location_Type_Parse(
    const ::std::string& name, TripPath_Location_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_Location_Type>(
    TripPath_Location_Type_descriptor(), name, value);
}
enum TripPath_Location_SideOfStreet {
  TripPath_Location_SideOfStreet_kNone = 0,
  TripPath_Location_SideOfStreet_kLeft = 1,
  TripPath_Location_SideOfStreet_kRight = 2
};
bool TripPath_Location_SideOfStreet_IsValid(int value);
const TripPath_Location_SideOfStreet TripPath_Location_SideOfStreet_SideOfStreet_MIN = TripPath_Location_SideOfStreet_kNone;
const TripPath_Location_SideOfStreet TripPath_Location_SideOfStreet_SideOfStreet_MAX = TripPath_Location_SideOfStreet_kRight;
const int TripPath_Location_SideOfStreet_SideOfStreet_ARRAYSIZE = TripPath_Location_SideOfStreet_SideOfStreet_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_Location_SideOfStreet_descriptor();
inline const ::std::string& TripPath_Location_SideOfStreet_Name(TripPath_Location_SideOfStreet value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_Location_SideOfStreet_descriptor(), value);
}
inline bool TripPath_Location_SideOfStreet_Parse(
    const ::std::string& name, TripPath_Location_SideOfStreet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_Location_SideOfStreet>(
    TripPath_Location_SideOfStreet_descriptor(), name, value);
}
enum TripPath_TransitStopInfo_Type {
  TripPath_TransitStopInfo_Type_kStop = 0,
  TripPath_TransitStopInfo_Type_kStation = 1
};
bool TripPath_TransitStopInfo_Type_IsValid(int value);
const TripPath_TransitStopInfo_Type TripPath_TransitStopInfo_Type_Type_MIN = TripPath_TransitStopInfo_Type_kStop;
const TripPath_TransitStopInfo_Type TripPath_TransitStopInfo_Type_Type_MAX = TripPath_TransitStopInfo_Type_kStation;
const int TripPath_TransitStopInfo_Type_Type_ARRAYSIZE = TripPath_TransitStopInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_TransitStopInfo_Type_descriptor();
inline const ::std::string& TripPath_TransitStopInfo_Type_Name(TripPath_TransitStopInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_TransitStopInfo_Type_descriptor(), value);
}
inline bool TripPath_TransitStopInfo_Type_Parse(
    const ::std::string& name, TripPath_TransitStopInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_TransitStopInfo_Type>(
    TripPath_TransitStopInfo_Type_descriptor(), name, value);
}
enum TripPath_Traversability {
  TripPath_Traversability_kNone = 0,
  TripPath_Traversability_kForward = 1,
  TripPath_Traversability_kBackward = 2,
  TripPath_Traversability_kBoth = 3
};
bool TripPath_Traversability_IsValid(int value);
const TripPath_Traversability TripPath_Traversability_Traversability_MIN = TripPath_Traversability_kNone;
const TripPath_Traversability TripPath_Traversability_Traversability_MAX = TripPath_Traversability_kBoth;
const int TripPath_Traversability_Traversability_ARRAYSIZE = TripPath_Traversability_Traversability_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_Traversability_descriptor();
inline const ::std::string& TripPath_Traversability_Name(TripPath_Traversability value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_Traversability_descriptor(), value);
}
inline bool TripPath_Traversability_Parse(
    const ::std::string& name, TripPath_Traversability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_Traversability>(
    TripPath_Traversability_descriptor(), name, value);
}
enum TripPath_RoadClass {
  TripPath_RoadClass_kMotorway = 0,
  TripPath_RoadClass_kTrunk = 1,
  TripPath_RoadClass_kPrimary = 2,
  TripPath_RoadClass_kSecondary = 3,
  TripPath_RoadClass_kTertiary = 4,
  TripPath_RoadClass_kUnclassified = 5,
  TripPath_RoadClass_kResidential = 6,
  TripPath_RoadClass_kServiceOther = 7
};
bool TripPath_RoadClass_IsValid(int value);
const TripPath_RoadClass TripPath_RoadClass_RoadClass_MIN = TripPath_RoadClass_kMotorway;
const TripPath_RoadClass TripPath_RoadClass_RoadClass_MAX = TripPath_RoadClass_kServiceOther;
const int TripPath_RoadClass_RoadClass_ARRAYSIZE = TripPath_RoadClass_RoadClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_RoadClass_descriptor();
inline const ::std::string& TripPath_RoadClass_Name(TripPath_RoadClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_RoadClass_descriptor(), value);
}
inline bool TripPath_RoadClass_Parse(
    const ::std::string& name, TripPath_RoadClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_RoadClass>(
    TripPath_RoadClass_descriptor(), name, value);
}
enum TripPath_TravelMode {
  TripPath_TravelMode_kDrive = 0,
  TripPath_TravelMode_kPedestrian = 1,
  TripPath_TravelMode_kBicycle = 2,
  TripPath_TravelMode_kTransit = 3
};
bool TripPath_TravelMode_IsValid(int value);
const TripPath_TravelMode TripPath_TravelMode_TravelMode_MIN = TripPath_TravelMode_kDrive;
const TripPath_TravelMode TripPath_TravelMode_TravelMode_MAX = TripPath_TravelMode_kTransit;
const int TripPath_TravelMode_TravelMode_ARRAYSIZE = TripPath_TravelMode_TravelMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_TravelMode_descriptor();
inline const ::std::string& TripPath_TravelMode_Name(TripPath_TravelMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_TravelMode_descriptor(), value);
}
inline bool TripPath_TravelMode_Parse(
    const ::std::string& name, TripPath_TravelMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_TravelMode>(
    TripPath_TravelMode_descriptor(), name, value);
}
enum TripPath_VehicleType {
  TripPath_VehicleType_kCar = 0,
  TripPath_VehicleType_kMotorcycle = 1,
  TripPath_VehicleType_kFourWheelDrive = 2,
  TripPath_VehicleType_kTractorTrailers = 3
};
bool TripPath_VehicleType_IsValid(int value);
const TripPath_VehicleType TripPath_VehicleType_VehicleType_MIN = TripPath_VehicleType_kCar;
const TripPath_VehicleType TripPath_VehicleType_VehicleType_MAX = TripPath_VehicleType_kTractorTrailers;
const int TripPath_VehicleType_VehicleType_ARRAYSIZE = TripPath_VehicleType_VehicleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_VehicleType_descriptor();
inline const ::std::string& TripPath_VehicleType_Name(TripPath_VehicleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_VehicleType_descriptor(), value);
}
inline bool TripPath_VehicleType_Parse(
    const ::std::string& name, TripPath_VehicleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_VehicleType>(
    TripPath_VehicleType_descriptor(), name, value);
}
enum TripPath_PedestrianType {
  TripPath_PedestrianType_kFoot = 0,
  TripPath_PedestrianType_kWheelChair = 1,
  TripPath_PedestrianType_kSegway = 2
};
bool TripPath_PedestrianType_IsValid(int value);
const TripPath_PedestrianType TripPath_PedestrianType_PedestrianType_MIN = TripPath_PedestrianType_kFoot;
const TripPath_PedestrianType TripPath_PedestrianType_PedestrianType_MAX = TripPath_PedestrianType_kSegway;
const int TripPath_PedestrianType_PedestrianType_ARRAYSIZE = TripPath_PedestrianType_PedestrianType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_PedestrianType_descriptor();
inline const ::std::string& TripPath_PedestrianType_Name(TripPath_PedestrianType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_PedestrianType_descriptor(), value);
}
inline bool TripPath_PedestrianType_Parse(
    const ::std::string& name, TripPath_PedestrianType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_PedestrianType>(
    TripPath_PedestrianType_descriptor(), name, value);
}
enum TripPath_BicycleType {
  TripPath_BicycleType_kRoad = 0,
  TripPath_BicycleType_kHybrid = 1,
  TripPath_BicycleType_kCity = 2,
  TripPath_BicycleType_kCross = 3,
  TripPath_BicycleType_kMountain = 4
};
bool TripPath_BicycleType_IsValid(int value);
const TripPath_BicycleType TripPath_BicycleType_BicycleType_MIN = TripPath_BicycleType_kRoad;
const TripPath_BicycleType TripPath_BicycleType_BicycleType_MAX = TripPath_BicycleType_kMountain;
const int TripPath_BicycleType_BicycleType_ARRAYSIZE = TripPath_BicycleType_BicycleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_BicycleType_descriptor();
inline const ::std::string& TripPath_BicycleType_Name(TripPath_BicycleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_BicycleType_descriptor(), value);
}
inline bool TripPath_BicycleType_Parse(
    const ::std::string& name, TripPath_BicycleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_BicycleType>(
    TripPath_BicycleType_descriptor(), name, value);
}
enum TripPath_TransitType {
  TripPath_TransitType_kTram = 0,
  TripPath_TransitType_kMetro = 1,
  TripPath_TransitType_kRail = 2,
  TripPath_TransitType_kBus = 3,
  TripPath_TransitType_kFerry = 4,
  TripPath_TransitType_kCableCar = 5,
  TripPath_TransitType_kGondola = 6,
  TripPath_TransitType_kFunicular = 7
};
bool TripPath_TransitType_IsValid(int value);
const TripPath_TransitType TripPath_TransitType_TransitType_MIN = TripPath_TransitType_kTram;
const TripPath_TransitType TripPath_TransitType_TransitType_MAX = TripPath_TransitType_kFunicular;
const int TripPath_TransitType_TransitType_ARRAYSIZE = TripPath_TransitType_TransitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripPath_TransitType_descriptor();
inline const ::std::string& TripPath_TransitType_Name(TripPath_TransitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripPath_TransitType_descriptor(), value);
}
inline bool TripPath_TransitType_Parse(
    const ::std::string& name, TripPath_TransitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripPath_TransitType>(
    TripPath_TransitType_descriptor(), name, value);
}
// ===================================================================

class TripPath_LatLng : public ::google::protobuf::Message {
 public:
  TripPath_LatLng();
  virtual ~TripPath_LatLng();

  TripPath_LatLng(const TripPath_LatLng& from);

  inline TripPath_LatLng& operator=(const TripPath_LatLng& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_LatLng& default_instance();

  void Swap(TripPath_LatLng* other);

  // implements Message ----------------------------------------------

  TripPath_LatLng* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_LatLng& from);
  void MergeFrom(const TripPath_LatLng& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lng = 2;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 2;
  inline float lng() const;
  inline void set_lng(float value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.LatLng)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lng();
  inline void clear_has_lng();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float lat_;
  float lng_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_LatLng* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_BoundingBox : public ::google::protobuf::Message {
 public:
  TripPath_BoundingBox();
  virtual ~TripPath_BoundingBox();

  TripPath_BoundingBox(const TripPath_BoundingBox& from);

  inline TripPath_BoundingBox& operator=(const TripPath_BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_BoundingBox& default_instance();

  void Swap(TripPath_BoundingBox* other);

  // implements Message ----------------------------------------------

  TripPath_BoundingBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_BoundingBox& from);
  void MergeFrom(const TripPath_BoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripPath.LatLng min_ll = 1;
  inline bool has_min_ll() const;
  inline void clear_min_ll();
  static const int kMinLlFieldNumber = 1;
  inline const ::valhalla::odin::TripPath_LatLng& min_ll() const;
  inline ::valhalla::odin::TripPath_LatLng* mutable_min_ll();
  inline ::valhalla::odin::TripPath_LatLng* release_min_ll();
  inline void set_allocated_min_ll(::valhalla::odin::TripPath_LatLng* min_ll);

  // optional .valhalla.odin.TripPath.LatLng max_ll = 2;
  inline bool has_max_ll() const;
  inline void clear_max_ll();
  static const int kMaxLlFieldNumber = 2;
  inline const ::valhalla::odin::TripPath_LatLng& max_ll() const;
  inline ::valhalla::odin::TripPath_LatLng* mutable_max_ll();
  inline ::valhalla::odin::TripPath_LatLng* release_max_ll();
  inline void set_allocated_max_ll(::valhalla::odin::TripPath_LatLng* max_ll);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.BoundingBox)
 private:
  inline void set_has_min_ll();
  inline void clear_has_min_ll();
  inline void set_has_max_ll();
  inline void clear_has_max_ll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::TripPath_LatLng* min_ll_;
  ::valhalla::odin::TripPath_LatLng* max_ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_Location : public ::google::protobuf::Message {
 public:
  TripPath_Location();
  virtual ~TripPath_Location();

  TripPath_Location(const TripPath_Location& from);

  inline TripPath_Location& operator=(const TripPath_Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_Location& default_instance();

  void Swap(TripPath_Location* other);

  // implements Message ----------------------------------------------

  TripPath_Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_Location& from);
  void MergeFrom(const TripPath_Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripPath_Location_Type Type;
  static const Type kBreak = TripPath_Location_Type_kBreak;
  static const Type kThrough = TripPath_Location_Type_kThrough;
  static inline bool Type_IsValid(int value) {
    return TripPath_Location_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripPath_Location_Type_Type_MIN;
  static const Type Type_MAX =
    TripPath_Location_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripPath_Location_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TripPath_Location_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TripPath_Location_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TripPath_Location_Type_Parse(name, value);
  }

  typedef TripPath_Location_SideOfStreet SideOfStreet;
  static const SideOfStreet kNone = TripPath_Location_SideOfStreet_kNone;
  static const SideOfStreet kLeft = TripPath_Location_SideOfStreet_kLeft;
  static const SideOfStreet kRight = TripPath_Location_SideOfStreet_kRight;
  static inline bool SideOfStreet_IsValid(int value) {
    return TripPath_Location_SideOfStreet_IsValid(value);
  }
  static const SideOfStreet SideOfStreet_MIN =
    TripPath_Location_SideOfStreet_SideOfStreet_MIN;
  static const SideOfStreet SideOfStreet_MAX =
    TripPath_Location_SideOfStreet_SideOfStreet_MAX;
  static const int SideOfStreet_ARRAYSIZE =
    TripPath_Location_SideOfStreet_SideOfStreet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SideOfStreet_descriptor() {
    return TripPath_Location_SideOfStreet_descriptor();
  }
  static inline const ::std::string& SideOfStreet_Name(SideOfStreet value) {
    return TripPath_Location_SideOfStreet_Name(value);
  }
  static inline bool SideOfStreet_Parse(const ::std::string& name,
      SideOfStreet* value) {
    return TripPath_Location_SideOfStreet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripPath.LatLng ll = 1;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 1;
  inline const ::valhalla::odin::TripPath_LatLng& ll() const;
  inline ::valhalla::odin::TripPath_LatLng* mutable_ll();
  inline ::valhalla::odin::TripPath_LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::odin::TripPath_LatLng* ll);

  // optional .valhalla.odin.TripPath.Location.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::valhalla::odin::TripPath_Location_Type type() const;
  inline void set_type(::valhalla::odin::TripPath_Location_Type value);

  // optional uint32 heading = 3;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 3;
  inline ::google::protobuf::uint32 heading() const;
  inline void set_heading(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string street = 5;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 5;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string postal_code = 8;
  inline bool has_postal_code() const;
  inline void clear_postal_code();
  static const int kPostalCodeFieldNumber = 8;
  inline const ::std::string& postal_code() const;
  inline void set_postal_code(const ::std::string& value);
  inline void set_postal_code(const char* value);
  inline void set_postal_code(const char* value, size_t size);
  inline ::std::string* mutable_postal_code();
  inline ::std::string* release_postal_code();
  inline void set_allocated_postal_code(::std::string* postal_code);

  // optional string country = 9;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 9;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string date_time = 10;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 10;
  inline const ::std::string& date_time() const;
  inline void set_date_time(const ::std::string& value);
  inline void set_date_time(const char* value);
  inline void set_date_time(const char* value, size_t size);
  inline ::std::string* mutable_date_time();
  inline ::std::string* release_date_time();
  inline void set_allocated_date_time(::std::string* date_time);

  // optional .valhalla.odin.TripPath.Location.SideOfStreet side_of_street = 11;
  inline bool has_side_of_street() const;
  inline void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 11;
  inline ::valhalla::odin::TripPath_Location_SideOfStreet side_of_street() const;
  inline void set_side_of_street(::valhalla::odin::TripPath_Location_SideOfStreet value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.Location)
 private:
  inline void set_has_ll();
  inline void clear_has_ll();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_postal_code();
  inline void clear_has_postal_code();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_date_time();
  inline void clear_has_date_time();
  inline void set_has_side_of_street();
  inline void clear_has_side_of_street();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::TripPath_LatLng* ll_;
  int type_;
  ::google::protobuf::uint32 heading_;
  ::std::string* name_;
  ::std::string* street_;
  ::std::string* city_;
  ::std::string* state_;
  ::std::string* postal_code_;
  ::std::string* country_;
  ::std::string* date_time_;
  int side_of_street_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_Location* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_Sign : public ::google::protobuf::Message {
 public:
  TripPath_Sign();
  virtual ~TripPath_Sign();

  TripPath_Sign(const TripPath_Sign& from);

  inline TripPath_Sign& operator=(const TripPath_Sign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_Sign& default_instance();

  void Swap(TripPath_Sign* other);

  // implements Message ----------------------------------------------

  TripPath_Sign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_Sign& from);
  void MergeFrom(const TripPath_Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string exit_number = 1;
  inline int exit_number_size() const;
  inline void clear_exit_number();
  static const int kExitNumberFieldNumber = 1;
  inline const ::std::string& exit_number(int index) const;
  inline ::std::string* mutable_exit_number(int index);
  inline void set_exit_number(int index, const ::std::string& value);
  inline void set_exit_number(int index, const char* value);
  inline void set_exit_number(int index, const char* value, size_t size);
  inline ::std::string* add_exit_number();
  inline void add_exit_number(const ::std::string& value);
  inline void add_exit_number(const char* value);
  inline void add_exit_number(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exit_number() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exit_number();

  // repeated string exit_branch = 2;
  inline int exit_branch_size() const;
  inline void clear_exit_branch();
  static const int kExitBranchFieldNumber = 2;
  inline const ::std::string& exit_branch(int index) const;
  inline ::std::string* mutable_exit_branch(int index);
  inline void set_exit_branch(int index, const ::std::string& value);
  inline void set_exit_branch(int index, const char* value);
  inline void set_exit_branch(int index, const char* value, size_t size);
  inline ::std::string* add_exit_branch();
  inline void add_exit_branch(const ::std::string& value);
  inline void add_exit_branch(const char* value);
  inline void add_exit_branch(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exit_branch() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exit_branch();

  // repeated string exit_toward = 3;
  inline int exit_toward_size() const;
  inline void clear_exit_toward();
  static const int kExitTowardFieldNumber = 3;
  inline const ::std::string& exit_toward(int index) const;
  inline ::std::string* mutable_exit_toward(int index);
  inline void set_exit_toward(int index, const ::std::string& value);
  inline void set_exit_toward(int index, const char* value);
  inline void set_exit_toward(int index, const char* value, size_t size);
  inline ::std::string* add_exit_toward();
  inline void add_exit_toward(const ::std::string& value);
  inline void add_exit_toward(const char* value);
  inline void add_exit_toward(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exit_toward() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exit_toward();

  // repeated string exit_name = 4;
  inline int exit_name_size() const;
  inline void clear_exit_name();
  static const int kExitNameFieldNumber = 4;
  inline const ::std::string& exit_name(int index) const;
  inline ::std::string* mutable_exit_name(int index);
  inline void set_exit_name(int index, const ::std::string& value);
  inline void set_exit_name(int index, const char* value);
  inline void set_exit_name(int index, const char* value, size_t size);
  inline ::std::string* add_exit_name();
  inline void add_exit_name(const ::std::string& value);
  inline void add_exit_name(const char* value);
  inline void add_exit_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& exit_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_exit_name();

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.Sign)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> exit_number_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exit_branch_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exit_toward_;
  ::google::protobuf::RepeatedPtrField< ::std::string> exit_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_Sign* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_TransitRouteInfo : public ::google::protobuf::Message {
 public:
  TripPath_TransitRouteInfo();
  virtual ~TripPath_TransitRouteInfo();

  TripPath_TransitRouteInfo(const TripPath_TransitRouteInfo& from);

  inline TripPath_TransitRouteInfo& operator=(const TripPath_TransitRouteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_TransitRouteInfo& default_instance();

  void Swap(TripPath_TransitRouteInfo* other);

  // implements Message ----------------------------------------------

  TripPath_TransitRouteInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_TransitRouteInfo& from);
  void MergeFrom(const TripPath_TransitRouteInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string onestop_id = 1;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 1;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional uint32 block_id = 2;
  inline bool has_block_id() const;
  inline void clear_block_id();
  static const int kBlockIdFieldNumber = 2;
  inline ::google::protobuf::uint32 block_id() const;
  inline void set_block_id(::google::protobuf::uint32 value);

  // optional uint32 trip_id = 3;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 3;
  inline ::google::protobuf::uint32 trip_id() const;
  inline void set_trip_id(::google::protobuf::uint32 value);

  // optional string short_name = 4;
  inline bool has_short_name() const;
  inline void clear_short_name();
  static const int kShortNameFieldNumber = 4;
  inline const ::std::string& short_name() const;
  inline void set_short_name(const ::std::string& value);
  inline void set_short_name(const char* value);
  inline void set_short_name(const char* value, size_t size);
  inline ::std::string* mutable_short_name();
  inline ::std::string* release_short_name();
  inline void set_allocated_short_name(::std::string* short_name);

  // optional string long_name = 5;
  inline bool has_long_name() const;
  inline void clear_long_name();
  static const int kLongNameFieldNumber = 5;
  inline const ::std::string& long_name() const;
  inline void set_long_name(const ::std::string& value);
  inline void set_long_name(const char* value);
  inline void set_long_name(const char* value, size_t size);
  inline ::std::string* mutable_long_name();
  inline ::std::string* release_long_name();
  inline void set_allocated_long_name(::std::string* long_name);

  // optional string headsign = 6;
  inline bool has_headsign() const;
  inline void clear_headsign();
  static const int kHeadsignFieldNumber = 6;
  inline const ::std::string& headsign() const;
  inline void set_headsign(const ::std::string& value);
  inline void set_headsign(const char* value);
  inline void set_headsign(const char* value, size_t size);
  inline ::std::string* mutable_headsign();
  inline ::std::string* release_headsign();
  inline void set_allocated_headsign(::std::string* headsign);

  // optional uint32 color = 7;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 7;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 text_color = 8;
  inline bool has_text_color() const;
  inline void clear_text_color();
  static const int kTextColorFieldNumber = 8;
  inline ::google::protobuf::uint32 text_color() const;
  inline void set_text_color(::google::protobuf::uint32 value);

  // optional string description = 9;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 9;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string operator_onestop_id = 10;
  inline bool has_operator_onestop_id() const;
  inline void clear_operator_onestop_id();
  static const int kOperatorOnestopIdFieldNumber = 10;
  inline const ::std::string& operator_onestop_id() const;
  inline void set_operator_onestop_id(const ::std::string& value);
  inline void set_operator_onestop_id(const char* value);
  inline void set_operator_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_operator_onestop_id();
  inline ::std::string* release_operator_onestop_id();
  inline void set_allocated_operator_onestop_id(::std::string* operator_onestop_id);

  // optional string operator_name = 11;
  inline bool has_operator_name() const;
  inline void clear_operator_name();
  static const int kOperatorNameFieldNumber = 11;
  inline const ::std::string& operator_name() const;
  inline void set_operator_name(const ::std::string& value);
  inline void set_operator_name(const char* value);
  inline void set_operator_name(const char* value, size_t size);
  inline ::std::string* mutable_operator_name();
  inline ::std::string* release_operator_name();
  inline void set_allocated_operator_name(::std::string* operator_name);

  // optional string operator_url = 12;
  inline bool has_operator_url() const;
  inline void clear_operator_url();
  static const int kOperatorUrlFieldNumber = 12;
  inline const ::std::string& operator_url() const;
  inline void set_operator_url(const ::std::string& value);
  inline void set_operator_url(const char* value);
  inline void set_operator_url(const char* value, size_t size);
  inline ::std::string* mutable_operator_url();
  inline ::std::string* release_operator_url();
  inline void set_allocated_operator_url(::std::string* operator_url);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.TransitRouteInfo)
 private:
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_block_id();
  inline void clear_has_block_id();
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_short_name();
  inline void clear_has_short_name();
  inline void set_has_long_name();
  inline void clear_has_long_name();
  inline void set_has_headsign();
  inline void clear_has_headsign();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_text_color();
  inline void clear_has_text_color();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_operator_onestop_id();
  inline void clear_has_operator_onestop_id();
  inline void set_has_operator_name();
  inline void clear_has_operator_name();
  inline void set_has_operator_url();
  inline void clear_has_operator_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* onestop_id_;
  ::google::protobuf::uint32 block_id_;
  ::google::protobuf::uint32 trip_id_;
  ::std::string* short_name_;
  ::std::string* long_name_;
  ::std::string* headsign_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 text_color_;
  ::std::string* description_;
  ::std::string* operator_onestop_id_;
  ::std::string* operator_name_;
  ::std::string* operator_url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_TransitRouteInfo* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_Edge : public ::google::protobuf::Message {
 public:
  TripPath_Edge();
  virtual ~TripPath_Edge();

  TripPath_Edge(const TripPath_Edge& from);

  inline TripPath_Edge& operator=(const TripPath_Edge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_Edge& default_instance();

  void Swap(TripPath_Edge* other);

  // implements Message ----------------------------------------------

  TripPath_Edge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_Edge& from);
  void MergeFrom(const TripPath_Edge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const char* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // optional float length = 2;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 2;
  inline float length() const;
  inline void set_length(float value);

  // optional float speed = 3;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 3;
  inline float speed() const;
  inline void set_speed(float value);

  // optional .valhalla.odin.TripPath.RoadClass road_class = 4;
  inline bool has_road_class() const;
  inline void clear_road_class();
  static const int kRoadClassFieldNumber = 4;
  inline ::valhalla::odin::TripPath_RoadClass road_class() const;
  inline void set_road_class(::valhalla::odin::TripPath_RoadClass value);

  // optional uint32 begin_heading = 5;
  inline bool has_begin_heading() const;
  inline void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 5;
  inline ::google::protobuf::uint32 begin_heading() const;
  inline void set_begin_heading(::google::protobuf::uint32 value);

  // optional uint32 end_heading = 6;
  inline bool has_end_heading() const;
  inline void clear_end_heading();
  static const int kEndHeadingFieldNumber = 6;
  inline ::google::protobuf::uint32 end_heading() const;
  inline void set_end_heading(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 7;
  inline bool has_begin_shape_index() const;
  inline void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 begin_shape_index() const;
  inline void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 8;
  inline bool has_end_shape_index() const;
  inline void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 end_shape_index() const;
  inline void set_end_shape_index(::google::protobuf::uint32 value);

  // optional .valhalla.odin.TripPath.Traversability traversability = 9;
  inline bool has_traversability() const;
  inline void clear_traversability();
  static const int kTraversabilityFieldNumber = 9;
  inline ::valhalla::odin::TripPath_Traversability traversability() const;
  inline void set_traversability(::valhalla::odin::TripPath_Traversability value);

  // optional bool ramp = 10;
  inline bool has_ramp() const;
  inline void clear_ramp();
  static const int kRampFieldNumber = 10;
  inline bool ramp() const;
  inline void set_ramp(bool value);

  // optional bool turn_channel = 11;
  inline bool has_turn_channel() const;
  inline void clear_turn_channel();
  static const int kTurnChannelFieldNumber = 11;
  inline bool turn_channel() const;
  inline void set_turn_channel(bool value);

  // optional bool ferry = 12;
  inline bool has_ferry() const;
  inline void clear_ferry();
  static const int kFerryFieldNumber = 12;
  inline bool ferry() const;
  inline void set_ferry(bool value);

  // optional bool rail_ferry = 13;
  inline bool has_rail_ferry() const;
  inline void clear_rail_ferry();
  static const int kRailFerryFieldNumber = 13;
  inline bool rail_ferry() const;
  inline void set_rail_ferry(bool value);

  // optional bool toll = 14;
  inline bool has_toll() const;
  inline void clear_toll();
  static const int kTollFieldNumber = 14;
  inline bool toll() const;
  inline void set_toll(bool value);

  // optional bool unpaved = 15;
  inline bool has_unpaved() const;
  inline void clear_unpaved();
  static const int kUnpavedFieldNumber = 15;
  inline bool unpaved() const;
  inline void set_unpaved(bool value);

  // optional bool tunnel = 16;
  inline bool has_tunnel() const;
  inline void clear_tunnel();
  static const int kTunnelFieldNumber = 16;
  inline bool tunnel() const;
  inline void set_tunnel(bool value);

  // optional bool bridge = 17;
  inline bool has_bridge() const;
  inline void clear_bridge();
  static const int kBridgeFieldNumber = 17;
  inline bool bridge() const;
  inline void set_bridge(bool value);

  // optional bool roundabout = 18;
  inline bool has_roundabout() const;
  inline void clear_roundabout();
  static const int kRoundaboutFieldNumber = 18;
  inline bool roundabout() const;
  inline void set_roundabout(bool value);

  // optional bool internal_intersection = 19;
  inline bool has_internal_intersection() const;
  inline void clear_internal_intersection();
  static const int kInternalIntersectionFieldNumber = 19;
  inline bool internal_intersection() const;
  inline void set_internal_intersection(bool value);

  // optional uint32 end_node_index = 20;
  inline bool has_end_node_index() const;
  inline void clear_end_node_index();
  static const int kEndNodeIndexFieldNumber = 20;
  inline ::google::protobuf::uint32 end_node_index() const;
  inline void set_end_node_index(::google::protobuf::uint32 value);

  // optional .valhalla.odin.TripPath.Sign sign = 21;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 21;
  inline const ::valhalla::odin::TripPath_Sign& sign() const;
  inline ::valhalla::odin::TripPath_Sign* mutable_sign();
  inline ::valhalla::odin::TripPath_Sign* release_sign();
  inline void set_allocated_sign(::valhalla::odin::TripPath_Sign* sign);

  // optional .valhalla.odin.TripPath.TravelMode travel_mode = 22;
  inline bool has_travel_mode() const;
  inline void clear_travel_mode();
  static const int kTravelModeFieldNumber = 22;
  inline ::valhalla::odin::TripPath_TravelMode travel_mode() const;
  inline void set_travel_mode(::valhalla::odin::TripPath_TravelMode value);

  // optional .valhalla.odin.TripPath.VehicleType vehicle_type = 23;
  inline bool has_vehicle_type() const;
  inline void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 23;
  inline ::valhalla::odin::TripPath_VehicleType vehicle_type() const;
  inline void set_vehicle_type(::valhalla::odin::TripPath_VehicleType value);

  // optional .valhalla.odin.TripPath.PedestrianType pedestrian_type = 24;
  inline bool has_pedestrian_type() const;
  inline void clear_pedestrian_type();
  static const int kPedestrianTypeFieldNumber = 24;
  inline ::valhalla::odin::TripPath_PedestrianType pedestrian_type() const;
  inline void set_pedestrian_type(::valhalla::odin::TripPath_PedestrianType value);

  // optional .valhalla.odin.TripPath.BicycleType bicycle_type = 25;
  inline bool has_bicycle_type() const;
  inline void clear_bicycle_type();
  static const int kBicycleTypeFieldNumber = 25;
  inline ::valhalla::odin::TripPath_BicycleType bicycle_type() const;
  inline void set_bicycle_type(::valhalla::odin::TripPath_BicycleType value);

  // optional .valhalla.odin.TripPath.TransitType transit_type = 26;
  inline bool has_transit_type() const;
  inline void clear_transit_type();
  static const int kTransitTypeFieldNumber = 26;
  inline ::valhalla::odin::TripPath_TransitType transit_type() const;
  inline void set_transit_type(::valhalla::odin::TripPath_TransitType value);

  // optional bool drive_on_right = 27 [default = true];
  inline bool has_drive_on_right() const;
  inline void clear_drive_on_right();
  static const int kDriveOnRightFieldNumber = 27;
  inline bool drive_on_right() const;
  inline void set_drive_on_right(bool value);

  // optional bool road = 28;
  inline bool has_road() const;
  inline void clear_road();
  static const int kRoadFieldNumber = 28;
  inline bool road() const;
  inline void set_road(bool value);

  // optional bool track = 29;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 29;
  inline bool track() const;
  inline void set_track(bool value);

  // optional bool driveway = 30;
  inline bool has_driveway() const;
  inline void clear_driveway();
  static const int kDrivewayFieldNumber = 30;
  inline bool driveway() const;
  inline void set_driveway(bool value);

  // optional bool alley = 31;
  inline bool has_alley() const;
  inline void clear_alley();
  static const int kAlleyFieldNumber = 31;
  inline bool alley() const;
  inline void set_alley(bool value);

  // optional bool parking_aisle = 32;
  inline bool has_parking_aisle() const;
  inline void clear_parking_aisle();
  static const int kParkingAisleFieldNumber = 32;
  inline bool parking_aisle() const;
  inline void set_parking_aisle(bool value);

  // optional bool emergency_access = 33;
  inline bool has_emergency_access() const;
  inline void clear_emergency_access();
  static const int kEmergencyAccessFieldNumber = 33;
  inline bool emergency_access() const;
  inline void set_emergency_access(bool value);

  // optional bool drive_thru = 34;
  inline bool has_drive_thru() const;
  inline void clear_drive_thru();
  static const int kDriveThruFieldNumber = 34;
  inline bool drive_thru() const;
  inline void set_drive_thru(bool value);

  // optional bool culdesac = 35;
  inline bool has_culdesac() const;
  inline void clear_culdesac();
  static const int kCuldesacFieldNumber = 35;
  inline bool culdesac() const;
  inline void set_culdesac(bool value);

  // optional bool footway = 36;
  inline bool has_footway() const;
  inline void clear_footway();
  static const int kFootwayFieldNumber = 36;
  inline bool footway() const;
  inline void set_footway(bool value);

  // optional bool stairs = 37;
  inline bool has_stairs() const;
  inline void clear_stairs();
  static const int kStairsFieldNumber = 37;
  inline bool stairs() const;
  inline void set_stairs(bool value);

  // optional bool cycleway = 38;
  inline bool has_cycleway() const;
  inline void clear_cycleway();
  static const int kCyclewayFieldNumber = 38;
  inline bool cycleway() const;
  inline void set_cycleway(bool value);

  // optional bool mountain_bike = 39;
  inline bool has_mountain_bike() const;
  inline void clear_mountain_bike();
  static const int kMountainBikeFieldNumber = 39;
  inline bool mountain_bike() const;
  inline void set_mountain_bike(bool value);

  // optional bool rail = 40;
  inline bool has_rail() const;
  inline void clear_rail();
  static const int kRailFieldNumber = 40;
  inline bool rail() const;
  inline void set_rail(bool value);

  // optional bool bus = 41;
  inline bool has_bus() const;
  inline void clear_bus();
  static const int kBusFieldNumber = 41;
  inline bool bus() const;
  inline void set_bus(bool value);

  // optional bool transit_connection = 42;
  inline bool has_transit_connection() const;
  inline void clear_transit_connection();
  static const int kTransitConnectionFieldNumber = 42;
  inline bool transit_connection() const;
  inline void set_transit_connection(bool value);

  // optional bool other = 43;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 43;
  inline bool other() const;
  inline void set_other(bool value);

  // optional .valhalla.odin.TripPath.TransitRouteInfo transit_route_info = 44;
  inline bool has_transit_route_info() const;
  inline void clear_transit_route_info();
  static const int kTransitRouteInfoFieldNumber = 44;
  inline const ::valhalla::odin::TripPath_TransitRouteInfo& transit_route_info() const;
  inline ::valhalla::odin::TripPath_TransitRouteInfo* mutable_transit_route_info();
  inline ::valhalla::odin::TripPath_TransitRouteInfo* release_transit_route_info();
  inline void set_allocated_transit_route_info(::valhalla::odin::TripPath_TransitRouteInfo* transit_route_info);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.Edge)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_road_class();
  inline void clear_has_road_class();
  inline void set_has_begin_heading();
  inline void clear_has_begin_heading();
  inline void set_has_end_heading();
  inline void clear_has_end_heading();
  inline void set_has_begin_shape_index();
  inline void clear_has_begin_shape_index();
  inline void set_has_end_shape_index();
  inline void clear_has_end_shape_index();
  inline void set_has_traversability();
  inline void clear_has_traversability();
  inline void set_has_ramp();
  inline void clear_has_ramp();
  inline void set_has_turn_channel();
  inline void clear_has_turn_channel();
  inline void set_has_ferry();
  inline void clear_has_ferry();
  inline void set_has_rail_ferry();
  inline void clear_has_rail_ferry();
  inline void set_has_toll();
  inline void clear_has_toll();
  inline void set_has_unpaved();
  inline void clear_has_unpaved();
  inline void set_has_tunnel();
  inline void clear_has_tunnel();
  inline void set_has_bridge();
  inline void clear_has_bridge();
  inline void set_has_roundabout();
  inline void clear_has_roundabout();
  inline void set_has_internal_intersection();
  inline void clear_has_internal_intersection();
  inline void set_has_end_node_index();
  inline void clear_has_end_node_index();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_travel_mode();
  inline void clear_has_travel_mode();
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();
  inline void set_has_pedestrian_type();
  inline void clear_has_pedestrian_type();
  inline void set_has_bicycle_type();
  inline void clear_has_bicycle_type();
  inline void set_has_transit_type();
  inline void clear_has_transit_type();
  inline void set_has_drive_on_right();
  inline void clear_has_drive_on_right();
  inline void set_has_road();
  inline void clear_has_road();
  inline void set_has_track();
  inline void clear_has_track();
  inline void set_has_driveway();
  inline void clear_has_driveway();
  inline void set_has_alley();
  inline void clear_has_alley();
  inline void set_has_parking_aisle();
  inline void clear_has_parking_aisle();
  inline void set_has_emergency_access();
  inline void clear_has_emergency_access();
  inline void set_has_drive_thru();
  inline void clear_has_drive_thru();
  inline void set_has_culdesac();
  inline void clear_has_culdesac();
  inline void set_has_footway();
  inline void clear_has_footway();
  inline void set_has_stairs();
  inline void clear_has_stairs();
  inline void set_has_cycleway();
  inline void clear_has_cycleway();
  inline void set_has_mountain_bike();
  inline void clear_has_mountain_bike();
  inline void set_has_rail();
  inline void clear_has_rail();
  inline void set_has_bus();
  inline void clear_has_bus();
  inline void set_has_transit_connection();
  inline void clear_has_transit_connection();
  inline void set_has_other();
  inline void clear_has_other();
  inline void set_has_transit_route_info();
  inline void clear_has_transit_route_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  float length_;
  float speed_;
  int road_class_;
  ::google::protobuf::uint32 begin_heading_;
  ::google::protobuf::uint32 end_heading_;
  ::google::protobuf::uint32 begin_shape_index_;
  ::google::protobuf::uint32 end_shape_index_;
  int traversability_;
  bool ramp_;
  bool turn_channel_;
  bool ferry_;
  bool rail_ferry_;
  bool toll_;
  bool unpaved_;
  bool tunnel_;
  bool bridge_;
  ::valhalla::odin::TripPath_Sign* sign_;
  ::google::protobuf::uint32 end_node_index_;
  int travel_mode_;
  int vehicle_type_;
  bool roundabout_;
  bool internal_intersection_;
  bool drive_on_right_;
  bool road_;
  int pedestrian_type_;
  int bicycle_type_;
  int transit_type_;
  bool track_;
  bool driveway_;
  bool alley_;
  bool parking_aisle_;
  bool emergency_access_;
  bool drive_thru_;
  bool culdesac_;
  bool footway_;
  bool stairs_;
  bool cycleway_;
  bool mountain_bike_;
  bool rail_;
  ::valhalla::odin::TripPath_TransitRouteInfo* transit_route_info_;
  bool bus_;
  bool transit_connection_;
  bool other_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(44 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_Edge* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_IntersectingEdge : public ::google::protobuf::Message {
 public:
  TripPath_IntersectingEdge();
  virtual ~TripPath_IntersectingEdge();

  TripPath_IntersectingEdge(const TripPath_IntersectingEdge& from);

  inline TripPath_IntersectingEdge& operator=(const TripPath_IntersectingEdge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_IntersectingEdge& default_instance();

  void Swap(TripPath_IntersectingEdge* other);

  // implements Message ----------------------------------------------

  TripPath_IntersectingEdge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_IntersectingEdge& from);
  void MergeFrom(const TripPath_IntersectingEdge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 begin_heading = 1;
  inline bool has_begin_heading() const;
  inline void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 1;
  inline ::google::protobuf::uint32 begin_heading() const;
  inline void set_begin_heading(::google::protobuf::uint32 value);

  // optional bool prev_name_consistency = 2;
  inline bool has_prev_name_consistency() const;
  inline void clear_prev_name_consistency();
  static const int kPrevNameConsistencyFieldNumber = 2;
  inline bool prev_name_consistency() const;
  inline void set_prev_name_consistency(bool value);

  // optional bool curr_name_consistency = 3;
  inline bool has_curr_name_consistency() const;
  inline void clear_curr_name_consistency();
  static const int kCurrNameConsistencyFieldNumber = 3;
  inline bool curr_name_consistency() const;
  inline void set_curr_name_consistency(bool value);

  // optional .valhalla.odin.TripPath.Traversability driveability = 4;
  inline bool has_driveability() const;
  inline void clear_driveability();
  static const int kDriveabilityFieldNumber = 4;
  inline ::valhalla::odin::TripPath_Traversability driveability() const;
  inline void set_driveability(::valhalla::odin::TripPath_Traversability value);

  // optional .valhalla.odin.TripPath.Traversability cyclability = 5;
  inline bool has_cyclability() const;
  inline void clear_cyclability();
  static const int kCyclabilityFieldNumber = 5;
  inline ::valhalla::odin::TripPath_Traversability cyclability() const;
  inline void set_cyclability(::valhalla::odin::TripPath_Traversability value);

  // optional .valhalla.odin.TripPath.Traversability walkability = 6;
  inline bool has_walkability() const;
  inline void clear_walkability();
  static const int kWalkabilityFieldNumber = 6;
  inline ::valhalla::odin::TripPath_Traversability walkability() const;
  inline void set_walkability(::valhalla::odin::TripPath_Traversability value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.IntersectingEdge)
 private:
  inline void set_has_begin_heading();
  inline void clear_has_begin_heading();
  inline void set_has_prev_name_consistency();
  inline void clear_has_prev_name_consistency();
  inline void set_has_curr_name_consistency();
  inline void clear_has_curr_name_consistency();
  inline void set_has_driveability();
  inline void clear_has_driveability();
  inline void set_has_cyclability();
  inline void clear_has_cyclability();
  inline void set_has_walkability();
  inline void clear_has_walkability();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 begin_heading_;
  bool prev_name_consistency_;
  bool curr_name_consistency_;
  int driveability_;
  int cyclability_;
  int walkability_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_IntersectingEdge* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_TransitStopInfo : public ::google::protobuf::Message {
 public:
  TripPath_TransitStopInfo();
  virtual ~TripPath_TransitStopInfo();

  TripPath_TransitStopInfo(const TripPath_TransitStopInfo& from);

  inline TripPath_TransitStopInfo& operator=(const TripPath_TransitStopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_TransitStopInfo& default_instance();

  void Swap(TripPath_TransitStopInfo* other);

  // implements Message ----------------------------------------------

  TripPath_TransitStopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_TransitStopInfo& from);
  void MergeFrom(const TripPath_TransitStopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripPath_TransitStopInfo_Type Type;
  static const Type kStop = TripPath_TransitStopInfo_Type_kStop;
  static const Type kStation = TripPath_TransitStopInfo_Type_kStation;
  static inline bool Type_IsValid(int value) {
    return TripPath_TransitStopInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripPath_TransitStopInfo_Type_Type_MIN;
  static const Type Type_MAX =
    TripPath_TransitStopInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripPath_TransitStopInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TripPath_TransitStopInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TripPath_TransitStopInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TripPath_TransitStopInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripPath.TransitStopInfo.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::valhalla::odin::TripPath_TransitStopInfo_Type type() const;
  inline void set_type(::valhalla::odin::TripPath_TransitStopInfo_Type value);

  // optional string onestop_id = 2;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 2;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string arrival_date_time = 4;
  inline bool has_arrival_date_time() const;
  inline void clear_arrival_date_time();
  static const int kArrivalDateTimeFieldNumber = 4;
  inline const ::std::string& arrival_date_time() const;
  inline void set_arrival_date_time(const ::std::string& value);
  inline void set_arrival_date_time(const char* value);
  inline void set_arrival_date_time(const char* value, size_t size);
  inline ::std::string* mutable_arrival_date_time();
  inline ::std::string* release_arrival_date_time();
  inline void set_allocated_arrival_date_time(::std::string* arrival_date_time);

  // optional string departure_date_time = 5;
  inline bool has_departure_date_time() const;
  inline void clear_departure_date_time();
  static const int kDepartureDateTimeFieldNumber = 5;
  inline const ::std::string& departure_date_time() const;
  inline void set_departure_date_time(const ::std::string& value);
  inline void set_departure_date_time(const char* value);
  inline void set_departure_date_time(const char* value, size_t size);
  inline ::std::string* mutable_departure_date_time();
  inline ::std::string* release_departure_date_time();
  inline void set_allocated_departure_date_time(::std::string* departure_date_time);

  // optional bool is_parent_stop = 6;
  inline bool has_is_parent_stop() const;
  inline void clear_is_parent_stop();
  static const int kIsParentStopFieldNumber = 6;
  inline bool is_parent_stop() const;
  inline void set_is_parent_stop(bool value);

  // optional bool assumed_schedule = 7;
  inline bool has_assumed_schedule() const;
  inline void clear_assumed_schedule();
  static const int kAssumedScheduleFieldNumber = 7;
  inline bool assumed_schedule() const;
  inline void set_assumed_schedule(bool value);

  // optional .valhalla.odin.TripPath.LatLng ll = 8;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 8;
  inline const ::valhalla::odin::TripPath_LatLng& ll() const;
  inline ::valhalla::odin::TripPath_LatLng* mutable_ll();
  inline ::valhalla::odin::TripPath_LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::odin::TripPath_LatLng* ll);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.TransitStopInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_arrival_date_time();
  inline void clear_has_arrival_date_time();
  inline void set_has_departure_date_time();
  inline void clear_has_departure_date_time();
  inline void set_has_is_parent_stop();
  inline void clear_has_is_parent_stop();
  inline void set_has_assumed_schedule();
  inline void clear_has_assumed_schedule();
  inline void set_has_ll();
  inline void clear_has_ll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* onestop_id_;
  ::std::string* name_;
  ::std::string* arrival_date_time_;
  int type_;
  bool is_parent_stop_;
  bool assumed_schedule_;
  ::std::string* departure_date_time_;
  ::valhalla::odin::TripPath_LatLng* ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_TransitStopInfo* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_Node : public ::google::protobuf::Message {
 public:
  TripPath_Node();
  virtual ~TripPath_Node();

  TripPath_Node(const TripPath_Node& from);

  inline TripPath_Node& operator=(const TripPath_Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_Node& default_instance();

  void Swap(TripPath_Node* other);

  // implements Message ----------------------------------------------

  TripPath_Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_Node& from);
  void MergeFrom(const TripPath_Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripPath.Edge edge = 1;
  inline bool has_edge() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 1;
  inline const ::valhalla::odin::TripPath_Edge& edge() const;
  inline ::valhalla::odin::TripPath_Edge* mutable_edge();
  inline ::valhalla::odin::TripPath_Edge* release_edge();
  inline void set_allocated_edge(::valhalla::odin::TripPath_Edge* edge);

  // repeated .valhalla.odin.TripPath.IntersectingEdge intersecting_edge = 2;
  inline int intersecting_edge_size() const;
  inline void clear_intersecting_edge();
  static const int kIntersectingEdgeFieldNumber = 2;
  inline const ::valhalla::odin::TripPath_IntersectingEdge& intersecting_edge(int index) const;
  inline ::valhalla::odin::TripPath_IntersectingEdge* mutable_intersecting_edge(int index);
  inline ::valhalla::odin::TripPath_IntersectingEdge* add_intersecting_edge();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_IntersectingEdge >&
      intersecting_edge() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_IntersectingEdge >*
      mutable_intersecting_edge();

  // optional uint32 elapsed_time = 3;
  inline bool has_elapsed_time() const;
  inline void clear_elapsed_time();
  static const int kElapsedTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 elapsed_time() const;
  inline void set_elapsed_time(::google::protobuf::uint32 value);

  // optional uint32 admin_index = 4;
  inline bool has_admin_index() const;
  inline void clear_admin_index();
  static const int kAdminIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 admin_index() const;
  inline void set_admin_index(::google::protobuf::uint32 value);

  // optional bool street_intersection = 5;
  inline bool has_street_intersection() const;
  inline void clear_street_intersection();
  static const int kStreetIntersectionFieldNumber = 5;
  inline bool street_intersection() const;
  inline void set_street_intersection(bool value);

  // optional bool gate = 6;
  inline bool has_gate() const;
  inline void clear_gate();
  static const int kGateFieldNumber = 6;
  inline bool gate() const;
  inline void set_gate(bool value);

  // optional bool bollard = 7;
  inline bool has_bollard() const;
  inline void clear_bollard();
  static const int kBollardFieldNumber = 7;
  inline bool bollard() const;
  inline void set_bollard(bool value);

  // optional bool toll_booth = 8;
  inline bool has_toll_booth() const;
  inline void clear_toll_booth();
  static const int kTollBoothFieldNumber = 8;
  inline bool toll_booth() const;
  inline void set_toll_booth(bool value);

  // optional bool bike_share = 9;
  inline bool has_bike_share() const;
  inline void clear_bike_share();
  static const int kBikeShareFieldNumber = 9;
  inline bool bike_share() const;
  inline void set_bike_share(bool value);

  // optional bool parking = 10;
  inline bool has_parking() const;
  inline void clear_parking();
  static const int kParkingFieldNumber = 10;
  inline bool parking() const;
  inline void set_parking(bool value);

  // optional bool motorway_junction = 11;
  inline bool has_motorway_junction() const;
  inline void clear_motorway_junction();
  static const int kMotorwayJunctionFieldNumber = 11;
  inline bool motorway_junction() const;
  inline void set_motorway_junction(bool value);

  // optional bool fork = 12;
  inline bool has_fork() const;
  inline void clear_fork();
  static const int kForkFieldNumber = 12;
  inline bool fork() const;
  inline void set_fork(bool value);

  // optional .valhalla.odin.TripPath.TransitStopInfo transit_stop_info = 13;
  inline bool has_transit_stop_info() const;
  inline void clear_transit_stop_info();
  static const int kTransitStopInfoFieldNumber = 13;
  inline const ::valhalla::odin::TripPath_TransitStopInfo& transit_stop_info() const;
  inline ::valhalla::odin::TripPath_TransitStopInfo* mutable_transit_stop_info();
  inline ::valhalla::odin::TripPath_TransitStopInfo* release_transit_stop_info();
  inline void set_allocated_transit_stop_info(::valhalla::odin::TripPath_TransitStopInfo* transit_stop_info);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.Node)
 private:
  inline void set_has_edge();
  inline void clear_has_edge();
  inline void set_has_elapsed_time();
  inline void clear_has_elapsed_time();
  inline void set_has_admin_index();
  inline void clear_has_admin_index();
  inline void set_has_street_intersection();
  inline void clear_has_street_intersection();
  inline void set_has_gate();
  inline void clear_has_gate();
  inline void set_has_bollard();
  inline void clear_has_bollard();
  inline void set_has_toll_booth();
  inline void clear_has_toll_booth();
  inline void set_has_bike_share();
  inline void clear_has_bike_share();
  inline void set_has_parking();
  inline void clear_has_parking();
  inline void set_has_motorway_junction();
  inline void clear_has_motorway_junction();
  inline void set_has_fork();
  inline void clear_has_fork();
  inline void set_has_transit_stop_info();
  inline void clear_has_transit_stop_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::TripPath_Edge* edge_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_IntersectingEdge > intersecting_edge_;
  ::google::protobuf::uint32 elapsed_time_;
  ::google::protobuf::uint32 admin_index_;
  bool street_intersection_;
  bool gate_;
  bool bollard_;
  bool toll_booth_;
  bool bike_share_;
  bool parking_;
  bool motorway_junction_;
  bool fork_;
  ::valhalla::odin::TripPath_TransitStopInfo* transit_stop_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_Node* default_instance_;
};
// -------------------------------------------------------------------

class TripPath_Admin : public ::google::protobuf::Message {
 public:
  TripPath_Admin();
  virtual ~TripPath_Admin();

  TripPath_Admin(const TripPath_Admin& from);

  inline TripPath_Admin& operator=(const TripPath_Admin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath_Admin& default_instance();

  void Swap(TripPath_Admin* other);

  // implements Message ----------------------------------------------

  TripPath_Admin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath_Admin& from);
  void MergeFrom(const TripPath_Admin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string country_code = 1;
  inline bool has_country_code() const;
  inline void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  inline const ::std::string& country_code() const;
  inline void set_country_code(const ::std::string& value);
  inline void set_country_code(const char* value);
  inline void set_country_code(const char* value, size_t size);
  inline ::std::string* mutable_country_code();
  inline ::std::string* release_country_code();
  inline void set_allocated_country_code(::std::string* country_code);

  // optional string country_text = 2;
  inline bool has_country_text() const;
  inline void clear_country_text();
  static const int kCountryTextFieldNumber = 2;
  inline const ::std::string& country_text() const;
  inline void set_country_text(const ::std::string& value);
  inline void set_country_text(const char* value);
  inline void set_country_text(const char* value, size_t size);
  inline ::std::string* mutable_country_text();
  inline ::std::string* release_country_text();
  inline void set_allocated_country_text(::std::string* country_text);

  // optional string state_code = 3;
  inline bool has_state_code() const;
  inline void clear_state_code();
  static const int kStateCodeFieldNumber = 3;
  inline const ::std::string& state_code() const;
  inline void set_state_code(const ::std::string& value);
  inline void set_state_code(const char* value);
  inline void set_state_code(const char* value, size_t size);
  inline ::std::string* mutable_state_code();
  inline ::std::string* release_state_code();
  inline void set_allocated_state_code(::std::string* state_code);

  // optional string state_text = 4;
  inline bool has_state_text() const;
  inline void clear_state_text();
  static const int kStateTextFieldNumber = 4;
  inline const ::std::string& state_text() const;
  inline void set_state_text(const ::std::string& value);
  inline void set_state_text(const char* value);
  inline void set_state_text(const char* value, size_t size);
  inline ::std::string* mutable_state_text();
  inline ::std::string* release_state_text();
  inline void set_allocated_state_text(::std::string* state_text);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath.Admin)
 private:
  inline void set_has_country_code();
  inline void clear_has_country_code();
  inline void set_has_country_text();
  inline void clear_has_country_text();
  inline void set_has_state_code();
  inline void clear_has_state_code();
  inline void set_has_state_text();
  inline void clear_has_state_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* country_code_;
  ::std::string* country_text_;
  ::std::string* state_code_;
  ::std::string* state_text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath_Admin* default_instance_;
};
// -------------------------------------------------------------------

class TripPath : public ::google::protobuf::Message {
 public:
  TripPath();
  virtual ~TripPath();

  TripPath(const TripPath& from);

  inline TripPath& operator=(const TripPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripPath& default_instance();

  void Swap(TripPath* other);

  // implements Message ----------------------------------------------

  TripPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripPath& from);
  void MergeFrom(const TripPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripPath_LatLng LatLng;
  typedef TripPath_BoundingBox BoundingBox;
  typedef TripPath_Location Location;
  typedef TripPath_Sign Sign;
  typedef TripPath_TransitRouteInfo TransitRouteInfo;
  typedef TripPath_Edge Edge;
  typedef TripPath_IntersectingEdge IntersectingEdge;
  typedef TripPath_TransitStopInfo TransitStopInfo;
  typedef TripPath_Node Node;
  typedef TripPath_Admin Admin;

  typedef TripPath_Traversability Traversability;
  static const Traversability kNone = TripPath_Traversability_kNone;
  static const Traversability kForward = TripPath_Traversability_kForward;
  static const Traversability kBackward = TripPath_Traversability_kBackward;
  static const Traversability kBoth = TripPath_Traversability_kBoth;
  static inline bool Traversability_IsValid(int value) {
    return TripPath_Traversability_IsValid(value);
  }
  static const Traversability Traversability_MIN =
    TripPath_Traversability_Traversability_MIN;
  static const Traversability Traversability_MAX =
    TripPath_Traversability_Traversability_MAX;
  static const int Traversability_ARRAYSIZE =
    TripPath_Traversability_Traversability_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Traversability_descriptor() {
    return TripPath_Traversability_descriptor();
  }
  static inline const ::std::string& Traversability_Name(Traversability value) {
    return TripPath_Traversability_Name(value);
  }
  static inline bool Traversability_Parse(const ::std::string& name,
      Traversability* value) {
    return TripPath_Traversability_Parse(name, value);
  }

  typedef TripPath_RoadClass RoadClass;
  static const RoadClass kMotorway = TripPath_RoadClass_kMotorway;
  static const RoadClass kTrunk = TripPath_RoadClass_kTrunk;
  static const RoadClass kPrimary = TripPath_RoadClass_kPrimary;
  static const RoadClass kSecondary = TripPath_RoadClass_kSecondary;
  static const RoadClass kTertiary = TripPath_RoadClass_kTertiary;
  static const RoadClass kUnclassified = TripPath_RoadClass_kUnclassified;
  static const RoadClass kResidential = TripPath_RoadClass_kResidential;
  static const RoadClass kServiceOther = TripPath_RoadClass_kServiceOther;
  static inline bool RoadClass_IsValid(int value) {
    return TripPath_RoadClass_IsValid(value);
  }
  static const RoadClass RoadClass_MIN =
    TripPath_RoadClass_RoadClass_MIN;
  static const RoadClass RoadClass_MAX =
    TripPath_RoadClass_RoadClass_MAX;
  static const int RoadClass_ARRAYSIZE =
    TripPath_RoadClass_RoadClass_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RoadClass_descriptor() {
    return TripPath_RoadClass_descriptor();
  }
  static inline const ::std::string& RoadClass_Name(RoadClass value) {
    return TripPath_RoadClass_Name(value);
  }
  static inline bool RoadClass_Parse(const ::std::string& name,
      RoadClass* value) {
    return TripPath_RoadClass_Parse(name, value);
  }

  typedef TripPath_TravelMode TravelMode;
  static const TravelMode kDrive = TripPath_TravelMode_kDrive;
  static const TravelMode kPedestrian = TripPath_TravelMode_kPedestrian;
  static const TravelMode kBicycle = TripPath_TravelMode_kBicycle;
  static const TravelMode kTransit = TripPath_TravelMode_kTransit;
  static inline bool TravelMode_IsValid(int value) {
    return TripPath_TravelMode_IsValid(value);
  }
  static const TravelMode TravelMode_MIN =
    TripPath_TravelMode_TravelMode_MIN;
  static const TravelMode TravelMode_MAX =
    TripPath_TravelMode_TravelMode_MAX;
  static const int TravelMode_ARRAYSIZE =
    TripPath_TravelMode_TravelMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TravelMode_descriptor() {
    return TripPath_TravelMode_descriptor();
  }
  static inline const ::std::string& TravelMode_Name(TravelMode value) {
    return TripPath_TravelMode_Name(value);
  }
  static inline bool TravelMode_Parse(const ::std::string& name,
      TravelMode* value) {
    return TripPath_TravelMode_Parse(name, value);
  }

  typedef TripPath_VehicleType VehicleType;
  static const VehicleType kCar = TripPath_VehicleType_kCar;
  static const VehicleType kMotorcycle = TripPath_VehicleType_kMotorcycle;
  static const VehicleType kFourWheelDrive = TripPath_VehicleType_kFourWheelDrive;
  static const VehicleType kTractorTrailers = TripPath_VehicleType_kTractorTrailers;
  static inline bool VehicleType_IsValid(int value) {
    return TripPath_VehicleType_IsValid(value);
  }
  static const VehicleType VehicleType_MIN =
    TripPath_VehicleType_VehicleType_MIN;
  static const VehicleType VehicleType_MAX =
    TripPath_VehicleType_VehicleType_MAX;
  static const int VehicleType_ARRAYSIZE =
    TripPath_VehicleType_VehicleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VehicleType_descriptor() {
    return TripPath_VehicleType_descriptor();
  }
  static inline const ::std::string& VehicleType_Name(VehicleType value) {
    return TripPath_VehicleType_Name(value);
  }
  static inline bool VehicleType_Parse(const ::std::string& name,
      VehicleType* value) {
    return TripPath_VehicleType_Parse(name, value);
  }

  typedef TripPath_PedestrianType PedestrianType;
  static const PedestrianType kFoot = TripPath_PedestrianType_kFoot;
  static const PedestrianType kWheelChair = TripPath_PedestrianType_kWheelChair;
  static const PedestrianType kSegway = TripPath_PedestrianType_kSegway;
  static inline bool PedestrianType_IsValid(int value) {
    return TripPath_PedestrianType_IsValid(value);
  }
  static const PedestrianType PedestrianType_MIN =
    TripPath_PedestrianType_PedestrianType_MIN;
  static const PedestrianType PedestrianType_MAX =
    TripPath_PedestrianType_PedestrianType_MAX;
  static const int PedestrianType_ARRAYSIZE =
    TripPath_PedestrianType_PedestrianType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PedestrianType_descriptor() {
    return TripPath_PedestrianType_descriptor();
  }
  static inline const ::std::string& PedestrianType_Name(PedestrianType value) {
    return TripPath_PedestrianType_Name(value);
  }
  static inline bool PedestrianType_Parse(const ::std::string& name,
      PedestrianType* value) {
    return TripPath_PedestrianType_Parse(name, value);
  }

  typedef TripPath_BicycleType BicycleType;
  static const BicycleType kRoad = TripPath_BicycleType_kRoad;
  static const BicycleType kHybrid = TripPath_BicycleType_kHybrid;
  static const BicycleType kCity = TripPath_BicycleType_kCity;
  static const BicycleType kCross = TripPath_BicycleType_kCross;
  static const BicycleType kMountain = TripPath_BicycleType_kMountain;
  static inline bool BicycleType_IsValid(int value) {
    return TripPath_BicycleType_IsValid(value);
  }
  static const BicycleType BicycleType_MIN =
    TripPath_BicycleType_BicycleType_MIN;
  static const BicycleType BicycleType_MAX =
    TripPath_BicycleType_BicycleType_MAX;
  static const int BicycleType_ARRAYSIZE =
    TripPath_BicycleType_BicycleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BicycleType_descriptor() {
    return TripPath_BicycleType_descriptor();
  }
  static inline const ::std::string& BicycleType_Name(BicycleType value) {
    return TripPath_BicycleType_Name(value);
  }
  static inline bool BicycleType_Parse(const ::std::string& name,
      BicycleType* value) {
    return TripPath_BicycleType_Parse(name, value);
  }

  typedef TripPath_TransitType TransitType;
  static const TransitType kTram = TripPath_TransitType_kTram;
  static const TransitType kMetro = TripPath_TransitType_kMetro;
  static const TransitType kRail = TripPath_TransitType_kRail;
  static const TransitType kBus = TripPath_TransitType_kBus;
  static const TransitType kFerry = TripPath_TransitType_kFerry;
  static const TransitType kCableCar = TripPath_TransitType_kCableCar;
  static const TransitType kGondola = TripPath_TransitType_kGondola;
  static const TransitType kFunicular = TripPath_TransitType_kFunicular;
  static inline bool TransitType_IsValid(int value) {
    return TripPath_TransitType_IsValid(value);
  }
  static const TransitType TransitType_MIN =
    TripPath_TransitType_TransitType_MIN;
  static const TransitType TransitType_MAX =
    TripPath_TransitType_TransitType_MAX;
  static const int TransitType_ARRAYSIZE =
    TripPath_TransitType_TransitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransitType_descriptor() {
    return TripPath_TransitType_descriptor();
  }
  static inline const ::std::string& TransitType_Name(TransitType value) {
    return TripPath_TransitType_Name(value);
  }
  static inline bool TransitType_Parse(const ::std::string& name,
      TransitType* value) {
    return TripPath_TransitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 trip_id = 1;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  inline ::google::protobuf::uint64 trip_id() const;
  inline void set_trip_id(::google::protobuf::uint64 value);

  // optional uint32 leg_id = 2;
  inline bool has_leg_id() const;
  inline void clear_leg_id();
  static const int kLegIdFieldNumber = 2;
  inline ::google::protobuf::uint32 leg_id() const;
  inline void set_leg_id(::google::protobuf::uint32 value);

  // optional uint32 leg_count = 3;
  inline bool has_leg_count() const;
  inline void clear_leg_count();
  static const int kLegCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leg_count() const;
  inline void set_leg_count(::google::protobuf::uint32 value);

  // repeated .valhalla.odin.TripPath.Location location = 4;
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::valhalla::odin::TripPath_Location& location(int index) const;
  inline ::valhalla::odin::TripPath_Location* mutable_location(int index);
  inline ::valhalla::odin::TripPath_Location* add_location();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Location >&
      location() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Location >*
      mutable_location();

  // repeated .valhalla.odin.TripPath.Node node = 5;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 5;
  inline const ::valhalla::odin::TripPath_Node& node(int index) const;
  inline ::valhalla::odin::TripPath_Node* mutable_node(int index);
  inline ::valhalla::odin::TripPath_Node* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Node >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Node >*
      mutable_node();

  // repeated .valhalla.odin.TripPath.Admin admin = 6;
  inline int admin_size() const;
  inline void clear_admin();
  static const int kAdminFieldNumber = 6;
  inline const ::valhalla::odin::TripPath_Admin& admin(int index) const;
  inline ::valhalla::odin::TripPath_Admin* mutable_admin(int index);
  inline ::valhalla::odin::TripPath_Admin* add_admin();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Admin >&
      admin() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Admin >*
      mutable_admin();

  // optional string shape = 7;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 7;
  inline const ::std::string& shape() const;
  inline void set_shape(const ::std::string& value);
  inline void set_shape(const char* value);
  inline void set_shape(const char* value, size_t size);
  inline ::std::string* mutable_shape();
  inline ::std::string* release_shape();
  inline void set_allocated_shape(::std::string* shape);

  // optional .valhalla.odin.TripPath.BoundingBox bbox = 8;
  inline bool has_bbox() const;
  inline void clear_bbox();
  static const int kBboxFieldNumber = 8;
  inline const ::valhalla::odin::TripPath_BoundingBox& bbox() const;
  inline ::valhalla::odin::TripPath_BoundingBox* mutable_bbox();
  inline ::valhalla::odin::TripPath_BoundingBox* release_bbox();
  inline void set_allocated_bbox(::valhalla::odin::TripPath_BoundingBox* bbox);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripPath)
 private:
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_leg_id();
  inline void clear_has_leg_id();
  inline void set_has_leg_count();
  inline void clear_has_leg_count();
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_bbox();
  inline void clear_has_bbox();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 trip_id_;
  ::google::protobuf::uint32 leg_id_;
  ::google::protobuf::uint32 leg_count_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Location > location_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Node > node_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Admin > admin_;
  ::std::string* shape_;
  ::valhalla::odin::TripPath_BoundingBox* bbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_trippath_2eproto();
  friend void protobuf_AssignDesc_trippath_2eproto();
  friend void protobuf_ShutdownFile_trippath_2eproto();

  void InitAsDefaultInstance();
  static TripPath* default_instance_;
};
// ===================================================================


// ===================================================================

// TripPath_LatLng

// optional float lat = 1;
inline bool TripPath_LatLng::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_LatLng::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_LatLng::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_LatLng::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float TripPath_LatLng::lat() const {
  return lat_;
}
inline void TripPath_LatLng::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lng = 2;
inline bool TripPath_LatLng::has_lng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_LatLng::set_has_lng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_LatLng::clear_has_lng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_LatLng::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline float TripPath_LatLng::lng() const {
  return lng_;
}
inline void TripPath_LatLng::set_lng(float value) {
  set_has_lng();
  lng_ = value;
}

// -------------------------------------------------------------------

// TripPath_BoundingBox

// optional .valhalla.odin.TripPath.LatLng min_ll = 1;
inline bool TripPath_BoundingBox::has_min_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_BoundingBox::set_has_min_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_BoundingBox::clear_has_min_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_BoundingBox::clear_min_ll() {
  if (min_ll_ != NULL) min_ll_->::valhalla::odin::TripPath_LatLng::Clear();
  clear_has_min_ll();
}
inline const ::valhalla::odin::TripPath_LatLng& TripPath_BoundingBox::min_ll() const {
  return min_ll_ != NULL ? *min_ll_ : *default_instance_->min_ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_BoundingBox::mutable_min_ll() {
  set_has_min_ll();
  if (min_ll_ == NULL) min_ll_ = new ::valhalla::odin::TripPath_LatLng;
  return min_ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_BoundingBox::release_min_ll() {
  clear_has_min_ll();
  ::valhalla::odin::TripPath_LatLng* temp = min_ll_;
  min_ll_ = NULL;
  return temp;
}
inline void TripPath_BoundingBox::set_allocated_min_ll(::valhalla::odin::TripPath_LatLng* min_ll) {
  delete min_ll_;
  min_ll_ = min_ll;
  if (min_ll) {
    set_has_min_ll();
  } else {
    clear_has_min_ll();
  }
}

// optional .valhalla.odin.TripPath.LatLng max_ll = 2;
inline bool TripPath_BoundingBox::has_max_ll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_BoundingBox::set_has_max_ll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_BoundingBox::clear_has_max_ll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_BoundingBox::clear_max_ll() {
  if (max_ll_ != NULL) max_ll_->::valhalla::odin::TripPath_LatLng::Clear();
  clear_has_max_ll();
}
inline const ::valhalla::odin::TripPath_LatLng& TripPath_BoundingBox::max_ll() const {
  return max_ll_ != NULL ? *max_ll_ : *default_instance_->max_ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_BoundingBox::mutable_max_ll() {
  set_has_max_ll();
  if (max_ll_ == NULL) max_ll_ = new ::valhalla::odin::TripPath_LatLng;
  return max_ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_BoundingBox::release_max_ll() {
  clear_has_max_ll();
  ::valhalla::odin::TripPath_LatLng* temp = max_ll_;
  max_ll_ = NULL;
  return temp;
}
inline void TripPath_BoundingBox::set_allocated_max_ll(::valhalla::odin::TripPath_LatLng* max_ll) {
  delete max_ll_;
  max_ll_ = max_ll;
  if (max_ll) {
    set_has_max_ll();
  } else {
    clear_has_max_ll();
  }
}

// -------------------------------------------------------------------

// TripPath_Location

// optional .valhalla.odin.TripPath.LatLng ll = 1;
inline bool TripPath_Location::has_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_Location::set_has_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_Location::clear_has_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_Location::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::odin::TripPath_LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::odin::TripPath_LatLng& TripPath_Location::ll() const {
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_Location::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::odin::TripPath_LatLng;
  return ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_Location::release_ll() {
  clear_has_ll();
  ::valhalla::odin::TripPath_LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TripPath_Location::set_allocated_ll(::valhalla::odin::TripPath_LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// optional .valhalla.odin.TripPath.Location.Type type = 2;
inline bool TripPath_Location::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_Location::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_Location::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_Location::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::odin::TripPath_Location_Type TripPath_Location::type() const {
  return static_cast< ::valhalla::odin::TripPath_Location_Type >(type_);
}
inline void TripPath_Location::set_type(::valhalla::odin::TripPath_Location_Type value) {
  assert(::valhalla::odin::TripPath_Location_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 heading = 3;
inline bool TripPath_Location::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_Location::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_Location::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_Location::clear_heading() {
  heading_ = 0u;
  clear_has_heading();
}
inline ::google::protobuf::uint32 TripPath_Location::heading() const {
  return heading_;
}
inline void TripPath_Location::set_heading(::google::protobuf::uint32 value) {
  set_has_heading();
  heading_ = value;
}

// optional string name = 4;
inline bool TripPath_Location::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_Location::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_Location::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_Location::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TripPath_Location::name() const {
  return *name_;
}
inline void TripPath_Location::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripPath_Location::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripPath_Location::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TripPath_Location::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string street = 5;
inline bool TripPath_Location::has_street() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripPath_Location::set_has_street() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripPath_Location::clear_has_street() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripPath_Location::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& TripPath_Location::street() const {
  return *street_;
}
inline void TripPath_Location::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void TripPath_Location::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void TripPath_Location::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* TripPath_Location::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 6;
inline bool TripPath_Location::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripPath_Location::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripPath_Location::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripPath_Location::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& TripPath_Location::city() const {
  return *city_;
}
inline void TripPath_Location::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void TripPath_Location::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void TripPath_Location::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* TripPath_Location::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 7;
inline bool TripPath_Location::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripPath_Location::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripPath_Location::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripPath_Location::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& TripPath_Location::state() const {
  return *state_;
}
inline void TripPath_Location::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void TripPath_Location::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void TripPath_Location::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* TripPath_Location::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string postal_code = 8;
inline bool TripPath_Location::has_postal_code() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripPath_Location::set_has_postal_code() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripPath_Location::clear_has_postal_code() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripPath_Location::clear_postal_code() {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    postal_code_->clear();
  }
  clear_has_postal_code();
}
inline const ::std::string& TripPath_Location::postal_code() const {
  return *postal_code_;
}
inline void TripPath_Location::set_postal_code(const ::std::string& value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void TripPath_Location::set_postal_code(const char* value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void TripPath_Location::set_postal_code(const char* value, size_t size) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_postal_code() {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  return postal_code_;
}
inline ::std::string* TripPath_Location::release_postal_code() {
  clear_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postal_code_;
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_postal_code(::std::string* postal_code) {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    delete postal_code_;
  }
  if (postal_code) {
    set_has_postal_code();
    postal_code_ = postal_code;
  } else {
    clear_has_postal_code();
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country = 9;
inline bool TripPath_Location::has_country() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripPath_Location::set_has_country() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripPath_Location::clear_has_country() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripPath_Location::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& TripPath_Location::country() const {
  return *country_;
}
inline void TripPath_Location::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void TripPath_Location::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void TripPath_Location::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* TripPath_Location::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date_time = 10;
inline bool TripPath_Location::has_date_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripPath_Location::set_has_date_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripPath_Location::clear_has_date_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripPath_Location::clear_date_time() {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    date_time_->clear();
  }
  clear_has_date_time();
}
inline const ::std::string& TripPath_Location::date_time() const {
  return *date_time_;
}
inline void TripPath_Location::set_date_time(const ::std::string& value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void TripPath_Location::set_date_time(const char* value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void TripPath_Location::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Location::mutable_date_time() {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  return date_time_;
}
inline ::std::string* TripPath_Location::release_date_time() {
  clear_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_;
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Location::set_allocated_date_time(::std::string* date_time) {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_;
  }
  if (date_time) {
    set_has_date_time();
    date_time_ = date_time;
  } else {
    clear_has_date_time();
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.odin.TripPath.Location.SideOfStreet side_of_street = 11;
inline bool TripPath_Location::has_side_of_street() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripPath_Location::set_has_side_of_street() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripPath_Location::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripPath_Location::clear_side_of_street() {
  side_of_street_ = 0;
  clear_has_side_of_street();
}
inline ::valhalla::odin::TripPath_Location_SideOfStreet TripPath_Location::side_of_street() const {
  return static_cast< ::valhalla::odin::TripPath_Location_SideOfStreet >(side_of_street_);
}
inline void TripPath_Location::set_side_of_street(::valhalla::odin::TripPath_Location_SideOfStreet value) {
  assert(::valhalla::odin::TripPath_Location_SideOfStreet_IsValid(value));
  set_has_side_of_street();
  side_of_street_ = value;
}

// -------------------------------------------------------------------

// TripPath_Sign

// repeated string exit_number = 1;
inline int TripPath_Sign::exit_number_size() const {
  return exit_number_.size();
}
inline void TripPath_Sign::clear_exit_number() {
  exit_number_.Clear();
}
inline const ::std::string& TripPath_Sign::exit_number(int index) const {
  return exit_number_.Get(index);
}
inline ::std::string* TripPath_Sign::mutable_exit_number(int index) {
  return exit_number_.Mutable(index);
}
inline void TripPath_Sign::set_exit_number(int index, const ::std::string& value) {
  exit_number_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_number(int index, const char* value) {
  exit_number_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_number(int index, const char* value, size_t size) {
  exit_number_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Sign::add_exit_number() {
  return exit_number_.Add();
}
inline void TripPath_Sign::add_exit_number(const ::std::string& value) {
  exit_number_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_number(const char* value) {
  exit_number_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_number(const char* value, size_t size) {
  exit_number_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripPath_Sign::exit_number() const {
  return exit_number_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripPath_Sign::mutable_exit_number() {
  return &exit_number_;
}

// repeated string exit_branch = 2;
inline int TripPath_Sign::exit_branch_size() const {
  return exit_branch_.size();
}
inline void TripPath_Sign::clear_exit_branch() {
  exit_branch_.Clear();
}
inline const ::std::string& TripPath_Sign::exit_branch(int index) const {
  return exit_branch_.Get(index);
}
inline ::std::string* TripPath_Sign::mutable_exit_branch(int index) {
  return exit_branch_.Mutable(index);
}
inline void TripPath_Sign::set_exit_branch(int index, const ::std::string& value) {
  exit_branch_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_branch(int index, const char* value) {
  exit_branch_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_branch(int index, const char* value, size_t size) {
  exit_branch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Sign::add_exit_branch() {
  return exit_branch_.Add();
}
inline void TripPath_Sign::add_exit_branch(const ::std::string& value) {
  exit_branch_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_branch(const char* value) {
  exit_branch_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_branch(const char* value, size_t size) {
  exit_branch_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripPath_Sign::exit_branch() const {
  return exit_branch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripPath_Sign::mutable_exit_branch() {
  return &exit_branch_;
}

// repeated string exit_toward = 3;
inline int TripPath_Sign::exit_toward_size() const {
  return exit_toward_.size();
}
inline void TripPath_Sign::clear_exit_toward() {
  exit_toward_.Clear();
}
inline const ::std::string& TripPath_Sign::exit_toward(int index) const {
  return exit_toward_.Get(index);
}
inline ::std::string* TripPath_Sign::mutable_exit_toward(int index) {
  return exit_toward_.Mutable(index);
}
inline void TripPath_Sign::set_exit_toward(int index, const ::std::string& value) {
  exit_toward_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_toward(int index, const char* value) {
  exit_toward_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_toward(int index, const char* value, size_t size) {
  exit_toward_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Sign::add_exit_toward() {
  return exit_toward_.Add();
}
inline void TripPath_Sign::add_exit_toward(const ::std::string& value) {
  exit_toward_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_toward(const char* value) {
  exit_toward_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_toward(const char* value, size_t size) {
  exit_toward_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripPath_Sign::exit_toward() const {
  return exit_toward_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripPath_Sign::mutable_exit_toward() {
  return &exit_toward_;
}

// repeated string exit_name = 4;
inline int TripPath_Sign::exit_name_size() const {
  return exit_name_.size();
}
inline void TripPath_Sign::clear_exit_name() {
  exit_name_.Clear();
}
inline const ::std::string& TripPath_Sign::exit_name(int index) const {
  return exit_name_.Get(index);
}
inline ::std::string* TripPath_Sign::mutable_exit_name(int index) {
  return exit_name_.Mutable(index);
}
inline void TripPath_Sign::set_exit_name(int index, const ::std::string& value) {
  exit_name_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_name(int index, const char* value) {
  exit_name_.Mutable(index)->assign(value);
}
inline void TripPath_Sign::set_exit_name(int index, const char* value, size_t size) {
  exit_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Sign::add_exit_name() {
  return exit_name_.Add();
}
inline void TripPath_Sign::add_exit_name(const ::std::string& value) {
  exit_name_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_name(const char* value) {
  exit_name_.Add()->assign(value);
}
inline void TripPath_Sign::add_exit_name(const char* value, size_t size) {
  exit_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripPath_Sign::exit_name() const {
  return exit_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripPath_Sign::mutable_exit_name() {
  return &exit_name_;
}

// -------------------------------------------------------------------

// TripPath_TransitRouteInfo

// optional string onestop_id = 1;
inline bool TripPath_TransitRouteInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_TransitRouteInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_TransitRouteInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TripPath_TransitRouteInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TripPath_TransitRouteInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 block_id = 2;
inline bool TripPath_TransitRouteInfo::has_block_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_block_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_TransitRouteInfo::clear_has_block_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_TransitRouteInfo::clear_block_id() {
  block_id_ = 0u;
  clear_has_block_id();
}
inline ::google::protobuf::uint32 TripPath_TransitRouteInfo::block_id() const {
  return block_id_;
}
inline void TripPath_TransitRouteInfo::set_block_id(::google::protobuf::uint32 value) {
  set_has_block_id();
  block_id_ = value;
}

// optional uint32 trip_id = 3;
inline bool TripPath_TransitRouteInfo::has_trip_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_trip_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_TransitRouteInfo::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_TransitRouteInfo::clear_trip_id() {
  trip_id_ = 0u;
  clear_has_trip_id();
}
inline ::google::protobuf::uint32 TripPath_TransitRouteInfo::trip_id() const {
  return trip_id_;
}
inline void TripPath_TransitRouteInfo::set_trip_id(::google::protobuf::uint32 value) {
  set_has_trip_id();
  trip_id_ = value;
}

// optional string short_name = 4;
inline bool TripPath_TransitRouteInfo::has_short_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_short_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_TransitRouteInfo::clear_has_short_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_TransitRouteInfo::clear_short_name() {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    short_name_->clear();
  }
  clear_has_short_name();
}
inline const ::std::string& TripPath_TransitRouteInfo::short_name() const {
  return *short_name_;
}
inline void TripPath_TransitRouteInfo::set_short_name(const ::std::string& value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_short_name(const char* value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_short_name(const char* value, size_t size) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_short_name() {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  return short_name_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_short_name() {
  clear_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_name_;
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_short_name(::std::string* short_name) {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    delete short_name_;
  }
  if (short_name) {
    set_has_short_name();
    short_name_ = short_name;
  } else {
    clear_has_short_name();
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string long_name = 5;
inline bool TripPath_TransitRouteInfo::has_long_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_long_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripPath_TransitRouteInfo::clear_has_long_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripPath_TransitRouteInfo::clear_long_name() {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    long_name_->clear();
  }
  clear_has_long_name();
}
inline const ::std::string& TripPath_TransitRouteInfo::long_name() const {
  return *long_name_;
}
inline void TripPath_TransitRouteInfo::set_long_name(const ::std::string& value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_long_name(const char* value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_long_name(const char* value, size_t size) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_long_name() {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  return long_name_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_long_name() {
  clear_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = long_name_;
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_long_name(::std::string* long_name) {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    delete long_name_;
  }
  if (long_name) {
    set_has_long_name();
    long_name_ = long_name;
  } else {
    clear_has_long_name();
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string headsign = 6;
inline bool TripPath_TransitRouteInfo::has_headsign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_headsign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripPath_TransitRouteInfo::clear_has_headsign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripPath_TransitRouteInfo::clear_headsign() {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    headsign_->clear();
  }
  clear_has_headsign();
}
inline const ::std::string& TripPath_TransitRouteInfo::headsign() const {
  return *headsign_;
}
inline void TripPath_TransitRouteInfo::set_headsign(const ::std::string& value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_headsign(const char* value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_headsign(const char* value, size_t size) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_headsign() {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  return headsign_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_headsign() {
  clear_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headsign_;
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_headsign(::std::string* headsign) {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    delete headsign_;
  }
  if (headsign) {
    set_has_headsign();
    headsign_ = headsign;
  } else {
    clear_has_headsign();
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 color = 7;
inline bool TripPath_TransitRouteInfo::has_color() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_color() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripPath_TransitRouteInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripPath_TransitRouteInfo::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 TripPath_TransitRouteInfo::color() const {
  return color_;
}
inline void TripPath_TransitRouteInfo::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// optional uint32 text_color = 8;
inline bool TripPath_TransitRouteInfo::has_text_color() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_text_color() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripPath_TransitRouteInfo::clear_has_text_color() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripPath_TransitRouteInfo::clear_text_color() {
  text_color_ = 0u;
  clear_has_text_color();
}
inline ::google::protobuf::uint32 TripPath_TransitRouteInfo::text_color() const {
  return text_color_;
}
inline void TripPath_TransitRouteInfo::set_text_color(::google::protobuf::uint32 value) {
  set_has_text_color();
  text_color_ = value;
}

// optional string description = 9;
inline bool TripPath_TransitRouteInfo::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripPath_TransitRouteInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripPath_TransitRouteInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TripPath_TransitRouteInfo::description() const {
  return *description_;
}
inline void TripPath_TransitRouteInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_onestop_id = 10;
inline bool TripPath_TransitRouteInfo::has_operator_onestop_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_operator_onestop_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripPath_TransitRouteInfo::clear_has_operator_onestop_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripPath_TransitRouteInfo::clear_operator_onestop_id() {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_->clear();
  }
  clear_has_operator_onestop_id();
}
inline const ::std::string& TripPath_TransitRouteInfo::operator_onestop_id() const {
  return *operator_onestop_id_;
}
inline void TripPath_TransitRouteInfo::set_operator_onestop_id(const ::std::string& value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_operator_onestop_id(const char* value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_operator_onestop_id(const char* value, size_t size) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_operator_onestop_id() {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  return operator_onestop_id_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_operator_onestop_id() {
  clear_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_onestop_id_;
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_operator_onestop_id(::std::string* operator_onestop_id) {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_onestop_id_;
  }
  if (operator_onestop_id) {
    set_has_operator_onestop_id();
    operator_onestop_id_ = operator_onestop_id;
  } else {
    clear_has_operator_onestop_id();
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_name = 11;
inline bool TripPath_TransitRouteInfo::has_operator_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_operator_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripPath_TransitRouteInfo::clear_has_operator_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripPath_TransitRouteInfo::clear_operator_name() {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    operator_name_->clear();
  }
  clear_has_operator_name();
}
inline const ::std::string& TripPath_TransitRouteInfo::operator_name() const {
  return *operator_name_;
}
inline void TripPath_TransitRouteInfo::set_operator_name(const ::std::string& value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_operator_name(const char* value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_operator_name(const char* value, size_t size) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_operator_name() {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  return operator_name_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_operator_name() {
  clear_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_name_;
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_operator_name(::std::string* operator_name) {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_name_;
  }
  if (operator_name) {
    set_has_operator_name();
    operator_name_ = operator_name;
  } else {
    clear_has_operator_name();
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_url = 12;
inline bool TripPath_TransitRouteInfo::has_operator_url() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TripPath_TransitRouteInfo::set_has_operator_url() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TripPath_TransitRouteInfo::clear_has_operator_url() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TripPath_TransitRouteInfo::clear_operator_url() {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    operator_url_->clear();
  }
  clear_has_operator_url();
}
inline const ::std::string& TripPath_TransitRouteInfo::operator_url() const {
  return *operator_url_;
}
inline void TripPath_TransitRouteInfo::set_operator_url(const ::std::string& value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_operator_url(const char* value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void TripPath_TransitRouteInfo::set_operator_url(const char* value, size_t size) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitRouteInfo::mutable_operator_url() {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  return operator_url_;
}
inline ::std::string* TripPath_TransitRouteInfo::release_operator_url() {
  clear_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_url_;
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitRouteInfo::set_allocated_operator_url(::std::string* operator_url) {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_url_;
  }
  if (operator_url) {
    set_has_operator_url();
    operator_url_ = operator_url;
  } else {
    clear_has_operator_url();
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TripPath_Edge

// repeated string name = 1;
inline int TripPath_Edge::name_size() const {
  return name_.size();
}
inline void TripPath_Edge::clear_name() {
  name_.Clear();
}
inline const ::std::string& TripPath_Edge::name(int index) const {
  return name_.Get(index);
}
inline ::std::string* TripPath_Edge::mutable_name(int index) {
  return name_.Mutable(index);
}
inline void TripPath_Edge::set_name(int index, const ::std::string& value) {
  name_.Mutable(index)->assign(value);
}
inline void TripPath_Edge::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
}
inline void TripPath_Edge::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Edge::add_name() {
  return name_.Add();
}
inline void TripPath_Edge::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
}
inline void TripPath_Edge::add_name(const char* value) {
  name_.Add()->assign(value);
}
inline void TripPath_Edge::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripPath_Edge::name() const {
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripPath_Edge::mutable_name() {
  return &name_;
}

// optional float length = 2;
inline bool TripPath_Edge::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_Edge::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_Edge::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_Edge::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float TripPath_Edge::length() const {
  return length_;
}
inline void TripPath_Edge::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional float speed = 3;
inline bool TripPath_Edge::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_Edge::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_Edge::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_Edge::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float TripPath_Edge::speed() const {
  return speed_;
}
inline void TripPath_Edge::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// optional .valhalla.odin.TripPath.RoadClass road_class = 4;
inline bool TripPath_Edge::has_road_class() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_Edge::set_has_road_class() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_Edge::clear_has_road_class() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_Edge::clear_road_class() {
  road_class_ = 0;
  clear_has_road_class();
}
inline ::valhalla::odin::TripPath_RoadClass TripPath_Edge::road_class() const {
  return static_cast< ::valhalla::odin::TripPath_RoadClass >(road_class_);
}
inline void TripPath_Edge::set_road_class(::valhalla::odin::TripPath_RoadClass value) {
  assert(::valhalla::odin::TripPath_RoadClass_IsValid(value));
  set_has_road_class();
  road_class_ = value;
}

// optional uint32 begin_heading = 5;
inline bool TripPath_Edge::has_begin_heading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripPath_Edge::set_has_begin_heading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripPath_Edge::clear_has_begin_heading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripPath_Edge::clear_begin_heading() {
  begin_heading_ = 0u;
  clear_has_begin_heading();
}
inline ::google::protobuf::uint32 TripPath_Edge::begin_heading() const {
  return begin_heading_;
}
inline void TripPath_Edge::set_begin_heading(::google::protobuf::uint32 value) {
  set_has_begin_heading();
  begin_heading_ = value;
}

// optional uint32 end_heading = 6;
inline bool TripPath_Edge::has_end_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripPath_Edge::set_has_end_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripPath_Edge::clear_has_end_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripPath_Edge::clear_end_heading() {
  end_heading_ = 0u;
  clear_has_end_heading();
}
inline ::google::protobuf::uint32 TripPath_Edge::end_heading() const {
  return end_heading_;
}
inline void TripPath_Edge::set_end_heading(::google::protobuf::uint32 value) {
  set_has_end_heading();
  end_heading_ = value;
}

// optional uint32 begin_shape_index = 7;
inline bool TripPath_Edge::has_begin_shape_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripPath_Edge::set_has_begin_shape_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripPath_Edge::clear_has_begin_shape_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripPath_Edge::clear_begin_shape_index() {
  begin_shape_index_ = 0u;
  clear_has_begin_shape_index();
}
inline ::google::protobuf::uint32 TripPath_Edge::begin_shape_index() const {
  return begin_shape_index_;
}
inline void TripPath_Edge::set_begin_shape_index(::google::protobuf::uint32 value) {
  set_has_begin_shape_index();
  begin_shape_index_ = value;
}

// optional uint32 end_shape_index = 8;
inline bool TripPath_Edge::has_end_shape_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripPath_Edge::set_has_end_shape_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripPath_Edge::clear_has_end_shape_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripPath_Edge::clear_end_shape_index() {
  end_shape_index_ = 0u;
  clear_has_end_shape_index();
}
inline ::google::protobuf::uint32 TripPath_Edge::end_shape_index() const {
  return end_shape_index_;
}
inline void TripPath_Edge::set_end_shape_index(::google::protobuf::uint32 value) {
  set_has_end_shape_index();
  end_shape_index_ = value;
}

// optional .valhalla.odin.TripPath.Traversability traversability = 9;
inline bool TripPath_Edge::has_traversability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripPath_Edge::set_has_traversability() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripPath_Edge::clear_has_traversability() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripPath_Edge::clear_traversability() {
  traversability_ = 0;
  clear_has_traversability();
}
inline ::valhalla::odin::TripPath_Traversability TripPath_Edge::traversability() const {
  return static_cast< ::valhalla::odin::TripPath_Traversability >(traversability_);
}
inline void TripPath_Edge::set_traversability(::valhalla::odin::TripPath_Traversability value) {
  assert(::valhalla::odin::TripPath_Traversability_IsValid(value));
  set_has_traversability();
  traversability_ = value;
}

// optional bool ramp = 10;
inline bool TripPath_Edge::has_ramp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripPath_Edge::set_has_ramp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripPath_Edge::clear_has_ramp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripPath_Edge::clear_ramp() {
  ramp_ = false;
  clear_has_ramp();
}
inline bool TripPath_Edge::ramp() const {
  return ramp_;
}
inline void TripPath_Edge::set_ramp(bool value) {
  set_has_ramp();
  ramp_ = value;
}

// optional bool turn_channel = 11;
inline bool TripPath_Edge::has_turn_channel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripPath_Edge::set_has_turn_channel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripPath_Edge::clear_has_turn_channel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripPath_Edge::clear_turn_channel() {
  turn_channel_ = false;
  clear_has_turn_channel();
}
inline bool TripPath_Edge::turn_channel() const {
  return turn_channel_;
}
inline void TripPath_Edge::set_turn_channel(bool value) {
  set_has_turn_channel();
  turn_channel_ = value;
}

// optional bool ferry = 12;
inline bool TripPath_Edge::has_ferry() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TripPath_Edge::set_has_ferry() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TripPath_Edge::clear_has_ferry() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TripPath_Edge::clear_ferry() {
  ferry_ = false;
  clear_has_ferry();
}
inline bool TripPath_Edge::ferry() const {
  return ferry_;
}
inline void TripPath_Edge::set_ferry(bool value) {
  set_has_ferry();
  ferry_ = value;
}

// optional bool rail_ferry = 13;
inline bool TripPath_Edge::has_rail_ferry() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TripPath_Edge::set_has_rail_ferry() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TripPath_Edge::clear_has_rail_ferry() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TripPath_Edge::clear_rail_ferry() {
  rail_ferry_ = false;
  clear_has_rail_ferry();
}
inline bool TripPath_Edge::rail_ferry() const {
  return rail_ferry_;
}
inline void TripPath_Edge::set_rail_ferry(bool value) {
  set_has_rail_ferry();
  rail_ferry_ = value;
}

// optional bool toll = 14;
inline bool TripPath_Edge::has_toll() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TripPath_Edge::set_has_toll() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TripPath_Edge::clear_has_toll() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TripPath_Edge::clear_toll() {
  toll_ = false;
  clear_has_toll();
}
inline bool TripPath_Edge::toll() const {
  return toll_;
}
inline void TripPath_Edge::set_toll(bool value) {
  set_has_toll();
  toll_ = value;
}

// optional bool unpaved = 15;
inline bool TripPath_Edge::has_unpaved() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TripPath_Edge::set_has_unpaved() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TripPath_Edge::clear_has_unpaved() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TripPath_Edge::clear_unpaved() {
  unpaved_ = false;
  clear_has_unpaved();
}
inline bool TripPath_Edge::unpaved() const {
  return unpaved_;
}
inline void TripPath_Edge::set_unpaved(bool value) {
  set_has_unpaved();
  unpaved_ = value;
}

// optional bool tunnel = 16;
inline bool TripPath_Edge::has_tunnel() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TripPath_Edge::set_has_tunnel() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TripPath_Edge::clear_has_tunnel() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TripPath_Edge::clear_tunnel() {
  tunnel_ = false;
  clear_has_tunnel();
}
inline bool TripPath_Edge::tunnel() const {
  return tunnel_;
}
inline void TripPath_Edge::set_tunnel(bool value) {
  set_has_tunnel();
  tunnel_ = value;
}

// optional bool bridge = 17;
inline bool TripPath_Edge::has_bridge() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TripPath_Edge::set_has_bridge() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TripPath_Edge::clear_has_bridge() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TripPath_Edge::clear_bridge() {
  bridge_ = false;
  clear_has_bridge();
}
inline bool TripPath_Edge::bridge() const {
  return bridge_;
}
inline void TripPath_Edge::set_bridge(bool value) {
  set_has_bridge();
  bridge_ = value;
}

// optional bool roundabout = 18;
inline bool TripPath_Edge::has_roundabout() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TripPath_Edge::set_has_roundabout() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TripPath_Edge::clear_has_roundabout() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TripPath_Edge::clear_roundabout() {
  roundabout_ = false;
  clear_has_roundabout();
}
inline bool TripPath_Edge::roundabout() const {
  return roundabout_;
}
inline void TripPath_Edge::set_roundabout(bool value) {
  set_has_roundabout();
  roundabout_ = value;
}

// optional bool internal_intersection = 19;
inline bool TripPath_Edge::has_internal_intersection() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TripPath_Edge::set_has_internal_intersection() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TripPath_Edge::clear_has_internal_intersection() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TripPath_Edge::clear_internal_intersection() {
  internal_intersection_ = false;
  clear_has_internal_intersection();
}
inline bool TripPath_Edge::internal_intersection() const {
  return internal_intersection_;
}
inline void TripPath_Edge::set_internal_intersection(bool value) {
  set_has_internal_intersection();
  internal_intersection_ = value;
}

// optional uint32 end_node_index = 20;
inline bool TripPath_Edge::has_end_node_index() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TripPath_Edge::set_has_end_node_index() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TripPath_Edge::clear_has_end_node_index() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TripPath_Edge::clear_end_node_index() {
  end_node_index_ = 0u;
  clear_has_end_node_index();
}
inline ::google::protobuf::uint32 TripPath_Edge::end_node_index() const {
  return end_node_index_;
}
inline void TripPath_Edge::set_end_node_index(::google::protobuf::uint32 value) {
  set_has_end_node_index();
  end_node_index_ = value;
}

// optional .valhalla.odin.TripPath.Sign sign = 21;
inline bool TripPath_Edge::has_sign() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TripPath_Edge::set_has_sign() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TripPath_Edge::clear_has_sign() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TripPath_Edge::clear_sign() {
  if (sign_ != NULL) sign_->::valhalla::odin::TripPath_Sign::Clear();
  clear_has_sign();
}
inline const ::valhalla::odin::TripPath_Sign& TripPath_Edge::sign() const {
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
}
inline ::valhalla::odin::TripPath_Sign* TripPath_Edge::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::valhalla::odin::TripPath_Sign;
  return sign_;
}
inline ::valhalla::odin::TripPath_Sign* TripPath_Edge::release_sign() {
  clear_has_sign();
  ::valhalla::odin::TripPath_Sign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void TripPath_Edge::set_allocated_sign(::valhalla::odin::TripPath_Sign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
}

// optional .valhalla.odin.TripPath.TravelMode travel_mode = 22;
inline bool TripPath_Edge::has_travel_mode() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TripPath_Edge::set_has_travel_mode() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TripPath_Edge::clear_has_travel_mode() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TripPath_Edge::clear_travel_mode() {
  travel_mode_ = 0;
  clear_has_travel_mode();
}
inline ::valhalla::odin::TripPath_TravelMode TripPath_Edge::travel_mode() const {
  return static_cast< ::valhalla::odin::TripPath_TravelMode >(travel_mode_);
}
inline void TripPath_Edge::set_travel_mode(::valhalla::odin::TripPath_TravelMode value) {
  assert(::valhalla::odin::TripPath_TravelMode_IsValid(value));
  set_has_travel_mode();
  travel_mode_ = value;
}

// optional .valhalla.odin.TripPath.VehicleType vehicle_type = 23;
inline bool TripPath_Edge::has_vehicle_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TripPath_Edge::set_has_vehicle_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TripPath_Edge::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TripPath_Edge::clear_vehicle_type() {
  vehicle_type_ = 0;
  clear_has_vehicle_type();
}
inline ::valhalla::odin::TripPath_VehicleType TripPath_Edge::vehicle_type() const {
  return static_cast< ::valhalla::odin::TripPath_VehicleType >(vehicle_type_);
}
inline void TripPath_Edge::set_vehicle_type(::valhalla::odin::TripPath_VehicleType value) {
  assert(::valhalla::odin::TripPath_VehicleType_IsValid(value));
  set_has_vehicle_type();
  vehicle_type_ = value;
}

// optional .valhalla.odin.TripPath.PedestrianType pedestrian_type = 24;
inline bool TripPath_Edge::has_pedestrian_type() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TripPath_Edge::set_has_pedestrian_type() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TripPath_Edge::clear_has_pedestrian_type() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TripPath_Edge::clear_pedestrian_type() {
  pedestrian_type_ = 0;
  clear_has_pedestrian_type();
}
inline ::valhalla::odin::TripPath_PedestrianType TripPath_Edge::pedestrian_type() const {
  return static_cast< ::valhalla::odin::TripPath_PedestrianType >(pedestrian_type_);
}
inline void TripPath_Edge::set_pedestrian_type(::valhalla::odin::TripPath_PedestrianType value) {
  assert(::valhalla::odin::TripPath_PedestrianType_IsValid(value));
  set_has_pedestrian_type();
  pedestrian_type_ = value;
}

// optional .valhalla.odin.TripPath.BicycleType bicycle_type = 25;
inline bool TripPath_Edge::has_bicycle_type() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TripPath_Edge::set_has_bicycle_type() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TripPath_Edge::clear_has_bicycle_type() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TripPath_Edge::clear_bicycle_type() {
  bicycle_type_ = 0;
  clear_has_bicycle_type();
}
inline ::valhalla::odin::TripPath_BicycleType TripPath_Edge::bicycle_type() const {
  return static_cast< ::valhalla::odin::TripPath_BicycleType >(bicycle_type_);
}
inline void TripPath_Edge::set_bicycle_type(::valhalla::odin::TripPath_BicycleType value) {
  assert(::valhalla::odin::TripPath_BicycleType_IsValid(value));
  set_has_bicycle_type();
  bicycle_type_ = value;
}

// optional .valhalla.odin.TripPath.TransitType transit_type = 26;
inline bool TripPath_Edge::has_transit_type() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TripPath_Edge::set_has_transit_type() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TripPath_Edge::clear_has_transit_type() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TripPath_Edge::clear_transit_type() {
  transit_type_ = 0;
  clear_has_transit_type();
}
inline ::valhalla::odin::TripPath_TransitType TripPath_Edge::transit_type() const {
  return static_cast< ::valhalla::odin::TripPath_TransitType >(transit_type_);
}
inline void TripPath_Edge::set_transit_type(::valhalla::odin::TripPath_TransitType value) {
  assert(::valhalla::odin::TripPath_TransitType_IsValid(value));
  set_has_transit_type();
  transit_type_ = value;
}

// optional bool drive_on_right = 27 [default = true];
inline bool TripPath_Edge::has_drive_on_right() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TripPath_Edge::set_has_drive_on_right() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TripPath_Edge::clear_has_drive_on_right() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TripPath_Edge::clear_drive_on_right() {
  drive_on_right_ = true;
  clear_has_drive_on_right();
}
inline bool TripPath_Edge::drive_on_right() const {
  return drive_on_right_;
}
inline void TripPath_Edge::set_drive_on_right(bool value) {
  set_has_drive_on_right();
  drive_on_right_ = value;
}

// optional bool road = 28;
inline bool TripPath_Edge::has_road() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TripPath_Edge::set_has_road() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TripPath_Edge::clear_has_road() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TripPath_Edge::clear_road() {
  road_ = false;
  clear_has_road();
}
inline bool TripPath_Edge::road() const {
  return road_;
}
inline void TripPath_Edge::set_road(bool value) {
  set_has_road();
  road_ = value;
}

// optional bool track = 29;
inline bool TripPath_Edge::has_track() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TripPath_Edge::set_has_track() {
  _has_bits_[0] |= 0x10000000u;
}
inline void TripPath_Edge::clear_has_track() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void TripPath_Edge::clear_track() {
  track_ = false;
  clear_has_track();
}
inline bool TripPath_Edge::track() const {
  return track_;
}
inline void TripPath_Edge::set_track(bool value) {
  set_has_track();
  track_ = value;
}

// optional bool driveway = 30;
inline bool TripPath_Edge::has_driveway() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TripPath_Edge::set_has_driveway() {
  _has_bits_[0] |= 0x20000000u;
}
inline void TripPath_Edge::clear_has_driveway() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void TripPath_Edge::clear_driveway() {
  driveway_ = false;
  clear_has_driveway();
}
inline bool TripPath_Edge::driveway() const {
  return driveway_;
}
inline void TripPath_Edge::set_driveway(bool value) {
  set_has_driveway();
  driveway_ = value;
}

// optional bool alley = 31;
inline bool TripPath_Edge::has_alley() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TripPath_Edge::set_has_alley() {
  _has_bits_[0] |= 0x40000000u;
}
inline void TripPath_Edge::clear_has_alley() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void TripPath_Edge::clear_alley() {
  alley_ = false;
  clear_has_alley();
}
inline bool TripPath_Edge::alley() const {
  return alley_;
}
inline void TripPath_Edge::set_alley(bool value) {
  set_has_alley();
  alley_ = value;
}

// optional bool parking_aisle = 32;
inline bool TripPath_Edge::has_parking_aisle() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void TripPath_Edge::set_has_parking_aisle() {
  _has_bits_[0] |= 0x80000000u;
}
inline void TripPath_Edge::clear_has_parking_aisle() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void TripPath_Edge::clear_parking_aisle() {
  parking_aisle_ = false;
  clear_has_parking_aisle();
}
inline bool TripPath_Edge::parking_aisle() const {
  return parking_aisle_;
}
inline void TripPath_Edge::set_parking_aisle(bool value) {
  set_has_parking_aisle();
  parking_aisle_ = value;
}

// optional bool emergency_access = 33;
inline bool TripPath_Edge::has_emergency_access() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void TripPath_Edge::set_has_emergency_access() {
  _has_bits_[1] |= 0x00000001u;
}
inline void TripPath_Edge::clear_has_emergency_access() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void TripPath_Edge::clear_emergency_access() {
  emergency_access_ = false;
  clear_has_emergency_access();
}
inline bool TripPath_Edge::emergency_access() const {
  return emergency_access_;
}
inline void TripPath_Edge::set_emergency_access(bool value) {
  set_has_emergency_access();
  emergency_access_ = value;
}

// optional bool drive_thru = 34;
inline bool TripPath_Edge::has_drive_thru() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void TripPath_Edge::set_has_drive_thru() {
  _has_bits_[1] |= 0x00000002u;
}
inline void TripPath_Edge::clear_has_drive_thru() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void TripPath_Edge::clear_drive_thru() {
  drive_thru_ = false;
  clear_has_drive_thru();
}
inline bool TripPath_Edge::drive_thru() const {
  return drive_thru_;
}
inline void TripPath_Edge::set_drive_thru(bool value) {
  set_has_drive_thru();
  drive_thru_ = value;
}

// optional bool culdesac = 35;
inline bool TripPath_Edge::has_culdesac() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void TripPath_Edge::set_has_culdesac() {
  _has_bits_[1] |= 0x00000004u;
}
inline void TripPath_Edge::clear_has_culdesac() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void TripPath_Edge::clear_culdesac() {
  culdesac_ = false;
  clear_has_culdesac();
}
inline bool TripPath_Edge::culdesac() const {
  return culdesac_;
}
inline void TripPath_Edge::set_culdesac(bool value) {
  set_has_culdesac();
  culdesac_ = value;
}

// optional bool footway = 36;
inline bool TripPath_Edge::has_footway() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void TripPath_Edge::set_has_footway() {
  _has_bits_[1] |= 0x00000008u;
}
inline void TripPath_Edge::clear_has_footway() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void TripPath_Edge::clear_footway() {
  footway_ = false;
  clear_has_footway();
}
inline bool TripPath_Edge::footway() const {
  return footway_;
}
inline void TripPath_Edge::set_footway(bool value) {
  set_has_footway();
  footway_ = value;
}

// optional bool stairs = 37;
inline bool TripPath_Edge::has_stairs() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void TripPath_Edge::set_has_stairs() {
  _has_bits_[1] |= 0x00000010u;
}
inline void TripPath_Edge::clear_has_stairs() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void TripPath_Edge::clear_stairs() {
  stairs_ = false;
  clear_has_stairs();
}
inline bool TripPath_Edge::stairs() const {
  return stairs_;
}
inline void TripPath_Edge::set_stairs(bool value) {
  set_has_stairs();
  stairs_ = value;
}

// optional bool cycleway = 38;
inline bool TripPath_Edge::has_cycleway() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void TripPath_Edge::set_has_cycleway() {
  _has_bits_[1] |= 0x00000020u;
}
inline void TripPath_Edge::clear_has_cycleway() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void TripPath_Edge::clear_cycleway() {
  cycleway_ = false;
  clear_has_cycleway();
}
inline bool TripPath_Edge::cycleway() const {
  return cycleway_;
}
inline void TripPath_Edge::set_cycleway(bool value) {
  set_has_cycleway();
  cycleway_ = value;
}

// optional bool mountain_bike = 39;
inline bool TripPath_Edge::has_mountain_bike() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void TripPath_Edge::set_has_mountain_bike() {
  _has_bits_[1] |= 0x00000040u;
}
inline void TripPath_Edge::clear_has_mountain_bike() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void TripPath_Edge::clear_mountain_bike() {
  mountain_bike_ = false;
  clear_has_mountain_bike();
}
inline bool TripPath_Edge::mountain_bike() const {
  return mountain_bike_;
}
inline void TripPath_Edge::set_mountain_bike(bool value) {
  set_has_mountain_bike();
  mountain_bike_ = value;
}

// optional bool rail = 40;
inline bool TripPath_Edge::has_rail() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void TripPath_Edge::set_has_rail() {
  _has_bits_[1] |= 0x00000080u;
}
inline void TripPath_Edge::clear_has_rail() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void TripPath_Edge::clear_rail() {
  rail_ = false;
  clear_has_rail();
}
inline bool TripPath_Edge::rail() const {
  return rail_;
}
inline void TripPath_Edge::set_rail(bool value) {
  set_has_rail();
  rail_ = value;
}

// optional bool bus = 41;
inline bool TripPath_Edge::has_bus() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void TripPath_Edge::set_has_bus() {
  _has_bits_[1] |= 0x00000100u;
}
inline void TripPath_Edge::clear_has_bus() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void TripPath_Edge::clear_bus() {
  bus_ = false;
  clear_has_bus();
}
inline bool TripPath_Edge::bus() const {
  return bus_;
}
inline void TripPath_Edge::set_bus(bool value) {
  set_has_bus();
  bus_ = value;
}

// optional bool transit_connection = 42;
inline bool TripPath_Edge::has_transit_connection() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void TripPath_Edge::set_has_transit_connection() {
  _has_bits_[1] |= 0x00000200u;
}
inline void TripPath_Edge::clear_has_transit_connection() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void TripPath_Edge::clear_transit_connection() {
  transit_connection_ = false;
  clear_has_transit_connection();
}
inline bool TripPath_Edge::transit_connection() const {
  return transit_connection_;
}
inline void TripPath_Edge::set_transit_connection(bool value) {
  set_has_transit_connection();
  transit_connection_ = value;
}

// optional bool other = 43;
inline bool TripPath_Edge::has_other() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void TripPath_Edge::set_has_other() {
  _has_bits_[1] |= 0x00000400u;
}
inline void TripPath_Edge::clear_has_other() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void TripPath_Edge::clear_other() {
  other_ = false;
  clear_has_other();
}
inline bool TripPath_Edge::other() const {
  return other_;
}
inline void TripPath_Edge::set_other(bool value) {
  set_has_other();
  other_ = value;
}

// optional .valhalla.odin.TripPath.TransitRouteInfo transit_route_info = 44;
inline bool TripPath_Edge::has_transit_route_info() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void TripPath_Edge::set_has_transit_route_info() {
  _has_bits_[1] |= 0x00000800u;
}
inline void TripPath_Edge::clear_has_transit_route_info() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void TripPath_Edge::clear_transit_route_info() {
  if (transit_route_info_ != NULL) transit_route_info_->::valhalla::odin::TripPath_TransitRouteInfo::Clear();
  clear_has_transit_route_info();
}
inline const ::valhalla::odin::TripPath_TransitRouteInfo& TripPath_Edge::transit_route_info() const {
  return transit_route_info_ != NULL ? *transit_route_info_ : *default_instance_->transit_route_info_;
}
inline ::valhalla::odin::TripPath_TransitRouteInfo* TripPath_Edge::mutable_transit_route_info() {
  set_has_transit_route_info();
  if (transit_route_info_ == NULL) transit_route_info_ = new ::valhalla::odin::TripPath_TransitRouteInfo;
  return transit_route_info_;
}
inline ::valhalla::odin::TripPath_TransitRouteInfo* TripPath_Edge::release_transit_route_info() {
  clear_has_transit_route_info();
  ::valhalla::odin::TripPath_TransitRouteInfo* temp = transit_route_info_;
  transit_route_info_ = NULL;
  return temp;
}
inline void TripPath_Edge::set_allocated_transit_route_info(::valhalla::odin::TripPath_TransitRouteInfo* transit_route_info) {
  delete transit_route_info_;
  transit_route_info_ = transit_route_info;
  if (transit_route_info) {
    set_has_transit_route_info();
  } else {
    clear_has_transit_route_info();
  }
}

// -------------------------------------------------------------------

// TripPath_IntersectingEdge

// optional uint32 begin_heading = 1;
inline bool TripPath_IntersectingEdge::has_begin_heading() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_IntersectingEdge::set_has_begin_heading() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_IntersectingEdge::clear_has_begin_heading() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_IntersectingEdge::clear_begin_heading() {
  begin_heading_ = 0u;
  clear_has_begin_heading();
}
inline ::google::protobuf::uint32 TripPath_IntersectingEdge::begin_heading() const {
  return begin_heading_;
}
inline void TripPath_IntersectingEdge::set_begin_heading(::google::protobuf::uint32 value) {
  set_has_begin_heading();
  begin_heading_ = value;
}

// optional bool prev_name_consistency = 2;
inline bool TripPath_IntersectingEdge::has_prev_name_consistency() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_IntersectingEdge::set_has_prev_name_consistency() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_IntersectingEdge::clear_has_prev_name_consistency() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_IntersectingEdge::clear_prev_name_consistency() {
  prev_name_consistency_ = false;
  clear_has_prev_name_consistency();
}
inline bool TripPath_IntersectingEdge::prev_name_consistency() const {
  return prev_name_consistency_;
}
inline void TripPath_IntersectingEdge::set_prev_name_consistency(bool value) {
  set_has_prev_name_consistency();
  prev_name_consistency_ = value;
}

// optional bool curr_name_consistency = 3;
inline bool TripPath_IntersectingEdge::has_curr_name_consistency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_IntersectingEdge::set_has_curr_name_consistency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_IntersectingEdge::clear_has_curr_name_consistency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_IntersectingEdge::clear_curr_name_consistency() {
  curr_name_consistency_ = false;
  clear_has_curr_name_consistency();
}
inline bool TripPath_IntersectingEdge::curr_name_consistency() const {
  return curr_name_consistency_;
}
inline void TripPath_IntersectingEdge::set_curr_name_consistency(bool value) {
  set_has_curr_name_consistency();
  curr_name_consistency_ = value;
}

// optional .valhalla.odin.TripPath.Traversability driveability = 4;
inline bool TripPath_IntersectingEdge::has_driveability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_IntersectingEdge::set_has_driveability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_IntersectingEdge::clear_has_driveability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_IntersectingEdge::clear_driveability() {
  driveability_ = 0;
  clear_has_driveability();
}
inline ::valhalla::odin::TripPath_Traversability TripPath_IntersectingEdge::driveability() const {
  return static_cast< ::valhalla::odin::TripPath_Traversability >(driveability_);
}
inline void TripPath_IntersectingEdge::set_driveability(::valhalla::odin::TripPath_Traversability value) {
  assert(::valhalla::odin::TripPath_Traversability_IsValid(value));
  set_has_driveability();
  driveability_ = value;
}

// optional .valhalla.odin.TripPath.Traversability cyclability = 5;
inline bool TripPath_IntersectingEdge::has_cyclability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripPath_IntersectingEdge::set_has_cyclability() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripPath_IntersectingEdge::clear_has_cyclability() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripPath_IntersectingEdge::clear_cyclability() {
  cyclability_ = 0;
  clear_has_cyclability();
}
inline ::valhalla::odin::TripPath_Traversability TripPath_IntersectingEdge::cyclability() const {
  return static_cast< ::valhalla::odin::TripPath_Traversability >(cyclability_);
}
inline void TripPath_IntersectingEdge::set_cyclability(::valhalla::odin::TripPath_Traversability value) {
  assert(::valhalla::odin::TripPath_Traversability_IsValid(value));
  set_has_cyclability();
  cyclability_ = value;
}

// optional .valhalla.odin.TripPath.Traversability walkability = 6;
inline bool TripPath_IntersectingEdge::has_walkability() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripPath_IntersectingEdge::set_has_walkability() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripPath_IntersectingEdge::clear_has_walkability() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripPath_IntersectingEdge::clear_walkability() {
  walkability_ = 0;
  clear_has_walkability();
}
inline ::valhalla::odin::TripPath_Traversability TripPath_IntersectingEdge::walkability() const {
  return static_cast< ::valhalla::odin::TripPath_Traversability >(walkability_);
}
inline void TripPath_IntersectingEdge::set_walkability(::valhalla::odin::TripPath_Traversability value) {
  assert(::valhalla::odin::TripPath_Traversability_IsValid(value));
  set_has_walkability();
  walkability_ = value;
}

// -------------------------------------------------------------------

// TripPath_TransitStopInfo

// optional .valhalla.odin.TripPath.TransitStopInfo.Type type = 1;
inline bool TripPath_TransitStopInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_TransitStopInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_TransitStopInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::odin::TripPath_TransitStopInfo_Type TripPath_TransitStopInfo::type() const {
  return static_cast< ::valhalla::odin::TripPath_TransitStopInfo_Type >(type_);
}
inline void TripPath_TransitStopInfo::set_type(::valhalla::odin::TripPath_TransitStopInfo_Type value) {
  assert(::valhalla::odin::TripPath_TransitStopInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string onestop_id = 2;
inline bool TripPath_TransitStopInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_TransitStopInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_TransitStopInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TripPath_TransitStopInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TripPath_TransitStopInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripPath_TransitStopInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripPath_TransitStopInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitStopInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TripPath_TransitStopInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitStopInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TripPath_TransitStopInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_TransitStopInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_TransitStopInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TripPath_TransitStopInfo::name() const {
  return *name_;
}
inline void TripPath_TransitStopInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripPath_TransitStopInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripPath_TransitStopInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitStopInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TripPath_TransitStopInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitStopInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrival_date_time = 4;
inline bool TripPath_TransitStopInfo::has_arrival_date_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_arrival_date_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_TransitStopInfo::clear_has_arrival_date_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_TransitStopInfo::clear_arrival_date_time() {
  if (arrival_date_time_ != &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_->clear();
  }
  clear_has_arrival_date_time();
}
inline const ::std::string& TripPath_TransitStopInfo::arrival_date_time() const {
  return *arrival_date_time_;
}
inline void TripPath_TransitStopInfo::set_arrival_date_time(const ::std::string& value) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(value);
}
inline void TripPath_TransitStopInfo::set_arrival_date_time(const char* value) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(value);
}
inline void TripPath_TransitStopInfo::set_arrival_date_time(const char* value, size_t size) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitStopInfo::mutable_arrival_date_time() {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  return arrival_date_time_;
}
inline ::std::string* TripPath_TransitStopInfo::release_arrival_date_time() {
  clear_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrival_date_time_;
    arrival_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitStopInfo::set_allocated_arrival_date_time(::std::string* arrival_date_time) {
  if (arrival_date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete arrival_date_time_;
  }
  if (arrival_date_time) {
    set_has_arrival_date_time();
    arrival_date_time_ = arrival_date_time;
  } else {
    clear_has_arrival_date_time();
    arrival_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string departure_date_time = 5;
inline bool TripPath_TransitStopInfo::has_departure_date_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_departure_date_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripPath_TransitStopInfo::clear_has_departure_date_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripPath_TransitStopInfo::clear_departure_date_time() {
  if (departure_date_time_ != &::google::protobuf::internal::kEmptyString) {
    departure_date_time_->clear();
  }
  clear_has_departure_date_time();
}
inline const ::std::string& TripPath_TransitStopInfo::departure_date_time() const {
  return *departure_date_time_;
}
inline void TripPath_TransitStopInfo::set_departure_date_time(const ::std::string& value) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(value);
}
inline void TripPath_TransitStopInfo::set_departure_date_time(const char* value) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(value);
}
inline void TripPath_TransitStopInfo::set_departure_date_time(const char* value, size_t size) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_TransitStopInfo::mutable_departure_date_time() {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  return departure_date_time_;
}
inline ::std::string* TripPath_TransitStopInfo::release_departure_date_time() {
  clear_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departure_date_time_;
    departure_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_TransitStopInfo::set_allocated_departure_date_time(::std::string* departure_date_time) {
  if (departure_date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete departure_date_time_;
  }
  if (departure_date_time) {
    set_has_departure_date_time();
    departure_date_time_ = departure_date_time;
  } else {
    clear_has_departure_date_time();
    departure_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_parent_stop = 6;
inline bool TripPath_TransitStopInfo::has_is_parent_stop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_is_parent_stop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripPath_TransitStopInfo::clear_has_is_parent_stop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripPath_TransitStopInfo::clear_is_parent_stop() {
  is_parent_stop_ = false;
  clear_has_is_parent_stop();
}
inline bool TripPath_TransitStopInfo::is_parent_stop() const {
  return is_parent_stop_;
}
inline void TripPath_TransitStopInfo::set_is_parent_stop(bool value) {
  set_has_is_parent_stop();
  is_parent_stop_ = value;
}

// optional bool assumed_schedule = 7;
inline bool TripPath_TransitStopInfo::has_assumed_schedule() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_assumed_schedule() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripPath_TransitStopInfo::clear_has_assumed_schedule() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripPath_TransitStopInfo::clear_assumed_schedule() {
  assumed_schedule_ = false;
  clear_has_assumed_schedule();
}
inline bool TripPath_TransitStopInfo::assumed_schedule() const {
  return assumed_schedule_;
}
inline void TripPath_TransitStopInfo::set_assumed_schedule(bool value) {
  set_has_assumed_schedule();
  assumed_schedule_ = value;
}

// optional .valhalla.odin.TripPath.LatLng ll = 8;
inline bool TripPath_TransitStopInfo::has_ll() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripPath_TransitStopInfo::set_has_ll() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripPath_TransitStopInfo::clear_has_ll() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripPath_TransitStopInfo::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::odin::TripPath_LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::odin::TripPath_LatLng& TripPath_TransitStopInfo::ll() const {
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_TransitStopInfo::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::odin::TripPath_LatLng;
  return ll_;
}
inline ::valhalla::odin::TripPath_LatLng* TripPath_TransitStopInfo::release_ll() {
  clear_has_ll();
  ::valhalla::odin::TripPath_LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TripPath_TransitStopInfo::set_allocated_ll(::valhalla::odin::TripPath_LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// -------------------------------------------------------------------

// TripPath_Node

// optional .valhalla.odin.TripPath.Edge edge = 1;
inline bool TripPath_Node::has_edge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_Node::set_has_edge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_Node::clear_has_edge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_Node::clear_edge() {
  if (edge_ != NULL) edge_->::valhalla::odin::TripPath_Edge::Clear();
  clear_has_edge();
}
inline const ::valhalla::odin::TripPath_Edge& TripPath_Node::edge() const {
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
}
inline ::valhalla::odin::TripPath_Edge* TripPath_Node::mutable_edge() {
  set_has_edge();
  if (edge_ == NULL) edge_ = new ::valhalla::odin::TripPath_Edge;
  return edge_;
}
inline ::valhalla::odin::TripPath_Edge* TripPath_Node::release_edge() {
  clear_has_edge();
  ::valhalla::odin::TripPath_Edge* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void TripPath_Node::set_allocated_edge(::valhalla::odin::TripPath_Edge* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    set_has_edge();
  } else {
    clear_has_edge();
  }
}

// repeated .valhalla.odin.TripPath.IntersectingEdge intersecting_edge = 2;
inline int TripPath_Node::intersecting_edge_size() const {
  return intersecting_edge_.size();
}
inline void TripPath_Node::clear_intersecting_edge() {
  intersecting_edge_.Clear();
}
inline const ::valhalla::odin::TripPath_IntersectingEdge& TripPath_Node::intersecting_edge(int index) const {
  return intersecting_edge_.Get(index);
}
inline ::valhalla::odin::TripPath_IntersectingEdge* TripPath_Node::mutable_intersecting_edge(int index) {
  return intersecting_edge_.Mutable(index);
}
inline ::valhalla::odin::TripPath_IntersectingEdge* TripPath_Node::add_intersecting_edge() {
  return intersecting_edge_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_IntersectingEdge >&
TripPath_Node::intersecting_edge() const {
  return intersecting_edge_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_IntersectingEdge >*
TripPath_Node::mutable_intersecting_edge() {
  return &intersecting_edge_;
}

// optional uint32 elapsed_time = 3;
inline bool TripPath_Node::has_elapsed_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_Node::set_has_elapsed_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_Node::clear_has_elapsed_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_Node::clear_elapsed_time() {
  elapsed_time_ = 0u;
  clear_has_elapsed_time();
}
inline ::google::protobuf::uint32 TripPath_Node::elapsed_time() const {
  return elapsed_time_;
}
inline void TripPath_Node::set_elapsed_time(::google::protobuf::uint32 value) {
  set_has_elapsed_time();
  elapsed_time_ = value;
}

// optional uint32 admin_index = 4;
inline bool TripPath_Node::has_admin_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_Node::set_has_admin_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_Node::clear_has_admin_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_Node::clear_admin_index() {
  admin_index_ = 0u;
  clear_has_admin_index();
}
inline ::google::protobuf::uint32 TripPath_Node::admin_index() const {
  return admin_index_;
}
inline void TripPath_Node::set_admin_index(::google::protobuf::uint32 value) {
  set_has_admin_index();
  admin_index_ = value;
}

// optional bool street_intersection = 5;
inline bool TripPath_Node::has_street_intersection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripPath_Node::set_has_street_intersection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripPath_Node::clear_has_street_intersection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripPath_Node::clear_street_intersection() {
  street_intersection_ = false;
  clear_has_street_intersection();
}
inline bool TripPath_Node::street_intersection() const {
  return street_intersection_;
}
inline void TripPath_Node::set_street_intersection(bool value) {
  set_has_street_intersection();
  street_intersection_ = value;
}

// optional bool gate = 6;
inline bool TripPath_Node::has_gate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripPath_Node::set_has_gate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripPath_Node::clear_has_gate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripPath_Node::clear_gate() {
  gate_ = false;
  clear_has_gate();
}
inline bool TripPath_Node::gate() const {
  return gate_;
}
inline void TripPath_Node::set_gate(bool value) {
  set_has_gate();
  gate_ = value;
}

// optional bool bollard = 7;
inline bool TripPath_Node::has_bollard() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripPath_Node::set_has_bollard() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripPath_Node::clear_has_bollard() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripPath_Node::clear_bollard() {
  bollard_ = false;
  clear_has_bollard();
}
inline bool TripPath_Node::bollard() const {
  return bollard_;
}
inline void TripPath_Node::set_bollard(bool value) {
  set_has_bollard();
  bollard_ = value;
}

// optional bool toll_booth = 8;
inline bool TripPath_Node::has_toll_booth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripPath_Node::set_has_toll_booth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripPath_Node::clear_has_toll_booth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripPath_Node::clear_toll_booth() {
  toll_booth_ = false;
  clear_has_toll_booth();
}
inline bool TripPath_Node::toll_booth() const {
  return toll_booth_;
}
inline void TripPath_Node::set_toll_booth(bool value) {
  set_has_toll_booth();
  toll_booth_ = value;
}

// optional bool bike_share = 9;
inline bool TripPath_Node::has_bike_share() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripPath_Node::set_has_bike_share() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripPath_Node::clear_has_bike_share() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripPath_Node::clear_bike_share() {
  bike_share_ = false;
  clear_has_bike_share();
}
inline bool TripPath_Node::bike_share() const {
  return bike_share_;
}
inline void TripPath_Node::set_bike_share(bool value) {
  set_has_bike_share();
  bike_share_ = value;
}

// optional bool parking = 10;
inline bool TripPath_Node::has_parking() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripPath_Node::set_has_parking() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripPath_Node::clear_has_parking() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripPath_Node::clear_parking() {
  parking_ = false;
  clear_has_parking();
}
inline bool TripPath_Node::parking() const {
  return parking_;
}
inline void TripPath_Node::set_parking(bool value) {
  set_has_parking();
  parking_ = value;
}

// optional bool motorway_junction = 11;
inline bool TripPath_Node::has_motorway_junction() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripPath_Node::set_has_motorway_junction() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripPath_Node::clear_has_motorway_junction() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripPath_Node::clear_motorway_junction() {
  motorway_junction_ = false;
  clear_has_motorway_junction();
}
inline bool TripPath_Node::motorway_junction() const {
  return motorway_junction_;
}
inline void TripPath_Node::set_motorway_junction(bool value) {
  set_has_motorway_junction();
  motorway_junction_ = value;
}

// optional bool fork = 12;
inline bool TripPath_Node::has_fork() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TripPath_Node::set_has_fork() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TripPath_Node::clear_has_fork() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TripPath_Node::clear_fork() {
  fork_ = false;
  clear_has_fork();
}
inline bool TripPath_Node::fork() const {
  return fork_;
}
inline void TripPath_Node::set_fork(bool value) {
  set_has_fork();
  fork_ = value;
}

// optional .valhalla.odin.TripPath.TransitStopInfo transit_stop_info = 13;
inline bool TripPath_Node::has_transit_stop_info() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TripPath_Node::set_has_transit_stop_info() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TripPath_Node::clear_has_transit_stop_info() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TripPath_Node::clear_transit_stop_info() {
  if (transit_stop_info_ != NULL) transit_stop_info_->::valhalla::odin::TripPath_TransitStopInfo::Clear();
  clear_has_transit_stop_info();
}
inline const ::valhalla::odin::TripPath_TransitStopInfo& TripPath_Node::transit_stop_info() const {
  return transit_stop_info_ != NULL ? *transit_stop_info_ : *default_instance_->transit_stop_info_;
}
inline ::valhalla::odin::TripPath_TransitStopInfo* TripPath_Node::mutable_transit_stop_info() {
  set_has_transit_stop_info();
  if (transit_stop_info_ == NULL) transit_stop_info_ = new ::valhalla::odin::TripPath_TransitStopInfo;
  return transit_stop_info_;
}
inline ::valhalla::odin::TripPath_TransitStopInfo* TripPath_Node::release_transit_stop_info() {
  clear_has_transit_stop_info();
  ::valhalla::odin::TripPath_TransitStopInfo* temp = transit_stop_info_;
  transit_stop_info_ = NULL;
  return temp;
}
inline void TripPath_Node::set_allocated_transit_stop_info(::valhalla::odin::TripPath_TransitStopInfo* transit_stop_info) {
  delete transit_stop_info_;
  transit_stop_info_ = transit_stop_info;
  if (transit_stop_info) {
    set_has_transit_stop_info();
  } else {
    clear_has_transit_stop_info();
  }
}

// -------------------------------------------------------------------

// TripPath_Admin

// optional string country_code = 1;
inline bool TripPath_Admin::has_country_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath_Admin::set_has_country_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath_Admin::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath_Admin::clear_country_code() {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    country_code_->clear();
  }
  clear_has_country_code();
}
inline const ::std::string& TripPath_Admin::country_code() const {
  return *country_code_;
}
inline void TripPath_Admin::set_country_code(const ::std::string& value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
}
inline void TripPath_Admin::set_country_code(const char* value) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(value);
}
inline void TripPath_Admin::set_country_code(const char* value, size_t size) {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  country_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Admin::mutable_country_code() {
  set_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    country_code_ = new ::std::string;
  }
  return country_code_;
}
inline ::std::string* TripPath_Admin::release_country_code() {
  clear_has_country_code();
  if (country_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_code_;
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Admin::set_allocated_country_code(::std::string* country_code) {
  if (country_code_ != &::google::protobuf::internal::kEmptyString) {
    delete country_code_;
  }
  if (country_code) {
    set_has_country_code();
    country_code_ = country_code;
  } else {
    clear_has_country_code();
    country_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country_text = 2;
inline bool TripPath_Admin::has_country_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath_Admin::set_has_country_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath_Admin::clear_has_country_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath_Admin::clear_country_text() {
  if (country_text_ != &::google::protobuf::internal::kEmptyString) {
    country_text_->clear();
  }
  clear_has_country_text();
}
inline const ::std::string& TripPath_Admin::country_text() const {
  return *country_text_;
}
inline void TripPath_Admin::set_country_text(const ::std::string& value) {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  country_text_->assign(value);
}
inline void TripPath_Admin::set_country_text(const char* value) {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  country_text_->assign(value);
}
inline void TripPath_Admin::set_country_text(const char* value, size_t size) {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  country_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Admin::mutable_country_text() {
  set_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    country_text_ = new ::std::string;
  }
  return country_text_;
}
inline ::std::string* TripPath_Admin::release_country_text() {
  clear_has_country_text();
  if (country_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_text_;
    country_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Admin::set_allocated_country_text(::std::string* country_text) {
  if (country_text_ != &::google::protobuf::internal::kEmptyString) {
    delete country_text_;
  }
  if (country_text) {
    set_has_country_text();
    country_text_ = country_text;
  } else {
    clear_has_country_text();
    country_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state_code = 3;
inline bool TripPath_Admin::has_state_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath_Admin::set_has_state_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath_Admin::clear_has_state_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath_Admin::clear_state_code() {
  if (state_code_ != &::google::protobuf::internal::kEmptyString) {
    state_code_->clear();
  }
  clear_has_state_code();
}
inline const ::std::string& TripPath_Admin::state_code() const {
  return *state_code_;
}
inline void TripPath_Admin::set_state_code(const ::std::string& value) {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  state_code_->assign(value);
}
inline void TripPath_Admin::set_state_code(const char* value) {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  state_code_->assign(value);
}
inline void TripPath_Admin::set_state_code(const char* value, size_t size) {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  state_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Admin::mutable_state_code() {
  set_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    state_code_ = new ::std::string;
  }
  return state_code_;
}
inline ::std::string* TripPath_Admin::release_state_code() {
  clear_has_state_code();
  if (state_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_code_;
    state_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Admin::set_allocated_state_code(::std::string* state_code) {
  if (state_code_ != &::google::protobuf::internal::kEmptyString) {
    delete state_code_;
  }
  if (state_code) {
    set_has_state_code();
    state_code_ = state_code;
  } else {
    clear_has_state_code();
    state_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state_text = 4;
inline bool TripPath_Admin::has_state_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripPath_Admin::set_has_state_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripPath_Admin::clear_has_state_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripPath_Admin::clear_state_text() {
  if (state_text_ != &::google::protobuf::internal::kEmptyString) {
    state_text_->clear();
  }
  clear_has_state_text();
}
inline const ::std::string& TripPath_Admin::state_text() const {
  return *state_text_;
}
inline void TripPath_Admin::set_state_text(const ::std::string& value) {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  state_text_->assign(value);
}
inline void TripPath_Admin::set_state_text(const char* value) {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  state_text_->assign(value);
}
inline void TripPath_Admin::set_state_text(const char* value, size_t size) {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  state_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath_Admin::mutable_state_text() {
  set_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    state_text_ = new ::std::string;
  }
  return state_text_;
}
inline ::std::string* TripPath_Admin::release_state_text() {
  clear_has_state_text();
  if (state_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_text_;
    state_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath_Admin::set_allocated_state_text(::std::string* state_text) {
  if (state_text_ != &::google::protobuf::internal::kEmptyString) {
    delete state_text_;
  }
  if (state_text) {
    set_has_state_text();
    state_text_ = state_text;
  } else {
    clear_has_state_text();
    state_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TripPath

// optional uint64 trip_id = 1;
inline bool TripPath::has_trip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripPath::set_has_trip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripPath::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripPath::clear_trip_id() {
  trip_id_ = GOOGLE_ULONGLONG(0);
  clear_has_trip_id();
}
inline ::google::protobuf::uint64 TripPath::trip_id() const {
  return trip_id_;
}
inline void TripPath::set_trip_id(::google::protobuf::uint64 value) {
  set_has_trip_id();
  trip_id_ = value;
}

// optional uint32 leg_id = 2;
inline bool TripPath::has_leg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripPath::set_has_leg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripPath::clear_has_leg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripPath::clear_leg_id() {
  leg_id_ = 0u;
  clear_has_leg_id();
}
inline ::google::protobuf::uint32 TripPath::leg_id() const {
  return leg_id_;
}
inline void TripPath::set_leg_id(::google::protobuf::uint32 value) {
  set_has_leg_id();
  leg_id_ = value;
}

// optional uint32 leg_count = 3;
inline bool TripPath::has_leg_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripPath::set_has_leg_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripPath::clear_has_leg_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripPath::clear_leg_count() {
  leg_count_ = 0u;
  clear_has_leg_count();
}
inline ::google::protobuf::uint32 TripPath::leg_count() const {
  return leg_count_;
}
inline void TripPath::set_leg_count(::google::protobuf::uint32 value) {
  set_has_leg_count();
  leg_count_ = value;
}

// repeated .valhalla.odin.TripPath.Location location = 4;
inline int TripPath::location_size() const {
  return location_.size();
}
inline void TripPath::clear_location() {
  location_.Clear();
}
inline const ::valhalla::odin::TripPath_Location& TripPath::location(int index) const {
  return location_.Get(index);
}
inline ::valhalla::odin::TripPath_Location* TripPath::mutable_location(int index) {
  return location_.Mutable(index);
}
inline ::valhalla::odin::TripPath_Location* TripPath::add_location() {
  return location_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Location >&
TripPath::location() const {
  return location_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Location >*
TripPath::mutable_location() {
  return &location_;
}

// repeated .valhalla.odin.TripPath.Node node = 5;
inline int TripPath::node_size() const {
  return node_.size();
}
inline void TripPath::clear_node() {
  node_.Clear();
}
inline const ::valhalla::odin::TripPath_Node& TripPath::node(int index) const {
  return node_.Get(index);
}
inline ::valhalla::odin::TripPath_Node* TripPath::mutable_node(int index) {
  return node_.Mutable(index);
}
inline ::valhalla::odin::TripPath_Node* TripPath::add_node() {
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Node >&
TripPath::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Node >*
TripPath::mutable_node() {
  return &node_;
}

// repeated .valhalla.odin.TripPath.Admin admin = 6;
inline int TripPath::admin_size() const {
  return admin_.size();
}
inline void TripPath::clear_admin() {
  admin_.Clear();
}
inline const ::valhalla::odin::TripPath_Admin& TripPath::admin(int index) const {
  return admin_.Get(index);
}
inline ::valhalla::odin::TripPath_Admin* TripPath::mutable_admin(int index) {
  return admin_.Mutable(index);
}
inline ::valhalla::odin::TripPath_Admin* TripPath::add_admin() {
  return admin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Admin >&
TripPath::admin() const {
  return admin_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripPath_Admin >*
TripPath::mutable_admin() {
  return &admin_;
}

// optional string shape = 7;
inline bool TripPath::has_shape() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripPath::set_has_shape() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripPath::clear_has_shape() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripPath::clear_shape() {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    shape_->clear();
  }
  clear_has_shape();
}
inline const ::std::string& TripPath::shape() const {
  return *shape_;
}
inline void TripPath::set_shape(const ::std::string& value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void TripPath::set_shape(const char* value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void TripPath::set_shape(const char* value, size_t size) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripPath::mutable_shape() {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  return shape_;
}
inline ::std::string* TripPath::release_shape() {
  clear_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shape_;
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripPath::set_allocated_shape(::std::string* shape) {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    delete shape_;
  }
  if (shape) {
    set_has_shape();
    shape_ = shape;
  } else {
    clear_has_shape();
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.odin.TripPath.BoundingBox bbox = 8;
inline bool TripPath::has_bbox() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripPath::set_has_bbox() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripPath::clear_has_bbox() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripPath::clear_bbox() {
  if (bbox_ != NULL) bbox_->::valhalla::odin::TripPath_BoundingBox::Clear();
  clear_has_bbox();
}
inline const ::valhalla::odin::TripPath_BoundingBox& TripPath::bbox() const {
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
}
inline ::valhalla::odin::TripPath_BoundingBox* TripPath::mutable_bbox() {
  set_has_bbox();
  if (bbox_ == NULL) bbox_ = new ::valhalla::odin::TripPath_BoundingBox;
  return bbox_;
}
inline ::valhalla::odin::TripPath_BoundingBox* TripPath::release_bbox() {
  clear_has_bbox();
  ::valhalla::odin::TripPath_BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void TripPath::set_allocated_bbox(::valhalla::odin::TripPath_BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    set_has_bbox();
  } else {
    clear_has_bbox();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace odin
}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_Location_Type>() {
  return ::valhalla::odin::TripPath_Location_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_Location_SideOfStreet>() {
  return ::valhalla::odin::TripPath_Location_SideOfStreet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_TransitStopInfo_Type>() {
  return ::valhalla::odin::TripPath_TransitStopInfo_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_Traversability>() {
  return ::valhalla::odin::TripPath_Traversability_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_RoadClass>() {
  return ::valhalla::odin::TripPath_RoadClass_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_TravelMode>() {
  return ::valhalla::odin::TripPath_TravelMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_VehicleType>() {
  return ::valhalla::odin::TripPath_VehicleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_PedestrianType>() {
  return ::valhalla::odin::TripPath_PedestrianType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_BicycleType>() {
  return ::valhalla::odin::TripPath_BicycleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripPath_TransitType>() {
  return ::valhalla::odin::TripPath_TransitType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trippath_2eproto__INCLUDED
