// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tripdirections.proto

#ifndef PROTOBUF_tripdirections_2eproto__INCLUDED
#define PROTOBUF_tripdirections_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace valhalla {
namespace odin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tripdirections_2eproto();
void protobuf_AssignDesc_tripdirections_2eproto();
void protobuf_ShutdownFile_tripdirections_2eproto();

class TripDirections;
class TripDirections_LatLng;
class TripDirections_BoundingBox;
class TripDirections_Location;
class TripDirections_Summary;
class TripDirections_TransitStop;
class TripDirections_TransitInfo;
class TripDirections_Maneuver;
class TripDirections_Maneuver_Sign;
class TripDirections_Maneuver_Sign_Element;

enum TripDirections_Location_Type {
  TripDirections_Location_Type_kBreak = 0,
  TripDirections_Location_Type_kThrough = 1
};
bool TripDirections_Location_Type_IsValid(int value);
const TripDirections_Location_Type TripDirections_Location_Type_Type_MIN = TripDirections_Location_Type_kBreak;
const TripDirections_Location_Type TripDirections_Location_Type_Type_MAX = TripDirections_Location_Type_kThrough;
const int TripDirections_Location_Type_Type_ARRAYSIZE = TripDirections_Location_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_Location_Type_descriptor();
inline const ::std::string& TripDirections_Location_Type_Name(TripDirections_Location_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_Location_Type_descriptor(), value);
}
inline bool TripDirections_Location_Type_Parse(
    const ::std::string& name, TripDirections_Location_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_Location_Type>(
    TripDirections_Location_Type_descriptor(), name, value);
}
enum TripDirections_Location_SideOfStreet {
  TripDirections_Location_SideOfStreet_kNone = 0,
  TripDirections_Location_SideOfStreet_kLeft = 1,
  TripDirections_Location_SideOfStreet_kRight = 2
};
bool TripDirections_Location_SideOfStreet_IsValid(int value);
const TripDirections_Location_SideOfStreet TripDirections_Location_SideOfStreet_SideOfStreet_MIN = TripDirections_Location_SideOfStreet_kNone;
const TripDirections_Location_SideOfStreet TripDirections_Location_SideOfStreet_SideOfStreet_MAX = TripDirections_Location_SideOfStreet_kRight;
const int TripDirections_Location_SideOfStreet_SideOfStreet_ARRAYSIZE = TripDirections_Location_SideOfStreet_SideOfStreet_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_Location_SideOfStreet_descriptor();
inline const ::std::string& TripDirections_Location_SideOfStreet_Name(TripDirections_Location_SideOfStreet value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_Location_SideOfStreet_descriptor(), value);
}
inline bool TripDirections_Location_SideOfStreet_Parse(
    const ::std::string& name, TripDirections_Location_SideOfStreet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_Location_SideOfStreet>(
    TripDirections_Location_SideOfStreet_descriptor(), name, value);
}
enum TripDirections_TransitStop_Type {
  TripDirections_TransitStop_Type_kStop = 0,
  TripDirections_TransitStop_Type_kStation = 1
};
bool TripDirections_TransitStop_Type_IsValid(int value);
const TripDirections_TransitStop_Type TripDirections_TransitStop_Type_Type_MIN = TripDirections_TransitStop_Type_kStop;
const TripDirections_TransitStop_Type TripDirections_TransitStop_Type_Type_MAX = TripDirections_TransitStop_Type_kStation;
const int TripDirections_TransitStop_Type_Type_ARRAYSIZE = TripDirections_TransitStop_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_TransitStop_Type_descriptor();
inline const ::std::string& TripDirections_TransitStop_Type_Name(TripDirections_TransitStop_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_TransitStop_Type_descriptor(), value);
}
inline bool TripDirections_TransitStop_Type_Parse(
    const ::std::string& name, TripDirections_TransitStop_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_TransitStop_Type>(
    TripDirections_TransitStop_Type_descriptor(), name, value);
}
enum TripDirections_Maneuver_CardinalDirection {
  TripDirections_Maneuver_CardinalDirection_kNorth = 0,
  TripDirections_Maneuver_CardinalDirection_kNorthEast = 1,
  TripDirections_Maneuver_CardinalDirection_kEast = 2,
  TripDirections_Maneuver_CardinalDirection_kSouthEast = 3,
  TripDirections_Maneuver_CardinalDirection_kSouth = 4,
  TripDirections_Maneuver_CardinalDirection_kSouthWest = 5,
  TripDirections_Maneuver_CardinalDirection_kWest = 6,
  TripDirections_Maneuver_CardinalDirection_kNorthWest = 7
};
bool TripDirections_Maneuver_CardinalDirection_IsValid(int value);
const TripDirections_Maneuver_CardinalDirection TripDirections_Maneuver_CardinalDirection_CardinalDirection_MIN = TripDirections_Maneuver_CardinalDirection_kNorth;
const TripDirections_Maneuver_CardinalDirection TripDirections_Maneuver_CardinalDirection_CardinalDirection_MAX = TripDirections_Maneuver_CardinalDirection_kNorthWest;
const int TripDirections_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE = TripDirections_Maneuver_CardinalDirection_CardinalDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_Maneuver_CardinalDirection_descriptor();
inline const ::std::string& TripDirections_Maneuver_CardinalDirection_Name(TripDirections_Maneuver_CardinalDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_Maneuver_CardinalDirection_descriptor(), value);
}
inline bool TripDirections_Maneuver_CardinalDirection_Parse(
    const ::std::string& name, TripDirections_Maneuver_CardinalDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_Maneuver_CardinalDirection>(
    TripDirections_Maneuver_CardinalDirection_descriptor(), name, value);
}
enum TripDirections_Maneuver_Type {
  TripDirections_Maneuver_Type_kNone = 0,
  TripDirections_Maneuver_Type_kStart = 1,
  TripDirections_Maneuver_Type_kStartRight = 2,
  TripDirections_Maneuver_Type_kStartLeft = 3,
  TripDirections_Maneuver_Type_kDestination = 4,
  TripDirections_Maneuver_Type_kDestinationRight = 5,
  TripDirections_Maneuver_Type_kDestinationLeft = 6,
  TripDirections_Maneuver_Type_kBecomes = 7,
  TripDirections_Maneuver_Type_kContinue = 8,
  TripDirections_Maneuver_Type_kSlightRight = 9,
  TripDirections_Maneuver_Type_kRight = 10,
  TripDirections_Maneuver_Type_kSharpRight = 11,
  TripDirections_Maneuver_Type_kUturnRight = 12,
  TripDirections_Maneuver_Type_kUturnLeft = 13,
  TripDirections_Maneuver_Type_kSharpLeft = 14,
  TripDirections_Maneuver_Type_kLeft = 15,
  TripDirections_Maneuver_Type_kSlightLeft = 16,
  TripDirections_Maneuver_Type_kRampStraight = 17,
  TripDirections_Maneuver_Type_kRampRight = 18,
  TripDirections_Maneuver_Type_kRampLeft = 19,
  TripDirections_Maneuver_Type_kExitRight = 20,
  TripDirections_Maneuver_Type_kExitLeft = 21,
  TripDirections_Maneuver_Type_kStayStraight = 22,
  TripDirections_Maneuver_Type_kStayRight = 23,
  TripDirections_Maneuver_Type_kStayLeft = 24,
  TripDirections_Maneuver_Type_kMerge = 25,
  TripDirections_Maneuver_Type_kRoundaboutEnter = 26,
  TripDirections_Maneuver_Type_kRoundaboutExit = 27,
  TripDirections_Maneuver_Type_kFerryEnter = 28,
  TripDirections_Maneuver_Type_kFerryExit = 29,
  TripDirections_Maneuver_Type_kTransit = 30,
  TripDirections_Maneuver_Type_kTransitTransfer = 31,
  TripDirections_Maneuver_Type_kTransitRemainOn = 32,
  TripDirections_Maneuver_Type_kTransitConnectionStart = 33,
  TripDirections_Maneuver_Type_kTransitConnectionTransfer = 34,
  TripDirections_Maneuver_Type_kTransitConnectionDestination = 35,
  TripDirections_Maneuver_Type_kPostTransitConnectionDestination = 36
};
bool TripDirections_Maneuver_Type_IsValid(int value);
const TripDirections_Maneuver_Type TripDirections_Maneuver_Type_Type_MIN = TripDirections_Maneuver_Type_kNone;
const TripDirections_Maneuver_Type TripDirections_Maneuver_Type_Type_MAX = TripDirections_Maneuver_Type_kPostTransitConnectionDestination;
const int TripDirections_Maneuver_Type_Type_ARRAYSIZE = TripDirections_Maneuver_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_Maneuver_Type_descriptor();
inline const ::std::string& TripDirections_Maneuver_Type_Name(TripDirections_Maneuver_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_Maneuver_Type_descriptor(), value);
}
inline bool TripDirections_Maneuver_Type_Parse(
    const ::std::string& name, TripDirections_Maneuver_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_Maneuver_Type>(
    TripDirections_Maneuver_Type_descriptor(), name, value);
}
enum TripDirections_TravelMode {
  TripDirections_TravelMode_kDrive = 0,
  TripDirections_TravelMode_kPedestrian = 1,
  TripDirections_TravelMode_kBicycle = 2,
  TripDirections_TravelMode_kTransit = 3
};
bool TripDirections_TravelMode_IsValid(int value);
const TripDirections_TravelMode TripDirections_TravelMode_TravelMode_MIN = TripDirections_TravelMode_kDrive;
const TripDirections_TravelMode TripDirections_TravelMode_TravelMode_MAX = TripDirections_TravelMode_kTransit;
const int TripDirections_TravelMode_TravelMode_ARRAYSIZE = TripDirections_TravelMode_TravelMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_TravelMode_descriptor();
inline const ::std::string& TripDirections_TravelMode_Name(TripDirections_TravelMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_TravelMode_descriptor(), value);
}
inline bool TripDirections_TravelMode_Parse(
    const ::std::string& name, TripDirections_TravelMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_TravelMode>(
    TripDirections_TravelMode_descriptor(), name, value);
}
enum TripDirections_VehicleType {
  TripDirections_VehicleType_kCar = 0,
  TripDirections_VehicleType_kMotorcycle = 1,
  TripDirections_VehicleType_kAutoBus = 2,
  TripDirections_VehicleType_kTractorTrailer = 3
};
bool TripDirections_VehicleType_IsValid(int value);
const TripDirections_VehicleType TripDirections_VehicleType_VehicleType_MIN = TripDirections_VehicleType_kCar;
const TripDirections_VehicleType TripDirections_VehicleType_VehicleType_MAX = TripDirections_VehicleType_kTractorTrailer;
const int TripDirections_VehicleType_VehicleType_ARRAYSIZE = TripDirections_VehicleType_VehicleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_VehicleType_descriptor();
inline const ::std::string& TripDirections_VehicleType_Name(TripDirections_VehicleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_VehicleType_descriptor(), value);
}
inline bool TripDirections_VehicleType_Parse(
    const ::std::string& name, TripDirections_VehicleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_VehicleType>(
    TripDirections_VehicleType_descriptor(), name, value);
}
enum TripDirections_PedestrianType {
  TripDirections_PedestrianType_kFoot = 0,
  TripDirections_PedestrianType_kWheelchair = 1,
  TripDirections_PedestrianType_kSegway = 2
};
bool TripDirections_PedestrianType_IsValid(int value);
const TripDirections_PedestrianType TripDirections_PedestrianType_PedestrianType_MIN = TripDirections_PedestrianType_kFoot;
const TripDirections_PedestrianType TripDirections_PedestrianType_PedestrianType_MAX = TripDirections_PedestrianType_kSegway;
const int TripDirections_PedestrianType_PedestrianType_ARRAYSIZE = TripDirections_PedestrianType_PedestrianType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_PedestrianType_descriptor();
inline const ::std::string& TripDirections_PedestrianType_Name(TripDirections_PedestrianType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_PedestrianType_descriptor(), value);
}
inline bool TripDirections_PedestrianType_Parse(
    const ::std::string& name, TripDirections_PedestrianType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_PedestrianType>(
    TripDirections_PedestrianType_descriptor(), name, value);
}
enum TripDirections_BicycleType {
  TripDirections_BicycleType_kRoad = 0,
  TripDirections_BicycleType_kCross = 1,
  TripDirections_BicycleType_kHybrid = 2,
  TripDirections_BicycleType_kMountain = 3
};
bool TripDirections_BicycleType_IsValid(int value);
const TripDirections_BicycleType TripDirections_BicycleType_BicycleType_MIN = TripDirections_BicycleType_kRoad;
const TripDirections_BicycleType TripDirections_BicycleType_BicycleType_MAX = TripDirections_BicycleType_kMountain;
const int TripDirections_BicycleType_BicycleType_ARRAYSIZE = TripDirections_BicycleType_BicycleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_BicycleType_descriptor();
inline const ::std::string& TripDirections_BicycleType_Name(TripDirections_BicycleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_BicycleType_descriptor(), value);
}
inline bool TripDirections_BicycleType_Parse(
    const ::std::string& name, TripDirections_BicycleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_BicycleType>(
    TripDirections_BicycleType_descriptor(), name, value);
}
enum TripDirections_TransitType {
  TripDirections_TransitType_kTram = 0,
  TripDirections_TransitType_kMetro = 1,
  TripDirections_TransitType_kRail = 2,
  TripDirections_TransitType_kBus = 3,
  TripDirections_TransitType_kFerry = 4,
  TripDirections_TransitType_kCableCar = 5,
  TripDirections_TransitType_kGondola = 6,
  TripDirections_TransitType_kFunicular = 7
};
bool TripDirections_TransitType_IsValid(int value);
const TripDirections_TransitType TripDirections_TransitType_TransitType_MIN = TripDirections_TransitType_kTram;
const TripDirections_TransitType TripDirections_TransitType_TransitType_MAX = TripDirections_TransitType_kFunicular;
const int TripDirections_TransitType_TransitType_ARRAYSIZE = TripDirections_TransitType_TransitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDirections_TransitType_descriptor();
inline const ::std::string& TripDirections_TransitType_Name(TripDirections_TransitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDirections_TransitType_descriptor(), value);
}
inline bool TripDirections_TransitType_Parse(
    const ::std::string& name, TripDirections_TransitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDirections_TransitType>(
    TripDirections_TransitType_descriptor(), name, value);
}
// ===================================================================

class TripDirections_LatLng : public ::google::protobuf::Message {
 public:
  TripDirections_LatLng();
  virtual ~TripDirections_LatLng();

  TripDirections_LatLng(const TripDirections_LatLng& from);

  inline TripDirections_LatLng& operator=(const TripDirections_LatLng& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_LatLng& default_instance();

  void Swap(TripDirections_LatLng* other);

  // implements Message ----------------------------------------------

  TripDirections_LatLng* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_LatLng& from);
  void MergeFrom(const TripDirections_LatLng& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lng = 2;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 2;
  inline float lng() const;
  inline void set_lng(float value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.LatLng)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lng();
  inline void clear_has_lng();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float lat_;
  float lng_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_LatLng* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_BoundingBox : public ::google::protobuf::Message {
 public:
  TripDirections_BoundingBox();
  virtual ~TripDirections_BoundingBox();

  TripDirections_BoundingBox(const TripDirections_BoundingBox& from);

  inline TripDirections_BoundingBox& operator=(const TripDirections_BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_BoundingBox& default_instance();

  void Swap(TripDirections_BoundingBox* other);

  // implements Message ----------------------------------------------

  TripDirections_BoundingBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_BoundingBox& from);
  void MergeFrom(const TripDirections_BoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripDirections.LatLng min_ll = 1;
  inline bool has_min_ll() const;
  inline void clear_min_ll();
  static const int kMinLlFieldNumber = 1;
  inline const ::valhalla::odin::TripDirections_LatLng& min_ll() const;
  inline ::valhalla::odin::TripDirections_LatLng* mutable_min_ll();
  inline ::valhalla::odin::TripDirections_LatLng* release_min_ll();
  inline void set_allocated_min_ll(::valhalla::odin::TripDirections_LatLng* min_ll);

  // optional .valhalla.odin.TripDirections.LatLng max_ll = 2;
  inline bool has_max_ll() const;
  inline void clear_max_ll();
  static const int kMaxLlFieldNumber = 2;
  inline const ::valhalla::odin::TripDirections_LatLng& max_ll() const;
  inline ::valhalla::odin::TripDirections_LatLng* mutable_max_ll();
  inline ::valhalla::odin::TripDirections_LatLng* release_max_ll();
  inline void set_allocated_max_ll(::valhalla::odin::TripDirections_LatLng* max_ll);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.BoundingBox)
 private:
  inline void set_has_min_ll();
  inline void clear_has_min_ll();
  inline void set_has_max_ll();
  inline void clear_has_max_ll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::TripDirections_LatLng* min_ll_;
  ::valhalla::odin::TripDirections_LatLng* max_ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_Location : public ::google::protobuf::Message {
 public:
  TripDirections_Location();
  virtual ~TripDirections_Location();

  TripDirections_Location(const TripDirections_Location& from);

  inline TripDirections_Location& operator=(const TripDirections_Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_Location& default_instance();

  void Swap(TripDirections_Location* other);

  // implements Message ----------------------------------------------

  TripDirections_Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_Location& from);
  void MergeFrom(const TripDirections_Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripDirections_Location_Type Type;
  static const Type kBreak = TripDirections_Location_Type_kBreak;
  static const Type kThrough = TripDirections_Location_Type_kThrough;
  static inline bool Type_IsValid(int value) {
    return TripDirections_Location_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripDirections_Location_Type_Type_MIN;
  static const Type Type_MAX =
    TripDirections_Location_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripDirections_Location_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TripDirections_Location_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TripDirections_Location_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TripDirections_Location_Type_Parse(name, value);
  }

  typedef TripDirections_Location_SideOfStreet SideOfStreet;
  static const SideOfStreet kNone = TripDirections_Location_SideOfStreet_kNone;
  static const SideOfStreet kLeft = TripDirections_Location_SideOfStreet_kLeft;
  static const SideOfStreet kRight = TripDirections_Location_SideOfStreet_kRight;
  static inline bool SideOfStreet_IsValid(int value) {
    return TripDirections_Location_SideOfStreet_IsValid(value);
  }
  static const SideOfStreet SideOfStreet_MIN =
    TripDirections_Location_SideOfStreet_SideOfStreet_MIN;
  static const SideOfStreet SideOfStreet_MAX =
    TripDirections_Location_SideOfStreet_SideOfStreet_MAX;
  static const int SideOfStreet_ARRAYSIZE =
    TripDirections_Location_SideOfStreet_SideOfStreet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SideOfStreet_descriptor() {
    return TripDirections_Location_SideOfStreet_descriptor();
  }
  static inline const ::std::string& SideOfStreet_Name(SideOfStreet value) {
    return TripDirections_Location_SideOfStreet_Name(value);
  }
  static inline bool SideOfStreet_Parse(const ::std::string& name,
      SideOfStreet* value) {
    return TripDirections_Location_SideOfStreet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripDirections.LatLng ll = 1;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 1;
  inline const ::valhalla::odin::TripDirections_LatLng& ll() const;
  inline ::valhalla::odin::TripDirections_LatLng* mutable_ll();
  inline ::valhalla::odin::TripDirections_LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::odin::TripDirections_LatLng* ll);

  // optional .valhalla.odin.TripDirections.Location.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::valhalla::odin::TripDirections_Location_Type type() const;
  inline void set_type(::valhalla::odin::TripDirections_Location_Type value);

  // optional uint32 heading = 3;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 3;
  inline ::google::protobuf::uint32 heading() const;
  inline void set_heading(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string street = 5;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 5;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string postal_code = 8;
  inline bool has_postal_code() const;
  inline void clear_postal_code();
  static const int kPostalCodeFieldNumber = 8;
  inline const ::std::string& postal_code() const;
  inline void set_postal_code(const ::std::string& value);
  inline void set_postal_code(const char* value);
  inline void set_postal_code(const char* value, size_t size);
  inline ::std::string* mutable_postal_code();
  inline ::std::string* release_postal_code();
  inline void set_allocated_postal_code(::std::string* postal_code);

  // optional string country = 9;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 9;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string date_time = 10;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 10;
  inline const ::std::string& date_time() const;
  inline void set_date_time(const ::std::string& value);
  inline void set_date_time(const char* value);
  inline void set_date_time(const char* value, size_t size);
  inline ::std::string* mutable_date_time();
  inline ::std::string* release_date_time();
  inline void set_allocated_date_time(::std::string* date_time);

  // optional .valhalla.odin.TripDirections.Location.SideOfStreet side_of_street = 11;
  inline bool has_side_of_street() const;
  inline void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 11;
  inline ::valhalla::odin::TripDirections_Location_SideOfStreet side_of_street() const;
  inline void set_side_of_street(::valhalla::odin::TripDirections_Location_SideOfStreet value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.Location)
 private:
  inline void set_has_ll();
  inline void clear_has_ll();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_postal_code();
  inline void clear_has_postal_code();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_date_time();
  inline void clear_has_date_time();
  inline void set_has_side_of_street();
  inline void clear_has_side_of_street();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::TripDirections_LatLng* ll_;
  int type_;
  ::google::protobuf::uint32 heading_;
  ::std::string* name_;
  ::std::string* street_;
  ::std::string* city_;
  ::std::string* state_;
  ::std::string* postal_code_;
  ::std::string* country_;
  ::std::string* date_time_;
  int side_of_street_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_Location* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_Summary : public ::google::protobuf::Message {
 public:
  TripDirections_Summary();
  virtual ~TripDirections_Summary();

  TripDirections_Summary(const TripDirections_Summary& from);

  inline TripDirections_Summary& operator=(const TripDirections_Summary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_Summary& default_instance();

  void Swap(TripDirections_Summary* other);

  // implements Message ----------------------------------------------

  TripDirections_Summary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_Summary& from);
  void MergeFrom(const TripDirections_Summary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline float length() const;
  inline void set_length(float value);

  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .valhalla.odin.TripDirections.BoundingBox bbox = 3;
  inline bool has_bbox() const;
  inline void clear_bbox();
  static const int kBboxFieldNumber = 3;
  inline const ::valhalla::odin::TripDirections_BoundingBox& bbox() const;
  inline ::valhalla::odin::TripDirections_BoundingBox* mutable_bbox();
  inline ::valhalla::odin::TripDirections_BoundingBox* release_bbox();
  inline void set_allocated_bbox(::valhalla::odin::TripDirections_BoundingBox* bbox);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.Summary)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bbox();
  inline void clear_has_bbox();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float length_;
  ::google::protobuf::uint32 time_;
  ::valhalla::odin::TripDirections_BoundingBox* bbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_Summary* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_TransitStop : public ::google::protobuf::Message {
 public:
  TripDirections_TransitStop();
  virtual ~TripDirections_TransitStop();

  TripDirections_TransitStop(const TripDirections_TransitStop& from);

  inline TripDirections_TransitStop& operator=(const TripDirections_TransitStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_TransitStop& default_instance();

  void Swap(TripDirections_TransitStop* other);

  // implements Message ----------------------------------------------

  TripDirections_TransitStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_TransitStop& from);
  void MergeFrom(const TripDirections_TransitStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripDirections_TransitStop_Type Type;
  static const Type kStop = TripDirections_TransitStop_Type_kStop;
  static const Type kStation = TripDirections_TransitStop_Type_kStation;
  static inline bool Type_IsValid(int value) {
    return TripDirections_TransitStop_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripDirections_TransitStop_Type_Type_MIN;
  static const Type Type_MAX =
    TripDirections_TransitStop_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripDirections_TransitStop_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TripDirections_TransitStop_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TripDirections_TransitStop_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TripDirections_TransitStop_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripDirections.TransitStop.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::valhalla::odin::TripDirections_TransitStop_Type type() const;
  inline void set_type(::valhalla::odin::TripDirections_TransitStop_Type value);

  // optional string onestop_id = 2;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 2;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string arrival_date_time = 4;
  inline bool has_arrival_date_time() const;
  inline void clear_arrival_date_time();
  static const int kArrivalDateTimeFieldNumber = 4;
  inline const ::std::string& arrival_date_time() const;
  inline void set_arrival_date_time(const ::std::string& value);
  inline void set_arrival_date_time(const char* value);
  inline void set_arrival_date_time(const char* value, size_t size);
  inline ::std::string* mutable_arrival_date_time();
  inline ::std::string* release_arrival_date_time();
  inline void set_allocated_arrival_date_time(::std::string* arrival_date_time);

  // optional string departure_date_time = 5;
  inline bool has_departure_date_time() const;
  inline void clear_departure_date_time();
  static const int kDepartureDateTimeFieldNumber = 5;
  inline const ::std::string& departure_date_time() const;
  inline void set_departure_date_time(const ::std::string& value);
  inline void set_departure_date_time(const char* value);
  inline void set_departure_date_time(const char* value, size_t size);
  inline ::std::string* mutable_departure_date_time();
  inline ::std::string* release_departure_date_time();
  inline void set_allocated_departure_date_time(::std::string* departure_date_time);

  // optional bool is_parent_stop = 6;
  inline bool has_is_parent_stop() const;
  inline void clear_is_parent_stop();
  static const int kIsParentStopFieldNumber = 6;
  inline bool is_parent_stop() const;
  inline void set_is_parent_stop(bool value);

  // optional bool assumed_schedule = 7;
  inline bool has_assumed_schedule() const;
  inline void clear_assumed_schedule();
  static const int kAssumedScheduleFieldNumber = 7;
  inline bool assumed_schedule() const;
  inline void set_assumed_schedule(bool value);

  // optional .valhalla.odin.TripDirections.LatLng ll = 8;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 8;
  inline const ::valhalla::odin::TripDirections_LatLng& ll() const;
  inline ::valhalla::odin::TripDirections_LatLng* mutable_ll();
  inline ::valhalla::odin::TripDirections_LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::odin::TripDirections_LatLng* ll);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.TransitStop)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_arrival_date_time();
  inline void clear_has_arrival_date_time();
  inline void set_has_departure_date_time();
  inline void clear_has_departure_date_time();
  inline void set_has_is_parent_stop();
  inline void clear_has_is_parent_stop();
  inline void set_has_assumed_schedule();
  inline void clear_has_assumed_schedule();
  inline void set_has_ll();
  inline void clear_has_ll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* onestop_id_;
  ::std::string* name_;
  ::std::string* arrival_date_time_;
  int type_;
  bool is_parent_stop_;
  bool assumed_schedule_;
  ::std::string* departure_date_time_;
  ::valhalla::odin::TripDirections_LatLng* ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_TransitStop* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_TransitInfo : public ::google::protobuf::Message {
 public:
  TripDirections_TransitInfo();
  virtual ~TripDirections_TransitInfo();

  TripDirections_TransitInfo(const TripDirections_TransitInfo& from);

  inline TripDirections_TransitInfo& operator=(const TripDirections_TransitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_TransitInfo& default_instance();

  void Swap(TripDirections_TransitInfo* other);

  // implements Message ----------------------------------------------

  TripDirections_TransitInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_TransitInfo& from);
  void MergeFrom(const TripDirections_TransitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string onestop_id = 1;
  inline bool has_onestop_id() const;
  inline void clear_onestop_id();
  static const int kOnestopIdFieldNumber = 1;
  inline const ::std::string& onestop_id() const;
  inline void set_onestop_id(const ::std::string& value);
  inline void set_onestop_id(const char* value);
  inline void set_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_onestop_id();
  inline ::std::string* release_onestop_id();
  inline void set_allocated_onestop_id(::std::string* onestop_id);

  // optional string short_name = 2;
  inline bool has_short_name() const;
  inline void clear_short_name();
  static const int kShortNameFieldNumber = 2;
  inline const ::std::string& short_name() const;
  inline void set_short_name(const ::std::string& value);
  inline void set_short_name(const char* value);
  inline void set_short_name(const char* value, size_t size);
  inline ::std::string* mutable_short_name();
  inline ::std::string* release_short_name();
  inline void set_allocated_short_name(::std::string* short_name);

  // optional string long_name = 3;
  inline bool has_long_name() const;
  inline void clear_long_name();
  static const int kLongNameFieldNumber = 3;
  inline const ::std::string& long_name() const;
  inline void set_long_name(const ::std::string& value);
  inline void set_long_name(const char* value);
  inline void set_long_name(const char* value, size_t size);
  inline ::std::string* mutable_long_name();
  inline ::std::string* release_long_name();
  inline void set_allocated_long_name(::std::string* long_name);

  // optional string headsign = 4;
  inline bool has_headsign() const;
  inline void clear_headsign();
  static const int kHeadsignFieldNumber = 4;
  inline const ::std::string& headsign() const;
  inline void set_headsign(const ::std::string& value);
  inline void set_headsign(const char* value);
  inline void set_headsign(const char* value, size_t size);
  inline ::std::string* mutable_headsign();
  inline ::std::string* release_headsign();
  inline void set_allocated_headsign(::std::string* headsign);

  // optional uint32 color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // optional uint32 text_color = 6;
  inline bool has_text_color() const;
  inline void clear_text_color();
  static const int kTextColorFieldNumber = 6;
  inline ::google::protobuf::uint32 text_color() const;
  inline void set_text_color(::google::protobuf::uint32 value);

  // optional string description = 7;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 7;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string operator_onestop_id = 8;
  inline bool has_operator_onestop_id() const;
  inline void clear_operator_onestop_id();
  static const int kOperatorOnestopIdFieldNumber = 8;
  inline const ::std::string& operator_onestop_id() const;
  inline void set_operator_onestop_id(const ::std::string& value);
  inline void set_operator_onestop_id(const char* value);
  inline void set_operator_onestop_id(const char* value, size_t size);
  inline ::std::string* mutable_operator_onestop_id();
  inline ::std::string* release_operator_onestop_id();
  inline void set_allocated_operator_onestop_id(::std::string* operator_onestop_id);

  // optional string operator_name = 9;
  inline bool has_operator_name() const;
  inline void clear_operator_name();
  static const int kOperatorNameFieldNumber = 9;
  inline const ::std::string& operator_name() const;
  inline void set_operator_name(const ::std::string& value);
  inline void set_operator_name(const char* value);
  inline void set_operator_name(const char* value, size_t size);
  inline ::std::string* mutable_operator_name();
  inline ::std::string* release_operator_name();
  inline void set_allocated_operator_name(::std::string* operator_name);

  // optional string operator_url = 10;
  inline bool has_operator_url() const;
  inline void clear_operator_url();
  static const int kOperatorUrlFieldNumber = 10;
  inline const ::std::string& operator_url() const;
  inline void set_operator_url(const ::std::string& value);
  inline void set_operator_url(const char* value);
  inline void set_operator_url(const char* value, size_t size);
  inline ::std::string* mutable_operator_url();
  inline ::std::string* release_operator_url();
  inline void set_allocated_operator_url(::std::string* operator_url);

  // repeated .valhalla.odin.TripDirections.TransitStop transit_stops = 11;
  inline int transit_stops_size() const;
  inline void clear_transit_stops();
  static const int kTransitStopsFieldNumber = 11;
  inline const ::valhalla::odin::TripDirections_TransitStop& transit_stops(int index) const;
  inline ::valhalla::odin::TripDirections_TransitStop* mutable_transit_stops(int index);
  inline ::valhalla::odin::TripDirections_TransitStop* add_transit_stops();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_TransitStop >&
      transit_stops() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_TransitStop >*
      mutable_transit_stops();

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.TransitInfo)
 private:
  inline void set_has_onestop_id();
  inline void clear_has_onestop_id();
  inline void set_has_short_name();
  inline void clear_has_short_name();
  inline void set_has_long_name();
  inline void clear_has_long_name();
  inline void set_has_headsign();
  inline void clear_has_headsign();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_text_color();
  inline void clear_has_text_color();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_operator_onestop_id();
  inline void clear_has_operator_onestop_id();
  inline void set_has_operator_name();
  inline void clear_has_operator_name();
  inline void set_has_operator_url();
  inline void clear_has_operator_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* onestop_id_;
  ::std::string* short_name_;
  ::std::string* long_name_;
  ::std::string* headsign_;
  ::google::protobuf::uint32 color_;
  ::google::protobuf::uint32 text_color_;
  ::std::string* description_;
  ::std::string* operator_onestop_id_;
  ::std::string* operator_name_;
  ::std::string* operator_url_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_TransitStop > transit_stops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_TransitInfo* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_Maneuver_Sign_Element : public ::google::protobuf::Message {
 public:
  TripDirections_Maneuver_Sign_Element();
  virtual ~TripDirections_Maneuver_Sign_Element();

  TripDirections_Maneuver_Sign_Element(const TripDirections_Maneuver_Sign_Element& from);

  inline TripDirections_Maneuver_Sign_Element& operator=(const TripDirections_Maneuver_Sign_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_Maneuver_Sign_Element& default_instance();

  void Swap(TripDirections_Maneuver_Sign_Element* other);

  // implements Message ----------------------------------------------

  TripDirections_Maneuver_Sign_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_Maneuver_Sign_Element& from);
  void MergeFrom(const TripDirections_Maneuver_Sign_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional uint32 consecutive_count = 2;
  inline bool has_consecutive_count() const;
  inline void clear_consecutive_count();
  static const int kConsecutiveCountFieldNumber = 2;
  inline ::google::protobuf::uint32 consecutive_count() const;
  inline void set_consecutive_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.Maneuver.Sign.Element)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_consecutive_count();
  inline void clear_has_consecutive_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::uint32 consecutive_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_Maneuver_Sign_Element* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_Maneuver_Sign : public ::google::protobuf::Message {
 public:
  TripDirections_Maneuver_Sign();
  virtual ~TripDirections_Maneuver_Sign();

  TripDirections_Maneuver_Sign(const TripDirections_Maneuver_Sign& from);

  inline TripDirections_Maneuver_Sign& operator=(const TripDirections_Maneuver_Sign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_Maneuver_Sign& default_instance();

  void Swap(TripDirections_Maneuver_Sign* other);

  // implements Message ----------------------------------------------

  TripDirections_Maneuver_Sign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_Maneuver_Sign& from);
  void MergeFrom(const TripDirections_Maneuver_Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripDirections_Maneuver_Sign_Element Element;

  // accessors -------------------------------------------------------

  // repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_number_elements = 1;
  inline int exit_number_elements_size() const;
  inline void clear_exit_number_elements();
  static const int kExitNumberElementsFieldNumber = 1;
  inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& exit_number_elements(int index) const;
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* mutable_exit_number_elements(int index);
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* add_exit_number_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
      exit_number_elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
      mutable_exit_number_elements();

  // repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_branch_elements = 2;
  inline int exit_branch_elements_size() const;
  inline void clear_exit_branch_elements();
  static const int kExitBranchElementsFieldNumber = 2;
  inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& exit_branch_elements(int index) const;
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* mutable_exit_branch_elements(int index);
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* add_exit_branch_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
      exit_branch_elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
      mutable_exit_branch_elements();

  // repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_toward_elements = 3;
  inline int exit_toward_elements_size() const;
  inline void clear_exit_toward_elements();
  static const int kExitTowardElementsFieldNumber = 3;
  inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& exit_toward_elements(int index) const;
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* mutable_exit_toward_elements(int index);
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* add_exit_toward_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
      exit_toward_elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
      mutable_exit_toward_elements();

  // repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_name_elements = 4;
  inline int exit_name_elements_size() const;
  inline void clear_exit_name_elements();
  static const int kExitNameElementsFieldNumber = 4;
  inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& exit_name_elements(int index) const;
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* mutable_exit_name_elements(int index);
  inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* add_exit_name_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
      exit_name_elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
      mutable_exit_name_elements();

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.Maneuver.Sign)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element > exit_number_elements_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element > exit_branch_elements_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element > exit_toward_elements_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element > exit_name_elements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_Maneuver_Sign* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections_Maneuver : public ::google::protobuf::Message {
 public:
  TripDirections_Maneuver();
  virtual ~TripDirections_Maneuver();

  TripDirections_Maneuver(const TripDirections_Maneuver& from);

  inline TripDirections_Maneuver& operator=(const TripDirections_Maneuver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections_Maneuver& default_instance();

  void Swap(TripDirections_Maneuver* other);

  // implements Message ----------------------------------------------

  TripDirections_Maneuver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections_Maneuver& from);
  void MergeFrom(const TripDirections_Maneuver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripDirections_Maneuver_Sign Sign;

  typedef TripDirections_Maneuver_CardinalDirection CardinalDirection;
  static const CardinalDirection kNorth = TripDirections_Maneuver_CardinalDirection_kNorth;
  static const CardinalDirection kNorthEast = TripDirections_Maneuver_CardinalDirection_kNorthEast;
  static const CardinalDirection kEast = TripDirections_Maneuver_CardinalDirection_kEast;
  static const CardinalDirection kSouthEast = TripDirections_Maneuver_CardinalDirection_kSouthEast;
  static const CardinalDirection kSouth = TripDirections_Maneuver_CardinalDirection_kSouth;
  static const CardinalDirection kSouthWest = TripDirections_Maneuver_CardinalDirection_kSouthWest;
  static const CardinalDirection kWest = TripDirections_Maneuver_CardinalDirection_kWest;
  static const CardinalDirection kNorthWest = TripDirections_Maneuver_CardinalDirection_kNorthWest;
  static inline bool CardinalDirection_IsValid(int value) {
    return TripDirections_Maneuver_CardinalDirection_IsValid(value);
  }
  static const CardinalDirection CardinalDirection_MIN =
    TripDirections_Maneuver_CardinalDirection_CardinalDirection_MIN;
  static const CardinalDirection CardinalDirection_MAX =
    TripDirections_Maneuver_CardinalDirection_CardinalDirection_MAX;
  static const int CardinalDirection_ARRAYSIZE =
    TripDirections_Maneuver_CardinalDirection_CardinalDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CardinalDirection_descriptor() {
    return TripDirections_Maneuver_CardinalDirection_descriptor();
  }
  static inline const ::std::string& CardinalDirection_Name(CardinalDirection value) {
    return TripDirections_Maneuver_CardinalDirection_Name(value);
  }
  static inline bool CardinalDirection_Parse(const ::std::string& name,
      CardinalDirection* value) {
    return TripDirections_Maneuver_CardinalDirection_Parse(name, value);
  }

  typedef TripDirections_Maneuver_Type Type;
  static const Type kNone = TripDirections_Maneuver_Type_kNone;
  static const Type kStart = TripDirections_Maneuver_Type_kStart;
  static const Type kStartRight = TripDirections_Maneuver_Type_kStartRight;
  static const Type kStartLeft = TripDirections_Maneuver_Type_kStartLeft;
  static const Type kDestination = TripDirections_Maneuver_Type_kDestination;
  static const Type kDestinationRight = TripDirections_Maneuver_Type_kDestinationRight;
  static const Type kDestinationLeft = TripDirections_Maneuver_Type_kDestinationLeft;
  static const Type kBecomes = TripDirections_Maneuver_Type_kBecomes;
  static const Type kContinue = TripDirections_Maneuver_Type_kContinue;
  static const Type kSlightRight = TripDirections_Maneuver_Type_kSlightRight;
  static const Type kRight = TripDirections_Maneuver_Type_kRight;
  static const Type kSharpRight = TripDirections_Maneuver_Type_kSharpRight;
  static const Type kUturnRight = TripDirections_Maneuver_Type_kUturnRight;
  static const Type kUturnLeft = TripDirections_Maneuver_Type_kUturnLeft;
  static const Type kSharpLeft = TripDirections_Maneuver_Type_kSharpLeft;
  static const Type kLeft = TripDirections_Maneuver_Type_kLeft;
  static const Type kSlightLeft = TripDirections_Maneuver_Type_kSlightLeft;
  static const Type kRampStraight = TripDirections_Maneuver_Type_kRampStraight;
  static const Type kRampRight = TripDirections_Maneuver_Type_kRampRight;
  static const Type kRampLeft = TripDirections_Maneuver_Type_kRampLeft;
  static const Type kExitRight = TripDirections_Maneuver_Type_kExitRight;
  static const Type kExitLeft = TripDirections_Maneuver_Type_kExitLeft;
  static const Type kStayStraight = TripDirections_Maneuver_Type_kStayStraight;
  static const Type kStayRight = TripDirections_Maneuver_Type_kStayRight;
  static const Type kStayLeft = TripDirections_Maneuver_Type_kStayLeft;
  static const Type kMerge = TripDirections_Maneuver_Type_kMerge;
  static const Type kRoundaboutEnter = TripDirections_Maneuver_Type_kRoundaboutEnter;
  static const Type kRoundaboutExit = TripDirections_Maneuver_Type_kRoundaboutExit;
  static const Type kFerryEnter = TripDirections_Maneuver_Type_kFerryEnter;
  static const Type kFerryExit = TripDirections_Maneuver_Type_kFerryExit;
  static const Type kTransit = TripDirections_Maneuver_Type_kTransit;
  static const Type kTransitTransfer = TripDirections_Maneuver_Type_kTransitTransfer;
  static const Type kTransitRemainOn = TripDirections_Maneuver_Type_kTransitRemainOn;
  static const Type kTransitConnectionStart = TripDirections_Maneuver_Type_kTransitConnectionStart;
  static const Type kTransitConnectionTransfer = TripDirections_Maneuver_Type_kTransitConnectionTransfer;
  static const Type kTransitConnectionDestination = TripDirections_Maneuver_Type_kTransitConnectionDestination;
  static const Type kPostTransitConnectionDestination = TripDirections_Maneuver_Type_kPostTransitConnectionDestination;
  static inline bool Type_IsValid(int value) {
    return TripDirections_Maneuver_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TripDirections_Maneuver_Type_Type_MIN;
  static const Type Type_MAX =
    TripDirections_Maneuver_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TripDirections_Maneuver_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TripDirections_Maneuver_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TripDirections_Maneuver_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TripDirections_Maneuver_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.TripDirections.Maneuver.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::valhalla::odin::TripDirections_Maneuver_Type type() const;
  inline void set_type(::valhalla::odin::TripDirections_Maneuver_Type value);

  // optional string text_instruction = 2;
  inline bool has_text_instruction() const;
  inline void clear_text_instruction();
  static const int kTextInstructionFieldNumber = 2;
  inline const ::std::string& text_instruction() const;
  inline void set_text_instruction(const ::std::string& value);
  inline void set_text_instruction(const char* value);
  inline void set_text_instruction(const char* value, size_t size);
  inline ::std::string* mutable_text_instruction();
  inline ::std::string* release_text_instruction();
  inline void set_allocated_text_instruction(::std::string* text_instruction);

  // repeated string street_name = 3;
  inline int street_name_size() const;
  inline void clear_street_name();
  static const int kStreetNameFieldNumber = 3;
  inline const ::std::string& street_name(int index) const;
  inline ::std::string* mutable_street_name(int index);
  inline void set_street_name(int index, const ::std::string& value);
  inline void set_street_name(int index, const char* value);
  inline void set_street_name(int index, const char* value, size_t size);
  inline ::std::string* add_street_name();
  inline void add_street_name(const ::std::string& value);
  inline void add_street_name(const char* value);
  inline void add_street_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& street_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_street_name();

  // optional float length = 4;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 4;
  inline float length() const;
  inline void set_length(float value);

  // optional uint32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .valhalla.odin.TripDirections.Maneuver.CardinalDirection begin_cardinal_direction = 6;
  inline bool has_begin_cardinal_direction() const;
  inline void clear_begin_cardinal_direction();
  static const int kBeginCardinalDirectionFieldNumber = 6;
  inline ::valhalla::odin::TripDirections_Maneuver_CardinalDirection begin_cardinal_direction() const;
  inline void set_begin_cardinal_direction(::valhalla::odin::TripDirections_Maneuver_CardinalDirection value);

  // optional uint32 begin_heading = 7;
  inline bool has_begin_heading() const;
  inline void clear_begin_heading();
  static const int kBeginHeadingFieldNumber = 7;
  inline ::google::protobuf::uint32 begin_heading() const;
  inline void set_begin_heading(::google::protobuf::uint32 value);

  // optional uint32 begin_shape_index = 8;
  inline bool has_begin_shape_index() const;
  inline void clear_begin_shape_index();
  static const int kBeginShapeIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 begin_shape_index() const;
  inline void set_begin_shape_index(::google::protobuf::uint32 value);

  // optional uint32 end_shape_index = 9;
  inline bool has_end_shape_index() const;
  inline void clear_end_shape_index();
  static const int kEndShapeIndexFieldNumber = 9;
  inline ::google::protobuf::uint32 end_shape_index() const;
  inline void set_end_shape_index(::google::protobuf::uint32 value);

  // optional bool portions_toll = 10;
  inline bool has_portions_toll() const;
  inline void clear_portions_toll();
  static const int kPortionsTollFieldNumber = 10;
  inline bool portions_toll() const;
  inline void set_portions_toll(bool value);

  // optional bool portions_unpaved = 11;
  inline bool has_portions_unpaved() const;
  inline void clear_portions_unpaved();
  static const int kPortionsUnpavedFieldNumber = 11;
  inline bool portions_unpaved() const;
  inline void set_portions_unpaved(bool value);

  // optional string verbal_transition_alert_instruction = 12;
  inline bool has_verbal_transition_alert_instruction() const;
  inline void clear_verbal_transition_alert_instruction();
  static const int kVerbalTransitionAlertInstructionFieldNumber = 12;
  inline const ::std::string& verbal_transition_alert_instruction() const;
  inline void set_verbal_transition_alert_instruction(const ::std::string& value);
  inline void set_verbal_transition_alert_instruction(const char* value);
  inline void set_verbal_transition_alert_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_transition_alert_instruction();
  inline ::std::string* release_verbal_transition_alert_instruction();
  inline void set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction);

  // optional string verbal_pre_transition_instruction = 13;
  inline bool has_verbal_pre_transition_instruction() const;
  inline void clear_verbal_pre_transition_instruction();
  static const int kVerbalPreTransitionInstructionFieldNumber = 13;
  inline const ::std::string& verbal_pre_transition_instruction() const;
  inline void set_verbal_pre_transition_instruction(const ::std::string& value);
  inline void set_verbal_pre_transition_instruction(const char* value);
  inline void set_verbal_pre_transition_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_pre_transition_instruction();
  inline ::std::string* release_verbal_pre_transition_instruction();
  inline void set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction);

  // optional string verbal_post_transition_instruction = 14;
  inline bool has_verbal_post_transition_instruction() const;
  inline void clear_verbal_post_transition_instruction();
  static const int kVerbalPostTransitionInstructionFieldNumber = 14;
  inline const ::std::string& verbal_post_transition_instruction() const;
  inline void set_verbal_post_transition_instruction(const ::std::string& value);
  inline void set_verbal_post_transition_instruction(const char* value);
  inline void set_verbal_post_transition_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_post_transition_instruction();
  inline ::std::string* release_verbal_post_transition_instruction();
  inline void set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction);

  // repeated string begin_street_name = 15;
  inline int begin_street_name_size() const;
  inline void clear_begin_street_name();
  static const int kBeginStreetNameFieldNumber = 15;
  inline const ::std::string& begin_street_name(int index) const;
  inline ::std::string* mutable_begin_street_name(int index);
  inline void set_begin_street_name(int index, const ::std::string& value);
  inline void set_begin_street_name(int index, const char* value);
  inline void set_begin_street_name(int index, const char* value, size_t size);
  inline ::std::string* add_begin_street_name();
  inline void add_begin_street_name(const ::std::string& value);
  inline void add_begin_street_name(const char* value);
  inline void add_begin_street_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& begin_street_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_begin_street_name();

  // optional .valhalla.odin.TripDirections.Maneuver.Sign sign = 16;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 16;
  inline const ::valhalla::odin::TripDirections_Maneuver_Sign& sign() const;
  inline ::valhalla::odin::TripDirections_Maneuver_Sign* mutable_sign();
  inline ::valhalla::odin::TripDirections_Maneuver_Sign* release_sign();
  inline void set_allocated_sign(::valhalla::odin::TripDirections_Maneuver_Sign* sign);

  // optional uint32 roundabout_exit_count = 17;
  inline bool has_roundabout_exit_count() const;
  inline void clear_roundabout_exit_count();
  static const int kRoundaboutExitCountFieldNumber = 17;
  inline ::google::protobuf::uint32 roundabout_exit_count() const;
  inline void set_roundabout_exit_count(::google::protobuf::uint32 value);

  // optional string depart_instruction = 18;
  inline bool has_depart_instruction() const;
  inline void clear_depart_instruction();
  static const int kDepartInstructionFieldNumber = 18;
  inline const ::std::string& depart_instruction() const;
  inline void set_depart_instruction(const ::std::string& value);
  inline void set_depart_instruction(const char* value);
  inline void set_depart_instruction(const char* value, size_t size);
  inline ::std::string* mutable_depart_instruction();
  inline ::std::string* release_depart_instruction();
  inline void set_allocated_depart_instruction(::std::string* depart_instruction);

  // optional string verbal_depart_instruction = 19;
  inline bool has_verbal_depart_instruction() const;
  inline void clear_verbal_depart_instruction();
  static const int kVerbalDepartInstructionFieldNumber = 19;
  inline const ::std::string& verbal_depart_instruction() const;
  inline void set_verbal_depart_instruction(const ::std::string& value);
  inline void set_verbal_depart_instruction(const char* value);
  inline void set_verbal_depart_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_depart_instruction();
  inline ::std::string* release_verbal_depart_instruction();
  inline void set_allocated_verbal_depart_instruction(::std::string* verbal_depart_instruction);

  // optional string arrive_instruction = 20;
  inline bool has_arrive_instruction() const;
  inline void clear_arrive_instruction();
  static const int kArriveInstructionFieldNumber = 20;
  inline const ::std::string& arrive_instruction() const;
  inline void set_arrive_instruction(const ::std::string& value);
  inline void set_arrive_instruction(const char* value);
  inline void set_arrive_instruction(const char* value, size_t size);
  inline ::std::string* mutable_arrive_instruction();
  inline ::std::string* release_arrive_instruction();
  inline void set_allocated_arrive_instruction(::std::string* arrive_instruction);

  // optional string verbal_arrive_instruction = 21;
  inline bool has_verbal_arrive_instruction() const;
  inline void clear_verbal_arrive_instruction();
  static const int kVerbalArriveInstructionFieldNumber = 21;
  inline const ::std::string& verbal_arrive_instruction() const;
  inline void set_verbal_arrive_instruction(const ::std::string& value);
  inline void set_verbal_arrive_instruction(const char* value);
  inline void set_verbal_arrive_instruction(const char* value, size_t size);
  inline ::std::string* mutable_verbal_arrive_instruction();
  inline ::std::string* release_verbal_arrive_instruction();
  inline void set_allocated_verbal_arrive_instruction(::std::string* verbal_arrive_instruction);

  // optional .valhalla.odin.TripDirections.TransitInfo transit_info = 22;
  inline bool has_transit_info() const;
  inline void clear_transit_info();
  static const int kTransitInfoFieldNumber = 22;
  inline const ::valhalla::odin::TripDirections_TransitInfo& transit_info() const;
  inline ::valhalla::odin::TripDirections_TransitInfo* mutable_transit_info();
  inline ::valhalla::odin::TripDirections_TransitInfo* release_transit_info();
  inline void set_allocated_transit_info(::valhalla::odin::TripDirections_TransitInfo* transit_info);

  // optional bool verbal_multi_cue = 23;
  inline bool has_verbal_multi_cue() const;
  inline void clear_verbal_multi_cue();
  static const int kVerbalMultiCueFieldNumber = 23;
  inline bool verbal_multi_cue() const;
  inline void set_verbal_multi_cue(bool value);

  // optional .valhalla.odin.TripDirections.TravelMode travel_mode = 24;
  inline bool has_travel_mode() const;
  inline void clear_travel_mode();
  static const int kTravelModeFieldNumber = 24;
  inline ::valhalla::odin::TripDirections_TravelMode travel_mode() const;
  inline void set_travel_mode(::valhalla::odin::TripDirections_TravelMode value);

  // optional .valhalla.odin.TripDirections.VehicleType vehicle_type = 25;
  inline bool has_vehicle_type() const;
  inline void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 25;
  inline ::valhalla::odin::TripDirections_VehicleType vehicle_type() const;
  inline void set_vehicle_type(::valhalla::odin::TripDirections_VehicleType value);

  // optional .valhalla.odin.TripDirections.PedestrianType pedestrian_type = 26;
  inline bool has_pedestrian_type() const;
  inline void clear_pedestrian_type();
  static const int kPedestrianTypeFieldNumber = 26;
  inline ::valhalla::odin::TripDirections_PedestrianType pedestrian_type() const;
  inline void set_pedestrian_type(::valhalla::odin::TripDirections_PedestrianType value);

  // optional .valhalla.odin.TripDirections.BicycleType bicycle_type = 27;
  inline bool has_bicycle_type() const;
  inline void clear_bicycle_type();
  static const int kBicycleTypeFieldNumber = 27;
  inline ::valhalla::odin::TripDirections_BicycleType bicycle_type() const;
  inline void set_bicycle_type(::valhalla::odin::TripDirections_BicycleType value);

  // optional .valhalla.odin.TripDirections.TransitType transit_type = 28;
  inline bool has_transit_type() const;
  inline void clear_transit_type();
  static const int kTransitTypeFieldNumber = 28;
  inline ::valhalla::odin::TripDirections_TransitType transit_type() const;
  inline void set_transit_type(::valhalla::odin::TripDirections_TransitType value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections.Maneuver)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text_instruction();
  inline void clear_has_text_instruction();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_begin_cardinal_direction();
  inline void clear_has_begin_cardinal_direction();
  inline void set_has_begin_heading();
  inline void clear_has_begin_heading();
  inline void set_has_begin_shape_index();
  inline void clear_has_begin_shape_index();
  inline void set_has_end_shape_index();
  inline void clear_has_end_shape_index();
  inline void set_has_portions_toll();
  inline void clear_has_portions_toll();
  inline void set_has_portions_unpaved();
  inline void clear_has_portions_unpaved();
  inline void set_has_verbal_transition_alert_instruction();
  inline void clear_has_verbal_transition_alert_instruction();
  inline void set_has_verbal_pre_transition_instruction();
  inline void clear_has_verbal_pre_transition_instruction();
  inline void set_has_verbal_post_transition_instruction();
  inline void clear_has_verbal_post_transition_instruction();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_roundabout_exit_count();
  inline void clear_has_roundabout_exit_count();
  inline void set_has_depart_instruction();
  inline void clear_has_depart_instruction();
  inline void set_has_verbal_depart_instruction();
  inline void clear_has_verbal_depart_instruction();
  inline void set_has_arrive_instruction();
  inline void clear_has_arrive_instruction();
  inline void set_has_verbal_arrive_instruction();
  inline void clear_has_verbal_arrive_instruction();
  inline void set_has_transit_info();
  inline void clear_has_transit_info();
  inline void set_has_verbal_multi_cue();
  inline void clear_has_verbal_multi_cue();
  inline void set_has_travel_mode();
  inline void clear_has_travel_mode();
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();
  inline void set_has_pedestrian_type();
  inline void clear_has_pedestrian_type();
  inline void set_has_bicycle_type();
  inline void clear_has_bicycle_type();
  inline void set_has_transit_type();
  inline void clear_has_transit_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_instruction_;
  int type_;
  float length_;
  ::google::protobuf::RepeatedPtrField< ::std::string> street_name_;
  ::google::protobuf::uint32 time_;
  int begin_cardinal_direction_;
  ::google::protobuf::uint32 begin_heading_;
  ::google::protobuf::uint32 begin_shape_index_;
  ::std::string* verbal_transition_alert_instruction_;
  ::std::string* verbal_pre_transition_instruction_;
  ::google::protobuf::uint32 end_shape_index_;
  bool portions_toll_;
  bool portions_unpaved_;
  bool verbal_multi_cue_;
  ::std::string* verbal_post_transition_instruction_;
  ::google::protobuf::RepeatedPtrField< ::std::string> begin_street_name_;
  ::valhalla::odin::TripDirections_Maneuver_Sign* sign_;
  ::std::string* depart_instruction_;
  ::std::string* verbal_depart_instruction_;
  ::std::string* arrive_instruction_;
  ::google::protobuf::uint32 roundabout_exit_count_;
  int travel_mode_;
  ::std::string* verbal_arrive_instruction_;
  ::valhalla::odin::TripDirections_TransitInfo* transit_info_;
  int vehicle_type_;
  int pedestrian_type_;
  int bicycle_type_;
  int transit_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections_Maneuver* default_instance_;
};
// -------------------------------------------------------------------

class TripDirections : public ::google::protobuf::Message {
 public:
  TripDirections();
  virtual ~TripDirections();

  TripDirections(const TripDirections& from);

  inline TripDirections& operator=(const TripDirections& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDirections& default_instance();

  void Swap(TripDirections* other);

  // implements Message ----------------------------------------------

  TripDirections* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDirections& from);
  void MergeFrom(const TripDirections& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripDirections_LatLng LatLng;
  typedef TripDirections_BoundingBox BoundingBox;
  typedef TripDirections_Location Location;
  typedef TripDirections_Summary Summary;
  typedef TripDirections_TransitStop TransitStop;
  typedef TripDirections_TransitInfo TransitInfo;
  typedef TripDirections_Maneuver Maneuver;

  typedef TripDirections_TravelMode TravelMode;
  static const TravelMode kDrive = TripDirections_TravelMode_kDrive;
  static const TravelMode kPedestrian = TripDirections_TravelMode_kPedestrian;
  static const TravelMode kBicycle = TripDirections_TravelMode_kBicycle;
  static const TravelMode kTransit = TripDirections_TravelMode_kTransit;
  static inline bool TravelMode_IsValid(int value) {
    return TripDirections_TravelMode_IsValid(value);
  }
  static const TravelMode TravelMode_MIN =
    TripDirections_TravelMode_TravelMode_MIN;
  static const TravelMode TravelMode_MAX =
    TripDirections_TravelMode_TravelMode_MAX;
  static const int TravelMode_ARRAYSIZE =
    TripDirections_TravelMode_TravelMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TravelMode_descriptor() {
    return TripDirections_TravelMode_descriptor();
  }
  static inline const ::std::string& TravelMode_Name(TravelMode value) {
    return TripDirections_TravelMode_Name(value);
  }
  static inline bool TravelMode_Parse(const ::std::string& name,
      TravelMode* value) {
    return TripDirections_TravelMode_Parse(name, value);
  }

  typedef TripDirections_VehicleType VehicleType;
  static const VehicleType kCar = TripDirections_VehicleType_kCar;
  static const VehicleType kMotorcycle = TripDirections_VehicleType_kMotorcycle;
  static const VehicleType kAutoBus = TripDirections_VehicleType_kAutoBus;
  static const VehicleType kTractorTrailer = TripDirections_VehicleType_kTractorTrailer;
  static inline bool VehicleType_IsValid(int value) {
    return TripDirections_VehicleType_IsValid(value);
  }
  static const VehicleType VehicleType_MIN =
    TripDirections_VehicleType_VehicleType_MIN;
  static const VehicleType VehicleType_MAX =
    TripDirections_VehicleType_VehicleType_MAX;
  static const int VehicleType_ARRAYSIZE =
    TripDirections_VehicleType_VehicleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VehicleType_descriptor() {
    return TripDirections_VehicleType_descriptor();
  }
  static inline const ::std::string& VehicleType_Name(VehicleType value) {
    return TripDirections_VehicleType_Name(value);
  }
  static inline bool VehicleType_Parse(const ::std::string& name,
      VehicleType* value) {
    return TripDirections_VehicleType_Parse(name, value);
  }

  typedef TripDirections_PedestrianType PedestrianType;
  static const PedestrianType kFoot = TripDirections_PedestrianType_kFoot;
  static const PedestrianType kWheelchair = TripDirections_PedestrianType_kWheelchair;
  static const PedestrianType kSegway = TripDirections_PedestrianType_kSegway;
  static inline bool PedestrianType_IsValid(int value) {
    return TripDirections_PedestrianType_IsValid(value);
  }
  static const PedestrianType PedestrianType_MIN =
    TripDirections_PedestrianType_PedestrianType_MIN;
  static const PedestrianType PedestrianType_MAX =
    TripDirections_PedestrianType_PedestrianType_MAX;
  static const int PedestrianType_ARRAYSIZE =
    TripDirections_PedestrianType_PedestrianType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PedestrianType_descriptor() {
    return TripDirections_PedestrianType_descriptor();
  }
  static inline const ::std::string& PedestrianType_Name(PedestrianType value) {
    return TripDirections_PedestrianType_Name(value);
  }
  static inline bool PedestrianType_Parse(const ::std::string& name,
      PedestrianType* value) {
    return TripDirections_PedestrianType_Parse(name, value);
  }

  typedef TripDirections_BicycleType BicycleType;
  static const BicycleType kRoad = TripDirections_BicycleType_kRoad;
  static const BicycleType kCross = TripDirections_BicycleType_kCross;
  static const BicycleType kHybrid = TripDirections_BicycleType_kHybrid;
  static const BicycleType kMountain = TripDirections_BicycleType_kMountain;
  static inline bool BicycleType_IsValid(int value) {
    return TripDirections_BicycleType_IsValid(value);
  }
  static const BicycleType BicycleType_MIN =
    TripDirections_BicycleType_BicycleType_MIN;
  static const BicycleType BicycleType_MAX =
    TripDirections_BicycleType_BicycleType_MAX;
  static const int BicycleType_ARRAYSIZE =
    TripDirections_BicycleType_BicycleType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BicycleType_descriptor() {
    return TripDirections_BicycleType_descriptor();
  }
  static inline const ::std::string& BicycleType_Name(BicycleType value) {
    return TripDirections_BicycleType_Name(value);
  }
  static inline bool BicycleType_Parse(const ::std::string& name,
      BicycleType* value) {
    return TripDirections_BicycleType_Parse(name, value);
  }

  typedef TripDirections_TransitType TransitType;
  static const TransitType kTram = TripDirections_TransitType_kTram;
  static const TransitType kMetro = TripDirections_TransitType_kMetro;
  static const TransitType kRail = TripDirections_TransitType_kRail;
  static const TransitType kBus = TripDirections_TransitType_kBus;
  static const TransitType kFerry = TripDirections_TransitType_kFerry;
  static const TransitType kCableCar = TripDirections_TransitType_kCableCar;
  static const TransitType kGondola = TripDirections_TransitType_kGondola;
  static const TransitType kFunicular = TripDirections_TransitType_kFunicular;
  static inline bool TransitType_IsValid(int value) {
    return TripDirections_TransitType_IsValid(value);
  }
  static const TransitType TransitType_MIN =
    TripDirections_TransitType_TransitType_MIN;
  static const TransitType TransitType_MAX =
    TripDirections_TransitType_TransitType_MAX;
  static const int TransitType_ARRAYSIZE =
    TripDirections_TransitType_TransitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransitType_descriptor() {
    return TripDirections_TransitType_descriptor();
  }
  static inline const ::std::string& TransitType_Name(TransitType value) {
    return TripDirections_TransitType_Name(value);
  }
  static inline bool TransitType_Parse(const ::std::string& name,
      TransitType* value) {
    return TripDirections_TransitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 trip_id = 1;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  inline ::google::protobuf::uint64 trip_id() const;
  inline void set_trip_id(::google::protobuf::uint64 value);

  // optional uint32 leg_id = 2;
  inline bool has_leg_id() const;
  inline void clear_leg_id();
  static const int kLegIdFieldNumber = 2;
  inline ::google::protobuf::uint32 leg_id() const;
  inline void set_leg_id(::google::protobuf::uint32 value);

  // optional uint32 leg_count = 3;
  inline bool has_leg_count() const;
  inline void clear_leg_count();
  static const int kLegCountFieldNumber = 3;
  inline ::google::protobuf::uint32 leg_count() const;
  inline void set_leg_count(::google::protobuf::uint32 value);

  // repeated .valhalla.odin.TripDirections.Location location = 4;
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 4;
  inline const ::valhalla::odin::TripDirections_Location& location(int index) const;
  inline ::valhalla::odin::TripDirections_Location* mutable_location(int index);
  inline ::valhalla::odin::TripDirections_Location* add_location();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Location >&
      location() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Location >*
      mutable_location();

  // optional .valhalla.odin.TripDirections.Summary summary = 5;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 5;
  inline const ::valhalla::odin::TripDirections_Summary& summary() const;
  inline ::valhalla::odin::TripDirections_Summary* mutable_summary();
  inline ::valhalla::odin::TripDirections_Summary* release_summary();
  inline void set_allocated_summary(::valhalla::odin::TripDirections_Summary* summary);

  // repeated .valhalla.odin.TripDirections.Maneuver maneuver = 6;
  inline int maneuver_size() const;
  inline void clear_maneuver();
  static const int kManeuverFieldNumber = 6;
  inline const ::valhalla::odin::TripDirections_Maneuver& maneuver(int index) const;
  inline ::valhalla::odin::TripDirections_Maneuver* mutable_maneuver(int index);
  inline ::valhalla::odin::TripDirections_Maneuver* add_maneuver();
  inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver >&
      maneuver() const;
  inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver >*
      mutable_maneuver();

  // optional string shape = 7;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 7;
  inline const ::std::string& shape() const;
  inline void set_shape(const ::std::string& value);
  inline void set_shape(const char* value);
  inline void set_shape(const char* value, size_t size);
  inline ::std::string* mutable_shape();
  inline ::std::string* release_shape();
  inline void set_allocated_shape(::std::string* shape);

  // @@protoc_insertion_point(class_scope:valhalla.odin.TripDirections)
 private:
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_leg_id();
  inline void clear_has_leg_id();
  inline void set_has_leg_count();
  inline void clear_has_leg_count();
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_shape();
  inline void clear_has_shape();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 trip_id_;
  ::google::protobuf::uint32 leg_id_;
  ::google::protobuf::uint32 leg_count_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Location > location_;
  ::valhalla::odin::TripDirections_Summary* summary_;
  ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver > maneuver_;
  ::std::string* shape_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_tripdirections_2eproto();
  friend void protobuf_AssignDesc_tripdirections_2eproto();
  friend void protobuf_ShutdownFile_tripdirections_2eproto();

  void InitAsDefaultInstance();
  static TripDirections* default_instance_;
};
// ===================================================================


// ===================================================================

// TripDirections_LatLng

// optional float lat = 1;
inline bool TripDirections_LatLng::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_LatLng::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_LatLng::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_LatLng::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float TripDirections_LatLng::lat() const {
  return lat_;
}
inline void TripDirections_LatLng::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lng = 2;
inline bool TripDirections_LatLng::has_lng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_LatLng::set_has_lng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_LatLng::clear_has_lng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_LatLng::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline float TripDirections_LatLng::lng() const {
  return lng_;
}
inline void TripDirections_LatLng::set_lng(float value) {
  set_has_lng();
  lng_ = value;
}

// -------------------------------------------------------------------

// TripDirections_BoundingBox

// optional .valhalla.odin.TripDirections.LatLng min_ll = 1;
inline bool TripDirections_BoundingBox::has_min_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_BoundingBox::set_has_min_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_BoundingBox::clear_has_min_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_BoundingBox::clear_min_ll() {
  if (min_ll_ != NULL) min_ll_->::valhalla::odin::TripDirections_LatLng::Clear();
  clear_has_min_ll();
}
inline const ::valhalla::odin::TripDirections_LatLng& TripDirections_BoundingBox::min_ll() const {
  return min_ll_ != NULL ? *min_ll_ : *default_instance_->min_ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_BoundingBox::mutable_min_ll() {
  set_has_min_ll();
  if (min_ll_ == NULL) min_ll_ = new ::valhalla::odin::TripDirections_LatLng;
  return min_ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_BoundingBox::release_min_ll() {
  clear_has_min_ll();
  ::valhalla::odin::TripDirections_LatLng* temp = min_ll_;
  min_ll_ = NULL;
  return temp;
}
inline void TripDirections_BoundingBox::set_allocated_min_ll(::valhalla::odin::TripDirections_LatLng* min_ll) {
  delete min_ll_;
  min_ll_ = min_ll;
  if (min_ll) {
    set_has_min_ll();
  } else {
    clear_has_min_ll();
  }
}

// optional .valhalla.odin.TripDirections.LatLng max_ll = 2;
inline bool TripDirections_BoundingBox::has_max_ll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_BoundingBox::set_has_max_ll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_BoundingBox::clear_has_max_ll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_BoundingBox::clear_max_ll() {
  if (max_ll_ != NULL) max_ll_->::valhalla::odin::TripDirections_LatLng::Clear();
  clear_has_max_ll();
}
inline const ::valhalla::odin::TripDirections_LatLng& TripDirections_BoundingBox::max_ll() const {
  return max_ll_ != NULL ? *max_ll_ : *default_instance_->max_ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_BoundingBox::mutable_max_ll() {
  set_has_max_ll();
  if (max_ll_ == NULL) max_ll_ = new ::valhalla::odin::TripDirections_LatLng;
  return max_ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_BoundingBox::release_max_ll() {
  clear_has_max_ll();
  ::valhalla::odin::TripDirections_LatLng* temp = max_ll_;
  max_ll_ = NULL;
  return temp;
}
inline void TripDirections_BoundingBox::set_allocated_max_ll(::valhalla::odin::TripDirections_LatLng* max_ll) {
  delete max_ll_;
  max_ll_ = max_ll;
  if (max_ll) {
    set_has_max_ll();
  } else {
    clear_has_max_ll();
  }
}

// -------------------------------------------------------------------

// TripDirections_Location

// optional .valhalla.odin.TripDirections.LatLng ll = 1;
inline bool TripDirections_Location::has_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_Location::set_has_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_Location::clear_has_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_Location::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::odin::TripDirections_LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::odin::TripDirections_LatLng& TripDirections_Location::ll() const {
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_Location::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::odin::TripDirections_LatLng;
  return ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_Location::release_ll() {
  clear_has_ll();
  ::valhalla::odin::TripDirections_LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TripDirections_Location::set_allocated_ll(::valhalla::odin::TripDirections_LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// optional .valhalla.odin.TripDirections.Location.Type type = 2;
inline bool TripDirections_Location::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_Location::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_Location::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_Location::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::odin::TripDirections_Location_Type TripDirections_Location::type() const {
  return static_cast< ::valhalla::odin::TripDirections_Location_Type >(type_);
}
inline void TripDirections_Location::set_type(::valhalla::odin::TripDirections_Location_Type value) {
  assert(::valhalla::odin::TripDirections_Location_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 heading = 3;
inline bool TripDirections_Location::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDirections_Location::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDirections_Location::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDirections_Location::clear_heading() {
  heading_ = 0u;
  clear_has_heading();
}
inline ::google::protobuf::uint32 TripDirections_Location::heading() const {
  return heading_;
}
inline void TripDirections_Location::set_heading(::google::protobuf::uint32 value) {
  set_has_heading();
  heading_ = value;
}

// optional string name = 4;
inline bool TripDirections_Location::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripDirections_Location::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripDirections_Location::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripDirections_Location::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TripDirections_Location::name() const {
  return *name_;
}
inline void TripDirections_Location::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripDirections_Location::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripDirections_Location::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TripDirections_Location::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string street = 5;
inline bool TripDirections_Location::has_street() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDirections_Location::set_has_street() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDirections_Location::clear_has_street() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDirections_Location::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& TripDirections_Location::street() const {
  return *street_;
}
inline void TripDirections_Location::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void TripDirections_Location::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void TripDirections_Location::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* TripDirections_Location::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 6;
inline bool TripDirections_Location::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripDirections_Location::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripDirections_Location::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripDirections_Location::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& TripDirections_Location::city() const {
  return *city_;
}
inline void TripDirections_Location::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void TripDirections_Location::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void TripDirections_Location::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* TripDirections_Location::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 7;
inline bool TripDirections_Location::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripDirections_Location::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripDirections_Location::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripDirections_Location::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& TripDirections_Location::state() const {
  return *state_;
}
inline void TripDirections_Location::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void TripDirections_Location::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void TripDirections_Location::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* TripDirections_Location::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string postal_code = 8;
inline bool TripDirections_Location::has_postal_code() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripDirections_Location::set_has_postal_code() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripDirections_Location::clear_has_postal_code() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripDirections_Location::clear_postal_code() {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    postal_code_->clear();
  }
  clear_has_postal_code();
}
inline const ::std::string& TripDirections_Location::postal_code() const {
  return *postal_code_;
}
inline void TripDirections_Location::set_postal_code(const ::std::string& value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void TripDirections_Location::set_postal_code(const char* value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void TripDirections_Location::set_postal_code(const char* value, size_t size) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_postal_code() {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  return postal_code_;
}
inline ::std::string* TripDirections_Location::release_postal_code() {
  clear_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postal_code_;
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_postal_code(::std::string* postal_code) {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    delete postal_code_;
  }
  if (postal_code) {
    set_has_postal_code();
    postal_code_ = postal_code;
  } else {
    clear_has_postal_code();
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country = 9;
inline bool TripDirections_Location::has_country() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripDirections_Location::set_has_country() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripDirections_Location::clear_has_country() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripDirections_Location::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& TripDirections_Location::country() const {
  return *country_;
}
inline void TripDirections_Location::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void TripDirections_Location::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void TripDirections_Location::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* TripDirections_Location::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date_time = 10;
inline bool TripDirections_Location::has_date_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripDirections_Location::set_has_date_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripDirections_Location::clear_has_date_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripDirections_Location::clear_date_time() {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    date_time_->clear();
  }
  clear_has_date_time();
}
inline const ::std::string& TripDirections_Location::date_time() const {
  return *date_time_;
}
inline void TripDirections_Location::set_date_time(const ::std::string& value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void TripDirections_Location::set_date_time(const char* value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void TripDirections_Location::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Location::mutable_date_time() {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  return date_time_;
}
inline ::std::string* TripDirections_Location::release_date_time() {
  clear_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_;
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Location::set_allocated_date_time(::std::string* date_time) {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_;
  }
  if (date_time) {
    set_has_date_time();
    date_time_ = date_time;
  } else {
    clear_has_date_time();
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.odin.TripDirections.Location.SideOfStreet side_of_street = 11;
inline bool TripDirections_Location::has_side_of_street() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripDirections_Location::set_has_side_of_street() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripDirections_Location::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripDirections_Location::clear_side_of_street() {
  side_of_street_ = 0;
  clear_has_side_of_street();
}
inline ::valhalla::odin::TripDirections_Location_SideOfStreet TripDirections_Location::side_of_street() const {
  return static_cast< ::valhalla::odin::TripDirections_Location_SideOfStreet >(side_of_street_);
}
inline void TripDirections_Location::set_side_of_street(::valhalla::odin::TripDirections_Location_SideOfStreet value) {
  assert(::valhalla::odin::TripDirections_Location_SideOfStreet_IsValid(value));
  set_has_side_of_street();
  side_of_street_ = value;
}

// -------------------------------------------------------------------

// TripDirections_Summary

// optional float length = 1;
inline bool TripDirections_Summary::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_Summary::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_Summary::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_Summary::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float TripDirections_Summary::length() const {
  return length_;
}
inline void TripDirections_Summary::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional uint32 time = 2;
inline bool TripDirections_Summary::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_Summary::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_Summary::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_Summary::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TripDirections_Summary::time() const {
  return time_;
}
inline void TripDirections_Summary::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .valhalla.odin.TripDirections.BoundingBox bbox = 3;
inline bool TripDirections_Summary::has_bbox() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDirections_Summary::set_has_bbox() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDirections_Summary::clear_has_bbox() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDirections_Summary::clear_bbox() {
  if (bbox_ != NULL) bbox_->::valhalla::odin::TripDirections_BoundingBox::Clear();
  clear_has_bbox();
}
inline const ::valhalla::odin::TripDirections_BoundingBox& TripDirections_Summary::bbox() const {
  return bbox_ != NULL ? *bbox_ : *default_instance_->bbox_;
}
inline ::valhalla::odin::TripDirections_BoundingBox* TripDirections_Summary::mutable_bbox() {
  set_has_bbox();
  if (bbox_ == NULL) bbox_ = new ::valhalla::odin::TripDirections_BoundingBox;
  return bbox_;
}
inline ::valhalla::odin::TripDirections_BoundingBox* TripDirections_Summary::release_bbox() {
  clear_has_bbox();
  ::valhalla::odin::TripDirections_BoundingBox* temp = bbox_;
  bbox_ = NULL;
  return temp;
}
inline void TripDirections_Summary::set_allocated_bbox(::valhalla::odin::TripDirections_BoundingBox* bbox) {
  delete bbox_;
  bbox_ = bbox;
  if (bbox) {
    set_has_bbox();
  } else {
    clear_has_bbox();
  }
}

// -------------------------------------------------------------------

// TripDirections_TransitStop

// optional .valhalla.odin.TripDirections.TransitStop.Type type = 1;
inline bool TripDirections_TransitStop::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_TransitStop::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_TransitStop::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_TransitStop::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::odin::TripDirections_TransitStop_Type TripDirections_TransitStop::type() const {
  return static_cast< ::valhalla::odin::TripDirections_TransitStop_Type >(type_);
}
inline void TripDirections_TransitStop::set_type(::valhalla::odin::TripDirections_TransitStop_Type value) {
  assert(::valhalla::odin::TripDirections_TransitStop_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string onestop_id = 2;
inline bool TripDirections_TransitStop::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_TransitStop::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_TransitStop::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_TransitStop::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TripDirections_TransitStop::onestop_id() const {
  return *onestop_id_;
}
inline void TripDirections_TransitStop::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripDirections_TransitStop::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripDirections_TransitStop::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitStop::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TripDirections_TransitStop::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitStop::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool TripDirections_TransitStop::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDirections_TransitStop::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDirections_TransitStop::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDirections_TransitStop::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TripDirections_TransitStop::name() const {
  return *name_;
}
inline void TripDirections_TransitStop::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripDirections_TransitStop::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TripDirections_TransitStop::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitStop::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TripDirections_TransitStop::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitStop::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrival_date_time = 4;
inline bool TripDirections_TransitStop::has_arrival_date_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripDirections_TransitStop::set_has_arrival_date_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripDirections_TransitStop::clear_has_arrival_date_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripDirections_TransitStop::clear_arrival_date_time() {
  if (arrival_date_time_ != &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_->clear();
  }
  clear_has_arrival_date_time();
}
inline const ::std::string& TripDirections_TransitStop::arrival_date_time() const {
  return *arrival_date_time_;
}
inline void TripDirections_TransitStop::set_arrival_date_time(const ::std::string& value) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(value);
}
inline void TripDirections_TransitStop::set_arrival_date_time(const char* value) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(value);
}
inline void TripDirections_TransitStop::set_arrival_date_time(const char* value, size_t size) {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  arrival_date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitStop::mutable_arrival_date_time() {
  set_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    arrival_date_time_ = new ::std::string;
  }
  return arrival_date_time_;
}
inline ::std::string* TripDirections_TransitStop::release_arrival_date_time() {
  clear_has_arrival_date_time();
  if (arrival_date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrival_date_time_;
    arrival_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitStop::set_allocated_arrival_date_time(::std::string* arrival_date_time) {
  if (arrival_date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete arrival_date_time_;
  }
  if (arrival_date_time) {
    set_has_arrival_date_time();
    arrival_date_time_ = arrival_date_time;
  } else {
    clear_has_arrival_date_time();
    arrival_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string departure_date_time = 5;
inline bool TripDirections_TransitStop::has_departure_date_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDirections_TransitStop::set_has_departure_date_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDirections_TransitStop::clear_has_departure_date_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDirections_TransitStop::clear_departure_date_time() {
  if (departure_date_time_ != &::google::protobuf::internal::kEmptyString) {
    departure_date_time_->clear();
  }
  clear_has_departure_date_time();
}
inline const ::std::string& TripDirections_TransitStop::departure_date_time() const {
  return *departure_date_time_;
}
inline void TripDirections_TransitStop::set_departure_date_time(const ::std::string& value) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(value);
}
inline void TripDirections_TransitStop::set_departure_date_time(const char* value) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(value);
}
inline void TripDirections_TransitStop::set_departure_date_time(const char* value, size_t size) {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  departure_date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitStop::mutable_departure_date_time() {
  set_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    departure_date_time_ = new ::std::string;
  }
  return departure_date_time_;
}
inline ::std::string* TripDirections_TransitStop::release_departure_date_time() {
  clear_has_departure_date_time();
  if (departure_date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = departure_date_time_;
    departure_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitStop::set_allocated_departure_date_time(::std::string* departure_date_time) {
  if (departure_date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete departure_date_time_;
  }
  if (departure_date_time) {
    set_has_departure_date_time();
    departure_date_time_ = departure_date_time;
  } else {
    clear_has_departure_date_time();
    departure_date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_parent_stop = 6;
inline bool TripDirections_TransitStop::has_is_parent_stop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripDirections_TransitStop::set_has_is_parent_stop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripDirections_TransitStop::clear_has_is_parent_stop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripDirections_TransitStop::clear_is_parent_stop() {
  is_parent_stop_ = false;
  clear_has_is_parent_stop();
}
inline bool TripDirections_TransitStop::is_parent_stop() const {
  return is_parent_stop_;
}
inline void TripDirections_TransitStop::set_is_parent_stop(bool value) {
  set_has_is_parent_stop();
  is_parent_stop_ = value;
}

// optional bool assumed_schedule = 7;
inline bool TripDirections_TransitStop::has_assumed_schedule() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripDirections_TransitStop::set_has_assumed_schedule() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripDirections_TransitStop::clear_has_assumed_schedule() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripDirections_TransitStop::clear_assumed_schedule() {
  assumed_schedule_ = false;
  clear_has_assumed_schedule();
}
inline bool TripDirections_TransitStop::assumed_schedule() const {
  return assumed_schedule_;
}
inline void TripDirections_TransitStop::set_assumed_schedule(bool value) {
  set_has_assumed_schedule();
  assumed_schedule_ = value;
}

// optional .valhalla.odin.TripDirections.LatLng ll = 8;
inline bool TripDirections_TransitStop::has_ll() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripDirections_TransitStop::set_has_ll() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripDirections_TransitStop::clear_has_ll() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripDirections_TransitStop::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::odin::TripDirections_LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::odin::TripDirections_LatLng& TripDirections_TransitStop::ll() const {
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_TransitStop::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::odin::TripDirections_LatLng;
  return ll_;
}
inline ::valhalla::odin::TripDirections_LatLng* TripDirections_TransitStop::release_ll() {
  clear_has_ll();
  ::valhalla::odin::TripDirections_LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void TripDirections_TransitStop::set_allocated_ll(::valhalla::odin::TripDirections_LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// -------------------------------------------------------------------

// TripDirections_TransitInfo

// optional string onestop_id = 1;
inline bool TripDirections_TransitInfo::has_onestop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_TransitInfo::set_has_onestop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_TransitInfo::clear_has_onestop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_TransitInfo::clear_onestop_id() {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    onestop_id_->clear();
  }
  clear_has_onestop_id();
}
inline const ::std::string& TripDirections_TransitInfo::onestop_id() const {
  return *onestop_id_;
}
inline void TripDirections_TransitInfo::set_onestop_id(const ::std::string& value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripDirections_TransitInfo::set_onestop_id(const char* value) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(value);
}
inline void TripDirections_TransitInfo::set_onestop_id(const char* value, size_t size) {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_onestop_id() {
  set_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    onestop_id_ = new ::std::string;
  }
  return onestop_id_;
}
inline ::std::string* TripDirections_TransitInfo::release_onestop_id() {
  clear_has_onestop_id();
  if (onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = onestop_id_;
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_onestop_id(::std::string* onestop_id) {
  if (onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete onestop_id_;
  }
  if (onestop_id) {
    set_has_onestop_id();
    onestop_id_ = onestop_id;
  } else {
    clear_has_onestop_id();
    onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string short_name = 2;
inline bool TripDirections_TransitInfo::has_short_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_TransitInfo::set_has_short_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_TransitInfo::clear_has_short_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_TransitInfo::clear_short_name() {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    short_name_->clear();
  }
  clear_has_short_name();
}
inline const ::std::string& TripDirections_TransitInfo::short_name() const {
  return *short_name_;
}
inline void TripDirections_TransitInfo::set_short_name(const ::std::string& value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void TripDirections_TransitInfo::set_short_name(const char* value) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(value);
}
inline void TripDirections_TransitInfo::set_short_name(const char* value, size_t size) {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  short_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_short_name() {
  set_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    short_name_ = new ::std::string;
  }
  return short_name_;
}
inline ::std::string* TripDirections_TransitInfo::release_short_name() {
  clear_has_short_name();
  if (short_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = short_name_;
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_short_name(::std::string* short_name) {
  if (short_name_ != &::google::protobuf::internal::kEmptyString) {
    delete short_name_;
  }
  if (short_name) {
    set_has_short_name();
    short_name_ = short_name;
  } else {
    clear_has_short_name();
    short_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string long_name = 3;
inline bool TripDirections_TransitInfo::has_long_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDirections_TransitInfo::set_has_long_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDirections_TransitInfo::clear_has_long_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDirections_TransitInfo::clear_long_name() {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    long_name_->clear();
  }
  clear_has_long_name();
}
inline const ::std::string& TripDirections_TransitInfo::long_name() const {
  return *long_name_;
}
inline void TripDirections_TransitInfo::set_long_name(const ::std::string& value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void TripDirections_TransitInfo::set_long_name(const char* value) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(value);
}
inline void TripDirections_TransitInfo::set_long_name(const char* value, size_t size) {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  long_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_long_name() {
  set_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    long_name_ = new ::std::string;
  }
  return long_name_;
}
inline ::std::string* TripDirections_TransitInfo::release_long_name() {
  clear_has_long_name();
  if (long_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = long_name_;
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_long_name(::std::string* long_name) {
  if (long_name_ != &::google::protobuf::internal::kEmptyString) {
    delete long_name_;
  }
  if (long_name) {
    set_has_long_name();
    long_name_ = long_name;
  } else {
    clear_has_long_name();
    long_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string headsign = 4;
inline bool TripDirections_TransitInfo::has_headsign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripDirections_TransitInfo::set_has_headsign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripDirections_TransitInfo::clear_has_headsign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripDirections_TransitInfo::clear_headsign() {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    headsign_->clear();
  }
  clear_has_headsign();
}
inline const ::std::string& TripDirections_TransitInfo::headsign() const {
  return *headsign_;
}
inline void TripDirections_TransitInfo::set_headsign(const ::std::string& value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void TripDirections_TransitInfo::set_headsign(const char* value) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(value);
}
inline void TripDirections_TransitInfo::set_headsign(const char* value, size_t size) {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  headsign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_headsign() {
  set_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    headsign_ = new ::std::string;
  }
  return headsign_;
}
inline ::std::string* TripDirections_TransitInfo::release_headsign() {
  clear_has_headsign();
  if (headsign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headsign_;
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_headsign(::std::string* headsign) {
  if (headsign_ != &::google::protobuf::internal::kEmptyString) {
    delete headsign_;
  }
  if (headsign) {
    set_has_headsign();
    headsign_ = headsign;
  } else {
    clear_has_headsign();
    headsign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 color = 5;
inline bool TripDirections_TransitInfo::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDirections_TransitInfo::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDirections_TransitInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDirections_TransitInfo::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 TripDirections_TransitInfo::color() const {
  return color_;
}
inline void TripDirections_TransitInfo::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// optional uint32 text_color = 6;
inline bool TripDirections_TransitInfo::has_text_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripDirections_TransitInfo::set_has_text_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripDirections_TransitInfo::clear_has_text_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripDirections_TransitInfo::clear_text_color() {
  text_color_ = 0u;
  clear_has_text_color();
}
inline ::google::protobuf::uint32 TripDirections_TransitInfo::text_color() const {
  return text_color_;
}
inline void TripDirections_TransitInfo::set_text_color(::google::protobuf::uint32 value) {
  set_has_text_color();
  text_color_ = value;
}

// optional string description = 7;
inline bool TripDirections_TransitInfo::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripDirections_TransitInfo::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripDirections_TransitInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripDirections_TransitInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& TripDirections_TransitInfo::description() const {
  return *description_;
}
inline void TripDirections_TransitInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TripDirections_TransitInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void TripDirections_TransitInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* TripDirections_TransitInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_onestop_id = 8;
inline bool TripDirections_TransitInfo::has_operator_onestop_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripDirections_TransitInfo::set_has_operator_onestop_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripDirections_TransitInfo::clear_has_operator_onestop_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripDirections_TransitInfo::clear_operator_onestop_id() {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_->clear();
  }
  clear_has_operator_onestop_id();
}
inline const ::std::string& TripDirections_TransitInfo::operator_onestop_id() const {
  return *operator_onestop_id_;
}
inline void TripDirections_TransitInfo::set_operator_onestop_id(const ::std::string& value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void TripDirections_TransitInfo::set_operator_onestop_id(const char* value) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(value);
}
inline void TripDirections_TransitInfo::set_operator_onestop_id(const char* value, size_t size) {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  operator_onestop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_operator_onestop_id() {
  set_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    operator_onestop_id_ = new ::std::string;
  }
  return operator_onestop_id_;
}
inline ::std::string* TripDirections_TransitInfo::release_operator_onestop_id() {
  clear_has_operator_onestop_id();
  if (operator_onestop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_onestop_id_;
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_operator_onestop_id(::std::string* operator_onestop_id) {
  if (operator_onestop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_onestop_id_;
  }
  if (operator_onestop_id) {
    set_has_operator_onestop_id();
    operator_onestop_id_ = operator_onestop_id;
  } else {
    clear_has_operator_onestop_id();
    operator_onestop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_name = 9;
inline bool TripDirections_TransitInfo::has_operator_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripDirections_TransitInfo::set_has_operator_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripDirections_TransitInfo::clear_has_operator_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripDirections_TransitInfo::clear_operator_name() {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    operator_name_->clear();
  }
  clear_has_operator_name();
}
inline const ::std::string& TripDirections_TransitInfo::operator_name() const {
  return *operator_name_;
}
inline void TripDirections_TransitInfo::set_operator_name(const ::std::string& value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void TripDirections_TransitInfo::set_operator_name(const char* value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
}
inline void TripDirections_TransitInfo::set_operator_name(const char* value, size_t size) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_operator_name() {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    operator_name_ = new ::std::string;
  }
  return operator_name_;
}
inline ::std::string* TripDirections_TransitInfo::release_operator_name() {
  clear_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_name_;
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_operator_name(::std::string* operator_name) {
  if (operator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_name_;
  }
  if (operator_name) {
    set_has_operator_name();
    operator_name_ = operator_name;
  } else {
    clear_has_operator_name();
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string operator_url = 10;
inline bool TripDirections_TransitInfo::has_operator_url() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripDirections_TransitInfo::set_has_operator_url() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripDirections_TransitInfo::clear_has_operator_url() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripDirections_TransitInfo::clear_operator_url() {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    operator_url_->clear();
  }
  clear_has_operator_url();
}
inline const ::std::string& TripDirections_TransitInfo::operator_url() const {
  return *operator_url_;
}
inline void TripDirections_TransitInfo::set_operator_url(const ::std::string& value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void TripDirections_TransitInfo::set_operator_url(const char* value) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(value);
}
inline void TripDirections_TransitInfo::set_operator_url(const char* value, size_t size) {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  operator_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_TransitInfo::mutable_operator_url() {
  set_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    operator_url_ = new ::std::string;
  }
  return operator_url_;
}
inline ::std::string* TripDirections_TransitInfo::release_operator_url() {
  clear_has_operator_url();
  if (operator_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = operator_url_;
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_TransitInfo::set_allocated_operator_url(::std::string* operator_url) {
  if (operator_url_ != &::google::protobuf::internal::kEmptyString) {
    delete operator_url_;
  }
  if (operator_url) {
    set_has_operator_url();
    operator_url_ = operator_url;
  } else {
    clear_has_operator_url();
    operator_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .valhalla.odin.TripDirections.TransitStop transit_stops = 11;
inline int TripDirections_TransitInfo::transit_stops_size() const {
  return transit_stops_.size();
}
inline void TripDirections_TransitInfo::clear_transit_stops() {
  transit_stops_.Clear();
}
inline const ::valhalla::odin::TripDirections_TransitStop& TripDirections_TransitInfo::transit_stops(int index) const {
  return transit_stops_.Get(index);
}
inline ::valhalla::odin::TripDirections_TransitStop* TripDirections_TransitInfo::mutable_transit_stops(int index) {
  return transit_stops_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_TransitStop* TripDirections_TransitInfo::add_transit_stops() {
  return transit_stops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_TransitStop >&
TripDirections_TransitInfo::transit_stops() const {
  return transit_stops_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_TransitStop >*
TripDirections_TransitInfo::mutable_transit_stops() {
  return &transit_stops_;
}

// -------------------------------------------------------------------

// TripDirections_Maneuver_Sign_Element

// optional string text = 1;
inline bool TripDirections_Maneuver_Sign_Element::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_Maneuver_Sign_Element::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_Maneuver_Sign_Element::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_Maneuver_Sign_Element::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TripDirections_Maneuver_Sign_Element::text() const {
  return *text_;
}
inline void TripDirections_Maneuver_Sign_Element::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TripDirections_Maneuver_Sign_Element::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TripDirections_Maneuver_Sign_Element::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver_Sign_Element::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TripDirections_Maneuver_Sign_Element::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver_Sign_Element::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 consecutive_count = 2;
inline bool TripDirections_Maneuver_Sign_Element::has_consecutive_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_Maneuver_Sign_Element::set_has_consecutive_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_Maneuver_Sign_Element::clear_has_consecutive_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_Maneuver_Sign_Element::clear_consecutive_count() {
  consecutive_count_ = 0u;
  clear_has_consecutive_count();
}
inline ::google::protobuf::uint32 TripDirections_Maneuver_Sign_Element::consecutive_count() const {
  return consecutive_count_;
}
inline void TripDirections_Maneuver_Sign_Element::set_consecutive_count(::google::protobuf::uint32 value) {
  set_has_consecutive_count();
  consecutive_count_ = value;
}

// -------------------------------------------------------------------

// TripDirections_Maneuver_Sign

// repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_number_elements = 1;
inline int TripDirections_Maneuver_Sign::exit_number_elements_size() const {
  return exit_number_elements_.size();
}
inline void TripDirections_Maneuver_Sign::clear_exit_number_elements() {
  exit_number_elements_.Clear();
}
inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& TripDirections_Maneuver_Sign::exit_number_elements(int index) const {
  return exit_number_elements_.Get(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::mutable_exit_number_elements(int index) {
  return exit_number_elements_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::add_exit_number_elements() {
  return exit_number_elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
TripDirections_Maneuver_Sign::exit_number_elements() const {
  return exit_number_elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
TripDirections_Maneuver_Sign::mutable_exit_number_elements() {
  return &exit_number_elements_;
}

// repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_branch_elements = 2;
inline int TripDirections_Maneuver_Sign::exit_branch_elements_size() const {
  return exit_branch_elements_.size();
}
inline void TripDirections_Maneuver_Sign::clear_exit_branch_elements() {
  exit_branch_elements_.Clear();
}
inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& TripDirections_Maneuver_Sign::exit_branch_elements(int index) const {
  return exit_branch_elements_.Get(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::mutable_exit_branch_elements(int index) {
  return exit_branch_elements_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::add_exit_branch_elements() {
  return exit_branch_elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
TripDirections_Maneuver_Sign::exit_branch_elements() const {
  return exit_branch_elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
TripDirections_Maneuver_Sign::mutable_exit_branch_elements() {
  return &exit_branch_elements_;
}

// repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_toward_elements = 3;
inline int TripDirections_Maneuver_Sign::exit_toward_elements_size() const {
  return exit_toward_elements_.size();
}
inline void TripDirections_Maneuver_Sign::clear_exit_toward_elements() {
  exit_toward_elements_.Clear();
}
inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& TripDirections_Maneuver_Sign::exit_toward_elements(int index) const {
  return exit_toward_elements_.Get(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::mutable_exit_toward_elements(int index) {
  return exit_toward_elements_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::add_exit_toward_elements() {
  return exit_toward_elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
TripDirections_Maneuver_Sign::exit_toward_elements() const {
  return exit_toward_elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
TripDirections_Maneuver_Sign::mutable_exit_toward_elements() {
  return &exit_toward_elements_;
}

// repeated .valhalla.odin.TripDirections.Maneuver.Sign.Element exit_name_elements = 4;
inline int TripDirections_Maneuver_Sign::exit_name_elements_size() const {
  return exit_name_elements_.size();
}
inline void TripDirections_Maneuver_Sign::clear_exit_name_elements() {
  exit_name_elements_.Clear();
}
inline const ::valhalla::odin::TripDirections_Maneuver_Sign_Element& TripDirections_Maneuver_Sign::exit_name_elements(int index) const {
  return exit_name_elements_.Get(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::mutable_exit_name_elements(int index) {
  return exit_name_elements_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign_Element* TripDirections_Maneuver_Sign::add_exit_name_elements() {
  return exit_name_elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >&
TripDirections_Maneuver_Sign::exit_name_elements() const {
  return exit_name_elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver_Sign_Element >*
TripDirections_Maneuver_Sign::mutable_exit_name_elements() {
  return &exit_name_elements_;
}

// -------------------------------------------------------------------

// TripDirections_Maneuver

// optional .valhalla.odin.TripDirections.Maneuver.Type type = 1;
inline bool TripDirections_Maneuver::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections_Maneuver::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections_Maneuver::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections_Maneuver::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::odin::TripDirections_Maneuver_Type TripDirections_Maneuver::type() const {
  return static_cast< ::valhalla::odin::TripDirections_Maneuver_Type >(type_);
}
inline void TripDirections_Maneuver::set_type(::valhalla::odin::TripDirections_Maneuver_Type value) {
  assert(::valhalla::odin::TripDirections_Maneuver_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string text_instruction = 2;
inline bool TripDirections_Maneuver::has_text_instruction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections_Maneuver::set_has_text_instruction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections_Maneuver::clear_has_text_instruction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections_Maneuver::clear_text_instruction() {
  if (text_instruction_ != &::google::protobuf::internal::kEmptyString) {
    text_instruction_->clear();
  }
  clear_has_text_instruction();
}
inline const ::std::string& TripDirections_Maneuver::text_instruction() const {
  return *text_instruction_;
}
inline void TripDirections_Maneuver::set_text_instruction(const ::std::string& value) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_text_instruction(const char* value) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_text_instruction(const char* value, size_t size) {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  text_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_text_instruction() {
  set_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    text_instruction_ = new ::std::string;
  }
  return text_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_text_instruction() {
  clear_has_text_instruction();
  if (text_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_instruction_;
    text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_text_instruction(::std::string* text_instruction) {
  if (text_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete text_instruction_;
  }
  if (text_instruction) {
    set_has_text_instruction();
    text_instruction_ = text_instruction;
  } else {
    clear_has_text_instruction();
    text_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string street_name = 3;
inline int TripDirections_Maneuver::street_name_size() const {
  return street_name_.size();
}
inline void TripDirections_Maneuver::clear_street_name() {
  street_name_.Clear();
}
inline const ::std::string& TripDirections_Maneuver::street_name(int index) const {
  return street_name_.Get(index);
}
inline ::std::string* TripDirections_Maneuver::mutable_street_name(int index) {
  return street_name_.Mutable(index);
}
inline void TripDirections_Maneuver::set_street_name(int index, const ::std::string& value) {
  street_name_.Mutable(index)->assign(value);
}
inline void TripDirections_Maneuver::set_street_name(int index, const char* value) {
  street_name_.Mutable(index)->assign(value);
}
inline void TripDirections_Maneuver::set_street_name(int index, const char* value, size_t size) {
  street_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::add_street_name() {
  return street_name_.Add();
}
inline void TripDirections_Maneuver::add_street_name(const ::std::string& value) {
  street_name_.Add()->assign(value);
}
inline void TripDirections_Maneuver::add_street_name(const char* value) {
  street_name_.Add()->assign(value);
}
inline void TripDirections_Maneuver::add_street_name(const char* value, size_t size) {
  street_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripDirections_Maneuver::street_name() const {
  return street_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripDirections_Maneuver::mutable_street_name() {
  return &street_name_;
}

// optional float length = 4;
inline bool TripDirections_Maneuver::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripDirections_Maneuver::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripDirections_Maneuver::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripDirections_Maneuver::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float TripDirections_Maneuver::length() const {
  return length_;
}
inline void TripDirections_Maneuver::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional uint32 time = 5;
inline bool TripDirections_Maneuver::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDirections_Maneuver::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDirections_Maneuver::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDirections_Maneuver::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 TripDirections_Maneuver::time() const {
  return time_;
}
inline void TripDirections_Maneuver::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .valhalla.odin.TripDirections.Maneuver.CardinalDirection begin_cardinal_direction = 6;
inline bool TripDirections_Maneuver::has_begin_cardinal_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TripDirections_Maneuver::set_has_begin_cardinal_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TripDirections_Maneuver::clear_has_begin_cardinal_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TripDirections_Maneuver::clear_begin_cardinal_direction() {
  begin_cardinal_direction_ = 0;
  clear_has_begin_cardinal_direction();
}
inline ::valhalla::odin::TripDirections_Maneuver_CardinalDirection TripDirections_Maneuver::begin_cardinal_direction() const {
  return static_cast< ::valhalla::odin::TripDirections_Maneuver_CardinalDirection >(begin_cardinal_direction_);
}
inline void TripDirections_Maneuver::set_begin_cardinal_direction(::valhalla::odin::TripDirections_Maneuver_CardinalDirection value) {
  assert(::valhalla::odin::TripDirections_Maneuver_CardinalDirection_IsValid(value));
  set_has_begin_cardinal_direction();
  begin_cardinal_direction_ = value;
}

// optional uint32 begin_heading = 7;
inline bool TripDirections_Maneuver::has_begin_heading() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripDirections_Maneuver::set_has_begin_heading() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripDirections_Maneuver::clear_has_begin_heading() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripDirections_Maneuver::clear_begin_heading() {
  begin_heading_ = 0u;
  clear_has_begin_heading();
}
inline ::google::protobuf::uint32 TripDirections_Maneuver::begin_heading() const {
  return begin_heading_;
}
inline void TripDirections_Maneuver::set_begin_heading(::google::protobuf::uint32 value) {
  set_has_begin_heading();
  begin_heading_ = value;
}

// optional uint32 begin_shape_index = 8;
inline bool TripDirections_Maneuver::has_begin_shape_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TripDirections_Maneuver::set_has_begin_shape_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TripDirections_Maneuver::clear_has_begin_shape_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TripDirections_Maneuver::clear_begin_shape_index() {
  begin_shape_index_ = 0u;
  clear_has_begin_shape_index();
}
inline ::google::protobuf::uint32 TripDirections_Maneuver::begin_shape_index() const {
  return begin_shape_index_;
}
inline void TripDirections_Maneuver::set_begin_shape_index(::google::protobuf::uint32 value) {
  set_has_begin_shape_index();
  begin_shape_index_ = value;
}

// optional uint32 end_shape_index = 9;
inline bool TripDirections_Maneuver::has_end_shape_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TripDirections_Maneuver::set_has_end_shape_index() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TripDirections_Maneuver::clear_has_end_shape_index() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TripDirections_Maneuver::clear_end_shape_index() {
  end_shape_index_ = 0u;
  clear_has_end_shape_index();
}
inline ::google::protobuf::uint32 TripDirections_Maneuver::end_shape_index() const {
  return end_shape_index_;
}
inline void TripDirections_Maneuver::set_end_shape_index(::google::protobuf::uint32 value) {
  set_has_end_shape_index();
  end_shape_index_ = value;
}

// optional bool portions_toll = 10;
inline bool TripDirections_Maneuver::has_portions_toll() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TripDirections_Maneuver::set_has_portions_toll() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TripDirections_Maneuver::clear_has_portions_toll() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TripDirections_Maneuver::clear_portions_toll() {
  portions_toll_ = false;
  clear_has_portions_toll();
}
inline bool TripDirections_Maneuver::portions_toll() const {
  return portions_toll_;
}
inline void TripDirections_Maneuver::set_portions_toll(bool value) {
  set_has_portions_toll();
  portions_toll_ = value;
}

// optional bool portions_unpaved = 11;
inline bool TripDirections_Maneuver::has_portions_unpaved() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TripDirections_Maneuver::set_has_portions_unpaved() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TripDirections_Maneuver::clear_has_portions_unpaved() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TripDirections_Maneuver::clear_portions_unpaved() {
  portions_unpaved_ = false;
  clear_has_portions_unpaved();
}
inline bool TripDirections_Maneuver::portions_unpaved() const {
  return portions_unpaved_;
}
inline void TripDirections_Maneuver::set_portions_unpaved(bool value) {
  set_has_portions_unpaved();
  portions_unpaved_ = value;
}

// optional string verbal_transition_alert_instruction = 12;
inline bool TripDirections_Maneuver::has_verbal_transition_alert_instruction() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TripDirections_Maneuver::set_has_verbal_transition_alert_instruction() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TripDirections_Maneuver::clear_has_verbal_transition_alert_instruction() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TripDirections_Maneuver::clear_verbal_transition_alert_instruction() {
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_->clear();
  }
  clear_has_verbal_transition_alert_instruction();
}
inline const ::std::string& TripDirections_Maneuver::verbal_transition_alert_instruction() const {
  return *verbal_transition_alert_instruction_;
}
inline void TripDirections_Maneuver::set_verbal_transition_alert_instruction(const ::std::string& value) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_transition_alert_instruction(const char* value) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_transition_alert_instruction(const char* value, size_t size) {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  verbal_transition_alert_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_verbal_transition_alert_instruction() {
  set_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_transition_alert_instruction_ = new ::std::string;
  }
  return verbal_transition_alert_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_verbal_transition_alert_instruction() {
  clear_has_verbal_transition_alert_instruction();
  if (verbal_transition_alert_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_transition_alert_instruction_;
    verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_verbal_transition_alert_instruction(::std::string* verbal_transition_alert_instruction) {
  if (verbal_transition_alert_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_transition_alert_instruction_;
  }
  if (verbal_transition_alert_instruction) {
    set_has_verbal_transition_alert_instruction();
    verbal_transition_alert_instruction_ = verbal_transition_alert_instruction;
  } else {
    clear_has_verbal_transition_alert_instruction();
    verbal_transition_alert_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_pre_transition_instruction = 13;
inline bool TripDirections_Maneuver::has_verbal_pre_transition_instruction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TripDirections_Maneuver::set_has_verbal_pre_transition_instruction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TripDirections_Maneuver::clear_has_verbal_pre_transition_instruction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TripDirections_Maneuver::clear_verbal_pre_transition_instruction() {
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_->clear();
  }
  clear_has_verbal_pre_transition_instruction();
}
inline const ::std::string& TripDirections_Maneuver::verbal_pre_transition_instruction() const {
  return *verbal_pre_transition_instruction_;
}
inline void TripDirections_Maneuver::set_verbal_pre_transition_instruction(const ::std::string& value) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_pre_transition_instruction(const char* value) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_pre_transition_instruction(const char* value, size_t size) {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  verbal_pre_transition_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_verbal_pre_transition_instruction() {
  set_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_pre_transition_instruction_ = new ::std::string;
  }
  return verbal_pre_transition_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_verbal_pre_transition_instruction() {
  clear_has_verbal_pre_transition_instruction();
  if (verbal_pre_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_pre_transition_instruction_;
    verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_verbal_pre_transition_instruction(::std::string* verbal_pre_transition_instruction) {
  if (verbal_pre_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_pre_transition_instruction_;
  }
  if (verbal_pre_transition_instruction) {
    set_has_verbal_pre_transition_instruction();
    verbal_pre_transition_instruction_ = verbal_pre_transition_instruction;
  } else {
    clear_has_verbal_pre_transition_instruction();
    verbal_pre_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_post_transition_instruction = 14;
inline bool TripDirections_Maneuver::has_verbal_post_transition_instruction() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TripDirections_Maneuver::set_has_verbal_post_transition_instruction() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TripDirections_Maneuver::clear_has_verbal_post_transition_instruction() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TripDirections_Maneuver::clear_verbal_post_transition_instruction() {
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_->clear();
  }
  clear_has_verbal_post_transition_instruction();
}
inline const ::std::string& TripDirections_Maneuver::verbal_post_transition_instruction() const {
  return *verbal_post_transition_instruction_;
}
inline void TripDirections_Maneuver::set_verbal_post_transition_instruction(const ::std::string& value) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_post_transition_instruction(const char* value) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_post_transition_instruction(const char* value, size_t size) {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  verbal_post_transition_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_verbal_post_transition_instruction() {
  set_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_post_transition_instruction_ = new ::std::string;
  }
  return verbal_post_transition_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_verbal_post_transition_instruction() {
  clear_has_verbal_post_transition_instruction();
  if (verbal_post_transition_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_post_transition_instruction_;
    verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_verbal_post_transition_instruction(::std::string* verbal_post_transition_instruction) {
  if (verbal_post_transition_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_post_transition_instruction_;
  }
  if (verbal_post_transition_instruction) {
    set_has_verbal_post_transition_instruction();
    verbal_post_transition_instruction_ = verbal_post_transition_instruction;
  } else {
    clear_has_verbal_post_transition_instruction();
    verbal_post_transition_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string begin_street_name = 15;
inline int TripDirections_Maneuver::begin_street_name_size() const {
  return begin_street_name_.size();
}
inline void TripDirections_Maneuver::clear_begin_street_name() {
  begin_street_name_.Clear();
}
inline const ::std::string& TripDirections_Maneuver::begin_street_name(int index) const {
  return begin_street_name_.Get(index);
}
inline ::std::string* TripDirections_Maneuver::mutable_begin_street_name(int index) {
  return begin_street_name_.Mutable(index);
}
inline void TripDirections_Maneuver::set_begin_street_name(int index, const ::std::string& value) {
  begin_street_name_.Mutable(index)->assign(value);
}
inline void TripDirections_Maneuver::set_begin_street_name(int index, const char* value) {
  begin_street_name_.Mutable(index)->assign(value);
}
inline void TripDirections_Maneuver::set_begin_street_name(int index, const char* value, size_t size) {
  begin_street_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::add_begin_street_name() {
  return begin_street_name_.Add();
}
inline void TripDirections_Maneuver::add_begin_street_name(const ::std::string& value) {
  begin_street_name_.Add()->assign(value);
}
inline void TripDirections_Maneuver::add_begin_street_name(const char* value) {
  begin_street_name_.Add()->assign(value);
}
inline void TripDirections_Maneuver::add_begin_street_name(const char* value, size_t size) {
  begin_street_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TripDirections_Maneuver::begin_street_name() const {
  return begin_street_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TripDirections_Maneuver::mutable_begin_street_name() {
  return &begin_street_name_;
}

// optional .valhalla.odin.TripDirections.Maneuver.Sign sign = 16;
inline bool TripDirections_Maneuver::has_sign() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TripDirections_Maneuver::set_has_sign() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TripDirections_Maneuver::clear_has_sign() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TripDirections_Maneuver::clear_sign() {
  if (sign_ != NULL) sign_->::valhalla::odin::TripDirections_Maneuver_Sign::Clear();
  clear_has_sign();
}
inline const ::valhalla::odin::TripDirections_Maneuver_Sign& TripDirections_Maneuver::sign() const {
  return sign_ != NULL ? *sign_ : *default_instance_->sign_;
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign* TripDirections_Maneuver::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) sign_ = new ::valhalla::odin::TripDirections_Maneuver_Sign;
  return sign_;
}
inline ::valhalla::odin::TripDirections_Maneuver_Sign* TripDirections_Maneuver::release_sign() {
  clear_has_sign();
  ::valhalla::odin::TripDirections_Maneuver_Sign* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void TripDirections_Maneuver::set_allocated_sign(::valhalla::odin::TripDirections_Maneuver_Sign* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
}

// optional uint32 roundabout_exit_count = 17;
inline bool TripDirections_Maneuver::has_roundabout_exit_count() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TripDirections_Maneuver::set_has_roundabout_exit_count() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TripDirections_Maneuver::clear_has_roundabout_exit_count() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TripDirections_Maneuver::clear_roundabout_exit_count() {
  roundabout_exit_count_ = 0u;
  clear_has_roundabout_exit_count();
}
inline ::google::protobuf::uint32 TripDirections_Maneuver::roundabout_exit_count() const {
  return roundabout_exit_count_;
}
inline void TripDirections_Maneuver::set_roundabout_exit_count(::google::protobuf::uint32 value) {
  set_has_roundabout_exit_count();
  roundabout_exit_count_ = value;
}

// optional string depart_instruction = 18;
inline bool TripDirections_Maneuver::has_depart_instruction() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TripDirections_Maneuver::set_has_depart_instruction() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TripDirections_Maneuver::clear_has_depart_instruction() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TripDirections_Maneuver::clear_depart_instruction() {
  if (depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    depart_instruction_->clear();
  }
  clear_has_depart_instruction();
}
inline const ::std::string& TripDirections_Maneuver::depart_instruction() const {
  return *depart_instruction_;
}
inline void TripDirections_Maneuver::set_depart_instruction(const ::std::string& value) {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  depart_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_depart_instruction(const char* value) {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  depart_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_depart_instruction(const char* value, size_t size) {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  depart_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_depart_instruction() {
  set_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    depart_instruction_ = new ::std::string;
  }
  return depart_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_depart_instruction() {
  clear_has_depart_instruction();
  if (depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = depart_instruction_;
    depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_depart_instruction(::std::string* depart_instruction) {
  if (depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete depart_instruction_;
  }
  if (depart_instruction) {
    set_has_depart_instruction();
    depart_instruction_ = depart_instruction;
  } else {
    clear_has_depart_instruction();
    depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_depart_instruction = 19;
inline bool TripDirections_Maneuver::has_verbal_depart_instruction() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TripDirections_Maneuver::set_has_verbal_depart_instruction() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TripDirections_Maneuver::clear_has_verbal_depart_instruction() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TripDirections_Maneuver::clear_verbal_depart_instruction() {
  if (verbal_depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_->clear();
  }
  clear_has_verbal_depart_instruction();
}
inline const ::std::string& TripDirections_Maneuver::verbal_depart_instruction() const {
  return *verbal_depart_instruction_;
}
inline void TripDirections_Maneuver::set_verbal_depart_instruction(const ::std::string& value) {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  verbal_depart_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_depart_instruction(const char* value) {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  verbal_depart_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_depart_instruction(const char* value, size_t size) {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  verbal_depart_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_verbal_depart_instruction() {
  set_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_depart_instruction_ = new ::std::string;
  }
  return verbal_depart_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_verbal_depart_instruction() {
  clear_has_verbal_depart_instruction();
  if (verbal_depart_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_depart_instruction_;
    verbal_depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_verbal_depart_instruction(::std::string* verbal_depart_instruction) {
  if (verbal_depart_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_depart_instruction_;
  }
  if (verbal_depart_instruction) {
    set_has_verbal_depart_instruction();
    verbal_depart_instruction_ = verbal_depart_instruction;
  } else {
    clear_has_verbal_depart_instruction();
    verbal_depart_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string arrive_instruction = 20;
inline bool TripDirections_Maneuver::has_arrive_instruction() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TripDirections_Maneuver::set_has_arrive_instruction() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TripDirections_Maneuver::clear_has_arrive_instruction() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TripDirections_Maneuver::clear_arrive_instruction() {
  if (arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_->clear();
  }
  clear_has_arrive_instruction();
}
inline const ::std::string& TripDirections_Maneuver::arrive_instruction() const {
  return *arrive_instruction_;
}
inline void TripDirections_Maneuver::set_arrive_instruction(const ::std::string& value) {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  arrive_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_arrive_instruction(const char* value) {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  arrive_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_arrive_instruction(const char* value, size_t size) {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  arrive_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_arrive_instruction() {
  set_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    arrive_instruction_ = new ::std::string;
  }
  return arrive_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_arrive_instruction() {
  clear_has_arrive_instruction();
  if (arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arrive_instruction_;
    arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_arrive_instruction(::std::string* arrive_instruction) {
  if (arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete arrive_instruction_;
  }
  if (arrive_instruction) {
    set_has_arrive_instruction();
    arrive_instruction_ = arrive_instruction;
  } else {
    clear_has_arrive_instruction();
    arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string verbal_arrive_instruction = 21;
inline bool TripDirections_Maneuver::has_verbal_arrive_instruction() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TripDirections_Maneuver::set_has_verbal_arrive_instruction() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TripDirections_Maneuver::clear_has_verbal_arrive_instruction() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TripDirections_Maneuver::clear_verbal_arrive_instruction() {
  if (verbal_arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_->clear();
  }
  clear_has_verbal_arrive_instruction();
}
inline const ::std::string& TripDirections_Maneuver::verbal_arrive_instruction() const {
  return *verbal_arrive_instruction_;
}
inline void TripDirections_Maneuver::set_verbal_arrive_instruction(const ::std::string& value) {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  verbal_arrive_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_arrive_instruction(const char* value) {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  verbal_arrive_instruction_->assign(value);
}
inline void TripDirections_Maneuver::set_verbal_arrive_instruction(const char* value, size_t size) {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  verbal_arrive_instruction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections_Maneuver::mutable_verbal_arrive_instruction() {
  set_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    verbal_arrive_instruction_ = new ::std::string;
  }
  return verbal_arrive_instruction_;
}
inline ::std::string* TripDirections_Maneuver::release_verbal_arrive_instruction() {
  clear_has_verbal_arrive_instruction();
  if (verbal_arrive_instruction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verbal_arrive_instruction_;
    verbal_arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections_Maneuver::set_allocated_verbal_arrive_instruction(::std::string* verbal_arrive_instruction) {
  if (verbal_arrive_instruction_ != &::google::protobuf::internal::kEmptyString) {
    delete verbal_arrive_instruction_;
  }
  if (verbal_arrive_instruction) {
    set_has_verbal_arrive_instruction();
    verbal_arrive_instruction_ = verbal_arrive_instruction;
  } else {
    clear_has_verbal_arrive_instruction();
    verbal_arrive_instruction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.odin.TripDirections.TransitInfo transit_info = 22;
inline bool TripDirections_Maneuver::has_transit_info() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TripDirections_Maneuver::set_has_transit_info() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TripDirections_Maneuver::clear_has_transit_info() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TripDirections_Maneuver::clear_transit_info() {
  if (transit_info_ != NULL) transit_info_->::valhalla::odin::TripDirections_TransitInfo::Clear();
  clear_has_transit_info();
}
inline const ::valhalla::odin::TripDirections_TransitInfo& TripDirections_Maneuver::transit_info() const {
  return transit_info_ != NULL ? *transit_info_ : *default_instance_->transit_info_;
}
inline ::valhalla::odin::TripDirections_TransitInfo* TripDirections_Maneuver::mutable_transit_info() {
  set_has_transit_info();
  if (transit_info_ == NULL) transit_info_ = new ::valhalla::odin::TripDirections_TransitInfo;
  return transit_info_;
}
inline ::valhalla::odin::TripDirections_TransitInfo* TripDirections_Maneuver::release_transit_info() {
  clear_has_transit_info();
  ::valhalla::odin::TripDirections_TransitInfo* temp = transit_info_;
  transit_info_ = NULL;
  return temp;
}
inline void TripDirections_Maneuver::set_allocated_transit_info(::valhalla::odin::TripDirections_TransitInfo* transit_info) {
  delete transit_info_;
  transit_info_ = transit_info;
  if (transit_info) {
    set_has_transit_info();
  } else {
    clear_has_transit_info();
  }
}

// optional bool verbal_multi_cue = 23;
inline bool TripDirections_Maneuver::has_verbal_multi_cue() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TripDirections_Maneuver::set_has_verbal_multi_cue() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TripDirections_Maneuver::clear_has_verbal_multi_cue() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TripDirections_Maneuver::clear_verbal_multi_cue() {
  verbal_multi_cue_ = false;
  clear_has_verbal_multi_cue();
}
inline bool TripDirections_Maneuver::verbal_multi_cue() const {
  return verbal_multi_cue_;
}
inline void TripDirections_Maneuver::set_verbal_multi_cue(bool value) {
  set_has_verbal_multi_cue();
  verbal_multi_cue_ = value;
}

// optional .valhalla.odin.TripDirections.TravelMode travel_mode = 24;
inline bool TripDirections_Maneuver::has_travel_mode() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TripDirections_Maneuver::set_has_travel_mode() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TripDirections_Maneuver::clear_has_travel_mode() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TripDirections_Maneuver::clear_travel_mode() {
  travel_mode_ = 0;
  clear_has_travel_mode();
}
inline ::valhalla::odin::TripDirections_TravelMode TripDirections_Maneuver::travel_mode() const {
  return static_cast< ::valhalla::odin::TripDirections_TravelMode >(travel_mode_);
}
inline void TripDirections_Maneuver::set_travel_mode(::valhalla::odin::TripDirections_TravelMode value) {
  assert(::valhalla::odin::TripDirections_TravelMode_IsValid(value));
  set_has_travel_mode();
  travel_mode_ = value;
}

// optional .valhalla.odin.TripDirections.VehicleType vehicle_type = 25;
inline bool TripDirections_Maneuver::has_vehicle_type() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TripDirections_Maneuver::set_has_vehicle_type() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TripDirections_Maneuver::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TripDirections_Maneuver::clear_vehicle_type() {
  vehicle_type_ = 0;
  clear_has_vehicle_type();
}
inline ::valhalla::odin::TripDirections_VehicleType TripDirections_Maneuver::vehicle_type() const {
  return static_cast< ::valhalla::odin::TripDirections_VehicleType >(vehicle_type_);
}
inline void TripDirections_Maneuver::set_vehicle_type(::valhalla::odin::TripDirections_VehicleType value) {
  assert(::valhalla::odin::TripDirections_VehicleType_IsValid(value));
  set_has_vehicle_type();
  vehicle_type_ = value;
}

// optional .valhalla.odin.TripDirections.PedestrianType pedestrian_type = 26;
inline bool TripDirections_Maneuver::has_pedestrian_type() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TripDirections_Maneuver::set_has_pedestrian_type() {
  _has_bits_[0] |= 0x02000000u;
}
inline void TripDirections_Maneuver::clear_has_pedestrian_type() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void TripDirections_Maneuver::clear_pedestrian_type() {
  pedestrian_type_ = 0;
  clear_has_pedestrian_type();
}
inline ::valhalla::odin::TripDirections_PedestrianType TripDirections_Maneuver::pedestrian_type() const {
  return static_cast< ::valhalla::odin::TripDirections_PedestrianType >(pedestrian_type_);
}
inline void TripDirections_Maneuver::set_pedestrian_type(::valhalla::odin::TripDirections_PedestrianType value) {
  assert(::valhalla::odin::TripDirections_PedestrianType_IsValid(value));
  set_has_pedestrian_type();
  pedestrian_type_ = value;
}

// optional .valhalla.odin.TripDirections.BicycleType bicycle_type = 27;
inline bool TripDirections_Maneuver::has_bicycle_type() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TripDirections_Maneuver::set_has_bicycle_type() {
  _has_bits_[0] |= 0x04000000u;
}
inline void TripDirections_Maneuver::clear_has_bicycle_type() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void TripDirections_Maneuver::clear_bicycle_type() {
  bicycle_type_ = 0;
  clear_has_bicycle_type();
}
inline ::valhalla::odin::TripDirections_BicycleType TripDirections_Maneuver::bicycle_type() const {
  return static_cast< ::valhalla::odin::TripDirections_BicycleType >(bicycle_type_);
}
inline void TripDirections_Maneuver::set_bicycle_type(::valhalla::odin::TripDirections_BicycleType value) {
  assert(::valhalla::odin::TripDirections_BicycleType_IsValid(value));
  set_has_bicycle_type();
  bicycle_type_ = value;
}

// optional .valhalla.odin.TripDirections.TransitType transit_type = 28;
inline bool TripDirections_Maneuver::has_transit_type() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TripDirections_Maneuver::set_has_transit_type() {
  _has_bits_[0] |= 0x08000000u;
}
inline void TripDirections_Maneuver::clear_has_transit_type() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void TripDirections_Maneuver::clear_transit_type() {
  transit_type_ = 0;
  clear_has_transit_type();
}
inline ::valhalla::odin::TripDirections_TransitType TripDirections_Maneuver::transit_type() const {
  return static_cast< ::valhalla::odin::TripDirections_TransitType >(transit_type_);
}
inline void TripDirections_Maneuver::set_transit_type(::valhalla::odin::TripDirections_TransitType value) {
  assert(::valhalla::odin::TripDirections_TransitType_IsValid(value));
  set_has_transit_type();
  transit_type_ = value;
}

// -------------------------------------------------------------------

// TripDirections

// optional uint64 trip_id = 1;
inline bool TripDirections::has_trip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDirections::set_has_trip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDirections::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDirections::clear_trip_id() {
  trip_id_ = GOOGLE_ULONGLONG(0);
  clear_has_trip_id();
}
inline ::google::protobuf::uint64 TripDirections::trip_id() const {
  return trip_id_;
}
inline void TripDirections::set_trip_id(::google::protobuf::uint64 value) {
  set_has_trip_id();
  trip_id_ = value;
}

// optional uint32 leg_id = 2;
inline bool TripDirections::has_leg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDirections::set_has_leg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDirections::clear_has_leg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDirections::clear_leg_id() {
  leg_id_ = 0u;
  clear_has_leg_id();
}
inline ::google::protobuf::uint32 TripDirections::leg_id() const {
  return leg_id_;
}
inline void TripDirections::set_leg_id(::google::protobuf::uint32 value) {
  set_has_leg_id();
  leg_id_ = value;
}

// optional uint32 leg_count = 3;
inline bool TripDirections::has_leg_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDirections::set_has_leg_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDirections::clear_has_leg_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDirections::clear_leg_count() {
  leg_count_ = 0u;
  clear_has_leg_count();
}
inline ::google::protobuf::uint32 TripDirections::leg_count() const {
  return leg_count_;
}
inline void TripDirections::set_leg_count(::google::protobuf::uint32 value) {
  set_has_leg_count();
  leg_count_ = value;
}

// repeated .valhalla.odin.TripDirections.Location location = 4;
inline int TripDirections::location_size() const {
  return location_.size();
}
inline void TripDirections::clear_location() {
  location_.Clear();
}
inline const ::valhalla::odin::TripDirections_Location& TripDirections::location(int index) const {
  return location_.Get(index);
}
inline ::valhalla::odin::TripDirections_Location* TripDirections::mutable_location(int index) {
  return location_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_Location* TripDirections::add_location() {
  return location_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Location >&
TripDirections::location() const {
  return location_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Location >*
TripDirections::mutable_location() {
  return &location_;
}

// optional .valhalla.odin.TripDirections.Summary summary = 5;
inline bool TripDirections::has_summary() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDirections::set_has_summary() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDirections::clear_has_summary() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDirections::clear_summary() {
  if (summary_ != NULL) summary_->::valhalla::odin::TripDirections_Summary::Clear();
  clear_has_summary();
}
inline const ::valhalla::odin::TripDirections_Summary& TripDirections::summary() const {
  return summary_ != NULL ? *summary_ : *default_instance_->summary_;
}
inline ::valhalla::odin::TripDirections_Summary* TripDirections::mutable_summary() {
  set_has_summary();
  if (summary_ == NULL) summary_ = new ::valhalla::odin::TripDirections_Summary;
  return summary_;
}
inline ::valhalla::odin::TripDirections_Summary* TripDirections::release_summary() {
  clear_has_summary();
  ::valhalla::odin::TripDirections_Summary* temp = summary_;
  summary_ = NULL;
  return temp;
}
inline void TripDirections::set_allocated_summary(::valhalla::odin::TripDirections_Summary* summary) {
  delete summary_;
  summary_ = summary;
  if (summary) {
    set_has_summary();
  } else {
    clear_has_summary();
  }
}

// repeated .valhalla.odin.TripDirections.Maneuver maneuver = 6;
inline int TripDirections::maneuver_size() const {
  return maneuver_.size();
}
inline void TripDirections::clear_maneuver() {
  maneuver_.Clear();
}
inline const ::valhalla::odin::TripDirections_Maneuver& TripDirections::maneuver(int index) const {
  return maneuver_.Get(index);
}
inline ::valhalla::odin::TripDirections_Maneuver* TripDirections::mutable_maneuver(int index) {
  return maneuver_.Mutable(index);
}
inline ::valhalla::odin::TripDirections_Maneuver* TripDirections::add_maneuver() {
  return maneuver_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver >&
TripDirections::maneuver() const {
  return maneuver_;
}
inline ::google::protobuf::RepeatedPtrField< ::valhalla::odin::TripDirections_Maneuver >*
TripDirections::mutable_maneuver() {
  return &maneuver_;
}

// optional string shape = 7;
inline bool TripDirections::has_shape() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TripDirections::set_has_shape() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TripDirections::clear_has_shape() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TripDirections::clear_shape() {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    shape_->clear();
  }
  clear_has_shape();
}
inline const ::std::string& TripDirections::shape() const {
  return *shape_;
}
inline void TripDirections::set_shape(const ::std::string& value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void TripDirections::set_shape(const char* value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
}
inline void TripDirections::set_shape(const char* value, size_t size) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  shape_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDirections::mutable_shape() {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    shape_ = new ::std::string;
  }
  return shape_;
}
inline ::std::string* TripDirections::release_shape() {
  clear_has_shape();
  if (shape_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shape_;
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDirections::set_allocated_shape(::std::string* shape) {
  if (shape_ != &::google::protobuf::internal::kEmptyString) {
    delete shape_;
  }
  if (shape) {
    set_has_shape();
    shape_ = shape;
  } else {
    clear_has_shape();
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace odin
}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_Location_Type>() {
  return ::valhalla::odin::TripDirections_Location_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_Location_SideOfStreet>() {
  return ::valhalla::odin::TripDirections_Location_SideOfStreet_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_TransitStop_Type>() {
  return ::valhalla::odin::TripDirections_TransitStop_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_Maneuver_CardinalDirection>() {
  return ::valhalla::odin::TripDirections_Maneuver_CardinalDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_Maneuver_Type>() {
  return ::valhalla::odin::TripDirections_Maneuver_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_TravelMode>() {
  return ::valhalla::odin::TripDirections_TravelMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_VehicleType>() {
  return ::valhalla::odin::TripDirections_VehicleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_PedestrianType>() {
  return ::valhalla::odin::TripDirections_PedestrianType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_BicycleType>() {
  return ::valhalla::odin::TripDirections_BicycleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::TripDirections_TransitType>() {
  return ::valhalla::odin::TripDirections_TransitType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tripdirections_2eproto__INCLUDED
