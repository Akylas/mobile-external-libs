// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tripcommon.proto

#ifndef PROTOBUF_tripcommon_2eproto__INCLUDED
#define PROTOBUF_tripcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace valhalla {
namespace odin {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tripcommon_2eproto();
void protobuf_AssignDesc_tripcommon_2eproto();
void protobuf_ShutdownFile_tripcommon_2eproto();

class LatLng;
class BoundingBox;
class Location;

enum Location_Type {
  Location_Type_kBreak = 0,
  Location_Type_kThrough = 1
};
bool Location_Type_IsValid(int value);
const Location_Type Location_Type_Type_MIN = Location_Type_kBreak;
const Location_Type Location_Type_Type_MAX = Location_Type_kThrough;
const int Location_Type_Type_ARRAYSIZE = Location_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Location_Type_descriptor();
inline const ::std::string& Location_Type_Name(Location_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Location_Type_descriptor(), value);
}
inline bool Location_Type_Parse(
    const ::std::string& name, Location_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Location_Type>(
    Location_Type_descriptor(), name, value);
}
enum Location_SideOfStreet {
  Location_SideOfStreet_kNone = 0,
  Location_SideOfStreet_kLeft = 1,
  Location_SideOfStreet_kRight = 2
};
bool Location_SideOfStreet_IsValid(int value);
const Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MIN = Location_SideOfStreet_kNone;
const Location_SideOfStreet Location_SideOfStreet_SideOfStreet_MAX = Location_SideOfStreet_kRight;
const int Location_SideOfStreet_SideOfStreet_ARRAYSIZE = Location_SideOfStreet_SideOfStreet_MAX + 1;

const ::google::protobuf::EnumDescriptor* Location_SideOfStreet_descriptor();
inline const ::std::string& Location_SideOfStreet_Name(Location_SideOfStreet value) {
  return ::google::protobuf::internal::NameOfEnum(
    Location_SideOfStreet_descriptor(), value);
}
inline bool Location_SideOfStreet_Parse(
    const ::std::string& name, Location_SideOfStreet* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Location_SideOfStreet>(
    Location_SideOfStreet_descriptor(), name, value);
}
// ===================================================================

class LatLng : public ::google::protobuf::Message {
 public:
  LatLng();
  virtual ~LatLng();

  LatLng(const LatLng& from);

  inline LatLng& operator=(const LatLng& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatLng& default_instance();

  void Swap(LatLng* other);

  // implements Message ----------------------------------------------

  LatLng* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatLng& from);
  void MergeFrom(const LatLng& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline float lat() const;
  inline void set_lat(float value);

  // optional float lng = 2;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 2;
  inline float lng() const;
  inline void set_lng(float value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.LatLng)
 private:
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_lng();
  inline void clear_has_lng();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float lat_;
  float lng_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tripcommon_2eproto();
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static LatLng* default_instance_;
};
// -------------------------------------------------------------------

class BoundingBox : public ::google::protobuf::Message {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundingBox& default_instance();

  void Swap(BoundingBox* other);

  // implements Message ----------------------------------------------

  BoundingBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.LatLng min_ll = 1;
  inline bool has_min_ll() const;
  inline void clear_min_ll();
  static const int kMinLlFieldNumber = 1;
  inline const ::valhalla::odin::LatLng& min_ll() const;
  inline ::valhalla::odin::LatLng* mutable_min_ll();
  inline ::valhalla::odin::LatLng* release_min_ll();
  inline void set_allocated_min_ll(::valhalla::odin::LatLng* min_ll);

  // optional .valhalla.odin.LatLng max_ll = 2;
  inline bool has_max_ll() const;
  inline void clear_max_ll();
  static const int kMaxLlFieldNumber = 2;
  inline const ::valhalla::odin::LatLng& max_ll() const;
  inline ::valhalla::odin::LatLng* mutable_max_ll();
  inline ::valhalla::odin::LatLng* release_max_ll();
  inline void set_allocated_max_ll(::valhalla::odin::LatLng* max_ll);

  // @@protoc_insertion_point(class_scope:valhalla.odin.BoundingBox)
 private:
  inline void set_has_min_ll();
  inline void clear_has_min_ll();
  inline void set_has_max_ll();
  inline void clear_has_max_ll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::LatLng* min_ll_;
  ::valhalla::odin::LatLng* max_ll_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tripcommon_2eproto();
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static BoundingBox* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Location_Type Type;
  static const Type kBreak = Location_Type_kBreak;
  static const Type kThrough = Location_Type_kThrough;
  static inline bool Type_IsValid(int value) {
    return Location_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Location_Type_Type_MIN;
  static const Type Type_MAX =
    Location_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Location_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Location_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Location_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Location_Type_Parse(name, value);
  }

  typedef Location_SideOfStreet SideOfStreet;
  static const SideOfStreet kNone = Location_SideOfStreet_kNone;
  static const SideOfStreet kLeft = Location_SideOfStreet_kLeft;
  static const SideOfStreet kRight = Location_SideOfStreet_kRight;
  static inline bool SideOfStreet_IsValid(int value) {
    return Location_SideOfStreet_IsValid(value);
  }
  static const SideOfStreet SideOfStreet_MIN =
    Location_SideOfStreet_SideOfStreet_MIN;
  static const SideOfStreet SideOfStreet_MAX =
    Location_SideOfStreet_SideOfStreet_MAX;
  static const int SideOfStreet_ARRAYSIZE =
    Location_SideOfStreet_SideOfStreet_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SideOfStreet_descriptor() {
    return Location_SideOfStreet_descriptor();
  }
  static inline const ::std::string& SideOfStreet_Name(SideOfStreet value) {
    return Location_SideOfStreet_Name(value);
  }
  static inline bool SideOfStreet_Parse(const ::std::string& name,
      SideOfStreet* value) {
    return Location_SideOfStreet_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .valhalla.odin.LatLng ll = 1;
  inline bool has_ll() const;
  inline void clear_ll();
  static const int kLlFieldNumber = 1;
  inline const ::valhalla::odin::LatLng& ll() const;
  inline ::valhalla::odin::LatLng* mutable_ll();
  inline ::valhalla::odin::LatLng* release_ll();
  inline void set_allocated_ll(::valhalla::odin::LatLng* ll);

  // optional .valhalla.odin.Location.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::valhalla::odin::Location_Type type() const;
  inline void set_type(::valhalla::odin::Location_Type value);

  // optional uint32 heading = 3;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 3;
  inline ::google::protobuf::uint32 heading() const;
  inline void set_heading(::google::protobuf::uint32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string street = 5;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 5;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string postal_code = 8;
  inline bool has_postal_code() const;
  inline void clear_postal_code();
  static const int kPostalCodeFieldNumber = 8;
  inline const ::std::string& postal_code() const;
  inline void set_postal_code(const ::std::string& value);
  inline void set_postal_code(const char* value);
  inline void set_postal_code(const char* value, size_t size);
  inline ::std::string* mutable_postal_code();
  inline ::std::string* release_postal_code();
  inline void set_allocated_postal_code(::std::string* postal_code);

  // optional string country = 9;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 9;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string date_time = 10;
  inline bool has_date_time() const;
  inline void clear_date_time();
  static const int kDateTimeFieldNumber = 10;
  inline const ::std::string& date_time() const;
  inline void set_date_time(const ::std::string& value);
  inline void set_date_time(const char* value);
  inline void set_date_time(const char* value, size_t size);
  inline ::std::string* mutable_date_time();
  inline ::std::string* release_date_time();
  inline void set_allocated_date_time(::std::string* date_time);

  // optional .valhalla.odin.Location.SideOfStreet side_of_street = 11;
  inline bool has_side_of_street() const;
  inline void clear_side_of_street();
  static const int kSideOfStreetFieldNumber = 11;
  inline ::valhalla::odin::Location_SideOfStreet side_of_street() const;
  inline void set_side_of_street(::valhalla::odin::Location_SideOfStreet value);

  // optional uint32 original_index = 12;
  inline bool has_original_index() const;
  inline void clear_original_index();
  static const int kOriginalIndexFieldNumber = 12;
  inline ::google::protobuf::uint32 original_index() const;
  inline void set_original_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:valhalla.odin.Location)
 private:
  inline void set_has_ll();
  inline void clear_has_ll();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_postal_code();
  inline void clear_has_postal_code();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_date_time();
  inline void clear_has_date_time();
  inline void set_has_side_of_street();
  inline void clear_has_side_of_street();
  inline void set_has_original_index();
  inline void clear_has_original_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::valhalla::odin::LatLng* ll_;
  int type_;
  ::google::protobuf::uint32 heading_;
  ::std::string* name_;
  ::std::string* street_;
  ::std::string* city_;
  ::std::string* state_;
  ::std::string* postal_code_;
  ::std::string* country_;
  ::std::string* date_time_;
  int side_of_street_;
  ::google::protobuf::uint32 original_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_tripcommon_2eproto();
  friend void protobuf_AssignDesc_tripcommon_2eproto();
  friend void protobuf_ShutdownFile_tripcommon_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// ===================================================================


// ===================================================================

// LatLng

// optional float lat = 1;
inline bool LatLng::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatLng::set_has_lat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatLng::clear_has_lat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatLng::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline float LatLng::lat() const {
  return lat_;
}
inline void LatLng::set_lat(float value) {
  set_has_lat();
  lat_ = value;
}

// optional float lng = 2;
inline bool LatLng::has_lng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatLng::set_has_lng() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatLng::clear_has_lng() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatLng::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline float LatLng::lng() const {
  return lng_;
}
inline void LatLng::set_lng(float value) {
  set_has_lng();
  lng_ = value;
}

// -------------------------------------------------------------------

// BoundingBox

// optional .valhalla.odin.LatLng min_ll = 1;
inline bool BoundingBox::has_min_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundingBox::set_has_min_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundingBox::clear_has_min_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundingBox::clear_min_ll() {
  if (min_ll_ != NULL) min_ll_->::valhalla::odin::LatLng::Clear();
  clear_has_min_ll();
}
inline const ::valhalla::odin::LatLng& BoundingBox::min_ll() const {
  return min_ll_ != NULL ? *min_ll_ : *default_instance_->min_ll_;
}
inline ::valhalla::odin::LatLng* BoundingBox::mutable_min_ll() {
  set_has_min_ll();
  if (min_ll_ == NULL) min_ll_ = new ::valhalla::odin::LatLng;
  return min_ll_;
}
inline ::valhalla::odin::LatLng* BoundingBox::release_min_ll() {
  clear_has_min_ll();
  ::valhalla::odin::LatLng* temp = min_ll_;
  min_ll_ = NULL;
  return temp;
}
inline void BoundingBox::set_allocated_min_ll(::valhalla::odin::LatLng* min_ll) {
  delete min_ll_;
  min_ll_ = min_ll;
  if (min_ll) {
    set_has_min_ll();
  } else {
    clear_has_min_ll();
  }
}

// optional .valhalla.odin.LatLng max_ll = 2;
inline bool BoundingBox::has_max_ll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundingBox::set_has_max_ll() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundingBox::clear_has_max_ll() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundingBox::clear_max_ll() {
  if (max_ll_ != NULL) max_ll_->::valhalla::odin::LatLng::Clear();
  clear_has_max_ll();
}
inline const ::valhalla::odin::LatLng& BoundingBox::max_ll() const {
  return max_ll_ != NULL ? *max_ll_ : *default_instance_->max_ll_;
}
inline ::valhalla::odin::LatLng* BoundingBox::mutable_max_ll() {
  set_has_max_ll();
  if (max_ll_ == NULL) max_ll_ = new ::valhalla::odin::LatLng;
  return max_ll_;
}
inline ::valhalla::odin::LatLng* BoundingBox::release_max_ll() {
  clear_has_max_ll();
  ::valhalla::odin::LatLng* temp = max_ll_;
  max_ll_ = NULL;
  return temp;
}
inline void BoundingBox::set_allocated_max_ll(::valhalla::odin::LatLng* max_ll) {
  delete max_ll_;
  max_ll_ = max_ll;
  if (max_ll) {
    set_has_max_ll();
  } else {
    clear_has_max_ll();
  }
}

// -------------------------------------------------------------------

// Location

// optional .valhalla.odin.LatLng ll = 1;
inline bool Location::has_ll() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_ll() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_ll() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_ll() {
  if (ll_ != NULL) ll_->::valhalla::odin::LatLng::Clear();
  clear_has_ll();
}
inline const ::valhalla::odin::LatLng& Location::ll() const {
  return ll_ != NULL ? *ll_ : *default_instance_->ll_;
}
inline ::valhalla::odin::LatLng* Location::mutable_ll() {
  set_has_ll();
  if (ll_ == NULL) ll_ = new ::valhalla::odin::LatLng;
  return ll_;
}
inline ::valhalla::odin::LatLng* Location::release_ll() {
  clear_has_ll();
  ::valhalla::odin::LatLng* temp = ll_;
  ll_ = NULL;
  return temp;
}
inline void Location::set_allocated_ll(::valhalla::odin::LatLng* ll) {
  delete ll_;
  ll_ = ll;
  if (ll) {
    set_has_ll();
  } else {
    clear_has_ll();
  }
}

// optional .valhalla.odin.Location.Type type = 2;
inline bool Location::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::valhalla::odin::Location_Type Location::type() const {
  return static_cast< ::valhalla::odin::Location_Type >(type_);
}
inline void Location::set_type(::valhalla::odin::Location_Type value) {
  assert(::valhalla::odin::Location_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 heading = 3;
inline bool Location::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location::clear_heading() {
  heading_ = 0u;
  clear_has_heading();
}
inline ::google::protobuf::uint32 Location::heading() const {
  return heading_;
}
inline void Location::set_heading(::google::protobuf::uint32 value) {
  set_has_heading();
  heading_ = value;
}

// optional string name = 4;
inline bool Location::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Location::name() const {
  return *name_;
}
inline void Location::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Location::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Location::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Location::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string street = 5;
inline bool Location::has_street() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location::set_has_street() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location::clear_has_street() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& Location::street() const {
  return *street_;
}
inline void Location::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void Location::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void Location::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* Location::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 6;
inline bool Location::has_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Location::set_has_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Location::clear_has_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Location::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Location::city() const {
  return *city_;
}
inline void Location::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Location::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Location::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* Location::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 7;
inline bool Location::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Location::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Location::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Location::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Location::state() const {
  return *state_;
}
inline void Location::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Location::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Location::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* Location::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string postal_code = 8;
inline bool Location::has_postal_code() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Location::set_has_postal_code() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Location::clear_has_postal_code() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Location::clear_postal_code() {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    postal_code_->clear();
  }
  clear_has_postal_code();
}
inline const ::std::string& Location::postal_code() const {
  return *postal_code_;
}
inline void Location::set_postal_code(const ::std::string& value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void Location::set_postal_code(const char* value) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(value);
}
inline void Location::set_postal_code(const char* value, size_t size) {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  postal_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_postal_code() {
  set_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    postal_code_ = new ::std::string;
  }
  return postal_code_;
}
inline ::std::string* Location::release_postal_code() {
  clear_has_postal_code();
  if (postal_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postal_code_;
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_postal_code(::std::string* postal_code) {
  if (postal_code_ != &::google::protobuf::internal::kEmptyString) {
    delete postal_code_;
  }
  if (postal_code) {
    set_has_postal_code();
    postal_code_ = postal_code;
  } else {
    clear_has_postal_code();
    postal_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country = 9;
inline bool Location::has_country() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Location::set_has_country() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Location::clear_has_country() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Location::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& Location::country() const {
  return *country_;
}
inline void Location::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void Location::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void Location::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* Location::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string date_time = 10;
inline bool Location::has_date_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Location::set_has_date_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Location::clear_has_date_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Location::clear_date_time() {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    date_time_->clear();
  }
  clear_has_date_time();
}
inline const ::std::string& Location::date_time() const {
  return *date_time_;
}
inline void Location::set_date_time(const ::std::string& value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void Location::set_date_time(const char* value) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(value);
}
inline void Location::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  date_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Location::mutable_date_time() {
  set_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    date_time_ = new ::std::string;
  }
  return date_time_;
}
inline ::std::string* Location::release_date_time() {
  clear_has_date_time();
  if (date_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_time_;
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Location::set_allocated_date_time(::std::string* date_time) {
  if (date_time_ != &::google::protobuf::internal::kEmptyString) {
    delete date_time_;
  }
  if (date_time) {
    set_has_date_time();
    date_time_ = date_time;
  } else {
    clear_has_date_time();
    date_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .valhalla.odin.Location.SideOfStreet side_of_street = 11;
inline bool Location::has_side_of_street() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Location::set_has_side_of_street() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Location::clear_has_side_of_street() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Location::clear_side_of_street() {
  side_of_street_ = 0;
  clear_has_side_of_street();
}
inline ::valhalla::odin::Location_SideOfStreet Location::side_of_street() const {
  return static_cast< ::valhalla::odin::Location_SideOfStreet >(side_of_street_);
}
inline void Location::set_side_of_street(::valhalla::odin::Location_SideOfStreet value) {
  assert(::valhalla::odin::Location_SideOfStreet_IsValid(value));
  set_has_side_of_street();
  side_of_street_ = value;
}

// optional uint32 original_index = 12;
inline bool Location::has_original_index() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Location::set_has_original_index() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Location::clear_has_original_index() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Location::clear_original_index() {
  original_index_ = 0u;
  clear_has_original_index();
}
inline ::google::protobuf::uint32 Location::original_index() const {
  return original_index_;
}
inline void Location::set_original_index(::google::protobuf::uint32 value) {
  set_has_original_index();
  original_index_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace odin
}  // namespace valhalla

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::Location_Type>() {
  return ::valhalla::odin::Location_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::valhalla::odin::Location_SideOfStreet>() {
  return ::valhalla::odin::Location_SideOfStreet_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tripcommon_2eproto__INCLUDED
